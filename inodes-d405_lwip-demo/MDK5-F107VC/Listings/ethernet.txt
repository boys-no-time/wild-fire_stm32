; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ethernet.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ethernet.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\system\arch -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Inc -I..\Middlewares\Third_Party\LwIP\src\include -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\ethernet.crf ..\Middlewares\Third_Party\LwIP\src\netif\ethernet.c]
                          THUMB

                          AREA ||i.ethernet_input||, CODE, READONLY, ALIGN=2

                  ethernet_input PROC
;;;80     err_t
;;;81     ethernet_input(struct pbuf *p, struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;82     {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;83       struct eth_hdr* ethhdr;
;;;84       u16_t type;
;;;85     #if LWIP_ARP || ETHARP_SUPPORT_VLAN || LWIP_IPV6
;;;86       s16_t ip_hdr_offset = SIZEOF_ETH_HDR;
;;;87     #endif /* LWIP_ARP || ETHARP_SUPPORT_VLAN */
;;;88     
;;;89       if (p->len <= SIZEOF_ETH_HDR) {
000006  8960              LDRH     r0,[r4,#0xa]
000008  280e              CMP      r0,#0xe
00000a  d93d              BLS      |L1.136|
;;;90         /* a packet with only an ethernet header (or less) is not valid for us */
;;;91         ETHARP_STATS_INC(etharp.proterr);
;;;92         ETHARP_STATS_INC(etharp.drop);
;;;93         MIB2_STATS_NETIF_INC(netif, ifinerrors);
;;;94         goto free_and_return;
;;;95       }
;;;96     
;;;97       /* points to packet payload, which starts with an Ethernet header */
;;;98       ethhdr = (struct eth_hdr *)p->payload;
00000c  6860              LDR      r0,[r4,#4]
;;;99       LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
;;;100        ("ethernet_input: dest:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", src:%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F":%"X8_F", type:%"X16_F"\n",
;;;101         (unsigned)ethhdr->dest.addr[0], (unsigned)ethhdr->dest.addr[1], (unsigned)ethhdr->dest.addr[2],
;;;102         (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
;;;103         (unsigned)ethhdr->src.addr[0],  (unsigned)ethhdr->src.addr[1],  (unsigned)ethhdr->src.addr[2],
;;;104         (unsigned)ethhdr->src.addr[3],  (unsigned)ethhdr->src.addr[4],  (unsigned)ethhdr->src.addr[5],
;;;105         lwip_htons(ethhdr->type)));
;;;106    
;;;107      type = ethhdr->type;
00000e  8985              LDRH     r5,[r0,#0xc]
;;;108    #if ETHARP_SUPPORT_VLAN
;;;109      if (type == PP_HTONS(ETHTYPE_VLAN)) {
;;;110        struct eth_vlan_hdr *vlan = (struct eth_vlan_hdr*)(((char*)ethhdr) + SIZEOF_ETH_HDR);
;;;111        if (p->len <= SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR) {
;;;112          /* a packet with only an ethernet/vlan header (or less) is not valid for us */
;;;113          ETHARP_STATS_INC(etharp.proterr);
;;;114          ETHARP_STATS_INC(etharp.drop);
;;;115          MIB2_STATS_NETIF_INC(netif, ifinerrors);
;;;116          goto free_and_return;
;;;117        }
;;;118    #if defined(LWIP_HOOK_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) /* if not, allow all VLANs */
;;;119    #ifdef LWIP_HOOK_VLAN_CHECK
;;;120        if (!LWIP_HOOK_VLAN_CHECK(netif, ethhdr, vlan)) {
;;;121    #elif defined(ETHARP_VLAN_CHECK_FN)
;;;122        if (!ETHARP_VLAN_CHECK_FN(ethhdr, vlan)) {
;;;123    #elif defined(ETHARP_VLAN_CHECK)
;;;124        if (VLAN_ID(vlan) != ETHARP_VLAN_CHECK) {
;;;125    #endif
;;;126          /* silently ignore this packet: not for our VLAN */
;;;127          pbuf_free(p);
;;;128          return ERR_OK;
;;;129        }
;;;130    #endif /* defined(LWIP_HOOK_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK) || defined(ETHARP_VLAN_CHECK_FN) */
;;;131        type = vlan->tpid;
;;;132        ip_hdr_offset = SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR;
;;;133      }
;;;134    #endif /* ETHARP_SUPPORT_VLAN */
;;;135    
;;;136    #if LWIP_ARP_FILTER_NETIF
;;;137      netif = LWIP_ARP_FILTER_NETIF_FN(p, netif, lwip_htons(type));
;;;138    #endif /* LWIP_ARP_FILTER_NETIF*/
;;;139    
;;;140      if (ethhdr->dest.addr[0] & 1) {
000010  7802              LDRB     r2,[r0,#0]
000012  07d1              LSLS     r1,r2,#31
000014  d015              BEQ      |L1.66|
;;;141        /* this might be a multicast or broadcast packet */
;;;142        if (ethhdr->dest.addr[0] == LL_IP4_MULTICAST_ADDR_0) {
000016  2a01              CMP      r2,#1
000018  d005              BEQ      |L1.38|
;;;143    #if LWIP_IPV4
;;;144          if ((ethhdr->dest.addr[1] == LL_IP4_MULTICAST_ADDR_1) &&
;;;145              (ethhdr->dest.addr[2] == LL_IP4_MULTICAST_ADDR_2)) {
;;;146            /* mark the pbuf as link-layer multicast */
;;;147            p->flags |= PBUF_FLAG_LLMCAST;
;;;148          }
;;;149    #endif /* LWIP_IPV4 */
;;;150        }
;;;151    #if LWIP_IPV6
;;;152        else if ((ethhdr->dest.addr[0] == LL_IP6_MULTICAST_ADDR_0) &&
;;;153                 (ethhdr->dest.addr[1] == LL_IP6_MULTICAST_ADDR_1)) {
;;;154            /* mark the pbuf as link-layer multicast */
;;;155            p->flags |= PBUF_FLAG_LLMCAST;
;;;156        }
;;;157    #endif /* LWIP_IPV6 */
;;;158        else if (eth_addr_cmp(&ethhdr->dest, &ethbroadcast)) {
00001a  2206              MOVS     r2,#6
00001c  4920              LDR      r1,|L1.160|
00001e  f7fffffe          BL       memcmp
000022  b150              CBZ      r0,|L1.58|
000024  e00d              B        |L1.66|
                  |L1.38|
000026  7841              LDRB     r1,[r0,#1]            ;144
000028  b959              CBNZ     r1,|L1.66|
00002a  7880              LDRB     r0,[r0,#2]            ;145
00002c  285e              CMP      r0,#0x5e              ;145
00002e  d108              BNE      |L1.66|
000030  7b60              LDRB     r0,[r4,#0xd]          ;147
000032  f0400010          ORR      r0,r0,#0x10           ;147
000036  7360              STRB     r0,[r4,#0xd]          ;147
000038  e003              B        |L1.66|
                  |L1.58|
;;;159          /* mark the pbuf as link-layer broadcast */
;;;160          p->flags |= PBUF_FLAG_LLBCAST;
00003a  7b60              LDRB     r0,[r4,#0xd]
00003c  f0400008          ORR      r0,r0,#8
000040  7360              STRB     r0,[r4,#0xd]
                  |L1.66|
;;;161        }
;;;162      }
;;;163    
;;;164      switch (type) {
;;;165    #if LWIP_IPV4 && LWIP_ARP
;;;166        /* IP packet? */
;;;167        case PP_HTONS(ETHTYPE_IP):
;;;168          if (!(netif->flags & NETIF_FLAG_ETHARP)) {
;;;169            goto free_and_return;
;;;170          }
;;;171          /* skip Ethernet header */
;;;172          if ((p->len < ip_hdr_offset) || pbuf_header(p, (s16_t)-ip_hdr_offset)) {
000042  f06f010d          MVN      r1,#0xd
000046  2d08              CMP      r5,#8                 ;164
000048  d003              BEQ      |L1.82|
00004a  f5b56fc1          CMP      r5,#0x608             ;164
00004e  d11b              BNE      |L1.136|
000050  e00f              B        |L1.114|
                  |L1.82|
000052  f8960037          LDRB     r0,[r6,#0x37]         ;168
000056  0700              LSLS     r0,r0,#28             ;168
000058  d516              BPL      |L1.136|
00005a  8960              LDRH     r0,[r4,#0xa]
00005c  280e              CMP      r0,#0xe
00005e  db13              BLT      |L1.136|
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       pbuf_header
000066  b978              CBNZ     r0,|L1.136|
;;;173            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;174              ("ethernet_input: IPv4 packet dropped, too short (%"S16_F"/%"S16_F")\n",
;;;175              p->tot_len, ip_hdr_offset));
;;;176            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("Can't move over header in packet"));
;;;177            goto free_and_return;
;;;178          } else {
;;;179            /* pass to IP layer */
;;;180            ip4_input(p, netif);
000068  4631              MOV      r1,r6
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       ip4_input
000070  e013              B        |L1.154|
                  |L1.114|
;;;181          }
;;;182          break;
;;;183    
;;;184        case PP_HTONS(ETHTYPE_ARP):
;;;185          if (!(netif->flags & NETIF_FLAG_ETHARP)) {
000072  f8960037          LDRB     r0,[r6,#0x37]
000076  0700              LSLS     r0,r0,#28
000078  d506              BPL      |L1.136|
;;;186            goto free_and_return;
;;;187          }
;;;188          /* skip Ethernet header */
;;;189          if ((p->len < ip_hdr_offset) || pbuf_header(p, (s16_t)-ip_hdr_offset)) {
00007a  8960              LDRH     r0,[r4,#0xa]
00007c  280e              CMP      r0,#0xe
00007e  db03              BLT      |L1.136|
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       pbuf_header
000086  b120              CBZ      r0,|L1.146|
                  |L1.136|
;;;190            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;191              ("ethernet_input: ARP response packet dropped, too short (%"S16_F"/%"S16_F")\n",
;;;192              p->tot_len, ip_hdr_offset));
;;;193            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("Can't move over header in packet"));
;;;194            ETHARP_STATS_INC(etharp.lenerr);
;;;195            ETHARP_STATS_INC(etharp.drop);
;;;196            goto free_and_return;
;;;197          } else {
;;;198            /* pass p to ARP module */
;;;199            etharp_input(p, netif);
;;;200          }
;;;201          break;
;;;202    #endif /* LWIP_IPV4 && LWIP_ARP */
;;;203    #if PPPOE_SUPPORT
;;;204        case PP_HTONS(ETHTYPE_PPPOEDISC): /* PPP Over Ethernet Discovery Stage */
;;;205          pppoe_disc_input(netif, p);
;;;206          break;
;;;207    
;;;208        case PP_HTONS(ETHTYPE_PPPOE): /* PPP Over Ethernet Session Stage */
;;;209          pppoe_data_input(netif, p);
;;;210          break;
;;;211    #endif /* PPPOE_SUPPORT */
;;;212    
;;;213    #if LWIP_IPV6
;;;214        case PP_HTONS(ETHTYPE_IPV6): /* IPv6 */
;;;215          /* skip Ethernet header */
;;;216          if ((p->len < ip_hdr_offset) || pbuf_header(p, (s16_t)-ip_hdr_offset)) {
;;;217            LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;218              ("ethernet_input: IPv6 packet dropped, too short (%"S16_F"/%"S16_F")\n",
;;;219              p->tot_len, ip_hdr_offset));
;;;220            goto free_and_return;
;;;221          } else {
;;;222            /* pass to IPv6 layer */
;;;223            ip6_input(p, netif);
;;;224          }
;;;225          break;
;;;226    #endif /* LWIP_IPV6 */
;;;227    
;;;228        default:
;;;229    #ifdef LWIP_HOOK_UNKNOWN_ETH_PROTOCOL
;;;230          if(LWIP_HOOK_UNKNOWN_ETH_PROTOCOL(p, netif) == ERR_OK) {
;;;231            break;
;;;232          }
;;;233    #endif
;;;234          ETHARP_STATS_INC(etharp.proterr);
;;;235          ETHARP_STATS_INC(etharp.drop);
;;;236          MIB2_STATS_NETIF_INC(netif, ifinunknownprotos);
;;;237          goto free_and_return;
;;;238      }
;;;239    
;;;240      /* This means the pbuf is freed or consumed,
;;;241         so the caller doesn't have to free it again */
;;;242      return ERR_OK;
;;;243    
;;;244    free_and_return:
;;;245      pbuf_free(p);
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       pbuf_free
;;;246      return ERR_OK;
00008e  2000              MOVS     r0,#0
;;;247    }
000090  bd70              POP      {r4-r6,pc}
                  |L1.146|
000092  4631              MOV      r1,r6                 ;199
000094  4620              MOV      r0,r4                 ;199
000096  f7fffffe          BL       etharp_input
                  |L1.154|
00009a  2000              MOVS     r0,#0                 ;242
00009c  bd70              POP      {r4-r6,pc}
;;;248    
                          ENDP

00009e  0000              DCW      0x0000
                  |L1.160|
                          DCD      ||.constdata||

                          AREA ||i.ethernet_output||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  ethernet_output PROC
;;;263    err_t
;;;264    ethernet_output(struct netif* netif, struct pbuf* p,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;265                    const struct eth_addr* src, const struct eth_addr* dst,
;;;266                    u16_t eth_type)
;;;267    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461c              MOV      r4,r3
00000c  9806              LDR      r0,[sp,#0x18]
;;;268      struct eth_hdr* ethhdr;
;;;269      u16_t eth_type_be = lwip_htons(eth_type);
00000e  f7fffffe          BL       lwip_htons
000012  4680              MOV      r8,r0
;;;270    
;;;271    #if ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET)
;;;272      s32_t vlan_prio_vid = LWIP_HOOK_VLAN_SET(netif, p, src, dst, eth_type);
;;;273      if (vlan_prio_vid >= 0) {
;;;274        struct eth_vlan_hdr* vlanhdr;
;;;275    
;;;276        LWIP_ASSERT("prio_vid must be <= 0xFFFF", vlan_prio_vid <= 0xFFFF);
;;;277    
;;;278        if (pbuf_header(p, SIZEOF_ETH_HDR + SIZEOF_VLAN_HDR) != 0) {
;;;279          goto pbuf_header_failed;
;;;280        }
;;;281        vlanhdr = (struct eth_vlan_hdr*)(((u8_t*)p->payload) + SIZEOF_ETH_HDR);
;;;282        vlanhdr->tpid     = eth_type_be;
;;;283        vlanhdr->prio_vid = lwip_htons((u16_t)vlan_prio_vid);
;;;284    
;;;285        eth_type_be = PP_HTONS(ETHTYPE_VLAN);
;;;286      } else
;;;287    #endif /* ETHARP_SUPPORT_VLAN && defined(LWIP_HOOK_VLAN_SET) */
;;;288      {
;;;289        if (pbuf_header(p, SIZEOF_ETH_HDR) != 0) {
000014  210e              MOVS     r1,#0xe
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       pbuf_header
00001c  b118              CBZ      r0,|L2.38|
;;;290          goto pbuf_header_failed;
;;;291        }
;;;292      }
;;;293    
;;;294      ethhdr = (struct eth_hdr*)p->payload;
;;;295      ethhdr->type = eth_type_be;
;;;296      ETHADDR32_COPY(&ethhdr->dest, dst);
;;;297      ETHADDR16_COPY(&ethhdr->src,  src);
;;;298    
;;;299      LWIP_ASSERT("netif->hwaddr_len must be 6 for ethernet_output!",
;;;300        (netif->hwaddr_len == ETH_HWADDR_LEN));
;;;301      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE,
;;;302        ("ethernet_output: sending packet %p\n", (void *)p));
;;;303    
;;;304      /* send the packet */
;;;305      return netif->linkoutput(netif, p);
;;;306    
;;;307    pbuf_header_failed:
;;;308      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
;;;309        ("ethernet_output: could not allocate room for header.\n"));
;;;310      LINK_STATS_INC(link.lenerr);
;;;311      return ERR_BUF;
00001e  f06f0001          MVN      r0,#1
;;;312    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L2.38|
000026  6878              LDR      r0,[r7,#4]            ;294
000028  f8a0800c          STRH     r8,[r0,#0xc]          ;295
00002c  6821              LDR      r1,[r4,#0]            ;296
00002e  6001              STR      r1,[r0,#0]            ;296
000030  88a1              LDRH     r1,[r4,#4]            ;296
000032  8081              STRH     r1,[r0,#4]            ;296
000034  6829              LDR      r1,[r5,#0]            ;297
000036  f8c01006          STR      r1,[r0,#6]            ;297
00003a  88a9              LDRH     r1,[r5,#4]            ;297
00003c  8141              STRH     r1,[r0,#0xa]          ;297
00003e  f8960030          LDRB     r0,[r6,#0x30]         ;299
000042  2806              CMP      r0,#6                 ;299
000044  d006              BEQ      |L2.84|
000046  a306              ADR      r3,|L2.96|
000048  f240122b          MOV      r2,#0x12b             ;299
00004c  a112              ADR      r1,|L2.152|
00004e  a01f              ADR      r0,|L2.204|
000050  f7fffffe          BL       __2printf
                  |L2.84|
000054  4639              MOV      r1,r7                 ;305
000056  4630              MOV      r0,r6                 ;305
000058  69b2              LDR      r2,[r6,#0x18]         ;305
00005a  e8bd41f0          POP      {r4-r8,lr}            ;305
00005e  4710              BX       r2                    ;305
;;;313    
                          ENDP

                  |L2.96|
000060  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\netif\\etherne"
000064  6964646c
000068  65776172
00006c  65735c54
000070  68697264
000074  5f506172
000078  74795c4c
00007c  7749505c
000080  7372635c
000084  6e657469
000088  665c6574
00008c  6865726e
000090  65      
000091  742e6300          DCB      "t.c",0
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L2.152|
000098  6e657469          DCB      "netif->hwaddr_len must be 6 for ethernet_output!",0
00009c  662d3e68
0000a0  77616464
0000a4  725f6c65
0000a8  6e206d75
0000ac  73742062
0000b0  65203620
0000b4  666f7220
0000b8  65746865
0000bc  726e6574
0000c0  5f6f7574
0000c4  70757421
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L2.204|
0000cc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000d0  7274696f
0000d4  6e202225
0000d8  73222066
0000dc  61696c65
0000e0  64206174
0000e4  206c696e
0000e8  65202564
0000ec  20696e20
0000f0  25730a00

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ethbroadcast
000000  ffffffff          DCB      0xff,0xff,0xff,0xff
000004  ffff              DCB      0xff,0xff

                          AREA ||area_number.6||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.6||, ||.constdata||
                  ethzero
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\netif\\ethernet.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_ethernet_c_3a17d0d9____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_ethernet_c_3a17d0d9____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_ethernet_c_3a17d0d9____REVSH|
#line 478
|__asm___10_ethernet_c_3a17d0d9____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_ethernet_c_3a17d0d9____RRX|
#line 665
|__asm___10_ethernet_c_3a17d0d9____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
