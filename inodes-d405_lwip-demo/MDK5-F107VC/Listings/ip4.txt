; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ip4.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ip4.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\ip4.crf ..\Middlewares\Third_Party\LwIP\src\core\ipv4\ip4.c]
                          THUMB

                          AREA ||i.ip4_input||, CODE, READONLY, ALIGN=2

                  ip4_input PROC
;;;425    err_t
;;;426    ip4_input(struct pbuf *p, struct netif *inp)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;427    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;428      const struct ip_hdr *iphdr;
;;;429      struct netif *netif;
;;;430      u16_t iphdr_hlen;
;;;431      u16_t iphdr_len;
;;;432    #if IP_ACCEPT_LINK_LAYER_ADDRESSING || LWIP_IGMP
;;;433      int check_ip_src = 1;
000008  f04f0901          MOV      r9,#1
;;;434    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING || LWIP_IGMP */
;;;435    #if LWIP_RAW
;;;436      raw_input_state_t raw_status;
;;;437    #endif /* LWIP_RAW */
;;;438    
;;;439      LWIP_ASSERT_CORE_LOCKED();
;;;440    
;;;441      IP_STATS_INC(ip.recv);
;;;442      MIB2_STATS_INC(mib2.ipinreceives);
;;;443    
;;;444      /* identify the IP header */
;;;445      iphdr = (struct ip_hdr *)p->payload;
00000c  687d              LDR      r5,[r7,#4]
;;;446      if (IPH_V(iphdr) != 4) {
00000e  2104              MOVS     r1,#4
000010  7828              LDRB     r0,[r5,#0]
000012  ebb11f10          CMP      r1,r0,LSR #4
000016  d005              BEQ      |L1.36|
;;;447        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
;;;448        ip4_debug_print(p);
;;;449        pbuf_free(p);
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       pbuf_free
;;;450        IP_STATS_INC(ip.err);
;;;451        IP_STATS_INC(ip.drop);
;;;452        MIB2_STATS_INC(mib2.ipinhdrerrors);
;;;453        return ERR_OK;
00001e  2000              MOVS     r0,#0
                  |L1.32|
;;;454      }
;;;455    
;;;456    #ifdef LWIP_HOOK_IP4_INPUT
;;;457      if (LWIP_HOOK_IP4_INPUT(p, inp)) {
;;;458        /* the packet has been eaten */
;;;459        return ERR_OK;
;;;460      }
;;;461    #endif
;;;462    
;;;463      /* obtain IP header length in bytes */
;;;464      iphdr_hlen = IPH_HL_BYTES(iphdr);
;;;465      /* obtain ip length in bytes */
;;;466      iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
;;;467    
;;;468      /* Trim pbuf. This is especially required for packets < 60 bytes. */
;;;469      if (iphdr_len < p->tot_len) {
;;;470        pbuf_realloc(p, iphdr_len);
;;;471      }
;;;472    
;;;473      /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
;;;474      if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
;;;475        if (iphdr_hlen < IP_HLEN) {
;;;476          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;477                      ("ip4_input: short IP header (%"U16_F" bytes) received, IP packet dropped\n", iphdr_hlen));
;;;478        }
;;;479        if (iphdr_hlen > p->len) {
;;;480          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;481                      ("IP header (len %"U16_F") does not fit in first pbuf (len %"U16_F"), IP packet dropped.\n",
;;;482                       iphdr_hlen, p->len));
;;;483        }
;;;484        if (iphdr_len > p->tot_len) {
;;;485          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;486                      ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
;;;487                       iphdr_len, p->tot_len));
;;;488        }
;;;489        /* free (drop) packet pbufs */
;;;490        pbuf_free(p);
;;;491        IP_STATS_INC(ip.lenerr);
;;;492        IP_STATS_INC(ip.drop);
;;;493        MIB2_STATS_INC(mib2.ipindiscards);
;;;494        return ERR_OK;
;;;495      }
;;;496    
;;;497      /* verify checksum */
;;;498    #if CHECKSUM_CHECK_IP
;;;499      IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_IP) {
;;;500        if (inet_chksum(iphdr, iphdr_hlen) != 0) {
;;;501    
;;;502          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;503                      ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
;;;504          ip4_debug_print(p);
;;;505          pbuf_free(p);
;;;506          IP_STATS_INC(ip.chkerr);
;;;507          IP_STATS_INC(ip.drop);
;;;508          MIB2_STATS_INC(mib2.ipinhdrerrors);
;;;509          return ERR_OK;
;;;510        }
;;;511      }
;;;512    #endif
;;;513    
;;;514      /* copy IP addresses to aligned ip_addr_t */
;;;515      ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
;;;516      ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
;;;517    
;;;518      /* match packet against an interface, i.e. is this packet for us? */
;;;519      if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
;;;520    #if LWIP_IGMP
;;;521        if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, ip4_current_dest_addr()))) {
;;;522          /* IGMP snooping switches need 0.0.0.0 to be allowed as source address (RFC 4541) */
;;;523          ip4_addr_t allsystems;
;;;524          IP4_ADDR(&allsystems, 224, 0, 0, 1);
;;;525          if (ip4_addr_cmp(ip4_current_dest_addr(), &allsystems) &&
;;;526              ip4_addr_isany(ip4_current_src_addr())) {
;;;527            check_ip_src = 0;
;;;528          }
;;;529          netif = inp;
;;;530        } else {
;;;531          netif = NULL;
;;;532        }
;;;533    #else /* LWIP_IGMP */
;;;534        if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
;;;535          netif = inp;
;;;536        } else {
;;;537          netif = NULL;
;;;538        }
;;;539    #endif /* LWIP_IGMP */
;;;540      } else {
;;;541        /* start trying with inp. if that's not acceptable, start walking the
;;;542           list of configured netifs. */
;;;543        if (ip4_input_accept(inp)) {
;;;544          netif = inp;
;;;545        } else {
;;;546          netif = NULL;
;;;547    #if !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF
;;;548          /* Packets sent to the loopback address must not be accepted on an
;;;549           * interface that does not have the loopback address assigned to it,
;;;550           * unless a non-loopback interface is used for loopback traffic. */
;;;551          if (!ip4_addr_isloopback(ip4_current_dest_addr()))
;;;552    #endif /* !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF */
;;;553          {
;;;554    #if !LWIP_SINGLE_NETIF
;;;555            NETIF_FOREACH(netif) {
;;;556              if (netif == inp) {
;;;557                /* we checked that before already */
;;;558                continue;
;;;559              }
;;;560              if (ip4_input_accept(netif)) {
;;;561                break;
;;;562              }
;;;563            }
;;;564    #endif /* !LWIP_SINGLE_NETIF */
;;;565          }
;;;566        }
;;;567      }
;;;568    
;;;569    #if IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;570      /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
;;;571       * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
;;;572       * According to RFC 1542 section 3.1.1, referred by RFC 2131).
;;;573       *
;;;574       * If you want to accept private broadcast communication while a netif is down,
;;;575       * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
;;;576       *
;;;577       * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
;;;578       */
;;;579      if (netif == NULL) {
;;;580        /* remote port is DHCP server? */
;;;581        if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
;;;582          const struct udp_hdr *udphdr = (const struct udp_hdr *)((const u8_t *)iphdr + iphdr_hlen);
;;;583          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: UDP packet to DHCP client port %"U16_F"\n",
;;;584                                                  lwip_ntohs(udphdr->dest)));
;;;585          if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
;;;586            LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: DHCP packet accepted.\n"));
;;;587            netif = inp;
;;;588            check_ip_src = 0;
;;;589          }
;;;590        }
;;;591      }
;;;592    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;593    
;;;594      /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
;;;595    #if LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;596      if (check_ip_src
;;;597    #if IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;598          /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
;;;599          && !ip4_addr_isany_val(*ip4_current_src_addr())
;;;600    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;601         )
;;;602    #endif /* LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;603      {
;;;604        if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
;;;605            (ip4_addr_ismulticast(ip4_current_src_addr()))) {
;;;606          /* packet source is not valid */
;;;607          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip4_input: packet source is not valid.\n"));
;;;608          /* free (drop) packet pbufs */
;;;609          pbuf_free(p);
;;;610          IP_STATS_INC(ip.drop);
;;;611          MIB2_STATS_INC(mib2.ipinaddrerrors);
;;;612          MIB2_STATS_INC(mib2.ipindiscards);
;;;613          return ERR_OK;
;;;614        }
;;;615      }
;;;616    
;;;617      /* packet not for us? */
;;;618      if (netif == NULL) {
;;;619        /* packet not for us, route or discard */
;;;620        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: packet not for us.\n"));
;;;621    #if IP_FORWARD
;;;622        /* non-broadcast packet? */
;;;623        if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), inp)) {
;;;624          /* try to forward IP packet on (other) interfaces */
;;;625          ip4_forward(p, (struct ip_hdr *)p->payload, inp);
;;;626        } else
;;;627    #endif /* IP_FORWARD */
;;;628        {
;;;629          IP_STATS_INC(ip.drop);
;;;630          MIB2_STATS_INC(mib2.ipinaddrerrors);
;;;631          MIB2_STATS_INC(mib2.ipindiscards);
;;;632        }
;;;633        pbuf_free(p);
;;;634        return ERR_OK;
;;;635      }
;;;636      /* packet consists of multiple fragments? */
;;;637      if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
;;;638    #if IP_REASSEMBLY /* packet fragment reassembly code present? */
;;;639        LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip4_reass()\n",
;;;640                               lwip_ntohs(IPH_ID(iphdr)), p->tot_len, lwip_ntohs(IPH_LEN(iphdr)), (u16_t)!!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (u16_t)((lwip_ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK) * 8)));
;;;641        /* reassemble the packet*/
;;;642        p = ip4_reass(p);
;;;643        /* packet not fully reassembled yet? */
;;;644        if (p == NULL) {
;;;645          return ERR_OK;
;;;646        }
;;;647        iphdr = (const struct ip_hdr *)p->payload;
;;;648    #else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
;;;649        pbuf_free(p);
;;;650        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since it was fragmented (0x%"X16_F") (while IP_REASSEMBLY == 0).\n",
;;;651                    lwip_ntohs(IPH_OFFSET(iphdr))));
;;;652        IP_STATS_INC(ip.opterr);
;;;653        IP_STATS_INC(ip.drop);
;;;654        /* unsupported protocol feature */
;;;655        MIB2_STATS_INC(mib2.ipinunknownprotos);
;;;656        return ERR_OK;
;;;657    #endif /* IP_REASSEMBLY */
;;;658      }
;;;659    
;;;660    #if IP_OPTIONS_ALLOWED == 0 /* no support for IP options in the IP header? */
;;;661    
;;;662    #if LWIP_IGMP
;;;663      /* there is an extra "router alert" option in IGMP messages which we allow for but do not police */
;;;664      if ((iphdr_hlen > IP_HLEN) &&  (IPH_PROTO(iphdr) != IP_PROTO_IGMP)) {
;;;665    #else
;;;666      if (iphdr_hlen > IP_HLEN) {
;;;667    #endif /* LWIP_IGMP */
;;;668        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since there were IP options (while IP_OPTIONS_ALLOWED == 0).\n"));
;;;669        pbuf_free(p);
;;;670        IP_STATS_INC(ip.opterr);
;;;671        IP_STATS_INC(ip.drop);
;;;672        /* unsupported protocol feature */
;;;673        MIB2_STATS_INC(mib2.ipinunknownprotos);
;;;674        return ERR_OK;
;;;675      }
;;;676    #endif /* IP_OPTIONS_ALLOWED == 0 */
;;;677    
;;;678      /* send to upper layers */
;;;679      LWIP_DEBUGF(IP_DEBUG, ("ip4_input: \n"));
;;;680      ip4_debug_print(p);
;;;681      LWIP_DEBUGF(IP_DEBUG, ("ip4_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));
;;;682    
;;;683      ip_data.current_netif = netif;
;;;684      ip_data.current_input_netif = inp;
;;;685      ip_data.current_ip4_header = iphdr;
;;;686      ip_data.current_ip_header_tot_len = IPH_HL_BYTES(iphdr);
;;;687    
;;;688    #if LWIP_RAW
;;;689      /* raw input did not eat the packet? */
;;;690      raw_status = raw_input(p, inp);
;;;691      if (raw_status != RAW_INPUT_EATEN)
;;;692    #endif /* LWIP_RAW */
;;;693      {
;;;694        pbuf_remove_header(p, iphdr_hlen); /* Move to payload, no check necessary. */
;;;695    
;;;696        switch (IPH_PROTO(iphdr)) {
;;;697    #if LWIP_UDP
;;;698          case IP_PROTO_UDP:
;;;699    #if LWIP_UDPLITE
;;;700          case IP_PROTO_UDPLITE:
;;;701    #endif /* LWIP_UDPLITE */
;;;702            MIB2_STATS_INC(mib2.ipindelivers);
;;;703            udp_input(p, inp);
;;;704            break;
;;;705    #endif /* LWIP_UDP */
;;;706    #if LWIP_TCP
;;;707          case IP_PROTO_TCP:
;;;708            MIB2_STATS_INC(mib2.ipindelivers);
;;;709            tcp_input(p, inp);
;;;710            break;
;;;711    #endif /* LWIP_TCP */
;;;712    #if LWIP_ICMP
;;;713          case IP_PROTO_ICMP:
;;;714            MIB2_STATS_INC(mib2.ipindelivers);
;;;715            icmp_input(p, inp);
;;;716            break;
;;;717    #endif /* LWIP_ICMP */
;;;718    #if LWIP_IGMP
;;;719          case IP_PROTO_IGMP:
;;;720            igmp_input(p, inp, ip4_current_dest_addr());
;;;721            break;
;;;722    #endif /* LWIP_IGMP */
;;;723          default:
;;;724    #if LWIP_RAW
;;;725            if (raw_status == RAW_INPUT_DELIVERED) {
;;;726              MIB2_STATS_INC(mib2.ipindelivers);
;;;727            } else
;;;728    #endif /* LWIP_RAW */
;;;729            {
;;;730    #if LWIP_ICMP
;;;731              /* send ICMP destination protocol unreachable unless is was a broadcast */
;;;732              if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
;;;733                  !ip4_addr_ismulticast(ip4_current_dest_addr())) {
;;;734                pbuf_header_force(p, (s16_t)iphdr_hlen); /* Move to ip header, no check necessary. */
;;;735                icmp_dest_unreach(p, ICMP_DUR_PROTO);
;;;736              }
;;;737    #endif /* LWIP_ICMP */
;;;738    
;;;739              LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", (u16_t)IPH_PROTO(iphdr)));
;;;740    
;;;741              IP_STATS_INC(ip.proterr);
;;;742              IP_STATS_INC(ip.drop);
;;;743              MIB2_STATS_INC(mib2.ipinunknownprotos);
;;;744            }
;;;745            pbuf_free(p);
;;;746            break;
;;;747        }
;;;748      }
;;;749    
;;;750      /* @todo: this is not really necessary... */
;;;751      ip_data.current_netif = NULL;
;;;752      ip_data.current_input_netif = NULL;
;;;753      ip_data.current_ip4_header = NULL;
;;;754      ip_data.current_ip_header_tot_len = 0;
;;;755      ip4_addr_set_any(ip4_current_src_addr());
;;;756      ip4_addr_set_any(ip4_current_dest_addr());
;;;757    
;;;758      return ERR_OK;
;;;759    }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L1.36|
000024  0700              LSLS     r0,r0,#28             ;464
000026  ea4f6890          LSR      r8,r0,#26             ;464
00002a  8868              LDRH     r0,[r5,#2]            ;466
00002c  f7fffffe          BL       lwip_htons
000030  4604              MOV      r4,r0                 ;466
000032  8938              LDRH     r0,[r7,#8]            ;469
000034  42a0              CMP      r0,r4                 ;469
000036  d903              BLS      |L1.64|
000038  4621              MOV      r1,r4                 ;470
00003a  4638              MOV      r0,r7                 ;470
00003c  f7fffffe          BL       pbuf_realloc
                  |L1.64|
000040  8978              LDRH     r0,[r7,#0xa]          ;474
000042  4540              CMP      r0,r8                 ;474
000044  d305              BCC      |L1.82|
000046  8938              LDRH     r0,[r7,#8]            ;474
000048  42a0              CMP      r0,r4                 ;474
00004a  d302              BCC      |L1.82|
00004c  f1b80f14          CMP      r8,#0x14              ;474
000050  d204              BCS      |L1.92|
                  |L1.82|
000052  4638              MOV      r0,r7                 ;490
000054  f7fffffe          BL       pbuf_free
000058  2000              MOVS     r0,#0                 ;494
00005a  e7e1              B        |L1.32|
                  |L1.92|
00005c  f8dfa158          LDR      r10,|L1.440|
000060  6928              LDR      r0,[r5,#0x10]         ;515
000062  f8ca0014          STR      r0,[r10,#0x14]        ;515  ; ip_data
000066  68e9              LDR      r1,[r5,#0xc]          ;516
000068  f8ca1010          STR      r1,[r10,#0x10]        ;516  ; ip_data
00006c  f3c01003          UBFX     r0,r0,#4,#4           ;519
000070  280e              CMP      r0,#0xe               ;519
000072  d005              BEQ      |L1.128|
000074  4630              MOV      r0,r6                 ;543
000076  f7fffffe          BL       ip4_input_accept
00007a  b158              CBZ      r0,|L1.148|
00007c  4634              MOV      r4,r6                 ;544
00007e  e01a              B        |L1.182|
                  |L1.128|
000080  f8960035          LDRB     r0,[r6,#0x35]         ;534
000084  07c0              LSLS     r0,r0,#31             ;534
000086  d003              BEQ      |L1.144|
000088  6870              LDR      r0,[r6,#4]            ;534
00008a  b108              CBZ      r0,|L1.144|
00008c  4634              MOV      r4,r6                 ;535
00008e  e012              B        |L1.182|
                  |L1.144|
000090  2400              MOVS     r4,#0                 ;537
000092  e010              B        |L1.182|
                  |L1.148|
000094  2400              MOVS     r4,#0                 ;546
000096  f89a0014          LDRB     r0,[r10,#0x14]        ;551  ; ip_data
00009a  287f              CMP      r0,#0x7f              ;551
00009c  d00b              BEQ      |L1.182|
00009e  4847              LDR      r0,|L1.444|
0000a0  6804              LDR      r4,[r0,#0]            ;555  ; netif_list
0000a2  e006              B        |L1.178|
                  |L1.164|
0000a4  42b4              CMP      r4,r6                 ;556
0000a6  d003              BEQ      |L1.176|
0000a8  4620              MOV      r0,r4                 ;560
0000aa  f7fffffe          BL       ip4_input_accept
0000ae  b910              CBNZ     r0,|L1.182|
                  |L1.176|
0000b0  6824              LDR      r4,[r4,#0]            ;555
                  |L1.178|
0000b2  2c00              CMP      r4,#0                 ;555
0000b4  d1f6              BNE      |L1.164|
                  |L1.182|
0000b6  b95c              CBNZ     r4,|L1.208|
0000b8  7a68              LDRB     r0,[r5,#9]            ;581
0000ba  2811              CMP      r0,#0x11              ;581
0000bc  d108              BNE      |L1.208|
0000be  eb050008          ADD      r0,r5,r8              ;582
0000c2  8840              LDRH     r0,[r0,#2]            ;585
0000c4  f5b04f88          CMP      r0,#0x4400            ;585
0000c8  d102              BNE      |L1.208|
0000ca  4634              MOV      r4,r6                 ;587
0000cc  f04f0900          MOV      r9,#0                 ;588
                  |L1.208|
0000d0  f1b90f00          CMP      r9,#0                 ;596
0000d4  d00c              BEQ      |L1.240|
0000d6  f8da0010          LDR      r0,[r10,#0x10]        ;599  ; ip_data
0000da  b148              CBZ      r0,|L1.240|
0000dc  4631              MOV      r1,r6                 ;604
0000de  f7fffffe          BL       ip4_addr_isbroadcast_u32
0000e2  bb68              CBNZ     r0,|L1.320|
0000e4  f89a0010          LDRB     r0,[r10,#0x10]        ;605  ; ip_data
0000e8  f3c01003          UBFX     r0,r0,#4,#4           ;605
0000ec  280e              CMP      r0,#0xe               ;605
0000ee  d027              BEQ      |L1.320|
                  |L1.240|
0000f0  b35c              CBZ      r4,|L1.330|
0000f2  88e8              LDRH     r0,[r5,#6]            ;637
0000f4  f03000c0          BICS     r0,r0,#0xc0           ;637
0000f8  d005              BEQ      |L1.262|
0000fa  4638              MOV      r0,r7                 ;642
0000fc  f7fffffe          BL       ip4_reass
000100  4607              MOV      r7,r0                 ;642
000102  b33f              CBZ      r7,|L1.340|
000104  687d              LDR      r5,[r7,#4]            ;647
                  |L1.262|
000106  f8ca4000          STR      r4,[r10,#0]           ;683  ; ip_data
00010a  f8ca6004          STR      r6,[r10,#4]           ;684  ; ip_data
00010e  f8ca5008          STR      r5,[r10,#8]           ;685  ; ip_data
000112  7828              LDRB     r0,[r5,#0]            ;686
000114  0700              LSLS     r0,r0,#28             ;686
000116  0e80              LSRS     r0,r0,#26             ;686
000118  f8aa000c          STRH     r0,[r10,#0xc]         ;686
00011c  4641              MOV      r1,r8                 ;694
00011e  4638              MOV      r0,r7                 ;694
000120  f7fffffe          BL       pbuf_remove_header
000124  7a68              LDRB     r0,[r5,#9]            ;696
000126  2801              CMP      r0,#1                 ;696
000128  d020              BEQ      |L1.364|
00012a  2806              CMP      r0,#6                 ;696
00012c  d019              BEQ      |L1.354|
00012e  2811              CMP      r0,#0x11              ;696
000130  d012              BEQ      |L1.344|
000132  4621              MOV      r1,r4                 ;732
000134  f8da0014          LDR      r0,[r10,#0x14]        ;732  ; ip_data
000138  f7fffffe          BL       ip4_addr_isbroadcast_u32
00013c  b1d8              CBZ      r0,|L1.374|
00013e  e029              B        |L1.404|
                  |L1.320|
000140  4638              MOV      r0,r7                 ;609
000142  f7fffffe          BL       pbuf_free
000146  2000              MOVS     r0,#0                 ;613
000148  e76a              B        |L1.32|
                  |L1.330|
00014a  4638              MOV      r0,r7                 ;633
00014c  f7fffffe          BL       pbuf_free
000150  2000              MOVS     r0,#0                 ;634
000152  e765              B        |L1.32|
                  |L1.340|
000154  2000              MOVS     r0,#0                 ;645
000156  e763              B        |L1.32|
                  |L1.344|
000158  4631              MOV      r1,r6                 ;703
00015a  4638              MOV      r0,r7                 ;703
00015c  f7fffffe          BL       udp_input
000160  e01b              B        |L1.410|
                  |L1.354|
000162  4631              MOV      r1,r6                 ;709
000164  4638              MOV      r0,r7                 ;709
000166  f7fffffe          BL       tcp_input
00016a  e016              B        |L1.410|
                  |L1.364|
00016c  4631              MOV      r1,r6                 ;715
00016e  4638              MOV      r0,r7                 ;715
000170  f7fffffe          BL       icmp_input
000174  e011              B        |L1.410|
                  |L1.374|
000176  f89a0014          LDRB     r0,[r10,#0x14]        ;733  ; ip_data
00017a  f3c01003          UBFX     r0,r0,#4,#4           ;733
00017e  280e              CMP      r0,#0xe               ;733
000180  d008              BEQ      |L1.404|
000182  fa0ff188          SXTH     r1,r8                 ;734
000186  4638              MOV      r0,r7                 ;734
000188  f7fffffe          BL       pbuf_header_force
00018c  2102              MOVS     r1,#2                 ;735
00018e  4638              MOV      r0,r7                 ;735
000190  f7fffffe          BL       icmp_dest_unreach
                  |L1.404|
000194  4638              MOV      r0,r7                 ;745
000196  f7fffffe          BL       pbuf_free
                  |L1.410|
00019a  2000              MOVS     r0,#0                 ;751
00019c  f8ca0000          STR      r0,[r10,#0]           ;751  ; ip_data
0001a0  f8ca0004          STR      r0,[r10,#4]           ;752  ; ip_data
0001a4  f8ca0008          STR      r0,[r10,#8]           ;753  ; ip_data
0001a8  f8aa000c          STRH     r0,[r10,#0xc]         ;754
0001ac  f8ca0010          STR      r0,[r10,#0x10]        ;755  ; ip_data
0001b0  f8ca0014          STR      r0,[r10,#0x14]        ;756  ; ip_data
0001b4  e734              B        |L1.32|
;;;760    
                          ENDP

0001b6  0000              DCW      0x0000
                  |L1.440|
                          DCD      ip_data
                  |L1.444|
                          DCD      netif_list

                          AREA ||i.ip4_input_accept||, CODE, READONLY, ALIGN=2

                  ip4_input_accept PROC
;;;373    static int
;;;374    ip4_input_accept(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;375    {
;;;376      LWIP_DEBUGF(IP_DEBUG, ("ip_input: iphdr->dest 0x%"X32_F" netif->ip_addr 0x%"X32_F" (0x%"X32_F", 0x%"X32_F", 0x%"X32_F")\n",
;;;377                             ip4_addr_get_u32(ip4_current_dest_addr()), ip4_addr_get_u32(netif_ip4_addr(netif)),
;;;378                             ip4_addr_get_u32(ip4_current_dest_addr()) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
;;;379                             ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
;;;380                             ip4_addr_get_u32(ip4_current_dest_addr()) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));
;;;381    
;;;382      /* interface is up and configured? */
;;;383      if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
000002  f8901035          LDRB     r1,[r0,#0x35]
000006  07c9              LSLS     r1,r1,#31
000008  d00c              BEQ      |L2.36|
00000a  6841              LDR      r1,[r0,#4]
00000c  b151              CBZ      r1,|L2.36|
;;;384        /* unicast to this interface address? */
;;;385        if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
00000e  4a06              LDR      r2,|L2.40|
000010  6952              LDR      r2,[r2,#0x14]  ; ip_data
000012  428a              CMP      r2,r1
000014  d004              BEQ      |L2.32|
;;;386            /* or broadcast on this interface network address? */
;;;387            ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
000016  4601              MOV      r1,r0
000018  4610              MOV      r0,r2
00001a  f7fffffe          BL       ip4_addr_isbroadcast_u32
00001e  b108              CBZ      r0,|L2.36|
                  |L2.32|
;;;388    #if LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF
;;;389            || (ip4_addr_get_u32(ip4_current_dest_addr()) == PP_HTONL(IPADDR_LOOPBACK))
;;;390    #endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
;;;391           ) {
;;;392          LWIP_DEBUGF(IP_DEBUG, ("ip4_input: packet accepted on interface %c%c\n",
;;;393                                 netif->name[0], netif->name[1]));
;;;394          /* accept on this netif */
;;;395          return 1;
000020  2001              MOVS     r0,#1
;;;396        }
;;;397    #if LWIP_AUTOIP
;;;398        /* connections to link-local addresses must persist after changing
;;;399            the netif's address (RFC3927 ch. 1.9) */
;;;400        if (autoip_accept_packet(netif, ip4_current_dest_addr())) {
;;;401          LWIP_DEBUGF(IP_DEBUG, ("ip4_input: LLA packet accepted on interface %c%c\n",
;;;402                                 netif->name[0], netif->name[1]));
;;;403          /* accept on this netif */
;;;404          return 1;
;;;405        }
;;;406    #endif /* LWIP_AUTOIP */
;;;407      }
;;;408      return 0;
;;;409    }
000022  bd10              POP      {r4,pc}
                  |L2.36|
000024  2000              MOVS     r0,#0                 ;408
000026  bd10              POP      {r4,pc}
;;;410    
                          ENDP

                  |L2.40|
                          DCD      ip_data

                          AREA ||i.ip4_output||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  ip4_output PROC
;;;1027   err_t
;;;1028   ip4_output(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;1029              u8_t ttl, u8_t tos, u8_t proto)
;;;1030   {
000004  e9dd560a          LDRD     r5,r6,[sp,#0x28]
000008  4604              MOV      r4,r0
00000a  4688              MOV      r8,r1
00000c  4617              MOV      r7,r2
00000e  4699              MOV      r9,r3
;;;1031     struct netif *netif;
;;;1032   
;;;1033     LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
000010  7ba0              LDRB     r0,[r4,#0xe]
000012  2801              CMP      r0,#1
000014  d006              BEQ      |L3.36|
000016  a30c              ADR      r3,|L3.72|
000018  f2404209          MOV      r2,#0x409
00001c  a117              ADR      r1,|L3.124|
00001e  a01a              ADR      r0,|L3.136|
000020  f7fffffe          BL       __2printf
                  |L3.36|
;;;1034   
;;;1035     if ((netif = ip4_route_src(src, dest)) == NULL) {
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       ip4_route
00002a  b150              CBZ      r0,|L3.66|
;;;1036       LWIP_DEBUGF(IP_DEBUG, ("ip4_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;1037                              ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
;;;1038       IP_STATS_INC(ip.rterr);
;;;1039       return ERR_RTE;
;;;1040     }
;;;1041   
;;;1042     return ip4_output_if(p, src, dest, ttl, tos, proto, netif);
00002c  e9cd5600          STRD     r5,r6,[sp,#0]
000030  9002              STR      r0,[sp,#8]
000032  464b              MOV      r3,r9
000034  463a              MOV      r2,r7
000036  4641              MOV      r1,r8
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       ip4_output_if
                  |L3.62|
;;;1043   }
00003e  e8bd83fe          POP      {r1-r9,pc}
                  |L3.66|
000042  f06f0003          MVN      r0,#3                 ;1039
000046  e7fa              B        |L3.62|
;;;1044   
                          ENDP

                  |L3.72|
000048  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip"
00004c  6964646c
000050  65776172
000054  65735c54
000058  68697264
00005c  5f506172
000060  74795c4c
000064  7749505c
000068  7372635c
00006c  636f7265
000070  5c697076
000074  345c6970
000078  342e6300          DCB      "4.c",0
                  |L3.124|
00007c  702d3e72          DCB      "p->ref == 1",0
000080  6566203d
000084  3d203100
                  |L3.136|
000088  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00008c  7274696f
000090  6e202225
000094  73222066
000098  61696c65
00009c  64206174
0000a0  206c696e
0000a4  65202564
0000a8  20696e20
0000ac  25730a00

                          AREA ||i.ip4_output_if||, CODE, READONLY, ALIGN=1

                  ip4_output_if PROC
;;;786    err_t
;;;787    ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
000000  b5fe              PUSH     {r1-r7,lr}
;;;788                  u8_t ttl, u8_t tos,
;;;789                  u8_t proto, struct netif *netif)
;;;790    {
000002  e9dd6708          LDRD     r6,r7,[sp,#0x20]
000006  9c0a              LDR      r4,[sp,#0x28]
;;;791    #if IP_OPTIONS_SEND
;;;792      return ip4_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
;;;793    }
;;;794    
;;;795    /**
;;;796     * Same as ip_output_if() but with the possibility to include IP options:
;;;797     *
;;;798     * @ param ip_options pointer to the IP options, copied into the IP header
;;;799     * @ param optlen length of ip_options
;;;800     */
;;;801    err_t
;;;802    ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
;;;803                      u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
;;;804                      u16_t optlen)
;;;805    {
;;;806    #endif /* IP_OPTIONS_SEND */
;;;807      const ip4_addr_t *src_used = src;
;;;808      if (dest != LWIP_IP_HDRINCL) {
000008  2a00              CMP      r2,#0
00000a  d004              BEQ      |L4.22|
;;;809        if (ip4_addr_isany(src)) {
00000c  000d              MOVS     r5,r1
00000e  d001              BEQ      |L4.20|
000010  680d              LDR      r5,[r1,#0]
000012  b905              CBNZ     r5,|L4.22|
                  |L4.20|
;;;810          src_used = netif_ip4_addr(netif);
000014  1d21              ADDS     r1,r4,#4
                  |L4.22|
;;;811        }
;;;812      }
;;;813    
;;;814    #if IP_OPTIONS_SEND
;;;815      return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
;;;816                                   ip_options, optlen);
;;;817    #else /* IP_OPTIONS_SEND */
;;;818      return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
000016  e9cd6700          STRD     r6,r7,[sp,#0]
00001a  9402              STR      r4,[sp,#8]
00001c  f7fffffe          BL       ip4_output_if_src
;;;819    #endif /* IP_OPTIONS_SEND */
;;;820    }
000020  bdfe              POP      {r1-r7,pc}
;;;821    
                          ENDP


                          AREA ||i.ip4_output_if_src||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  ip4_output_if_src PROC
;;;826    err_t
;;;827    ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;828                      u8_t ttl, u8_t tos,
;;;829                      u8_t proto, struct netif *netif)
;;;830    {
000004  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
000008  f8dd8030          LDR      r8,[sp,#0x30]
00000c  4605              MOV      r5,r0
00000e  4689              MOV      r9,r1
000010  4616              MOV      r6,r2
000012  461f              MOV      r7,r3
;;;831    #if IP_OPTIONS_SEND
;;;832      return ip4_output_if_opt_src(p, src, dest, ttl, tos, proto, netif, NULL, 0);
;;;833    }
;;;834    
;;;835    /**
;;;836     * Same as ip_output_if_opt() but 'src' address is not replaced by netif address
;;;837     * when it is 'any'.
;;;838     */
;;;839    err_t
;;;840    ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
;;;841                          u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
;;;842                          u16_t optlen)
;;;843    {
;;;844    #endif /* IP_OPTIONS_SEND */
;;;845      struct ip_hdr *iphdr;
;;;846      ip4_addr_t dest_addr;
;;;847    #if CHECKSUM_GEN_IP_INLINE
;;;848      u32_t chk_sum = 0;
;;;849    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;850    
;;;851      LWIP_ASSERT_CORE_LOCKED();
;;;852      LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
000014  7ba8              LDRB     r0,[r5,#0xe]
000016  2801              CMP      r0,#1
000018  d006              BEQ      |L5.40|
00001a  a330              ADR      r3,|L5.220|
00001c  f44f7255          MOV      r2,#0x354
000020  a13b              ADR      r1,|L5.272|
000022  a03e              ADR      r0,|L5.284|
000024  f7fffffe          BL       __2printf
                  |L5.40|
;;;853    
;;;854      MIB2_STATS_INC(mib2.ipoutrequests);
;;;855    
;;;856      /* Should the IP header be generated or is it already included in p? */
;;;857      if (dest != LWIP_IP_HDRINCL) {
;;;858        u16_t ip_hlen = IP_HLEN;
;;;859    #if IP_OPTIONS_SEND
;;;860        u16_t optlen_aligned = 0;
;;;861        if (optlen != 0) {
;;;862    #if CHECKSUM_GEN_IP_INLINE
;;;863          int i;
;;;864    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;865          if (optlen > (IP_HLEN_MAX - IP_HLEN)) {
;;;866            /* optlen too long */
;;;867            LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output_if_opt: optlen too long\n"));
;;;868            IP_STATS_INC(ip.err);
;;;869            MIB2_STATS_INC(mib2.ipoutdiscards);
;;;870            return ERR_VAL;
;;;871          }
;;;872          /* round up to a multiple of 4 */
;;;873          optlen_aligned = (u16_t)((optlen + 3) & ~3);
;;;874          ip_hlen = (u16_t)(ip_hlen + optlen_aligned);
;;;875          /* First write in the IP options */
;;;876          if (pbuf_add_header(p, optlen_aligned)) {
;;;877            LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output_if_opt: not enough room for IP options in pbuf\n"));
;;;878            IP_STATS_INC(ip.err);
;;;879            MIB2_STATS_INC(mib2.ipoutdiscards);
;;;880            return ERR_BUF;
;;;881          }
;;;882          MEMCPY(p->payload, ip_options, optlen);
;;;883          if (optlen < optlen_aligned) {
;;;884            /* zero the remaining bytes */
;;;885            memset(((char *)p->payload) + optlen, 0, (size_t)(optlen_aligned - optlen));
;;;886          }
;;;887    #if CHECKSUM_GEN_IP_INLINE
;;;888          for (i = 0; i < optlen_aligned / 2; i++) {
;;;889            chk_sum += ((u16_t *)p->payload)[i];
;;;890          }
;;;891    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;892        }
;;;893    #endif /* IP_OPTIONS_SEND */
;;;894        /* generate IP header */
;;;895        if (pbuf_add_header(p, IP_HLEN)) {
;;;896          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: not enough room for IP header in pbuf\n"));
;;;897    
;;;898          IP_STATS_INC(ip.err);
;;;899          MIB2_STATS_INC(mib2.ipoutdiscards);
;;;900          return ERR_BUF;
000028  f06f0401          MVN      r4,#1
00002c  2e00              CMP      r6,#0                 ;857
00002e  d038              BEQ      |L5.162|
000030  2114              MOVS     r1,#0x14              ;895
000032  4628              MOV      r0,r5                 ;895
000034  f7fffffe          BL       pbuf_add_header
000038  b110              CBZ      r0,|L5.64|
00003a  4620              MOV      r0,r4
                  |L5.60|
;;;901        }
;;;902    
;;;903        iphdr = (struct ip_hdr *)p->payload;
;;;904        LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
;;;905                    (p->len >= sizeof(struct ip_hdr)));
;;;906    
;;;907        IPH_TTL_SET(iphdr, ttl);
;;;908        IPH_PROTO_SET(iphdr, proto);
;;;909    #if CHECKSUM_GEN_IP_INLINE
;;;910        chk_sum += PP_NTOHS(proto | (ttl << 8));
;;;911    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;912    
;;;913        /* dest cannot be NULL here */
;;;914        ip4_addr_copy(iphdr->dest, *dest);
;;;915    #if CHECKSUM_GEN_IP_INLINE
;;;916        chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
;;;917        chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
;;;918    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;919    
;;;920        IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
;;;921        IPH_TOS_SET(iphdr, tos);
;;;922    #if CHECKSUM_GEN_IP_INLINE
;;;923        chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
;;;924    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;925        IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
;;;926    #if CHECKSUM_GEN_IP_INLINE
;;;927        chk_sum += iphdr->_len;
;;;928    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;929        IPH_OFFSET_SET(iphdr, 0);
;;;930        IPH_ID_SET(iphdr, lwip_htons(ip_id));
;;;931    #if CHECKSUM_GEN_IP_INLINE
;;;932        chk_sum += iphdr->_id;
;;;933    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;934        ++ip_id;
;;;935    
;;;936        if (src == NULL) {
;;;937          ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
;;;938        } else {
;;;939          /* src cannot be NULL here */
;;;940          ip4_addr_copy(iphdr->src, *src);
;;;941        }
;;;942    
;;;943    #if CHECKSUM_GEN_IP_INLINE
;;;944        chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
;;;945        chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
;;;946        chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
;;;947        chk_sum = (chk_sum >> 16) + chk_sum;
;;;948        chk_sum = ~chk_sum;
;;;949        IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
;;;950          iphdr->_chksum = (u16_t)chk_sum; /* network order */
;;;951        }
;;;952    #if LWIP_CHECKSUM_CTRL_PER_NETIF
;;;953        else {
;;;954          IPH_CHKSUM_SET(iphdr, 0);
;;;955        }
;;;956    #endif /* LWIP_CHECKSUM_CTRL_PER_NETIF*/
;;;957    #else /* CHECKSUM_GEN_IP_INLINE */
;;;958        IPH_CHKSUM_SET(iphdr, 0);
;;;959    #if CHECKSUM_GEN_IP
;;;960        IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
;;;961          IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
;;;962        }
;;;963    #endif /* CHECKSUM_GEN_IP */
;;;964    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;965      } else {
;;;966        /* IP header already included in p */
;;;967        if (p->len < IP_HLEN) {
;;;968          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: LWIP_IP_HDRINCL but pbuf is too short\n"));
;;;969          IP_STATS_INC(ip.err);
;;;970          MIB2_STATS_INC(mib2.ipoutdiscards);
;;;971          return ERR_BUF;
;;;972        }
;;;973        iphdr = (struct ip_hdr *)p->payload;
;;;974        ip4_addr_copy(dest_addr, iphdr->dest);
;;;975        dest = &dest_addr;
;;;976      }
;;;977    
;;;978      IP_STATS_INC(ip.xmit);
;;;979    
;;;980      LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], (u16_t)netif->num));
;;;981      ip4_debug_print(p);
;;;982    
;;;983    #if ENABLE_LOOPBACK
;;;984      if (ip4_addr_cmp(dest, netif_ip4_addr(netif))
;;;985    #if !LWIP_HAVE_LOOPIF
;;;986          || ip4_addr_isloopback(dest)
;;;987    #endif /* !LWIP_HAVE_LOOPIF */
;;;988         ) {
;;;989        /* Packet to self, enqueue it for loopback */
;;;990        LWIP_DEBUGF(IP_DEBUG, ("netif_loop_output()"));
;;;991        return netif_loop_output(netif, p);
;;;992      }
;;;993    #if LWIP_MULTICAST_TX_OPTIONS
;;;994      if ((p->flags & PBUF_FLAG_MCASTLOOP) != 0) {
;;;995        netif_loop_output(netif, p);
;;;996      }
;;;997    #endif /* LWIP_MULTICAST_TX_OPTIONS */
;;;998    #endif /* ENABLE_LOOPBACK */
;;;999    #if IP_FRAG
;;;1000     /* don't fragment if interface has mtu set to 0 [loopif] */
;;;1001     if (netif->mtu && (p->tot_len > netif->mtu)) {
;;;1002       return ip4_frag(p, netif, dest);
;;;1003     }
;;;1004   #endif /* IP_FRAG */
;;;1005   
;;;1006     LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
;;;1007     return netif->output(netif, p, dest);
;;;1008   }
00003c  e8bd8ff8          POP      {r3-r11,pc}
                  |L5.64|
000040  686c              LDR      r4,[r5,#4]            ;903
000042  8968              LDRH     r0,[r5,#0xa]          ;904
000044  2814              CMP      r0,#0x14              ;904
000046  d206              BCS      |L5.86|
000048  a324              ADR      r3,|L5.220|
00004a  f44f7262          MOV      r2,#0x388             ;904
00004e  a13d              ADR      r1,|L5.324|
000050  a032              ADR      r0,|L5.284|
000052  f7fffffe          BL       __2printf
                  |L5.86|
000056  7227              STRB     r7,[r4,#8]            ;907
000058  f884b009          STRB     r11,[r4,#9]           ;908
00005c  6830              LDR      r0,[r6,#0]            ;914
00005e  6120              STR      r0,[r4,#0x10]         ;914
000060  2045              MOVS     r0,#0x45              ;920
000062  7020              STRB     r0,[r4,#0]            ;920
000064  f884a001          STRB     r10,[r4,#1]           ;921
000068  8928              LDRH     r0,[r5,#8]            ;925
00006a  f7fffffe          BL       lwip_htons
00006e  8060              STRH     r0,[r4,#2]            ;925
000070  f04f0a00          MOV      r10,#0                ;929
000074  f8a4a006          STRH     r10,[r4,#6]           ;929
000078  4f3e              LDR      r7,|L5.372|
00007a  8838              LDRH     r0,[r7,#0]            ;930  ; ip_id
00007c  f7fffffe          BL       lwip_htons
000080  80a0              STRH     r0,[r4,#4]            ;930
000082  8838              LDRH     r0,[r7,#0]            ;934  ; ip_id
000084  1c40              ADDS     r0,r0,#1              ;934
000086  8038              STRH     r0,[r7,#0]            ;934
000088  f1b90f00          CMP      r9,#0                 ;936
00008c  d005              BEQ      |L5.154|
00008e  f8d90000          LDR      r0,[r9,#0]            ;940
000092  60e0              STR      r0,[r4,#0xc]          ;940
                  |L5.148|
000094  f8a4a00a          STRH     r10,[r4,#0xa]         ;958
000098  e00c              B        |L5.180|
                  |L5.154|
00009a  4837              LDR      r0,|L5.376|
00009c  6800              LDR      r0,[r0,#0]            ;937  ; ip_addr_any
00009e  60e0              STR      r0,[r4,#0xc]          ;937
0000a0  e7f8              B        |L5.148|
                  |L5.162|
0000a2  8968              LDRH     r0,[r5,#0xa]          ;967
0000a4  2814              CMP      r0,#0x14              ;967
0000a6  d201              BCS      |L5.172|
0000a8  4620              MOV      r0,r4                 ;971
0000aa  e7c7              B        |L5.60|
                  |L5.172|
0000ac  6868              LDR      r0,[r5,#4]            ;973
0000ae  6900              LDR      r0,[r0,#0x10]         ;974
0000b0  9000              STR      r0,[sp,#0]            ;974
0000b2  466e              MOV      r6,sp                 ;975
                  |L5.180|
0000b4  f8b8002c          LDRH     r0,[r8,#0x2c]         ;1001
0000b8  b140              CBZ      r0,|L5.204|
0000ba  8929              LDRH     r1,[r5,#8]            ;1001
0000bc  4281              CMP      r1,r0                 ;1001
0000be  d905              BLS      |L5.204|
0000c0  4632              MOV      r2,r6                 ;1002
0000c2  4641              MOV      r1,r8                 ;1002
0000c4  4628              MOV      r0,r5                 ;1002
0000c6  f7fffffe          BL       ip4_frag
0000ca  e7b7              B        |L5.60|
                  |L5.204|
0000cc  f8d83014          LDR      r3,[r8,#0x14]         ;1007
0000d0  4632              MOV      r2,r6                 ;1007
0000d2  4629              MOV      r1,r5                 ;1007
0000d4  4640              MOV      r0,r8                 ;1007
0000d6  4798              BLX      r3                    ;1007
0000d8  e7b0              B        |L5.60|
;;;1009   
                          ENDP

0000da  0000              DCW      0x0000
                  |L5.220|
0000dc  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip"
0000e0  6964646c
0000e4  65776172
0000e8  65735c54
0000ec  68697264
0000f0  5f506172
0000f4  74795c4c
0000f8  7749505c
0000fc  7372635c
000100  636f7265
000104  5c697076
000108  345c6970
00010c  342e6300          DCB      "4.c",0
                  |L5.272|
000110  702d3e72          DCB      "p->ref == 1",0
000114  6566203d
000118  3d203100
                  |L5.284|
00011c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000120  7274696f
000124  6e202225
000128  73222066
00012c  61696c65
000130  64206174
000134  206c696e
000138  65202564
00013c  20696e20
000140  25730a00
                  |L5.324|
000144  63686563          DCB      "check that first pbuf can hold struct ip_hdr",0
000148  6b207468
00014c  61742066
000150  69727374
000154  20706275
000158  66206361
00015c  6e20686f
000160  6c642073
000164  74727563
000168  74206970
00016c  5f686472
000170  00      
000171  00                DCB      0
000172  00                DCB      0
000173  00                DCB      0
                  |L5.372|
                          DCD      ||.data||
                  |L5.376|
                          DCD      ip_addr_any

                          AREA ||i.ip4_route||, CODE, READONLY, ALIGN=2

                  ip4_route PROC
;;;151    struct netif *
;;;152    ip4_route(const ip4_addr_t *dest)
000000  b570              PUSH     {r4-r6,lr}
;;;153    {
000002  4606              MOV      r6,r0
;;;154    #if !LWIP_SINGLE_NETIF
;;;155      struct netif *netif;
;;;156    
;;;157      LWIP_ASSERT_CORE_LOCKED();
;;;158    
;;;159    #if LWIP_MULTICAST_TX_OPTIONS
;;;160      /* Use administratively selected interface for multicast by default */
;;;161      if (ip4_addr_ismulticast(dest) && ip4_default_multicast_netif) {
;;;162        return ip4_default_multicast_netif;
;;;163      }
;;;164    #endif /* LWIP_MULTICAST_TX_OPTIONS */
;;;165    
;;;166      /* bug #54569: in case LWIP_SINGLE_NETIF=1 and LWIP_DEBUGF() disabled, the following loop is optimized away */
;;;167      LWIP_UNUSED_ARG(dest);
;;;168    
;;;169      /* iterate through netifs */
;;;170      NETIF_FOREACH(netif) {
000004  4814              LDR      r0,|L6.88|
000006  6800              LDR      r0,[r0,#0]  ; netif_list
000008  e014              B        |L6.52|
                  |L6.10|
;;;171        /* is the netif up, does it have a link and a valid address? */
;;;172        if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
00000a  f8901035          LDRB     r1,[r0,#0x35]
00000e  07ca              LSLS     r2,r1,#31
000010  d00f              BEQ      |L6.50|
000012  074a              LSLS     r2,r1,#29
000014  d50d              BPL      |L6.50|
000016  6843              LDR      r3,[r0,#4]
000018  b15b              CBZ      r3,|L6.50|
;;;173          /* network mask matches? */
;;;174          if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
00001a  6884              LDR      r4,[r0,#8]
00001c  6832              LDR      r2,[r6,#0]
00001e  4023              ANDS     r3,r3,r4
000020  ea020504          AND      r5,r2,r4
000024  429d              CMP      r5,r3
000026  d016              BEQ      |L6.86|
;;;175            /* return netif on which to forward IP packet */
;;;176            return netif;
;;;177          }
;;;178          /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
;;;179          if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
000028  0789              LSLS     r1,r1,#30
00002a  d402              BMI      |L6.50|
00002c  68c1              LDR      r1,[r0,#0xc]
00002e  428a              CMP      r2,r1
000030  d011              BEQ      |L6.86|
                  |L6.50|
000032  6800              LDR      r0,[r0,#0]            ;170
                  |L6.52|
000034  2800              CMP      r0,#0                 ;170
000036  d1e8              BNE      |L6.10|
;;;180            /* return netif on which to forward IP packet */
;;;181            return netif;
;;;182          }
;;;183        }
;;;184      }
;;;185    
;;;186    #if LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF
;;;187      /* loopif is disabled, looopback traffic is passed through any netif */
;;;188      if (ip4_addr_isloopback(dest)) {
;;;189        /* don't check for link on loopback traffic */
;;;190        if (netif_default != NULL && netif_is_up(netif_default)) {
;;;191          return netif_default;
;;;192        }
;;;193        /* default netif is not up, just use any netif for loopback traffic */
;;;194        NETIF_FOREACH(netif) {
;;;195          if (netif_is_up(netif)) {
;;;196            return netif;
;;;197          }
;;;198        }
;;;199        return NULL;
;;;200      }
;;;201    #endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
;;;202    
;;;203    #ifdef LWIP_HOOK_IP4_ROUTE_SRC
;;;204      netif = LWIP_HOOK_IP4_ROUTE_SRC(NULL, dest);
;;;205      if (netif != NULL) {
;;;206        return netif;
;;;207      }
;;;208    #elif defined(LWIP_HOOK_IP4_ROUTE)
;;;209      netif = LWIP_HOOK_IP4_ROUTE(dest);
;;;210      if (netif != NULL) {
;;;211        return netif;
;;;212      }
;;;213    #endif
;;;214    #endif /* !LWIP_SINGLE_NETIF */
;;;215    
;;;216      if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
000038  4808              LDR      r0,|L6.92|
00003a  6800              LDR      r0,[r0,#0]  ; netif_default
00003c  b150              CBZ      r0,|L6.84|
00003e  f8901035          LDRB     r1,[r0,#0x35]
000042  07ca              LSLS     r2,r1,#31
000044  d006              BEQ      |L6.84|
000046  0749              LSLS     r1,r1,#29
000048  d504              BPL      |L6.84|
;;;217          ip4_addr_isany_val(*netif_ip4_addr(netif_default)) || ip4_addr_isloopback(dest)) {
00004a  6841              LDR      r1,[r0,#4]
00004c  b111              CBZ      r1,|L6.84|
00004e  7831              LDRB     r1,[r6,#0]
000050  297f              CMP      r1,#0x7f
000052  d100              BNE      |L6.86|
                  |L6.84|
;;;218        /* No matching netif found and default netif is not usable.
;;;219           If this is not good enough for you, use LWIP_HOOK_IP4_ROUTE() */
;;;220        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;221                    ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
;;;222        IP_STATS_INC(ip.rterr);
;;;223        MIB2_STATS_INC(mib2.ipoutnoroutes);
;;;224        return NULL;
000054  2000              MOVS     r0,#0
                  |L6.86|
;;;225      }
;;;226    
;;;227      return netif_default;
;;;228    }
000056  bd70              POP      {r4-r6,pc}
;;;229    
                          ENDP

                  |L6.88|
                          DCD      netif_list
                  |L6.92|
                          DCD      netif_default

                          AREA ||.data||, DATA, ALIGN=1

                  ip_id
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip4.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_ip4_c_df8b5ec6____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_ip4_c_df8b5ec6____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_ip4_c_df8b5ec6____REVSH|
#line 478
|__asm___5_ip4_c_df8b5ec6____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_ip4_c_df8b5ec6____RRX|
#line 665
|__asm___5_ip4_c_df8b5ec6____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
