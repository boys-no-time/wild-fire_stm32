; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ip4.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ip4.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\system\arch -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Inc -I..\Middlewares\Third_Party\LwIP\src\include -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\ip4.crf ..\Middlewares\Third_Party\LwIP\src\core\ipv4\ip4.c]
                          THUMB

                          AREA ||i.ip4_input||, CODE, READONLY, ALIGN=2

                  ip4_input PROC
;;;373    err_t
;;;374    ip4_input(struct pbuf *p, struct netif *inp)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;375    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;376      struct ip_hdr *iphdr;
;;;377      struct netif *netif;
;;;378      u16_t iphdr_hlen;
;;;379      u16_t iphdr_len;
;;;380    #if IP_ACCEPT_LINK_LAYER_ADDRESSING || LWIP_IGMP
;;;381      int check_ip_src = 1;
000008  f04f0b01          MOV      r11,#1
;;;382    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING || LWIP_IGMP */
;;;383    
;;;384      IP_STATS_INC(ip.recv);
;;;385      MIB2_STATS_INC(mib2.ipinreceives);
;;;386    
;;;387      /* identify the IP header */
;;;388      iphdr = (struct ip_hdr *)p->payload;
00000c  6875              LDR      r5,[r6,#4]
;;;389      if (IPH_V(iphdr) != 4) {
00000e  2104              MOVS     r1,#4
000010  7828              LDRB     r0,[r5,#0]
000012  ebb11f10          CMP      r1,r0,LSR #4
000016  d005              BEQ      |L1.36|
;;;390        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IP packet dropped due to bad version number %"U16_F"\n", (u16_t)IPH_V(iphdr)));
;;;391        ip4_debug_print(p);
;;;392        pbuf_free(p);
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       pbuf_free
;;;393        IP_STATS_INC(ip.err);
;;;394        IP_STATS_INC(ip.drop);
;;;395        MIB2_STATS_INC(mib2.ipinhdrerrors);
;;;396        return ERR_OK;
00001e  2000              MOVS     r0,#0
                  |L1.32|
;;;397      }
;;;398    
;;;399    #ifdef LWIP_HOOK_IP4_INPUT
;;;400      if (LWIP_HOOK_IP4_INPUT(p, inp)) {
;;;401        /* the packet has been eaten */
;;;402        return ERR_OK;
;;;403      }
;;;404    #endif
;;;405    
;;;406      /* obtain IP header length in number of 32-bit words */
;;;407      iphdr_hlen = IPH_HL(iphdr);
;;;408      /* calculate IP header length in bytes */
;;;409      iphdr_hlen *= 4;
;;;410      /* obtain ip length in bytes */
;;;411      iphdr_len = lwip_ntohs(IPH_LEN(iphdr));
;;;412    
;;;413      /* Trim pbuf. This is especially required for packets < 60 bytes. */
;;;414      if (iphdr_len < p->tot_len) {
;;;415        pbuf_realloc(p, iphdr_len);
;;;416      }
;;;417    
;;;418      /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
;;;419      if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len) || (iphdr_hlen < IP_HLEN)) {
;;;420        if (iphdr_hlen < IP_HLEN) {
;;;421          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;422            ("ip4_input: short IP header (%"U16_F" bytes) received, IP packet dropped\n", iphdr_hlen));
;;;423        }
;;;424        if (iphdr_hlen > p->len) {
;;;425          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;426            ("IP header (len %"U16_F") does not fit in first pbuf (len %"U16_F"), IP packet dropped.\n",
;;;427            iphdr_hlen, p->len));
;;;428        }
;;;429        if (iphdr_len > p->tot_len) {
;;;430          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;431            ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
;;;432            iphdr_len, p->tot_len));
;;;433        }
;;;434        /* free (drop) packet pbufs */
;;;435        pbuf_free(p);
;;;436        IP_STATS_INC(ip.lenerr);
;;;437        IP_STATS_INC(ip.drop);
;;;438        MIB2_STATS_INC(mib2.ipindiscards);
;;;439        return ERR_OK;
;;;440      }
;;;441    
;;;442      /* verify checksum */
;;;443    #if CHECKSUM_CHECK_IP
;;;444      IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_IP) {
;;;445        if (inet_chksum(iphdr, iphdr_hlen) != 0) {
;;;446    
;;;447          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;448            ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
;;;449          ip4_debug_print(p);
;;;450          pbuf_free(p);
;;;451          IP_STATS_INC(ip.chkerr);
;;;452          IP_STATS_INC(ip.drop);
;;;453          MIB2_STATS_INC(mib2.ipinhdrerrors);
;;;454          return ERR_OK;
;;;455        }
;;;456      }
;;;457    #endif
;;;458    
;;;459      /* copy IP addresses to aligned ip_addr_t */
;;;460      ip_addr_copy_from_ip4(ip_data.current_iphdr_dest, iphdr->dest);
;;;461      ip_addr_copy_from_ip4(ip_data.current_iphdr_src, iphdr->src);
;;;462    
;;;463      /* match packet against an interface, i.e. is this packet for us? */
;;;464      if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
;;;465    #if LWIP_IGMP
;;;466        if ((inp->flags & NETIF_FLAG_IGMP) && (igmp_lookfor_group(inp, ip4_current_dest_addr()))) {
;;;467          /* IGMP snooping switches need 0.0.0.0 to be allowed as source address (RFC 4541) */
;;;468          ip4_addr_t allsystems;
;;;469          IP4_ADDR(&allsystems, 224, 0, 0, 1);
;;;470          if (ip4_addr_cmp(ip4_current_dest_addr(), &allsystems) &&
;;;471              ip4_addr_isany(ip4_current_src_addr())) {
;;;472            check_ip_src = 0;
;;;473          }
;;;474          netif = inp;
;;;475        } else {
;;;476          netif = NULL;
;;;477        }
;;;478    #else /* LWIP_IGMP */
;;;479        if ((netif_is_up(inp)) && (!ip4_addr_isany_val(*netif_ip4_addr(inp)))) {
;;;480          netif = inp;
;;;481        } else {
;;;482          netif = NULL;
;;;483        }
;;;484    #endif /* LWIP_IGMP */
;;;485      } else {
;;;486        /* start trying with inp. if that's not acceptable, start walking the
;;;487           list of configured netifs.
;;;488           'first' is used as a boolean to mark whether we started walking the list */
;;;489        int first = 1;
;;;490        netif = inp;
;;;491        do {
;;;492          LWIP_DEBUGF(IP_DEBUG, ("ip_input: iphdr->dest 0x%"X32_F" netif->ip_addr 0x%"X32_F" (0x%"X32_F", 0x%"X32_F", 0x%"X32_F")\n",
;;;493              ip4_addr_get_u32(&iphdr->dest), ip4_addr_get_u32(netif_ip4_addr(netif)),
;;;494              ip4_addr_get_u32(&iphdr->dest) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
;;;495              ip4_addr_get_u32(netif_ip4_addr(netif)) & ip4_addr_get_u32(netif_ip4_netmask(netif)),
;;;496              ip4_addr_get_u32(&iphdr->dest) & ~ip4_addr_get_u32(netif_ip4_netmask(netif))));
;;;497    
;;;498          /* interface is up and configured? */
;;;499          if ((netif_is_up(netif)) && (!ip4_addr_isany_val(*netif_ip4_addr(netif)))) {
;;;500            /* unicast to this interface address? */
;;;501            if (ip4_addr_cmp(ip4_current_dest_addr(), netif_ip4_addr(netif)) ||
;;;502                /* or broadcast on this interface network address? */
;;;503                ip4_addr_isbroadcast(ip4_current_dest_addr(), netif)
;;;504    #if LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF
;;;505                || (ip4_addr_get_u32(ip4_current_dest_addr()) == PP_HTONL(IPADDR_LOOPBACK))
;;;506    #endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
;;;507                ) {
;;;508              LWIP_DEBUGF(IP_DEBUG, ("ip4_input: packet accepted on interface %c%c\n",
;;;509                  netif->name[0], netif->name[1]));
;;;510              /* break out of for loop */
;;;511              break;
;;;512            }
;;;513    #if LWIP_AUTOIP
;;;514            /* connections to link-local addresses must persist after changing
;;;515               the netif's address (RFC3927 ch. 1.9) */
;;;516            if (autoip_accept_packet(netif, ip4_current_dest_addr())) {
;;;517              LWIP_DEBUGF(IP_DEBUG, ("ip4_input: LLA packet accepted on interface %c%c\n",
;;;518                  netif->name[0], netif->name[1]));
;;;519              /* break out of for loop */
;;;520              break;
;;;521            }
;;;522    #endif /* LWIP_AUTOIP */
;;;523          }
;;;524          if (first) {
;;;525    #if !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF
;;;526            /* Packets sent to the loopback address must not be accepted on an
;;;527             * interface that does not have the loopback address assigned to it,
;;;528             * unless a non-loopback interface is used for loopback traffic. */
;;;529            if (ip4_addr_isloopback(ip4_current_dest_addr())) {
;;;530              netif = NULL;
;;;531              break;
;;;532            }
;;;533    #endif /* !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF */
;;;534            first = 0;
;;;535            netif = netif_list;
;;;536          } else {
;;;537            netif = netif->next;
;;;538          }
;;;539          if (netif == inp) {
;;;540            netif = netif->next;
;;;541          }
;;;542        } while (netif != NULL);
;;;543      }
;;;544    
;;;545    #if IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;546      /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
;;;547       * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
;;;548       * According to RFC 1542 section 3.1.1, referred by RFC 2131).
;;;549       *
;;;550       * If you want to accept private broadcast communication while a netif is down,
;;;551       * define LWIP_IP_ACCEPT_UDP_PORT(dst_port), e.g.:
;;;552       *
;;;553       * #define LWIP_IP_ACCEPT_UDP_PORT(dst_port) ((dst_port) == PP_NTOHS(12345))
;;;554       */
;;;555      if (netif == NULL) {
;;;556        /* remote port is DHCP server? */
;;;557        if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
;;;558          struct udp_hdr *udphdr = (struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen);
;;;559          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: UDP packet to DHCP client port %"U16_F"\n",
;;;560            lwip_ntohs(udphdr->dest)));
;;;561          if (IP_ACCEPT_LINK_LAYER_ADDRESSED_PORT(udphdr->dest)) {
;;;562            LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: DHCP packet accepted.\n"));
;;;563            netif = inp;
;;;564            check_ip_src = 0;
;;;565          }
;;;566        }
;;;567      }
;;;568    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;569    
;;;570      /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
;;;571    #if LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;572      if (check_ip_src
;;;573    #if IP_ACCEPT_LINK_LAYER_ADDRESSING
;;;574      /* DHCP servers need 0.0.0.0 to be allowed as source address (RFC 1.1.2.2: 3.2.1.3/a) */
;;;575          && !ip4_addr_isany_val(*ip4_current_src_addr())
;;;576    #endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;577         )
;;;578    #endif /* LWIP_IGMP || IP_ACCEPT_LINK_LAYER_ADDRESSING */
;;;579      {
;;;580        if ((ip4_addr_isbroadcast(ip4_current_src_addr(), inp)) ||
;;;581            (ip4_addr_ismulticast(ip4_current_src_addr()))) {
;;;582          /* packet source is not valid */
;;;583          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("ip4_input: packet source is not valid.\n"));
;;;584          /* free (drop) packet pbufs */
;;;585          pbuf_free(p);
;;;586          IP_STATS_INC(ip.drop);
;;;587          MIB2_STATS_INC(mib2.ipinaddrerrors);
;;;588          MIB2_STATS_INC(mib2.ipindiscards);
;;;589          return ERR_OK;
;;;590        }
;;;591      }
;;;592    
;;;593      /* packet not for us? */
;;;594      if (netif == NULL) {
;;;595        /* packet not for us, route or discard */
;;;596        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE, ("ip4_input: packet not for us.\n"));
;;;597    #if IP_FORWARD
;;;598        /* non-broadcast packet? */
;;;599        if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), inp)) {
;;;600          /* try to forward IP packet on (other) interfaces */
;;;601          ip4_forward(p, iphdr, inp);
;;;602        } else
;;;603    #endif /* IP_FORWARD */
;;;604        {
;;;605          IP_STATS_INC(ip.drop);
;;;606          MIB2_STATS_INC(mib2.ipinaddrerrors);
;;;607          MIB2_STATS_INC(mib2.ipindiscards);
;;;608        }
;;;609        pbuf_free(p);
;;;610        return ERR_OK;
;;;611      }
;;;612      /* packet consists of multiple fragments? */
;;;613      if ((IPH_OFFSET(iphdr) & PP_HTONS(IP_OFFMASK | IP_MF)) != 0) {
;;;614    #if IP_REASSEMBLY /* packet fragment reassembly code present? */
;;;615        LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip4_reass()\n",
;;;616          lwip_ntohs(IPH_ID(iphdr)), p->tot_len, lwip_ntohs(IPH_LEN(iphdr)), (u16_t)!!(IPH_OFFSET(iphdr) & PP_HTONS(IP_MF)), (u16_t)((lwip_ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8)));
;;;617        /* reassemble the packet*/
;;;618        p = ip4_reass(p);
;;;619        /* packet not fully reassembled yet? */
;;;620        if (p == NULL) {
;;;621          return ERR_OK;
;;;622        }
;;;623        iphdr = (struct ip_hdr *)p->payload;
;;;624    #else /* IP_REASSEMBLY == 0, no packet fragment reassembly code present */
;;;625        pbuf_free(p);
;;;626        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since it was fragmented (0x%"X16_F") (while IP_REASSEMBLY == 0).\n",
;;;627          lwip_ntohs(IPH_OFFSET(iphdr))));
;;;628        IP_STATS_INC(ip.opterr);
;;;629        IP_STATS_INC(ip.drop);
;;;630        /* unsupported protocol feature */
;;;631        MIB2_STATS_INC(mib2.ipinunknownprotos);
;;;632        return ERR_OK;
;;;633    #endif /* IP_REASSEMBLY */
;;;634      }
;;;635    
;;;636    #if IP_OPTIONS_ALLOWED == 0 /* no support for IP options in the IP header? */
;;;637    
;;;638    #if LWIP_IGMP
;;;639      /* there is an extra "router alert" option in IGMP messages which we allow for but do not police */
;;;640      if ((iphdr_hlen > IP_HLEN) &&  (IPH_PROTO(iphdr) != IP_PROTO_IGMP)) {
;;;641    #else
;;;642      if (iphdr_hlen > IP_HLEN) {
;;;643    #endif /* LWIP_IGMP */
;;;644        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("IP packet dropped since there were IP options (while IP_OPTIONS_ALLOWED == 0).\n"));
;;;645        pbuf_free(p);
;;;646        IP_STATS_INC(ip.opterr);
;;;647        IP_STATS_INC(ip.drop);
;;;648        /* unsupported protocol feature */
;;;649        MIB2_STATS_INC(mib2.ipinunknownprotos);
;;;650        return ERR_OK;
;;;651      }
;;;652    #endif /* IP_OPTIONS_ALLOWED == 0 */
;;;653    
;;;654      /* send to upper layers */
;;;655      LWIP_DEBUGF(IP_DEBUG, ("ip4_input: \n"));
;;;656      ip4_debug_print(p);
;;;657      LWIP_DEBUGF(IP_DEBUG, ("ip4_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));
;;;658    
;;;659      ip_data.current_netif = netif;
;;;660      ip_data.current_input_netif = inp;
;;;661      ip_data.current_ip4_header = iphdr;
;;;662      ip_data.current_ip_header_tot_len = IPH_HL(iphdr) * 4;
;;;663    
;;;664    #if LWIP_RAW
;;;665      /* raw input did not eat the packet? */
;;;666      if (raw_input(p, inp) == 0)
;;;667    #endif /* LWIP_RAW */
;;;668      {
;;;669        pbuf_header(p, -(s16_t)iphdr_hlen); /* Move to payload, no check necessary. */
;;;670    
;;;671        switch (IPH_PROTO(iphdr)) {
;;;672    #if LWIP_UDP
;;;673        case IP_PROTO_UDP:
;;;674    #if LWIP_UDPLITE
;;;675        case IP_PROTO_UDPLITE:
;;;676    #endif /* LWIP_UDPLITE */
;;;677          MIB2_STATS_INC(mib2.ipindelivers);
;;;678          udp_input(p, inp);
;;;679          break;
;;;680    #endif /* LWIP_UDP */
;;;681    #if LWIP_TCP
;;;682        case IP_PROTO_TCP:
;;;683          MIB2_STATS_INC(mib2.ipindelivers);
;;;684          tcp_input(p, inp);
;;;685          break;
;;;686    #endif /* LWIP_TCP */
;;;687    #if LWIP_ICMP
;;;688        case IP_PROTO_ICMP:
;;;689          MIB2_STATS_INC(mib2.ipindelivers);
;;;690          icmp_input(p, inp);
;;;691          break;
;;;692    #endif /* LWIP_ICMP */
;;;693    #if LWIP_IGMP
;;;694        case IP_PROTO_IGMP:
;;;695          igmp_input(p, inp, ip4_current_dest_addr());
;;;696          break;
;;;697    #endif /* LWIP_IGMP */
;;;698        default:
;;;699    #if LWIP_ICMP
;;;700          /* send ICMP destination protocol unreachable unless is was a broadcast */
;;;701          if (!ip4_addr_isbroadcast(ip4_current_dest_addr(), netif) &&
;;;702              !ip4_addr_ismulticast(ip4_current_dest_addr())) {
;;;703            pbuf_header_force(p, iphdr_hlen); /* Move to ip header, no check necessary. */
;;;704            p->payload = iphdr;
;;;705            icmp_dest_unreach(p, ICMP_DUR_PROTO);
;;;706          }
;;;707    #endif /* LWIP_ICMP */
;;;708          pbuf_free(p);
;;;709    
;;;710          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Unsupported transport protocol %"U16_F"\n", (u16_t)IPH_PROTO(iphdr)));
;;;711    
;;;712          IP_STATS_INC(ip.proterr);
;;;713          IP_STATS_INC(ip.drop);
;;;714          MIB2_STATS_INC(mib2.ipinunknownprotos);
;;;715        }
;;;716      }
;;;717    
;;;718      /* @todo: this is not really necessary... */
;;;719      ip_data.current_netif = NULL;
;;;720      ip_data.current_input_netif = NULL;
;;;721      ip_data.current_ip4_header = NULL;
;;;722      ip_data.current_ip_header_tot_len = 0;
;;;723      ip4_addr_set_any(ip4_current_src_addr());
;;;724      ip4_addr_set_any(ip4_current_dest_addr());
;;;725    
;;;726      return ERR_OK;
;;;727    }
000020  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.36|
000024  f000000f          AND      r0,r0,#0xf            ;407
000028  f64f71ff          MOV      r1,#0xffff            ;409
00002c  ea010880          AND      r8,r1,r0,LSL #2       ;409
000030  8868              LDRH     r0,[r5,#2]            ;411
000032  f7fffffe          BL       lwip_htons
000036  4604              MOV      r4,r0                 ;411
000038  8930              LDRH     r0,[r6,#8]            ;414
00003a  42a0              CMP      r0,r4                 ;414
00003c  d903              BLS      |L1.70|
00003e  4621              MOV      r1,r4                 ;415
000040  4630              MOV      r0,r6                 ;415
000042  f7fffffe          BL       pbuf_realloc
                  |L1.70|
000046  8970              LDRH     r0,[r6,#0xa]          ;419
000048  4540              CMP      r0,r8                 ;419
00004a  d305              BCC      |L1.88|
00004c  8930              LDRH     r0,[r6,#8]            ;419
00004e  42a0              CMP      r0,r4                 ;419
000050  d302              BCC      |L1.88|
000052  f1b80f14          CMP      r8,#0x14              ;419
000056  d204              BCS      |L1.98|
                  |L1.88|
000058  4630              MOV      r0,r6                 ;435
00005a  f7fffffe          BL       pbuf_free
00005e  2000              MOVS     r0,#0                 ;439
000060  e7de              B        |L1.32|
                  |L1.98|
000062  f8dfa184          LDR      r10,|L1.488|
000066  6928              LDR      r0,[r5,#0x10]         ;460
000068  f8ca0014          STR      r0,[r10,#0x14]        ;460  ; ip_data
00006c  68e9              LDR      r1,[r5,#0xc]          ;461
00006e  f8ca1010          STR      r1,[r10,#0x10]        ;461  ; ip_data
000072  f3c01003          UBFX     r0,r0,#4,#4           ;464
000076  280e              CMP      r0,#0xe               ;464
000078  d011              BEQ      |L1.158|
00007a  f04f0901          MOV      r9,#1                 ;489
00007e  463c              MOV      r4,r7                 ;490
                  |L1.128|
000080  f8940037          LDRB     r0,[r4,#0x37]         ;499
000084  07c0              LSLS     r0,r0,#31             ;499
000086  d014              BEQ      |L1.178|
000088  6861              LDR      r1,[r4,#4]            ;499
00008a  b191              CBZ      r1,|L1.178|
00008c  f8da0014          LDR      r0,[r10,#0x14]        ;501  ; ip_data
000090  4288              CMP      r0,r1                 ;501
000092  d022              BEQ      |L1.218|
000094  4621              MOV      r1,r4                 ;503
000096  f7fffffe          BL       ip4_addr_isbroadcast_u32
00009a  b9f0              CBNZ     r0,|L1.218|
00009c  e009              B        |L1.178|
                  |L1.158|
00009e  f8970037          LDRB     r0,[r7,#0x37]         ;479
0000a2  07c0              LSLS     r0,r0,#31             ;479
0000a4  d003              BEQ      |L1.174|
0000a6  6878              LDR      r0,[r7,#4]            ;479
0000a8  b108              CBZ      r0,|L1.174|
0000aa  463c              MOV      r4,r7                 ;480
0000ac  e015              B        |L1.218|
                  |L1.174|
0000ae  2400              MOVS     r4,#0                 ;482
0000b0  e013              B        |L1.218|
                  |L1.178|
0000b2  f1b90f00          CMP      r9,#0                 ;524
0000b6  d00a              BEQ      |L1.206|
0000b8  f89a0014          LDRB     r0,[r10,#0x14]        ;529  ; ip_data
0000bc  287f              CMP      r0,#0x7f              ;529
0000be  d004              BEQ      |L1.202|
0000c0  f04f0900          MOV      r9,#0                 ;534
0000c4  4849              LDR      r0,|L1.492|
0000c6  6804              LDR      r4,[r0,#0]            ;535  ; netif_list
0000c8  e002              B        |L1.208|
                  |L1.202|
0000ca  2400              MOVS     r4,#0                 ;530
0000cc  e005              B        |L1.218|
                  |L1.206|
0000ce  6824              LDR      r4,[r4,#0]            ;537
                  |L1.208|
0000d0  42bc              CMP      r4,r7                 ;539
0000d2  d100              BNE      |L1.214|
0000d4  6824              LDR      r4,[r4,#0]            ;540
                  |L1.214|
0000d6  2c00              CMP      r4,#0                 ;542
0000d8  d1d2              BNE      |L1.128|
                  |L1.218|
0000da  b95c              CBNZ     r4,|L1.244|
0000dc  7a68              LDRB     r0,[r5,#9]            ;557
0000de  2811              CMP      r0,#0x11              ;557
0000e0  d108              BNE      |L1.244|
0000e2  eb050008          ADD      r0,r5,r8              ;558
0000e6  8840              LDRH     r0,[r0,#2]            ;561
0000e8  f5b04f88          CMP      r0,#0x4400            ;561
0000ec  d102              BNE      |L1.244|
0000ee  463c              MOV      r4,r7                 ;563
0000f0  f04f0b00          MOV      r11,#0                ;564
                  |L1.244|
0000f4  f1bb0f00          CMP      r11,#0                ;572
0000f8  d00c              BEQ      |L1.276|
0000fa  f8da0010          LDR      r0,[r10,#0x10]        ;575  ; ip_data
0000fe  b148              CBZ      r0,|L1.276|
000100  4639              MOV      r1,r7                 ;580
000102  f7fffffe          BL       ip4_addr_isbroadcast_u32
000106  bb88              CBNZ     r0,|L1.364|
000108  f89a0010          LDRB     r0,[r10,#0x10]        ;581  ; ip_data
00010c  f3c01003          UBFX     r0,r0,#4,#4           ;581
000110  280e              CMP      r0,#0xe               ;581
000112  d02d              BEQ      |L1.368|
                  |L1.276|
000114  b35c              CBZ      r4,|L1.366|
000116  88e8              LDRH     r0,[r5,#6]            ;613
000118  f03000c0          BICS     r0,r0,#0xc0           ;613
00011c  d005              BEQ      |L1.298|
00011e  4630              MOV      r0,r6                 ;618
000120  f7fffffe          BL       ip4_reass
000124  4606              MOV      r6,r0                 ;618
000126  b36e              CBZ      r6,|L1.388|
000128  6875              LDR      r5,[r6,#4]            ;623
                  |L1.298|
00012a  f8ca4000          STR      r4,[r10,#0]           ;659  ; ip_data
00012e  f8ca7004          STR      r7,[r10,#4]           ;660  ; ip_data
000132  f8ca5008          STR      r5,[r10,#8]           ;661  ; ip_data
000136  7828              LDRB     r0,[r5,#0]            ;662
000138  0700              LSLS     r0,r0,#28             ;662
00013a  0e80              LSRS     r0,r0,#26             ;662
00013c  f8aa000c          STRH     r0,[r10,#0xc]         ;662
000140  fa0ff888          SXTH     r8,r8                 ;669
000144  f1c80000          RSB      r0,r8,#0              ;669
000148  b201              SXTH     r1,r0                 ;669
00014a  4630              MOV      r0,r6                 ;669
00014c  f7fffffe          BL       pbuf_header
000150  7a68              LDRB     r0,[r5,#9]            ;671
000152  2801              CMP      r0,#1                 ;671
000154  d022              BEQ      |L1.412|
000156  2806              CMP      r0,#6                 ;671
000158  d01b              BEQ      |L1.402|
00015a  2811              CMP      r0,#0x11              ;671
00015c  d014              BEQ      |L1.392|
00015e  4621              MOV      r1,r4                 ;701
000160  f8da0014          LDR      r0,[r10,#0x14]        ;701  ; ip_data
000164  f7fffffe          BL       ip4_addr_isbroadcast_u32
000168  b1e8              CBZ      r0,|L1.422|
00016a  e02b              B        |L1.452|
                  |L1.364|
00016c  e000              B        |L1.368|
                  |L1.366|
00016e  e004              B        |L1.378|
                  |L1.368|
000170  4630              MOV      r0,r6                 ;585
000172  f7fffffe          BL       pbuf_free
000176  2000              MOVS     r0,#0                 ;589
000178  e752              B        |L1.32|
                  |L1.378|
00017a  4630              MOV      r0,r6                 ;609
00017c  f7fffffe          BL       pbuf_free
000180  2000              MOVS     r0,#0                 ;610
000182  e74d              B        |L1.32|
                  |L1.388|
000184  2000              MOVS     r0,#0                 ;621
000186  e74b              B        |L1.32|
                  |L1.392|
000188  4639              MOV      r1,r7                 ;678
00018a  4630              MOV      r0,r6                 ;678
00018c  f7fffffe          BL       udp_input
000190  e01b              B        |L1.458|
                  |L1.402|
000192  4639              MOV      r1,r7                 ;684
000194  4630              MOV      r0,r6                 ;684
000196  f7fffffe          BL       tcp_input
00019a  e016              B        |L1.458|
                  |L1.412|
00019c  4639              MOV      r1,r7                 ;690
00019e  4630              MOV      r0,r6                 ;690
0001a0  f7fffffe          BL       icmp_input
0001a4  e011              B        |L1.458|
                  |L1.422|
0001a6  f89a0014          LDRB     r0,[r10,#0x14]        ;702  ; ip_data
0001aa  f3c01003          UBFX     r0,r0,#4,#4           ;702
0001ae  280e              CMP      r0,#0xe               ;702
0001b0  d008              BEQ      |L1.452|
0001b2  4641              MOV      r1,r8                 ;703
0001b4  4630              MOV      r0,r6                 ;703
0001b6  f7fffffe          BL       pbuf_header_force
0001ba  6075              STR      r5,[r6,#4]            ;704
0001bc  2102              MOVS     r1,#2                 ;705
0001be  4630              MOV      r0,r6                 ;705
0001c0  f7fffffe          BL       icmp_dest_unreach
                  |L1.452|
0001c4  4630              MOV      r0,r6                 ;708
0001c6  f7fffffe          BL       pbuf_free
                  |L1.458|
0001ca  2000              MOVS     r0,#0                 ;719
0001cc  f8ca0000          STR      r0,[r10,#0]           ;719  ; ip_data
0001d0  f8ca0004          STR      r0,[r10,#4]           ;720  ; ip_data
0001d4  f8ca0008          STR      r0,[r10,#8]           ;721  ; ip_data
0001d8  f8aa000c          STRH     r0,[r10,#0xc]         ;722
0001dc  f8ca0010          STR      r0,[r10,#0x10]        ;723  ; ip_data
0001e0  f8ca0014          STR      r0,[r10,#0x14]        ;724  ; ip_data
0001e4  e71c              B        |L1.32|
;;;728    
                          ENDP

0001e6  0000              DCW      0x0000
                  |L1.488|
                          DCD      ip_data
                  |L1.492|
                          DCD      netif_list

                          AREA ||i.ip4_output||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  ip4_output PROC
;;;981    err_t
;;;982    ip4_output(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;983              u8_t ttl, u8_t tos, u8_t proto)
;;;984    {
000004  e9dd560a          LDRD     r5,r6,[sp,#0x28]
000008  4604              MOV      r4,r0
00000a  4688              MOV      r8,r1
00000c  4617              MOV      r7,r2
00000e  4699              MOV      r9,r3
;;;985      struct netif *netif;
;;;986    
;;;987      LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
000010  89e0              LDRH     r0,[r4,#0xe]
000012  2801              CMP      r0,#1
000014  d006              BEQ      |L2.36|
000016  a30c              ADR      r3,|L2.72|
000018  f24032db          MOV      r2,#0x3db
00001c  a117              ADR      r1,|L2.124|
00001e  a01a              ADR      r0,|L2.136|
000020  f7fffffe          BL       __2printf
                  |L2.36|
;;;988    
;;;989      if ((netif = ip4_route_src(dest, src)) == NULL) {
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       ip4_route
00002a  b150              CBZ      r0,|L2.66|
;;;990        LWIP_DEBUGF(IP_DEBUG, ("ip4_output: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;991          ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
;;;992        IP_STATS_INC(ip.rterr);
;;;993        return ERR_RTE;
;;;994      }
;;;995    
;;;996      return ip4_output_if(p, src, dest, ttl, tos, proto, netif);
00002c  e9cd5600          STRD     r5,r6,[sp,#0]
000030  9002              STR      r0,[sp,#8]
000032  464b              MOV      r3,r9
000034  463a              MOV      r2,r7
000036  4641              MOV      r1,r8
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       ip4_output_if
                  |L2.62|
;;;997    }
00003e  e8bd83fe          POP      {r1-r9,pc}
                  |L2.66|
000042  f06f0003          MVN      r0,#3                 ;993
000046  e7fa              B        |L2.62|
;;;998    
                          ENDP

                  |L2.72|
000048  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip"
00004c  6964646c
000050  65776172
000054  65735c54
000058  68697264
00005c  5f506172
000060  74795c4c
000064  7749505c
000068  7372635c
00006c  636f7265
000070  5c697076
000074  345c6970
000078  342e6300          DCB      "4.c",0
                  |L2.124|
00007c  702d3e72          DCB      "p->ref == 1",0
000080  6566203d
000084  3d203100
                  |L2.136|
000088  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00008c  7274696f
000090  6e202225
000094  73222066
000098  61696c65
00009c  64206174
0000a0  206c696e
0000a4  65202564
0000a8  20696e20
0000ac  25730a00

                          AREA ||i.ip4_output_if||, CODE, READONLY, ALIGN=1

                  ip4_output_if PROC
;;;754    err_t
;;;755    ip4_output_if(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
000000  b5fe              PUSH     {r1-r7,lr}
;;;756                 u8_t ttl, u8_t tos,
;;;757                 u8_t proto, struct netif *netif)
;;;758    {
000002  e9dd6708          LDRD     r6,r7,[sp,#0x20]
000006  9c0a              LDR      r4,[sp,#0x28]
;;;759    #if IP_OPTIONS_SEND
;;;760      return ip4_output_if_opt(p, src, dest, ttl, tos, proto, netif, NULL, 0);
;;;761    }
;;;762    
;;;763    /**
;;;764     * Same as ip_output_if() but with the possibility to include IP options:
;;;765     *
;;;766     * @ param ip_options pointer to the IP options, copied into the IP header
;;;767     * @ param optlen length of ip_options
;;;768     */
;;;769    err_t
;;;770    ip4_output_if_opt(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
;;;771           u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
;;;772           u16_t optlen)
;;;773    {
;;;774    #endif /* IP_OPTIONS_SEND */
;;;775      const ip4_addr_t *src_used = src;
;;;776      if (dest != LWIP_IP_HDRINCL) {
000008  2a00              CMP      r2,#0
00000a  d004              BEQ      |L3.22|
;;;777        if (ip4_addr_isany(src)) {
00000c  000d              MOVS     r5,r1
00000e  d001              BEQ      |L3.20|
000010  680d              LDR      r5,[r1,#0]
000012  b905              CBNZ     r5,|L3.22|
                  |L3.20|
;;;778          src_used = netif_ip4_addr(netif);
000014  1d21              ADDS     r1,r4,#4
                  |L3.22|
;;;779        }
;;;780      }
;;;781    
;;;782    #if IP_OPTIONS_SEND
;;;783      return ip4_output_if_opt_src(p, src_used, dest, ttl, tos, proto, netif,
;;;784        ip_options, optlen);
;;;785    #else /* IP_OPTIONS_SEND */
;;;786      return ip4_output_if_src(p, src_used, dest, ttl, tos, proto, netif);
000016  e9cd6700          STRD     r6,r7,[sp,#0]
00001a  9402              STR      r4,[sp,#8]
00001c  f7fffffe          BL       ip4_output_if_src
;;;787    #endif /* IP_OPTIONS_SEND */
;;;788    }
000020  bdfe              POP      {r1-r7,pc}
;;;789    
                          ENDP


                          AREA ||i.ip4_output_if_src||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  ip4_output_if_src PROC
;;;794    err_t
;;;795    ip4_output_if_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;796                 u8_t ttl, u8_t tos,
;;;797                 u8_t proto, struct netif *netif)
;;;798    {
000004  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
000008  f8dd8030          LDR      r8,[sp,#0x30]
00000c  4605              MOV      r5,r0
00000e  4689              MOV      r9,r1
000010  4616              MOV      r6,r2
000012  461f              MOV      r7,r3
;;;799    #if IP_OPTIONS_SEND
;;;800      return ip4_output_if_opt_src(p, src, dest, ttl, tos, proto, netif, NULL, 0);
;;;801    }
;;;802    
;;;803    /**
;;;804     * Same as ip_output_if_opt() but 'src' address is not replaced by netif address
;;;805     * when it is 'any'.
;;;806     */
;;;807    err_t
;;;808    ip4_output_if_opt_src(struct pbuf *p, const ip4_addr_t *src, const ip4_addr_t *dest,
;;;809           u8_t ttl, u8_t tos, u8_t proto, struct netif *netif, void *ip_options,
;;;810           u16_t optlen)
;;;811    {
;;;812    #endif /* IP_OPTIONS_SEND */
;;;813      struct ip_hdr *iphdr;
;;;814      ip4_addr_t dest_addr;
;;;815    #if CHECKSUM_GEN_IP_INLINE
;;;816      u32_t chk_sum = 0;
;;;817    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;818    
;;;819      LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
000014  89e8              LDRH     r0,[r5,#0xe]
000016  2801              CMP      r0,#1
000018  d006              BEQ      |L4.40|
00001a  a32d              ADR      r3,|L4.208|
00001c  f2403233          MOV      r2,#0x333
000020  a138              ADR      r1,|L4.260|
000022  a03b              ADR      r0,|L4.272|
000024  f7fffffe          BL       __2printf
                  |L4.40|
;;;820    
;;;821      MIB2_STATS_INC(mib2.ipoutrequests);
;;;822    
;;;823      /* Should the IP header be generated or is it already included in p? */
;;;824      if (dest != LWIP_IP_HDRINCL) {
000028  2e00              CMP      r6,#0
00002a  d039              BEQ      |L4.160|
;;;825        u16_t ip_hlen = IP_HLEN;
;;;826    #if IP_OPTIONS_SEND
;;;827        u16_t optlen_aligned = 0;
;;;828        if (optlen != 0) {
;;;829    #if CHECKSUM_GEN_IP_INLINE
;;;830          int i;
;;;831    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;832          /* round up to a multiple of 4 */
;;;833          optlen_aligned = ((optlen + 3) & ~3);
;;;834          ip_hlen += optlen_aligned;
;;;835          /* First write in the IP options */
;;;836          if (pbuf_header(p, optlen_aligned)) {
;;;837            LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output_if_opt: not enough room for IP options in pbuf\n"));
;;;838            IP_STATS_INC(ip.err);
;;;839            MIB2_STATS_INC(mib2.ipoutdiscards);
;;;840            return ERR_BUF;
;;;841          }
;;;842          MEMCPY(p->payload, ip_options, optlen);
;;;843          if (optlen < optlen_aligned) {
;;;844            /* zero the remaining bytes */
;;;845            memset(((char*)p->payload) + optlen, 0, optlen_aligned - optlen);
;;;846          }
;;;847    #if CHECKSUM_GEN_IP_INLINE
;;;848          for (i = 0; i < optlen_aligned/2; i++) {
;;;849            chk_sum += ((u16_t*)p->payload)[i];
;;;850          }
;;;851    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;852        }
;;;853    #endif /* IP_OPTIONS_SEND */
;;;854        /* generate IP header */
;;;855        if (pbuf_header(p, IP_HLEN)) {
00002c  2114              MOVS     r1,#0x14
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       pbuf_header
000034  b118              CBZ      r0,|L4.62|
;;;856          LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_output: not enough room for IP header in pbuf\n"));
;;;857    
;;;858          IP_STATS_INC(ip.err);
;;;859          MIB2_STATS_INC(mib2.ipoutdiscards);
;;;860          return ERR_BUF;
000036  f06f0001          MVN      r0,#1
                  |L4.58|
;;;861        }
;;;862    
;;;863        iphdr = (struct ip_hdr *)p->payload;
;;;864        LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
;;;865                   (p->len >= sizeof(struct ip_hdr)));
;;;866    
;;;867        IPH_TTL_SET(iphdr, ttl);
;;;868        IPH_PROTO_SET(iphdr, proto);
;;;869    #if CHECKSUM_GEN_IP_INLINE
;;;870        chk_sum += PP_NTOHS(proto | (ttl << 8));
;;;871    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;872    
;;;873        /* dest cannot be NULL here */
;;;874        ip4_addr_copy(iphdr->dest, *dest);
;;;875    #if CHECKSUM_GEN_IP_INLINE
;;;876        chk_sum += ip4_addr_get_u32(&iphdr->dest) & 0xFFFF;
;;;877        chk_sum += ip4_addr_get_u32(&iphdr->dest) >> 16;
;;;878    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;879    
;;;880        IPH_VHL_SET(iphdr, 4, ip_hlen / 4);
;;;881        IPH_TOS_SET(iphdr, tos);
;;;882    #if CHECKSUM_GEN_IP_INLINE
;;;883        chk_sum += PP_NTOHS(tos | (iphdr->_v_hl << 8));
;;;884    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;885        IPH_LEN_SET(iphdr, lwip_htons(p->tot_len));
;;;886    #if CHECKSUM_GEN_IP_INLINE
;;;887        chk_sum += iphdr->_len;
;;;888    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;889        IPH_OFFSET_SET(iphdr, 0);
;;;890        IPH_ID_SET(iphdr, lwip_htons(ip_id));
;;;891    #if CHECKSUM_GEN_IP_INLINE
;;;892        chk_sum += iphdr->_id;
;;;893    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;894        ++ip_id;
;;;895    
;;;896        if (src == NULL) {
;;;897          ip4_addr_copy(iphdr->src, *IP4_ADDR_ANY4);
;;;898        } else {
;;;899          /* src cannot be NULL here */
;;;900          ip4_addr_copy(iphdr->src, *src);
;;;901        }
;;;902    
;;;903    #if CHECKSUM_GEN_IP_INLINE
;;;904        chk_sum += ip4_addr_get_u32(&iphdr->src) & 0xFFFF;
;;;905        chk_sum += ip4_addr_get_u32(&iphdr->src) >> 16;
;;;906        chk_sum = (chk_sum >> 16) + (chk_sum & 0xFFFF);
;;;907        chk_sum = (chk_sum >> 16) + chk_sum;
;;;908        chk_sum = ~chk_sum;
;;;909        IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
;;;910          iphdr->_chksum = (u16_t)chk_sum; /* network order */
;;;911        }
;;;912    #if LWIP_CHECKSUM_CTRL_PER_NETIF
;;;913        else {
;;;914          IPH_CHKSUM_SET(iphdr, 0);
;;;915        }
;;;916    #endif /* LWIP_CHECKSUM_CTRL_PER_NETIF*/
;;;917    #else /* CHECKSUM_GEN_IP_INLINE */
;;;918        IPH_CHKSUM_SET(iphdr, 0);
;;;919    #if CHECKSUM_GEN_IP
;;;920        IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
;;;921          IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, ip_hlen));
;;;922        }
;;;923    #endif /* CHECKSUM_GEN_IP */
;;;924    #endif /* CHECKSUM_GEN_IP_INLINE */
;;;925      } else {
;;;926        /* IP header already included in p */
;;;927        iphdr = (struct ip_hdr *)p->payload;
;;;928        ip4_addr_copy(dest_addr, iphdr->dest);
;;;929        dest = &dest_addr;
;;;930      }
;;;931    
;;;932      IP_STATS_INC(ip.xmit);
;;;933    
;;;934      LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], (u16_t)netif->num));
;;;935      ip4_debug_print(p);
;;;936    
;;;937    #if ENABLE_LOOPBACK
;;;938      if (ip4_addr_cmp(dest, netif_ip4_addr(netif))
;;;939    #if !LWIP_HAVE_LOOPIF
;;;940          || ip4_addr_isloopback(dest)
;;;941    #endif /* !LWIP_HAVE_LOOPIF */
;;;942          ) {
;;;943        /* Packet to self, enqueue it for loopback */
;;;944        LWIP_DEBUGF(IP_DEBUG, ("netif_loop_output()"));
;;;945        return netif_loop_output(netif, p);
;;;946      }
;;;947    #if LWIP_MULTICAST_TX_OPTIONS
;;;948      if ((p->flags & PBUF_FLAG_MCASTLOOP) != 0) {
;;;949        netif_loop_output(netif, p);
;;;950      }
;;;951    #endif /* LWIP_MULTICAST_TX_OPTIONS */
;;;952    #endif /* ENABLE_LOOPBACK */
;;;953    #if IP_FRAG
;;;954      /* don't fragment if interface has mtu set to 0 [loopif] */
;;;955      if (netif->mtu && (p->tot_len > netif->mtu)) {
;;;956        return ip4_frag(p, netif, dest);
;;;957      }
;;;958    #endif /* IP_FRAG */
;;;959    
;;;960      LWIP_DEBUGF(IP_DEBUG, ("ip4_output_if: call netif->output()\n"));
;;;961      return netif->output(netif, p, dest);
;;;962    }
00003a  e8bd8ff8          POP      {r3-r11,pc}
                  |L4.62|
00003e  686c              LDR      r4,[r5,#4]            ;863
000040  8968              LDRH     r0,[r5,#0xa]          ;864
000042  2814              CMP      r0,#0x14              ;864
000044  d206              BCS      |L4.84|
000046  a322              ADR      r3,|L4.208|
000048  f44f7258          MOV      r2,#0x360             ;864
00004c  a13a              ADR      r1,|L4.312|
00004e  a030              ADR      r0,|L4.272|
000050  f7fffffe          BL       __2printf
                  |L4.84|
000054  7227              STRB     r7,[r4,#8]            ;867
000056  f884b009          STRB     r11,[r4,#9]           ;868
00005a  6830              LDR      r0,[r6,#0]            ;874
00005c  6120              STR      r0,[r4,#0x10]         ;874
00005e  2045              MOVS     r0,#0x45              ;880
000060  7020              STRB     r0,[r4,#0]            ;880
000062  f884a001          STRB     r10,[r4,#1]           ;881
000066  8928              LDRH     r0,[r5,#8]            ;885
000068  f7fffffe          BL       lwip_htons
00006c  8060              STRH     r0,[r4,#2]            ;885
00006e  f04f0a00          MOV      r10,#0                ;889
000072  f8a4a006          STRH     r10,[r4,#6]           ;889
000076  4f3c              LDR      r7,|L4.360|
000078  8838              LDRH     r0,[r7,#0]            ;890  ; ip_id
00007a  f7fffffe          BL       lwip_htons
00007e  80a0              STRH     r0,[r4,#4]            ;890
000080  8838              LDRH     r0,[r7,#0]            ;894  ; ip_id
000082  1c40              ADDS     r0,r0,#1              ;894
000084  8038              STRH     r0,[r7,#0]            ;894
000086  f1b90f00          CMP      r9,#0                 ;896
00008a  d005              BEQ      |L4.152|
00008c  f8d90000          LDR      r0,[r9,#0]            ;900
000090  60e0              STR      r0,[r4,#0xc]          ;900
                  |L4.146|
000092  f8a4a00a          STRH     r10,[r4,#0xa]         ;918
000096  e007              B        |L4.168|
                  |L4.152|
000098  4834              LDR      r0,|L4.364|
00009a  6800              LDR      r0,[r0,#0]            ;897  ; ip_addr_any
00009c  60e0              STR      r0,[r4,#0xc]          ;897
00009e  e7f8              B        |L4.146|
                  |L4.160|
0000a0  6868              LDR      r0,[r5,#4]            ;927
0000a2  6900              LDR      r0,[r0,#0x10]         ;928
0000a4  9000              STR      r0,[sp,#0]            ;928
0000a6  466e              MOV      r6,sp                 ;929
                  |L4.168|
0000a8  f8b8002e          LDRH     r0,[r8,#0x2e]         ;955
0000ac  b140              CBZ      r0,|L4.192|
0000ae  8929              LDRH     r1,[r5,#8]            ;955
0000b0  4281              CMP      r1,r0                 ;955
0000b2  d905              BLS      |L4.192|
0000b4  4632              MOV      r2,r6                 ;956
0000b6  4641              MOV      r1,r8                 ;956
0000b8  4628              MOV      r0,r5                 ;956
0000ba  f7fffffe          BL       ip4_frag
0000be  e7bc              B        |L4.58|
                  |L4.192|
0000c0  f8d83014          LDR      r3,[r8,#0x14]         ;961
0000c4  4632              MOV      r2,r6                 ;961
0000c6  4629              MOV      r1,r5                 ;961
0000c8  4640              MOV      r0,r8                 ;961
0000ca  4798              BLX      r3                    ;961
0000cc  e7b5              B        |L4.58|
;;;963    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L4.208|
0000d0  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip"
0000d4  6964646c
0000d8  65776172
0000dc  65735c54
0000e0  68697264
0000e4  5f506172
0000e8  74795c4c
0000ec  7749505c
0000f0  7372635c
0000f4  636f7265
0000f8  5c697076
0000fc  345c6970
000100  342e6300          DCB      "4.c",0
                  |L4.260|
000104  702d3e72          DCB      "p->ref == 1",0
000108  6566203d
00010c  3d203100
                  |L4.272|
000110  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000114  7274696f
000118  6e202225
00011c  73222066
000120  61696c65
000124  64206174
000128  206c696e
00012c  65202564
000130  20696e20
000134  25730a00
                  |L4.312|
000138  63686563          DCB      "check that first pbuf can hold struct ip_hdr",0
00013c  6b207468
000140  61742066
000144  69727374
000148  20706275
00014c  66206361
000150  6e20686f
000154  6c642073
000158  74727563
00015c  74206970
000160  5f686472
000164  00      
000165  00                DCB      0
000166  00                DCB      0
000167  00                DCB      0
                  |L4.360|
                          DCD      ||.data||
                  |L4.364|
                          DCD      ip_addr_any

                          AREA ||i.ip4_route||, CODE, READONLY, ALIGN=2

                  ip4_route PROC
;;;151    struct netif *
;;;152    ip4_route(const ip4_addr_t *dest)
000000  b570              PUSH     {r4-r6,lr}
;;;153    {
000002  4606              MOV      r6,r0
;;;154      struct netif *netif;
;;;155    
;;;156    #if LWIP_MULTICAST_TX_OPTIONS
;;;157      /* Use administratively selected interface for multicast by default */
;;;158      if (ip4_addr_ismulticast(dest) && ip4_default_multicast_netif) {
;;;159        return ip4_default_multicast_netif;
;;;160      }
;;;161    #endif /* LWIP_MULTICAST_TX_OPTIONS */
;;;162    
;;;163      /* iterate through netifs */
;;;164      for (netif = netif_list; netif != NULL; netif = netif->next) {
000004  4813              LDR      r0,|L5.84|
000006  6800              LDR      r0,[r0,#0]  ; netif_list
000008  e014              B        |L5.52|
                  |L5.10|
;;;165        /* is the netif up, does it have a link and a valid address? */
;;;166        if (netif_is_up(netif) && netif_is_link_up(netif) && !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
00000a  f8901037          LDRB     r1,[r0,#0x37]
00000e  07ca              LSLS     r2,r1,#31
000010  d00f              BEQ      |L5.50|
000012  074a              LSLS     r2,r1,#29
000014  d50d              BPL      |L5.50|
000016  6843              LDR      r3,[r0,#4]
000018  b15b              CBZ      r3,|L5.50|
;;;167          /* network mask matches? */
;;;168          if (ip4_addr_netcmp(dest, netif_ip4_addr(netif), netif_ip4_netmask(netif))) {
00001a  6884              LDR      r4,[r0,#8]
00001c  6832              LDR      r2,[r6,#0]
00001e  4023              ANDS     r3,r3,r4
000020  ea020504          AND      r5,r2,r4
000024  429d              CMP      r5,r3
000026  d014              BEQ      |L5.82|
;;;169            /* return netif on which to forward IP packet */
;;;170            return netif;
;;;171          }
;;;172          /* gateway matches on a non broadcast interface? (i.e. peer in a point to point interface) */
;;;173          if (((netif->flags & NETIF_FLAG_BROADCAST) == 0) && ip4_addr_cmp(dest, netif_ip4_gw(netif))) {
000028  0789              LSLS     r1,r1,#30
00002a  d402              BMI      |L5.50|
00002c  68c1              LDR      r1,[r0,#0xc]
00002e  428a              CMP      r2,r1
000030  d00f              BEQ      |L5.82|
                  |L5.50|
000032  6800              LDR      r0,[r0,#0]            ;164
                  |L5.52|
000034  2800              CMP      r0,#0                 ;164
000036  d1e8              BNE      |L5.10|
;;;174            /* return netif on which to forward IP packet */
;;;175            return netif;
;;;176          }
;;;177        }
;;;178      }
;;;179    
;;;180    #if LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF
;;;181      /* loopif is disabled, looopback traffic is passed through any netif */
;;;182      if (ip4_addr_isloopback(dest)) {
;;;183        /* don't check for link on loopback traffic */
;;;184        if (netif_default != NULL && netif_is_up(netif_default)) {
;;;185          return netif_default;
;;;186        }
;;;187        /* default netif is not up, just use any netif for loopback traffic */
;;;188        for (netif = netif_list; netif != NULL; netif = netif->next) {
;;;189          if (netif_is_up(netif)) {
;;;190            return netif;
;;;191          }
;;;192        }
;;;193        return NULL;
;;;194      }
;;;195    #endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
;;;196    
;;;197    #ifdef LWIP_HOOK_IP4_ROUTE_SRC
;;;198      netif = LWIP_HOOK_IP4_ROUTE_SRC(dest, NULL);
;;;199      if (netif != NULL) {
;;;200        return netif;
;;;201      }
;;;202    #elif defined(LWIP_HOOK_IP4_ROUTE)
;;;203      netif = LWIP_HOOK_IP4_ROUTE(dest);
;;;204      if (netif != NULL) {
;;;205        return netif;
;;;206      }
;;;207    #endif
;;;208    
;;;209      if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default) ||
000038  4807              LDR      r0,|L5.88|
00003a  6800              LDR      r0,[r0,#0]  ; netif_default
00003c  b140              CBZ      r0,|L5.80|
00003e  f8901037          LDRB     r1,[r0,#0x37]
000042  07ca              LSLS     r2,r1,#31
000044  d004              BEQ      |L5.80|
000046  0749              LSLS     r1,r1,#29
000048  d502              BPL      |L5.80|
;;;210          ip4_addr_isany_val(*netif_ip4_addr(netif_default))) {
00004a  6841              LDR      r1,[r0,#4]
00004c  2900              CMP      r1,#0
00004e  d100              BNE      |L5.82|
                  |L5.80|
;;;211        /* No matching netif found and default netif is not usable.
;;;212           If this is not good enough for you, use LWIP_HOOK_IP4_ROUTE() */
;;;213        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip4_route: No route to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;214          ip4_addr1_16(dest), ip4_addr2_16(dest), ip4_addr3_16(dest), ip4_addr4_16(dest)));
;;;215        IP_STATS_INC(ip.rterr);
;;;216        MIB2_STATS_INC(mib2.ipoutnoroutes);
;;;217        return NULL;
000050  2000              MOVS     r0,#0
                  |L5.82|
;;;218      }
;;;219    
;;;220      return netif_default;
;;;221    }
000052  bd70              POP      {r4-r6,pc}
;;;222    
                          ENDP

                  |L5.84|
                          DCD      netif_list
                  |L5.88|
                          DCD      netif_default

                          AREA ||.data||, DATA, ALIGN=1

                  ip_id
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip4.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_ip4_c_df8b5ec6____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_ip4_c_df8b5ec6____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_ip4_c_df8b5ec6____REVSH|
#line 478
|__asm___5_ip4_c_df8b5ec6____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_ip4_c_df8b5ec6____RRX|
#line 665
|__asm___5_ip4_c_df8b5ec6____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
