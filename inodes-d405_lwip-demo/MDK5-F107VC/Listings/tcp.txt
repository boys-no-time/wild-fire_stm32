; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\tcp.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\tcp.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\tcp.crf ..\Middlewares\Third_Party\LwIP\src\core\tcp.c]
                          THUMB

                          AREA ||i.tcp_abandon||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_abandon PROC
;;;469    void
;;;470    tcp_abandon(struct tcp_pcb *pcb, int reset)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;471    {
000004  4604              MOV      r4,r0
000006  468b              MOV      r11,r1
;;;472      u32_t seqno, ackno;
;;;473    #if LWIP_CALLBACK_API
;;;474      tcp_err_fn errf;
;;;475    #endif /* LWIP_CALLBACK_API */
;;;476      void *errf_arg;
;;;477    
;;;478      /* pcb->state LISTEN not allowed here */
;;;479      LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
000008  7d20              LDRB     r0,[r4,#0x14]
00000a  2801              CMP      r0,#1
00000c  d106              BNE      |L1.28|
00000e  a335              ADR      r3,|L1.228|
000010  f24012df          MOV      r2,#0x1df
000014  a13f              ADR      r1,|L1.276|
000016  a04c              ADR      r0,|L1.328|
000018  f7fffffe          BL       __2printf
                  |L1.28|
;;;480        pcb->state != LISTEN);
;;;481      /* Figure out on which TCP PCB list we are, and remove us. If we
;;;482         are in an active state, call the receive function associated with
;;;483         the PCB with a NULL argument, and send an RST to the remote end. */
;;;484      if (pcb->state == TIME_WAIT) {
00001c  7d20              LDRB     r0,[r4,#0x14]
00001e  280a              CMP      r0,#0xa
000020  d03a              BEQ      |L1.152|
;;;485        tcp_pcb_remove(&tcp_tw_pcbs, pcb);
;;;486        memp_free(MEMP_TCP_PCB, pcb);
;;;487      } else {
;;;488        int send_rst = 0;
000022  2500              MOVS     r5,#0
;;;489        u16_t local_port = 0;
000024  2700              MOVS     r7,#0
;;;490        enum tcp_state last_state;
;;;491        seqno = pcb->snd_nxt;
000026  6ce1              LDR      r1,[r4,#0x4c]
000028  9102              STR      r1,[sp,#8]
;;;492        ackno = pcb->rcv_nxt;
00002a  f8d48024          LDR      r8,[r4,#0x24]
;;;493    #if LWIP_CALLBACK_API
;;;494        errf = pcb->errf;
00002e  f8d4608c          LDR      r6,[r4,#0x8c]
;;;495    #endif /* LWIP_CALLBACK_API */
;;;496        errf_arg = pcb->callback_arg;
000032  f8d49010          LDR      r9,[r4,#0x10]
;;;497        if (pcb->state == CLOSED) {
;;;498          if (pcb->local_port != 0) {
;;;499            /* bound, not yet opened */
;;;500            TCP_RMV(&tcp_bound_pcbs, pcb);
000036  f8dfa138          LDR      r10,|L1.368|
00003a  b3c8              CBZ      r0,|L1.176|
;;;501          }
;;;502        } else {
;;;503          send_rst = reset;
00003c  465d              MOV      r5,r11
;;;504          local_port = pcb->local_port;
00003e  8ae7              LDRH     r7,[r4,#0x16]
;;;505          TCP_PCB_REMOVE_ACTIVE(pcb);
000040  4621              MOV      r1,r4
000042  f10a0018          ADD      r0,r10,#0x18
000046  f7fffffe          BL       tcp_pcb_remove
00004a  2001              MOVS     r0,#1
00004c  f88a0000          STRB     r0,[r10,#0]
                  |L1.80|
;;;506        }
;;;507        if (pcb->unacked != NULL) {
000050  6ee0              LDR      r0,[r4,#0x6c]
000052  b108              CBZ      r0,|L1.88|
;;;508          tcp_segs_free(pcb->unacked);
000054  f7fffffe          BL       tcp_segs_free
                  |L1.88|
;;;509        }
;;;510        if (pcb->unsent != NULL) {
000058  6ea0              LDR      r0,[r4,#0x68]
00005a  b108              CBZ      r0,|L1.96|
;;;511          tcp_segs_free(pcb->unsent);
00005c  f7fffffe          BL       tcp_segs_free
                  |L1.96|
;;;512        }
;;;513    #if TCP_QUEUE_OOSEQ
;;;514        if (pcb->ooseq != NULL) {
000060  6f20              LDR      r0,[r4,#0x70]
000062  b108              CBZ      r0,|L1.104|
;;;515          tcp_segs_free(pcb->ooseq);
000064  f7fffffe          BL       tcp_segs_free
                  |L1.104|
;;;516        }
;;;517    #endif /* TCP_QUEUE_OOSEQ */
;;;518        tcp_backlog_accepted(pcb);
;;;519        if (send_rst) {
000068  b145              CBZ      r5,|L1.124|
;;;520          LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
;;;521          tcp_rst(seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
00006a  8b20              LDRH     r0,[r4,#0x18]
00006c  1d23              ADDS     r3,r4,#4
00006e  e9cd7000          STRD     r7,r0,[sp,#0]
000072  4622              MOV      r2,r4
000074  4641              MOV      r1,r8
000076  9802              LDR      r0,[sp,#8]
000078  f7fffffe          BL       tcp_rst
                  |L1.124|
;;;522        }
;;;523        last_state = pcb->state;
;;;524        memp_free(MEMP_TCP_PCB, pcb);
00007c  4621              MOV      r1,r4
00007e  2001              MOVS     r0,#1
000080  f7fffffe          BL       memp_free
;;;525        TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
000084  2e00              CMP      r6,#0
000086  d02a              BEQ      |L1.222|
000088  b003              ADD      sp,sp,#0xc
00008a  4648              MOV      r0,r9
00008c  46b4              MOV      r12,r6
00008e  e8bd4ff0          POP      {r4-r11,lr}
000092  f06f010c          MVN      r1,#0xc
000096  4760              BX       r12
                  |L1.152|
000098  4835              LDR      r0,|L1.368|
00009a  4621              MOV      r1,r4                 ;485
00009c  301c              ADDS     r0,r0,#0x1c           ;485
00009e  f7fffffe          BL       tcp_pcb_remove
0000a2  b003              ADD      sp,sp,#0xc            ;486
0000a4  4621              MOV      r1,r4                 ;486
0000a6  e8bd4ff0          POP      {r4-r11,lr}           ;486
0000aa  2001              MOVS     r0,#1                 ;486
0000ac  f7ffbffe          B.W      memp_free
                  |L1.176|
0000b0  8ae0              LDRH     r0,[r4,#0x16]         ;498
0000b2  2800              CMP      r0,#0                 ;498
0000b4  d0cc              BEQ      |L1.80|
0000b6  f8da0010          LDR      r0,[r10,#0x10]        ;500  ; tcp_bound_pcbs
0000ba  42a0              CMP      r0,r4                 ;500
0000bc  d10a              BNE      |L1.212|
0000be  68c0              LDR      r0,[r0,#0xc]          ;500
0000c0  f8ca0010          STR      r0,[r10,#0x10]        ;500  ; tcp_bound_pcbs
0000c4  e008              B        |L1.216|
                  |L1.198|
0000c6  68c1              LDR      r1,[r0,#0xc]          ;500
0000c8  42a1              CMP      r1,r4                 ;500
0000ca  d102              BNE      |L1.210|
0000cc  68e1              LDR      r1,[r4,#0xc]          ;500
0000ce  60c1              STR      r1,[r0,#0xc]          ;500
0000d0  e002              B        |L1.216|
                  |L1.210|
0000d2  4608              MOV      r0,r1                 ;500
                  |L1.212|
0000d4  2800              CMP      r0,#0                 ;500
0000d6  d1f6              BNE      |L1.198|
                  |L1.216|
0000d8  2000              MOVS     r0,#0                 ;500
0000da  60e0              STR      r0,[r4,#0xc]          ;500
0000dc  e7b8              B        |L1.80|
                  |L1.222|
;;;526      }
;;;527    }
0000de  e8bd8ffe          POP      {r1-r11,pc}
;;;528    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L1.228|
0000e4  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
0000e8  6964646c
0000ec  65776172
0000f0  65735c54
0000f4  68697264
0000f8  5f506172
0000fc  74795c4c
000100  7749505c
000104  7372635c
000108  636f7265
00010c  5c746370
000110  2e6300  
000113  00                DCB      0
                  |L1.276|
000114  646f6e27          DCB      "don't call tcp_abort/tcp_abandon for listen-pcbs",0
000118  74206361
00011c  6c6c2074
000120  63705f61
000124  626f7274
000128  2f746370
00012c  5f616261
000130  6e646f6e
000134  20666f72
000138  206c6973
00013c  74656e2d
000140  70636273
000144  00      
000145  00                DCB      0
000146  00                DCB      0
000147  00                DCB      0
                  |L1.328|
000148  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00014c  7274696f
000150  6e202225
000154  73222066
000158  61696c65
00015c  64206174
000160  206c696e
000164  65202564
000168  20696e20
00016c  25730a00
                  |L1.368|
                          DCD      ||.data||

                          AREA ||i.tcp_abort||, CODE, READONLY, ALIGN=1

                  tcp_abort PROC
;;;540    void
;;;541    tcp_abort(struct tcp_pcb *pcb)
000000  2101              MOVS     r1,#1
;;;542    {
;;;543      tcp_abandon(pcb, 1);
000002  f7ffbffe          B.W      tcp_abandon
;;;544    }
;;;545    
                          ENDP


                          AREA ||i.tcp_accept||, CODE, READONLY, ALIGN=1

                  tcp_accept PROC
;;;1774   void
;;;1775   tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
000000  2800              CMP      r0,#0
;;;1776   {
000002  d003              BEQ      |L3.12|
;;;1777     if ((pcb != NULL) && (pcb->state == LISTEN)) {
000004  7d02              LDRB     r2,[r0,#0x14]
000006  2a01              CMP      r2,#1
000008  d100              BNE      |L3.12|
;;;1778       struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen*)pcb;
;;;1779       lpcb->accept = accept;
00000a  6181              STR      r1,[r0,#0x18]
                  |L3.12|
;;;1780     }
;;;1781   }
00000c  4770              BX       lr
;;;1782   #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_accept_null||, CODE, READONLY, ALIGN=1

                  tcp_accept_null PROC
;;;636    static err_t
;;;637    tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
000000  b510              PUSH     {r4,lr}
;;;638    {
000002  4608              MOV      r0,r1
;;;639      LWIP_UNUSED_ARG(arg);
;;;640      LWIP_UNUSED_ARG(err);
;;;641    
;;;642      tcp_abort(pcb);
000004  f7fffffe          BL       tcp_abort
;;;643    
;;;644      return ERR_ABRT;
000008  f06f000c          MVN      r0,#0xc
;;;645    }
00000c  bd10              POP      {r4,pc}
;;;646    #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_alloc||, CODE, READONLY, ALIGN=2

                  tcp_alloc PROC
;;;1554   struct tcp_pcb *
;;;1555   tcp_alloc(u8_t prio)
000000  b570              PUSH     {r4-r6,lr}
;;;1556   {
000002  4605              MOV      r5,r0
;;;1557     struct tcp_pcb *pcb;
;;;1558   
;;;1559     pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       memp_malloc
00000a  4604              MOV      r4,r0
;;;1560     if (pcb == NULL) {
00000c  b9ec              CBNZ     r4,|L5.74|
;;;1561       /* Try killing oldest connection in TIME-WAIT. */
;;;1562       LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
;;;1563       tcp_kill_timewait();
00000e  f7fffffe          BL       tcp_kill_timewait
;;;1564       /* Try to allocate a tcp_pcb again. */
;;;1565       pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       memp_malloc
000018  4604              MOV      r4,r0
;;;1566       if (pcb == NULL) {
00001a  b9b4              CBNZ     r4,|L5.74|
;;;1567         /* Try killing oldest connection in LAST-ACK (these wouldn't go to TIME-WAIT). */
;;;1568         LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest LAST-ACK connection\n"));
;;;1569         tcp_kill_state(LAST_ACK);
00001c  2009              MOVS     r0,#9
00001e  f7fffffe          BL       tcp_kill_state
;;;1570         /* Try to allocate a tcp_pcb again. */
;;;1571         pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       memp_malloc
000028  4604              MOV      r4,r0
;;;1572         if (pcb == NULL) {
00002a  b974              CBNZ     r4,|L5.74|
;;;1573           /* Try killing oldest connection in CLOSING. */
;;;1574           LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest CLOSING connection\n"));
;;;1575           tcp_kill_state(CLOSING);
00002c  2008              MOVS     r0,#8
00002e  f7fffffe          BL       tcp_kill_state
;;;1576           /* Try to allocate a tcp_pcb again. */
;;;1577           pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000032  2001              MOVS     r0,#1
000034  f7fffffe          BL       memp_malloc
000038  4604              MOV      r4,r0
;;;1578           if (pcb == NULL) {
00003a  b934              CBNZ     r4,|L5.74|
;;;1579             /* Try killing active connections with lower priority than the new one. */
;;;1580             LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing connection with prio lower than %d\n", prio));
;;;1581             tcp_kill_prio(prio);
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       tcp_kill_prio
;;;1582             /* Try to allocate a tcp_pcb again. */
;;;1583             pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       memp_malloc
000048  4604              MOV      r4,r0
                  |L5.74|
;;;1584             if (pcb != NULL) {
;;;1585               /* adjust err stats: memp_malloc failed multiple times before */
;;;1586               MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1587             }
;;;1588           }
;;;1589           if (pcb != NULL) {
;;;1590             /* adjust err stats: memp_malloc failed multiple times before */
;;;1591             MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1592           }
;;;1593         }
;;;1594         if (pcb != NULL) {
;;;1595           /* adjust err stats: memp_malloc failed multiple times before */
;;;1596           MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1597         }
;;;1598       }
;;;1599       if (pcb != NULL) {
;;;1600         /* adjust err stats: memp_malloc failed above */
;;;1601         MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1602       }
;;;1603     }
;;;1604     if (pcb != NULL) {
00004a  b31c              CBZ      r4,|L5.148|
;;;1605       /* zero out the whole pcb, so there is no need to initialize members to zero */
;;;1606       memset(pcb, 0, sizeof(struct tcp_pcb));
00004c  2198              MOVS     r1,#0x98
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       __aeabi_memclr4
;;;1607       pcb->prio = prio;
000054  3414              ADDS     r4,r4,#0x14
000056  7065              STRB     r5,[r4,#1]
;;;1608       pcb->snd_buf = TCP_SND_BUF;
000058  f44f6186          MOV      r1,#0x430
00005c  f8a4104c          STRH     r1,[r4,#0x4c]
;;;1609       /* Start with a window that does not need scaling. When window scaling is
;;;1610          enabled and used, the window is enlarged when both sides agree on scaling. */
;;;1611       pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
000060  0048              LSLS     r0,r1,#1
000062  82e0              STRH     r0,[r4,#0x16]
000064  82a0              STRH     r0,[r4,#0x14]
;;;1612       pcb->ttl = TCP_TTL;
000066  20ff              MOVS     r0,#0xff
000068  f8040c0a          STRB     r0,[r4,#-0xa]
;;;1613       /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;1614          The send MSS is updated when an MSS option is received. */
;;;1615       pcb->mss = INITIAL_MSS;
00006c  1048              ASRS     r0,r1,#1
00006e  83e0              STRH     r0,[r4,#0x1e]
;;;1616       pcb->rto = 3000 / TCP_SLOW_INTERVAL;
000070  2006              MOVS     r0,#6
000072  85a0              STRH     r0,[r4,#0x2c]
;;;1617       pcb->sv = 3000 / TCP_SLOW_INTERVAL;
000074  8560              STRH     r0,[r4,#0x2a]
;;;1618       pcb->rtime = -1;
000076  1fc0              SUBS     r0,r0,#7
000078  83a0              STRH     r0,[r4,#0x1c]
;;;1619       pcb->cwnd = 1;
00007a  2001              MOVS     r0,#1
00007c  86a0              STRH     r0,[r4,#0x34]
;;;1620       pcb->tmr = tcp_ticks;
00007e  4806              LDR      r0,|L5.152|
000080  68c2              LDR      r2,[r0,#0xc]  ; tcp_ticks
000082  60e2              STR      r2,[r4,#0xc]
;;;1621       pcb->last_timer = tcp_timer_ctr;
000084  7880              LDRB     r0,[r0,#2]  ; tcp_timer_ctr
000086  7260              STRB     r0,[r4,#9]
;;;1622   
;;;1623       /* RFC 5681 recommends setting ssthresh abritrarily high and gives an example
;;;1624       of using the largest advertised receive window.  We've seen complications with
;;;1625       receiving TCPs that use window scaling and/or window auto-tuning where the
;;;1626       initial advertised window is very small and then grows rapidly once the
;;;1627       connection is established. To avoid these complications, we set ssthresh to the
;;;1628       largest effective cwnd (amount of in-flight data) that the sender can have. */
;;;1629       pcb->ssthresh = TCP_SND_BUF;
000088  86e1              STRH     r1,[r4,#0x36]
;;;1630   
;;;1631   #if LWIP_CALLBACK_API
;;;1632       pcb->recv = tcp_recv_null;
00008a  4804              LDR      r0,|L5.156|
00008c  66e0              STR      r0,[r4,#0x6c]
;;;1633   #endif /* LWIP_CALLBACK_API */
;;;1634   
;;;1635       /* Init KEEPALIVE timer */
;;;1636       pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
00008e  4804              LDR      r0,|L5.160|
000090  67e0              STR      r0,[r4,#0x7c]
000092  3c14              SUBS     r4,r4,#0x14
                  |L5.148|
;;;1637   
;;;1638   #if LWIP_TCP_KEEPALIVE
;;;1639       pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
;;;1640       pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
;;;1641   #endif /* LWIP_TCP_KEEPALIVE */
;;;1642     }
;;;1643     return pcb;
000094  4620              MOV      r0,r4
;;;1644   }
000096  bd70              POP      {r4-r6,pc}
;;;1645   
                          ENDP

                  |L5.152|
                          DCD      ||.data||
                  |L5.156|
                          DCD      tcp_recv_null
                  |L5.160|
                          DCD      0x006ddd00

                          AREA ||i.tcp_arg||, CODE, READONLY, ALIGN=1

                  tcp_arg PROC
;;;1700   void
;;;1701   tcp_arg(struct tcp_pcb *pcb, void *arg)
000000  2800              CMP      r0,#0
;;;1702   {
000002  d000              BEQ      |L6.6|
;;;1703     /* This function is allowed to be called for both listen pcbs and
;;;1704        connection pcbs. */
;;;1705     if (pcb != NULL) {
;;;1706       pcb->callback_arg = arg;
000004  6101              STR      r1,[r0,#0x10]
                  |L6.6|
;;;1707     }
;;;1708   }
000006  4770              BX       lr
;;;1709   #if LWIP_CALLBACK_API
                          ENDP


                          AREA ||i.tcp_bind||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_bind PROC
;;;561    err_t
;;;562    tcp_bind(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;563    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;564      int i;
;;;565      int max_pcb_list = NUM_TCP_PCB_LISTS;
000008  2004              MOVS     r0,#4
;;;566      struct tcp_pcb *cpcb;
;;;567    
;;;568    #if LWIP_IPV4
;;;569      /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
;;;570      if (ipaddr == NULL) {
00000a  2c00              CMP      r4,#0
00000c  d100              BNE      |L7.16|
;;;571        ipaddr = IP4_ADDR_ANY;
00000e  4c23              LDR      r4,|L7.156|
                  |L7.16|
;;;572      }
;;;573    #endif /* LWIP_IPV4 */
;;;574    
;;;575      /* still need to check for ipaddr == NULL in IPv6 only case */
;;;576      if ((pcb == NULL) || (ipaddr == NULL)) {
;;;577        return ERR_VAL;
000010  f06f0505          MVN      r5,#5
000014  2f00              CMP      r7,#0                 ;576
000016  d00e              BEQ      |L7.54|
000018  2c00              CMP      r4,#0                 ;576
00001a  d00c              BEQ      |L7.54|
;;;578      }
;;;579    
;;;580      LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
00001c  7d39              LDRB     r1,[r7,#0x14]
00001e  2900              CMP      r1,#0
000020  d00b              BEQ      |L7.58|
000022  a31f              ADR      r3,|L7.160|
000024  f44f7211          MOV      r2,#0x244
000028  a129              ADR      r1,|L7.208|
00002a  a033              ADR      r0,|L7.248|
00002c  f7fffffe          BL       __2printf
000030  4628              MOV      r0,r5
                  |L7.50|
;;;581    
;;;582    #if SO_REUSE
;;;583      /* Unless the REUSEADDR flag is set,
;;;584         we have to check the pcbs in TIME-WAIT state, also.
;;;585         We do not dump TIME_WAIT pcb's; they can still be matched by incoming
;;;586         packets using both local and remote IP addresses and ports to distinguish.
;;;587       */
;;;588      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;589        max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
;;;590      }
;;;591    #endif /* SO_REUSE */
;;;592    
;;;593      if (port == 0) {
;;;594        port = tcp_new_port();
;;;595        if (port == 0) {
;;;596          return ERR_BUF;
;;;597        }
;;;598      } else {
;;;599        /* Check if the address already is in use (on all lists) */
;;;600        for (i = 0; i < max_pcb_list; i++) {
;;;601          for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;602            if (cpcb->local_port == port) {
;;;603    #if SO_REUSE
;;;604              /* Omit checking for the same port if both pcbs have REUSEADDR set.
;;;605                 For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
;;;606                 tcp_connect. */
;;;607              if (!ip_get_option(pcb, SOF_REUSEADDR) ||
;;;608                  !ip_get_option(cpcb, SOF_REUSEADDR))
;;;609    #endif /* SO_REUSE */
;;;610              {
;;;611                /* @todo: check accept_any_ip_version */
;;;612                if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
;;;613                    (ip_addr_isany(&cpcb->local_ip) ||
;;;614                    ip_addr_isany(ipaddr) ||
;;;615                    ip_addr_cmp(&cpcb->local_ip, ipaddr))) {
;;;616                  return ERR_USE;
;;;617                }
;;;618              }
;;;619            }
;;;620          }
;;;621        }
;;;622      }
;;;623    
;;;624      if (!ip_addr_isany(ipaddr)) {
;;;625        ip_addr_set(&pcb->local_ip, ipaddr);
;;;626      }
;;;627      pcb->local_port = port;
;;;628      TCP_REG(&tcp_bound_pcbs, pcb);
;;;629      LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
;;;630      return ERR_OK;
;;;631    }
000032  e8bd81f0          POP      {r4-r8,pc}
                  |L7.54|
000036  4628              MOV      r0,r5                 ;577
000038  e7fb              B        |L7.50|
                  |L7.58|
00003a  b11a              CBZ      r2,|L7.68|
00003c  2100              MOVS     r1,#0                 ;600
00003e  f8dfc0e0          LDR      r12,|L7.288|
000042  e01c              B        |L7.126|
                  |L7.68|
000044  f7fffffe          BL       tcp_new_port
000048  4602              MOV      r2,r0                 ;594
00004a  0010              MOVS     r0,r2                 ;595
00004c  d119              BNE      |L7.130|
00004e  1e80              SUBS     r0,r0,#2              ;596
000050  e7ef              B        |L7.50|
                  |L7.82|
000052  f85c3021          LDR      r3,[r12,r1,LSL #2]    ;601
000056  681b              LDR      r3,[r3,#0]            ;601
000058  e00e              B        |L7.120|
                  |L7.90|
00005a  8add              LDRH     r5,[r3,#0x16]         ;602
00005c  4295              CMP      r5,r2                 ;602
00005e  d10a              BNE      |L7.118|
000060  b133              CBZ      r3,|L7.112|
000062  681d              LDR      r5,[r3,#0]            ;613
000064  b125              CBZ      r5,|L7.112|
000066  b11c              CBZ      r4,|L7.112|
000068  6826              LDR      r6,[r4,#0]            ;614
00006a  b10e              CBZ      r6,|L7.112|
00006c  42b5              CMP      r5,r6                 ;615
00006e  d102              BNE      |L7.118|
                  |L7.112|
000070  f06f0007          MVN      r0,#7                 ;616
000074  e7dd              B        |L7.50|
                  |L7.118|
000076  68db              LDR      r3,[r3,#0xc]          ;601
                  |L7.120|
000078  2b00              CMP      r3,#0                 ;601
00007a  d1ee              BNE      |L7.90|
00007c  1c49              ADDS     r1,r1,#1              ;600
                  |L7.126|
00007e  4281              CMP      r1,r0                 ;600
000080  dbe7              BLT      |L7.82|
                  |L7.130|
000082  b114              CBZ      r4,|L7.138|
000084  6820              LDR      r0,[r4,#0]            ;624
000086  b100              CBZ      r0,|L7.138|
000088  6038              STR      r0,[r7,#0]            ;625
                  |L7.138|
00008a  82fa              STRH     r2,[r7,#0x16]         ;627
00008c  4825              LDR      r0,|L7.292|
00008e  6901              LDR      r1,[r0,#0x10]         ;628  ; tcp_bound_pcbs
000090  60f9              STR      r1,[r7,#0xc]          ;628
000092  6107              STR      r7,[r0,#0x10]         ;628  ; tcp_bound_pcbs
000094  f7fffffe          BL       tcp_timer_needed
000098  2000              MOVS     r0,#0                 ;630
00009a  e7ca              B        |L7.50|
;;;632    #if LWIP_CALLBACK_API
                          ENDP

                  |L7.156|
                          DCD      ip_addr_any
                  |L7.160|
0000a0  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
0000a4  6964646c
0000a8  65776172
0000ac  65735c54
0000b0  68697264
0000b4  5f506172
0000b8  74795c4c
0000bc  7749505c
0000c0  7372635c
0000c4  636f7265
0000c8  5c746370
0000cc  2e6300  
0000cf  00                DCB      0
                  |L7.208|
0000d0  7463705f          DCB      "tcp_bind: can only bind in state CLOSED",0
0000d4  62696e64
0000d8  3a206361
0000dc  6e206f6e
0000e0  6c792062
0000e4  696e6420
0000e8  696e2073
0000ec  74617465
0000f0  20434c4f
0000f4  53454400
                  |L7.248|
0000f8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000fc  7274696f
000100  6e202225
000104  73222066
000108  61696c65
00010c  64206174
000110  206c696e
000114  65202564
000118  20696e20
00011c  25730a00
                  |L7.288|
                          DCD      ||.constdata||+0x44
                  |L7.292|
                          DCD      ||.data||

                          AREA ||i.tcp_close||, CODE, READONLY, ALIGN=1

                  tcp_close PROC
;;;398    err_t
;;;399    tcp_close(struct tcp_pcb *pcb)
000000  7d01              LDRB     r1,[r0,#0x14]
;;;400    {
;;;401      LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
;;;402      tcp_debug_print_state(pcb->state);
;;;403    
;;;404      if (pcb->state != LISTEN) {
000002  2901              CMP      r1,#1
000004  d003              BEQ      |L8.14|
;;;405        /* Set a flag not to receive any more data... */
;;;406        pcb->flags |= TF_RXCLOSED;
000006  7e81              LDRB     r1,[r0,#0x1a]
000008  f0410110          ORR      r1,r1,#0x10
00000c  7681              STRB     r1,[r0,#0x1a]
                  |L8.14|
;;;407      }
;;;408      /* ... and close */
;;;409      return tcp_close_shutdown(pcb, 1);
00000e  2101              MOVS     r1,#1
000010  f7ffbffe          B.W      tcp_close_shutdown
;;;410    }
;;;411    
                          ENDP


                          AREA ||i.tcp_close_shutdown||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_close_shutdown PROC
;;;264    static err_t
;;;265    tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;266    {
000004  4604              MOV      r4,r0
;;;267      if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
000006  2500              MOVS     r5,#0
;;;268        if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
;;;269          /* Not all data received by application, send RST to tell the remote
;;;270             side about this. */
;;;271          LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
;;;272    
;;;273          /* don't call tcp_abort here: we must not deallocate the pcb since
;;;274             that might not be expected when calling tcp_close */
;;;275          tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
;;;276                   pcb->local_port, pcb->remote_port);
;;;277    
;;;278          tcp_pcb_purge(pcb);
;;;279          TCP_RMV_ACTIVE(pcb);
000008  2701              MOVS     r7,#1
00000a  7d20              LDRB     r0,[r4,#0x14]         ;267
00000c  4e43              LDR      r6,|L9.284|
00000e  2900              CMP      r1,#0                 ;267
000010  d04a              BEQ      |L9.168|
000012  2804              CMP      r0,#4                 ;267
000014  d001              BEQ      |L9.26|
000016  2807              CMP      r0,#7                 ;267
000018  d146              BNE      |L9.168|
                  |L9.26|
00001a  6f61              LDR      r1,[r4,#0x74]         ;268
00001c  b919              CBNZ     r1,|L9.38|
00001e  8d21              LDRH     r1,[r4,#0x28]         ;268
000020  f5b16f06          CMP      r1,#0x860             ;268
000024  d040              BEQ      |L9.168|
                  |L9.38|
000026  7ea0              LDRB     r0,[r4,#0x1a]         ;271
000028  06c0              LSLS     r0,r0,#27             ;271
00002a  d406              BMI      |L9.58|
00002c  a33c              ADR      r3,|L9.288|
00002e  f240120f          MOV      r2,#0x10f             ;271
000032  a147              ADR      r1,|L9.336|
000034  a04d              ADR      r0,|L9.364|
000036  f7fffffe          BL       __2printf
                  |L9.58|
00003a  8b20              LDRH     r0,[r4,#0x18]         ;275
00003c  8ae1              LDRH     r1,[r4,#0x16]         ;275
00003e  e9cd1000          STRD     r1,r0,[sp,#0]         ;275
000042  1d23              ADDS     r3,r4,#4              ;275
000044  4622              MOV      r2,r4                 ;275
000046  6a61              LDR      r1,[r4,#0x24]         ;275
000048  6ce0              LDR      r0,[r4,#0x4c]         ;275
00004a  f7fffffe          BL       tcp_rst
00004e  4620              MOV      r0,r4                 ;278
000050  f7fffffe          BL       tcp_pcb_purge
000054  69b0              LDR      r0,[r6,#0x18]  ; tcp_active_pcbs
000056  42a0              CMP      r0,r4
000058  d109              BNE      |L9.110|
00005a  68c0              LDR      r0,[r0,#0xc]
00005c  61b0              STR      r0,[r6,#0x18]  ; tcp_active_pcbs
00005e  e008              B        |L9.114|
                  |L9.96|
000060  68c1              LDR      r1,[r0,#0xc]
000062  42a1              CMP      r1,r4
000064  d102              BNE      |L9.108|
000066  68e1              LDR      r1,[r4,#0xc]
000068  60c1              STR      r1,[r0,#0xc]
00006a  e002              B        |L9.114|
                  |L9.108|
00006c  4608              MOV      r0,r1
                  |L9.110|
00006e  2800              CMP      r0,#0
000070  d1f6              BNE      |L9.96|
                  |L9.114|
000072  60e5              STR      r5,[r4,#0xc]
000074  7037              STRB     r7,[r6,#0]
;;;280          if (pcb->state == ESTABLISHED) {
000076  7d20              LDRB     r0,[r4,#0x14]
000078  2804              CMP      r0,#4
00007a  d006              BEQ      |L9.138|
;;;281            /* move to TIME_WAIT since we close actively */
;;;282            pcb->state = TIME_WAIT;
;;;283            TCP_REG(&tcp_tw_pcbs, pcb);
;;;284          } else {
;;;285            /* CLOSE_WAIT: deallocate the pcb since we already sent a RST for it */
;;;286            if (tcp_input_pcb == pcb) {
00007c  4845              LDR      r0,|L9.404|
00007e  6800              LDR      r0,[r0,#0]  ; tcp_input_pcb
000080  42a0              CMP      r0,r4
000082  d10a              BNE      |L9.154|
;;;287              /* prevent using a deallocated pcb: free it from tcp_input later */
;;;288              tcp_trigger_input_pcb_close();
000084  f7fffffe          BL       tcp_trigger_input_pcb_close
000088  e00b              B        |L9.162|
                  |L9.138|
00008a  200a              MOVS     r0,#0xa               ;282
00008c  7520              STRB     r0,[r4,#0x14]         ;282
00008e  69f0              LDR      r0,[r6,#0x1c]         ;283  ; tcp_tw_pcbs
000090  60e0              STR      r0,[r4,#0xc]          ;283
000092  61f4              STR      r4,[r6,#0x1c]         ;283  ; tcp_tw_pcbs
000094  f7fffffe          BL       tcp_timer_needed
000098  e003              B        |L9.162|
                  |L9.154|
;;;289            } else {
;;;290              memp_free(MEMP_TCP_PCB, pcb);
00009a  4621              MOV      r1,r4
00009c  2001              MOVS     r0,#1
00009e  f7fffffe          BL       memp_free
                  |L9.162|
;;;291            }
;;;292          }
;;;293          return ERR_OK;
0000a2  2000              MOVS     r0,#0
                  |L9.164|
;;;294        }
;;;295      }
;;;296    
;;;297      /* - states which free the pcb are handled here,
;;;298         - states which send FIN and change state are handled in tcp_close_shutdown_fin() */
;;;299      switch (pcb->state) {
;;;300      case CLOSED:
;;;301        /* Closing a pcb in the CLOSED state might seem erroneous,
;;;302         * however, it is in this state once allocated and as yet unused
;;;303         * and the user needs some way to free it should the need arise.
;;;304         * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
;;;305         * or for a pcb that has been used and then entered the CLOSED state
;;;306         * is erroneous, but this should never happen as the pcb has in those cases
;;;307         * been freed, and so any remaining handles are bogus. */
;;;308        if (pcb->local_port != 0) {
;;;309          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;310        }
;;;311        memp_free(MEMP_TCP_PCB, pcb);
;;;312        break;
;;;313      case LISTEN:
;;;314        tcp_listen_closed(pcb);
;;;315        tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
;;;316        memp_free(MEMP_TCP_PCB_LISTEN, pcb);
;;;317        break;
;;;318      case SYN_SENT:
;;;319        TCP_PCB_REMOVE_ACTIVE(pcb);
;;;320        memp_free(MEMP_TCP_PCB, pcb);
;;;321        MIB2_STATS_INC(mib2.tcpattemptfails);
;;;322        break;
;;;323      default:
;;;324        return tcp_close_shutdown_fin(pcb);
;;;325      }
;;;326      return ERR_OK;
;;;327    }
0000a4  e8bd81fc          POP      {r2-r8,pc}
                  |L9.168|
0000a8  b140              CBZ      r0,|L9.188|
0000aa  2801              CMP      r0,#1                 ;299
0000ac  d01d              BEQ      |L9.234|
0000ae  2802              CMP      r0,#2                 ;299
0000b0  d028              BEQ      |L9.260|
0000b2  4620              MOV      r0,r4                 ;324
0000b4  e8bd41fc          POP      {r2-r8,lr}            ;324
0000b8  f7ffbffe          B.W      tcp_close_shutdown_fin
                  |L9.188|
0000bc  8ae0              LDRH     r0,[r4,#0x16]         ;308
0000be  b178              CBZ      r0,|L9.224|
0000c0  6930              LDR      r0,[r6,#0x10]         ;309  ; tcp_bound_pcbs
0000c2  42a0              CMP      r0,r4                 ;309
0000c4  d109              BNE      |L9.218|
0000c6  68c0              LDR      r0,[r0,#0xc]          ;309
0000c8  6130              STR      r0,[r6,#0x10]         ;309  ; tcp_bound_pcbs
0000ca  e008              B        |L9.222|
                  |L9.204|
0000cc  68c1              LDR      r1,[r0,#0xc]          ;309
0000ce  42a1              CMP      r1,r4                 ;309
0000d0  d102              BNE      |L9.216|
0000d2  68e1              LDR      r1,[r4,#0xc]          ;309
0000d4  60c1              STR      r1,[r0,#0xc]          ;309
0000d6  e002              B        |L9.222|
                  |L9.216|
0000d8  4608              MOV      r0,r1                 ;309
                  |L9.218|
0000da  2800              CMP      r0,#0                 ;309
0000dc  d1f6              BNE      |L9.204|
                  |L9.222|
0000de  60e5              STR      r5,[r4,#0xc]          ;309
                  |L9.224|
0000e0  4621              MOV      r1,r4                 ;311
0000e2  2001              MOVS     r0,#1                 ;311
0000e4  f7fffffe          BL       memp_free
0000e8  e016              B        |L9.280|
                  |L9.234|
0000ea  4620              MOV      r0,r4                 ;314
0000ec  f7fffffe          BL       tcp_listen_closed
0000f0  480a              LDR      r0,|L9.284|
0000f2  4621              MOV      r1,r4                 ;315
0000f4  3014              ADDS     r0,r0,#0x14           ;315
0000f6  f7fffffe          BL       tcp_pcb_remove
0000fa  4621              MOV      r1,r4                 ;316
0000fc  2002              MOVS     r0,#2                 ;316
0000fe  f7fffffe          BL       memp_free
000102  e009              B        |L9.280|
                  |L9.260|
000104  4805              LDR      r0,|L9.284|
000106  4621              MOV      r1,r4                 ;319
000108  3018              ADDS     r0,r0,#0x18           ;319
00010a  f7fffffe          BL       tcp_pcb_remove
00010e  7037              STRB     r7,[r6,#0]            ;319
000110  4621              MOV      r1,r4                 ;320
000112  2001              MOVS     r0,#1                 ;320
000114  f7fffffe          BL       memp_free
                  |L9.280|
000118  2000              MOVS     r0,#0                 ;326
00011a  e7c3              B        |L9.164|
;;;328    
                          ENDP

                  |L9.284|
                          DCD      ||.data||
                  |L9.288|
000120  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000124  6964646c
000128  65776172
00012c  65735c54
000130  68697264
000134  5f506172
000138  74795c4c
00013c  7749505c
000140  7372635c
000144  636f7265
000148  5c746370
00014c  2e6300  
00014f  00                DCB      0
                  |L9.336|
000150  7063622d          DCB      "pcb->flags & TF_RXCLOSED",0
000154  3e666c61
000158  67732026
00015c  2054465f
000160  5258434c
000164  4f534544
000168  00      
000169  00                DCB      0
00016a  00                DCB      0
00016b  00                DCB      0
                  |L9.364|
00016c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000170  7274696f
000174  6e202225
000178  73222066
00017c  61696c65
000180  64206174
000184  206c696e
000188  65202564
00018c  20696e20
000190  25730a00
                  |L9.404|
                          DCD      tcp_input_pcb

                          AREA ||i.tcp_close_shutdown_fin||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_close_shutdown_fin PROC
;;;329    static err_t
;;;330    tcp_close_shutdown_fin(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;331    {
000002  4605              MOV      r5,r0
;;;332      err_t err;
;;;333      LWIP_ASSERT("pcb != NULL", pcb != NULL);
000004  2d00              CMP      r5,#0
000006  d106              BNE      |L10.22|
000008  a31a              ADR      r3,|L10.116|
00000a  f240124d          MOV      r2,#0x14d
00000e  a125              ADR      r1,|L10.164|
000010  a027              ADR      r0,|L10.176|
000012  f7fffffe          BL       __2printf
                  |L10.22|
;;;334    
;;;335      switch (pcb->state) {
000016  7d28              LDRB     r0,[r5,#0x14]
;;;336      case SYN_RCVD:
;;;337        err = tcp_send_fin(pcb);
;;;338        if (err == ERR_OK) {
;;;339          tcp_backlog_accepted(pcb);
;;;340          MIB2_STATS_INC(mib2.tcpattemptfails);
;;;341          pcb->state = FIN_WAIT_1;
000018  2605              MOVS     r6,#5
00001a  2803              CMP      r0,#3                 ;335
00001c  d005              BEQ      |L10.42|
00001e  2804              CMP      r0,#4                 ;335
000020  d00a              BEQ      |L10.56|
000022  2807              CMP      r0,#7                 ;335
000024  d00f              BEQ      |L10.70|
;;;342        }
;;;343        break;
;;;344      case ESTABLISHED:
;;;345        err = tcp_send_fin(pcb);
;;;346        if (err == ERR_OK) {
;;;347          MIB2_STATS_INC(mib2.tcpestabresets);
;;;348          pcb->state = FIN_WAIT_1;
;;;349        }
;;;350        break;
;;;351      case CLOSE_WAIT:
;;;352        err = tcp_send_fin(pcb);
;;;353        if (err == ERR_OK) {
;;;354          MIB2_STATS_INC(mib2.tcpestabresets);
;;;355          pcb->state = LAST_ACK;
;;;356        }
;;;357        break;
;;;358      default:
;;;359        /* Has already been closed, do nothing. */
;;;360        return ERR_OK;
000026  2000              MOVS     r0,#0
;;;361      }
;;;362    
;;;363      if (err == ERR_OK) {
;;;364        /* To ensure all data has been sent when tcp_close returns, we have
;;;365           to make sure tcp_output doesn't fail.
;;;366           Since we don't really have to ensure all data has been sent when tcp_close
;;;367           returns (unsent data is sent from tcp timer functions, also), we don't care
;;;368           for the return value of tcp_output for now. */
;;;369        tcp_output(pcb);
;;;370      } else if (err == ERR_MEM) {
;;;371        /* Mark this pcb for closing. Closing is retried from tcp_tmr. */
;;;372        pcb->flags |= TF_CLOSEPEND;
;;;373        /* We have to return ERR_OK from here to indicate to the callers that this
;;;374           pcb should not be used any more as it will be freed soon via tcp_tmr.
;;;375           This is OK here since sending FIN does not guarantee a time frime for
;;;376           actually freeing the pcb, either (it is left in closure states for
;;;377           remote ACK or timeout) */
;;;378        return ERR_OK;
;;;379      }
;;;380      return err;
;;;381    }
000028  bd70              POP      {r4-r6,pc}
                  |L10.42|
00002a  4628              MOV      r0,r5                 ;337
00002c  f7fffffe          BL       tcp_send_fin
000030  4604              MOV      r4,r0                 ;337
000032  b97c              CBNZ     r4,|L10.84|
000034  752e              STRB     r6,[r5,#0x14]         ;341
000036  e00d              B        |L10.84|
                  |L10.56|
000038  4628              MOV      r0,r5                 ;345
00003a  f7fffffe          BL       tcp_send_fin
00003e  4604              MOV      r4,r0                 ;345
000040  b944              CBNZ     r4,|L10.84|
000042  752e              STRB     r6,[r5,#0x14]         ;348
000044  e006              B        |L10.84|
                  |L10.70|
000046  4628              MOV      r0,r5                 ;352
000048  f7fffffe          BL       tcp_send_fin
00004c  4604              MOV      r4,r0                 ;352
00004e  b90c              CBNZ     r4,|L10.84|
000050  2009              MOVS     r0,#9                 ;355
000052  7528              STRB     r0,[r5,#0x14]         ;355
                  |L10.84|
000054  b114              CBZ      r4,|L10.92|
000056  1c60              ADDS     r0,r4,#1              ;370
000058  d005              BEQ      |L10.102|
00005a  e002              B        |L10.98|
                  |L10.92|
00005c  4628              MOV      r0,r5                 ;369
00005e  f7fffffe          BL       tcp_output
                  |L10.98|
000062  4620              MOV      r0,r4                 ;380
000064  bd70              POP      {r4-r6,pc}
                  |L10.102|
000066  7ea8              LDRB     r0,[r5,#0x1a]         ;372
000068  f0400008          ORR      r0,r0,#8              ;372
00006c  76a8              STRB     r0,[r5,#0x1a]         ;372
00006e  2000              MOVS     r0,#0                 ;378
000070  bd70              POP      {r4-r6,pc}
;;;382    
                          ENDP

000072  0000              DCW      0x0000
                  |L10.116|
000074  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000078  6964646c
00007c  65776172
000080  65735c54
000084  68697264
000088  5f506172
00008c  74795c4c
000090  7749505c
000094  7372635c
000098  636f7265
00009c  5c746370
0000a0  2e6300  
0000a3  00                DCB      0
                  |L10.164|
0000a4  70636220          DCB      "pcb != NULL",0
0000a8  213d204e
0000ac  554c4c00
                  |L10.176|
0000b0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000b4  7274696f
0000b8  6e202225
0000bc  73222066
0000c0  61696c65
0000c4  64206174
0000c8  206c696e
0000cc  65202564
0000d0  20696e20
0000d4  25730a00

                          AREA ||i.tcp_connect||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_connect PROC
;;;876    err_t
;;;877    tcp_connect(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;878          tcp_connected_fn connected)
;;;879    {
000004  4604              MOV      r4,r0
000006  461d              MOV      r5,r3
;;;880      err_t ret;
;;;881      u32_t iss;
;;;882      u16_t old_local_port;
;;;883    
;;;884      if ((pcb == NULL) || (ipaddr == NULL)) {
000008  2c00              CMP      r4,#0
00000a  d00f              BEQ      |L11.44|
00000c  2900              CMP      r1,#0
00000e  d00d              BEQ      |L11.44|
;;;885        return ERR_VAL;
;;;886      }
;;;887    
;;;888      LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
000010  7d20              LDRB     r0,[r4,#0x14]
000012  2800              CMP      r0,#0
000014  d00d              BEQ      |L11.50|
000016  a33c              ADR      r3,|L11.264|
000018  f44f725e          MOV      r2,#0x378
00001c  a146              ADR      r1,|L11.312|
00001e  a052              ADR      r0,|L11.360|
000020  f7fffffe          BL       __2printf
000024  f06f0009          MVN      r0,#9
                  |L11.40|
;;;889    
;;;890      LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
;;;891      ip_addr_set(&pcb->remote_ip, ipaddr);
;;;892      pcb->remote_port = port;
;;;893    
;;;894      /* check if we have a route to the remote host */
;;;895      if (ip_addr_isany(&pcb->local_ip)) {
;;;896        /* no local IP address set, yet. */
;;;897        struct netif *netif;
;;;898        const ip_addr_t *local_ip;
;;;899        ip_route_get_local_ip(&pcb->local_ip, &pcb->remote_ip, netif, local_ip);
;;;900        if ((netif == NULL) || (local_ip == NULL)) {
;;;901          /* Don't even try to send a SYN packet if we have no route
;;;902             since that will fail. */
;;;903          return ERR_RTE;
;;;904        }
;;;905        /* Use the address as local address of the pcb. */
;;;906        ip_addr_copy(pcb->local_ip, *local_ip);
;;;907      }
;;;908    
;;;909      old_local_port = pcb->local_port;
;;;910      if (pcb->local_port == 0) {
;;;911        pcb->local_port = tcp_new_port();
;;;912        if (pcb->local_port == 0) {
;;;913          return ERR_BUF;
;;;914        }
;;;915      } else {
;;;916    #if SO_REUSE
;;;917        if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;918          /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
;;;919             now that the 5-tuple is unique. */
;;;920          struct tcp_pcb *cpcb;
;;;921          int i;
;;;922          /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
;;;923          for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
;;;924            for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;925              if ((cpcb->local_port == pcb->local_port) &&
;;;926                  (cpcb->remote_port == port) &&
;;;927                  ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
;;;928                  ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
;;;929                /* linux returns EISCONN here, but ERR_USE should be OK for us */
;;;930                return ERR_USE;
;;;931              }
;;;932            }
;;;933          }
;;;934        }
;;;935    #endif /* SO_REUSE */
;;;936      }
;;;937    
;;;938      iss = tcp_next_iss(pcb);
;;;939      pcb->rcv_nxt = 0;
;;;940      pcb->snd_nxt = iss;
;;;941      pcb->lastack = iss - 1;
;;;942      pcb->snd_wl2 = iss - 1;
;;;943      pcb->snd_lbb = iss - 1;
;;;944      /* Start with a window that does not need scaling. When window scaling is
;;;945         enabled and used, the window is enlarged when both sides agree on scaling. */
;;;946      pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
;;;947      pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;948      pcb->snd_wnd = TCP_WND;
;;;949      /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;950         The send MSS is updated when an MSS option is received. */
;;;951      pcb->mss = INITIAL_MSS;
;;;952    #if TCP_CALCULATE_EFF_SEND_MSS
;;;953      pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
;;;954    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;955      pcb->cwnd = 1;
;;;956    #if LWIP_CALLBACK_API
;;;957      pcb->connected = connected;
;;;958    #else /* LWIP_CALLBACK_API */
;;;959      LWIP_UNUSED_ARG(connected);
;;;960    #endif /* LWIP_CALLBACK_API */
;;;961    
;;;962      /* Send a SYN together with the MSS option. */
;;;963      ret = tcp_enqueue_flags(pcb, TCP_SYN);
;;;964      if (ret == ERR_OK) {
;;;965        /* SYN segment was enqueued, changed the pcbs state now */
;;;966        pcb->state = SYN_SENT;
;;;967        if (old_local_port != 0) {
;;;968          TCP_RMV(&tcp_bound_pcbs, pcb);
;;;969        }
;;;970        TCP_REG_ACTIVE(pcb);
;;;971        MIB2_STATS_INC(mib2.tcpactiveopens);
;;;972    
;;;973        tcp_output(pcb);
;;;974      }
;;;975      return ret;
;;;976    }
000028  e8bd87f0          POP      {r4-r10,pc}
                  |L11.44|
00002c  f06f0005          MVN      r0,#5                 ;885
000030  e7fa              B        |L11.40|
                  |L11.50|
000032  6808              LDR      r0,[r1,#0]            ;891
000034  6060              STR      r0,[r4,#4]            ;891
000036  8322              STRH     r2,[r4,#0x18]         ;892
000038  6820              LDR      r0,[r4,#0]            ;891
00003a  b968              CBNZ     r0,|L11.88|
00003c  1d20              ADDS     r0,r4,#4              ;899
00003e  f7fffffe          BL       ip4_route
000042  2800              CMP      r0,#0                 ;899
000044  d002              BEQ      |L11.76|
000046  f1000004          ADD      r0,r0,#4              ;899
00004a  e001              B        |L11.80|
                  |L11.76|
00004c  f04f0000          MOV      r0,#0                 ;899
                  |L11.80|
000050  d008              BEQ      |L11.100|
000052  b138              CBZ      r0,|L11.100|
000054  6800              LDR      r0,[r0,#0]            ;906
000056  6020              STR      r0,[r4,#0]            ;906
                  |L11.88|
000058  f8b49016          LDRH     r9,[r4,#0x16]         ;909
00005c  f1b90f00          CMP      r9,#0                 ;910
000060  d003              BEQ      |L11.106|
000062  e006              B        |L11.114|
                  |L11.100|
000064  f06f0003          MVN      r0,#3                 ;903
000068  e7de              B        |L11.40|
                  |L11.106|
00006a  f7fffffe          BL       tcp_new_port
00006e  82e0              STRH     r0,[r4,#0x16]         ;911
000070  b320              CBZ      r0,|L11.188|
                  |L11.114|
000072  4620              MOV      r0,r4                 ;938
000074  f7fffffe          BL       tcp_next_iss
000078  2700              MOVS     r7,#0                 ;939
00007a  6267              STR      r7,[r4,#0x24]         ;939
00007c  64e0              STR      r0,[r4,#0x4c]         ;940
00007e  1e40              SUBS     r0,r0,#1              ;941
000080  6460              STR      r0,[r4,#0x44]         ;941
000082  6560              STR      r0,[r4,#0x54]         ;942
000084  65a0              STR      r0,[r4,#0x58]         ;943
000086  f44f6006          MOV      r0,#0x860             ;946
00008a  8560              STRH     r0,[r4,#0x2a]         ;946
00008c  8520              STRH     r0,[r4,#0x28]         ;946
00008e  62e7              STR      r7,[r4,#0x2c]         ;947
000090  f8a4005c          STRH     r0,[r4,#0x5c]         ;948
000094  1080              ASRS     r0,r0,#2              ;951
000096  8660              STRH     r0,[r4,#0x32]         ;951
000098  1d21              ADDS     r1,r4,#4              ;953
00009a  f7fffffe          BL       tcp_eff_send_mss_impl
00009e  8660              STRH     r0,[r4,#0x32]         ;953
0000a0  f04f0801          MOV      r8,#1                 ;955
0000a4  f8a48048          STRH     r8,[r4,#0x48]         ;955
0000a8  f8c45084          STR      r5,[r4,#0x84]         ;957
0000ac  2102              MOVS     r1,#2                 ;963
0000ae  4620              MOV      r0,r4                 ;963
0000b0  f7fffffe          BL       tcp_enqueue_flags
0000b4  4605              MOV      r5,r0                 ;963
0000b6  0028              MOVS     r0,r5                 ;964
0000b8  d003              BEQ      |L11.194|
0000ba  e022              B        |L11.258|
                  |L11.188|
0000bc  f06f0001          MVN      r0,#1                 ;913
0000c0  e7b2              B        |L11.40|
                  |L11.194|
0000c2  2002              MOVS     r0,#2                 ;966
0000c4  7520              STRB     r0,[r4,#0x14]         ;966
0000c6  4e32              LDR      r6,|L11.400|
0000c8  f1b90f00          CMP      r9,#0                 ;967
0000cc  d00f              BEQ      |L11.238|
0000ce  6930              LDR      r0,[r6,#0x10]         ;968  ; tcp_bound_pcbs
0000d0  42a0              CMP      r0,r4                 ;968
0000d2  d109              BNE      |L11.232|
0000d4  68c0              LDR      r0,[r0,#0xc]          ;968
0000d6  6130              STR      r0,[r6,#0x10]         ;968  ; tcp_bound_pcbs
0000d8  e008              B        |L11.236|
                  |L11.218|
0000da  68c1              LDR      r1,[r0,#0xc]          ;968
0000dc  42a1              CMP      r1,r4                 ;968
0000de  d102              BNE      |L11.230|
0000e0  68e1              LDR      r1,[r4,#0xc]          ;968
0000e2  60c1              STR      r1,[r0,#0xc]          ;968
0000e4  e002              B        |L11.236|
                  |L11.230|
0000e6  4608              MOV      r0,r1                 ;968
                  |L11.232|
0000e8  2800              CMP      r0,#0                 ;968
0000ea  d1f6              BNE      |L11.218|
                  |L11.236|
0000ec  60e7              STR      r7,[r4,#0xc]          ;968
                  |L11.238|
0000ee  69b0              LDR      r0,[r6,#0x18]         ;970  ; tcp_active_pcbs
0000f0  60e0              STR      r0,[r4,#0xc]          ;970
0000f2  61b4              STR      r4,[r6,#0x18]         ;970  ; tcp_active_pcbs
0000f4  f7fffffe          BL       tcp_timer_needed
0000f8  f8868000          STRB     r8,[r6,#0]            ;970
0000fc  4620              MOV      r0,r4                 ;973
0000fe  f7fffffe          BL       tcp_output
                  |L11.258|
000102  4628              MOV      r0,r5                 ;975
000104  e790              B        |L11.40|
;;;977    
                          ENDP

000106  0000              DCW      0x0000
                  |L11.264|
000108  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
00010c  6964646c
000110  65776172
000114  65735c54
000118  68697264
00011c  5f506172
000120  74795c4c
000124  7749505c
000128  7372635c
00012c  636f7265
000130  5c746370
000134  2e6300  
000137  00                DCB      0
                  |L11.312|
000138  7463705f          DCB      "tcp_connect: can only connect from state CLOSED",0
00013c  636f6e6e
000140  6563743a
000144  2063616e
000148  206f6e6c
00014c  7920636f
000150  6e6e6563
000154  74206672
000158  6f6d2073
00015c  74617465
000160  20434c4f
000164  53454400
                  |L11.360|
000168  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00016c  7274696f
000170  6e202225
000174  73222066
000178  61696c65
00017c  64206174
000180  206c696e
000184  65202564
000188  20696e20
00018c  25730a00
                  |L11.400|
                          DCD      ||.data||

                          AREA ||i.tcp_debug_state_str||, CODE, READONLY, ALIGN=2

                  tcp_debug_state_str PROC
;;;2029   const char*
;;;2030   tcp_debug_state_str(enum tcp_state s)
000000  4901              LDR      r1,|L12.8|
;;;2031   {
;;;2032     return tcp_state_str[s];
000002  f8510020          LDR      r0,[r1,r0,LSL #2]
;;;2033   }
000006  4770              BX       lr
;;;2034   
                          ENDP

                  |L12.8|
                          DCD      ||.constdata||+0x8

                          AREA ||i.tcp_eff_send_mss_impl||, CODE, READONLY, ALIGN=1

                  tcp_eff_send_mss_impl PROC
;;;1915   u16_t
;;;1916   tcp_eff_send_mss_impl(u16_t sendmss, const ip_addr_t *dest
000000  b510              PUSH     {r4,lr}
;;;1917   #if LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING
;;;1918                        , const ip_addr_t *src
;;;1919   #endif /* LWIP_IPV6 || LWIP_IPV4_SRC_ROUTING */
;;;1920                        )
;;;1921   {
000002  4604              MOV      r4,r0
000004  4608              MOV      r0,r1
;;;1922     u16_t mss_s;
;;;1923     struct netif *outif;
;;;1924     s16_t mtu;
;;;1925   
;;;1926     outif = ip_route(src, dest);
000006  f7fffffe          BL       ip4_route
;;;1927   #if LWIP_IPV6
;;;1928   #if LWIP_IPV4
;;;1929     if (IP_IS_V6(dest))
;;;1930   #endif /* LWIP_IPV4 */
;;;1931     {
;;;1932       /* First look in destination cache, to see if there is a Path MTU. */
;;;1933       mtu = nd6_get_destination_mtu(ip_2_ip6(dest), outif);
;;;1934     }
;;;1935   #if LWIP_IPV4
;;;1936     else
;;;1937   #endif /* LWIP_IPV4 */
;;;1938   #endif /* LWIP_IPV6 */
;;;1939   #if LWIP_IPV4
;;;1940     {
;;;1941       if (outif == NULL) {
00000a  b150              CBZ      r0,|L13.34|
;;;1942         return sendmss;
;;;1943       }
;;;1944       mtu = outif->mtu;
00000c  f9b0002e          LDRSH    r0,[r0,#0x2e]
;;;1945     }
;;;1946   #endif /* LWIP_IPV4 */
;;;1947   
;;;1948     if (mtu != 0) {
000010  b128              CBZ      r0,|L13.30|
;;;1949   #if LWIP_IPV6
;;;1950   #if LWIP_IPV4
;;;1951       if (IP_IS_V6(dest))
;;;1952   #endif /* LWIP_IPV4 */
;;;1953       {
;;;1954         mss_s = mtu - IP6_HLEN - TCP_HLEN;
;;;1955       }
;;;1956   #if LWIP_IPV4
;;;1957       else
;;;1958   #endif /* LWIP_IPV4 */
;;;1959   #endif /* LWIP_IPV6 */
;;;1960   #if LWIP_IPV4
;;;1961       {
;;;1962         mss_s = mtu - IP_HLEN - TCP_HLEN;
000012  3828              SUBS     r0,r0,#0x28
000014  b280              UXTH     r0,r0
;;;1963       }
;;;1964   #endif /* LWIP_IPV4 */
;;;1965       /* RFC 1122, chap 4.2.2.6:
;;;1966        * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
;;;1967        * We correct for TCP options in tcp_write(), and don't support IP options.
;;;1968        */
;;;1969       sendmss = LWIP_MIN(sendmss, mss_s);
000016  4284              CMP      r4,r0
000018  d200              BCS      |L13.28|
00001a  4620              MOV      r0,r4
                  |L13.28|
00001c  4604              MOV      r4,r0
                  |L13.30|
;;;1970     }
;;;1971     return sendmss;
00001e  4620              MOV      r0,r4
;;;1972   }
000020  bd10              POP      {r4,pc}
                  |L13.34|
000022  4620              MOV      r0,r4                 ;1942
000024  bd10              POP      {r4,pc}
;;;1973   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
                          ENDP


                          AREA ||i.tcp_err||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_err PROC
;;;1756   void
;;;1757   tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
000000  b570              PUSH     {r4-r6,lr}
;;;1758   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1759     if (pcb != NULL) {
000006  2c00              CMP      r4,#0
000008  d00b              BEQ      |L14.34|
;;;1760       LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
00000a  7d20              LDRB     r0,[r4,#0x14]
00000c  2801              CMP      r0,#1
00000e  d106              BNE      |L14.30|
000010  a304              ADR      r3,|L14.36|
000012  f44f62dc          MOV      r2,#0x6e0
000016  a10f              ADR      r1,|L14.84|
000018  a018              ADR      r0,|L14.124|
00001a  f7fffffe          BL       __2printf
                  |L14.30|
;;;1761       pcb->errf = err;
00001e  f8c4508c          STR      r5,[r4,#0x8c]
                  |L14.34|
;;;1762     }
;;;1763   }
000022  bd70              POP      {r4-r6,pc}
;;;1764   
                          ENDP

                  |L14.36|
000024  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000028  6964646c
00002c  65776172
000030  65735c54
000034  68697264
000038  5f506172
00003c  74795c4c
000040  7749505c
000044  7372635c
000048  636f7265
00004c  5c746370
000050  2e6300  
000053  00                DCB      0
                  |L14.84|
000054  696e7661          DCB      "invalid socket state for err callback",0
000058  6c696420
00005c  736f636b
000060  65742073
000064  74617465
000068  20666f72
00006c  20657272
000070  2063616c
000074  6c626163
000078  6b00    
00007a  00                DCB      0
00007b  00                DCB      0
                  |L14.124|
00007c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000080  7274696f
000084  6e202225
000088  73222066
00008c  61696c65
000090  64206174
000094  206c696e
000098  65202564
00009c  20696e20
0000a0  25730a00

                          AREA ||i.tcp_fasttmr||, CODE, READONLY, ALIGN=2

                  tcp_fasttmr PROC
;;;1250   void
;;;1251   tcp_fasttmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1252   {
;;;1253     struct tcp_pcb *pcb;
;;;1254   
;;;1255     ++tcp_timer_ctr;
000002  4e19              LDR      r6,|L15.104|
000004  78b0              LDRB     r0,[r6,#2]  ; tcp_timer_ctr
000006  1c40              ADDS     r0,r0,#1
000008  70b0              STRB     r0,[r6,#2]
                  |L15.10|
;;;1256   
;;;1257   tcp_fasttmr_start:
;;;1258     pcb = tcp_active_pcbs;
00000a  69b4              LDR      r4,[r6,#0x18]  ; tcp_active_pcbs
;;;1259   
;;;1260     while (pcb != NULL) {
00000c  e028              B        |L15.96|
                  |L15.14|
;;;1261       if (pcb->last_timer != tcp_timer_ctr) {
00000e  7f61              LDRB     r1,[r4,#0x1d]
000010  78b0              LDRB     r0,[r6,#2]  ; tcp_timer_ctr
000012  4281              CMP      r1,r0
000014  d023              BEQ      |L15.94|
;;;1262         struct tcp_pcb *next;
;;;1263         pcb->last_timer = tcp_timer_ctr;
000016  7760              STRB     r0,[r4,#0x1d]
;;;1264         /* send delayed ACKs */
;;;1265         if (pcb->flags & TF_ACK_DELAY) {
000018  7ea0              LDRB     r0,[r4,#0x1a]
00001a  07c1              LSLS     r1,r0,#31
00001c  d009              BEQ      |L15.50|
;;;1266           LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
;;;1267           tcp_ack_now(pcb);
00001e  f0400002          ORR      r0,r0,#2
000022  76a0              STRB     r0,[r4,#0x1a]
;;;1268           tcp_output(pcb);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       tcp_output
;;;1269           pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
00002a  7ea0              LDRB     r0,[r4,#0x1a]
00002c  f0200003          BIC      r0,r0,#3
000030  76a0              STRB     r0,[r4,#0x1a]
                  |L15.50|
;;;1270         }
;;;1271         /* send pending FIN */
;;;1272         if (pcb->flags & TF_CLOSEPEND) {
000032  7ea0              LDRB     r0,[r4,#0x1a]
000034  0701              LSLS     r1,r0,#28
000036  d505              BPL      |L15.68|
;;;1273           LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: pending FIN\n"));
;;;1274           pcb->flags &= ~(TF_CLOSEPEND);
000038  f0200008          BIC      r0,r0,#8
00003c  76a0              STRB     r0,[r4,#0x1a]
;;;1275           tcp_close_shutdown_fin(pcb);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       tcp_close_shutdown_fin
                  |L15.68|
;;;1276         }
;;;1277   
;;;1278         next = pcb->next;
000044  68e5              LDR      r5,[r4,#0xc]
;;;1279   
;;;1280         /* If there is data which was previously "refused" by upper layer */
;;;1281         if (pcb->refused_data != NULL) {
000046  6f60              LDR      r0,[r4,#0x74]
000048  b138              CBZ      r0,|L15.90|
;;;1282           tcp_active_pcbs_changed = 0;
00004a  2000              MOVS     r0,#0
00004c  7030              STRB     r0,[r6,#0]
;;;1283           tcp_process_refused_data(pcb);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       tcp_process_refused_data
;;;1284           if (tcp_active_pcbs_changed) {
000054  7830              LDRB     r0,[r6,#0]  ; tcp_active_pcbs_changed
000056  2800              CMP      r0,#0
000058  d1d7              BNE      |L15.10|
                  |L15.90|
;;;1285             /* application callback has changed the pcb list: restart the loop */
;;;1286             goto tcp_fasttmr_start;
;;;1287           }
;;;1288         }
;;;1289         pcb = next;
00005a  462c              MOV      r4,r5
;;;1290       } else {
00005c  e000              B        |L15.96|
                  |L15.94|
;;;1291         pcb = pcb->next;
00005e  68e4              LDR      r4,[r4,#0xc]
                  |L15.96|
000060  2c00              CMP      r4,#0                 ;1260
000062  d1d4              BNE      |L15.14|
;;;1292       }
;;;1293     }
;;;1294   }
000064  bd70              POP      {r4-r6,pc}
;;;1295   
                          ENDP

000066  0000              DCW      0x0000
                  |L15.104|
                          DCD      ||.data||

                          AREA ||i.tcp_init||, CODE, READONLY, ALIGN=1

                  tcp_init PROC
;;;144    void
;;;145    tcp_init(void)
000000  4770              BX       lr
;;;146    {
;;;147    #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
;;;148      tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
;;;149    #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
;;;150    }
;;;151    
                          ENDP


                          AREA ||i.tcp_kill_prio||, CODE, READONLY, ALIGN=2

                  tcp_kill_prio PROC
;;;1463   static void
;;;1464   tcp_kill_prio(u8_t prio)
000000  b4f0              PUSH     {r4-r7}
;;;1465   {
;;;1466     struct tcp_pcb *pcb, *inactive;
;;;1467     u32_t inactivity;
;;;1468     u8_t mprio;
;;;1469   
;;;1470     mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
000002  287f              CMP      r0,#0x7f
000004  d901              BLS      |L17.10|
000006  237f              MOVS     r3,#0x7f
000008  e000              B        |L17.12|
                  |L17.10|
00000a  4603              MOV      r3,r0
                  |L17.12|
;;;1471   
;;;1472     /* We kill the oldest active connection that has lower priority than prio. */
;;;1473     inactivity = 0;
00000c  2500              MOVS     r5,#0
;;;1474     inactive = NULL;
00000e  2400              MOVS     r4,#0
;;;1475     for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000010  480c              LDR      r0,|L17.68|
000012  6980              LDR      r0,[r0,#0x18]  ; tcp_active_pcbs
000014  490b              LDR      r1,|L17.68|
000016  68ce              LDR      r6,[r1,#0xc]
000018  e00a              B        |L17.48|
                  |L17.26|
;;;1476       if (pcb->prio <= mprio &&
00001a  7d42              LDRB     r2,[r0,#0x15]
00001c  429a              CMP      r2,r3
00001e  d806              BHI      |L17.46|
;;;1477          (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
000020  6a01              LDR      r1,[r0,#0x20]
000022  1a71              SUBS     r1,r6,r1
000024  42a9              CMP      r1,r5
000026  d302              BCC      |L17.46|
;;;1478         inactivity = tcp_ticks - pcb->tmr;
000028  460d              MOV      r5,r1
;;;1479         inactive = pcb;
00002a  4604              MOV      r4,r0
;;;1480         mprio = pcb->prio;
00002c  4613              MOV      r3,r2
                  |L17.46|
00002e  68c0              LDR      r0,[r0,#0xc]          ;1475
                  |L17.48|
000030  2800              CMP      r0,#0                 ;1475
000032  d1f2              BNE      |L17.26|
;;;1481       }
;;;1482     }
;;;1483     if (inactive != NULL) {
000034  2c00              CMP      r4,#0
000036  d003              BEQ      |L17.64|
;;;1484       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
;;;1485              (void *)inactive, inactivity));
;;;1486       tcp_abort(inactive);
000038  4620              MOV      r0,r4
00003a  bcf0              POP      {r4-r7}
00003c  f7ffbffe          B.W      tcp_abort
                  |L17.64|
;;;1487     }
;;;1488   }
000040  bcf0              POP      {r4-r7}
000042  4770              BX       lr
;;;1489   
                          ENDP

                  |L17.68|
                          DCD      ||.data||

                          AREA ||i.tcp_kill_state||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_kill_state PROC
;;;1494   static void
;;;1495   tcp_kill_state(enum tcp_state state)
000000  b570              PUSH     {r4-r6,lr}
;;;1496   {
000002  4604              MOV      r4,r0
;;;1497     struct tcp_pcb *pcb, *inactive;
;;;1498     u32_t inactivity;
;;;1499   
;;;1500     LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
000004  2c08              CMP      r4,#8
000006  d008              BEQ      |L18.26|
000008  2c09              CMP      r4,#9
00000a  d006              BEQ      |L18.26|
00000c  a310              ADR      r3,|L18.80|
00000e  f24052dc          MOV      r2,#0x5dc
000012  a11b              ADR      r1,|L18.128|
000014  a01e              ADR      r0,|L18.144|
000016  f7fffffe          BL       __2printf
                  |L18.26|
;;;1501   
;;;1502     inactivity = 0;
00001a  2300              MOVS     r3,#0
;;;1503     inactive = NULL;
00001c  2000              MOVS     r0,#0
;;;1504     /* Go through the list of active pcbs and get the oldest pcb that is in state
;;;1505        CLOSING/LAST_ACK. */
;;;1506     for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
00001e  4926              LDR      r1,|L18.184|
000020  698a              LDR      r2,[r1,#0x18]  ; tcp_active_pcbs
;;;1507       if (pcb->state == state) {
;;;1508         if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
000022  68cd              LDR      r5,[r1,#0xc]
000024  e009              B        |L18.58|
                  |L18.38|
000026  7d11              LDRB     r1,[r2,#0x14]         ;1507
000028  42a1              CMP      r1,r4                 ;1507
00002a  d105              BNE      |L18.56|
00002c  6a11              LDR      r1,[r2,#0x20]
00002e  1a69              SUBS     r1,r5,r1
000030  4299              CMP      r1,r3
000032  d301              BCC      |L18.56|
;;;1509           inactivity = tcp_ticks - pcb->tmr;
000034  460b              MOV      r3,r1
;;;1510           inactive = pcb;
000036  4610              MOV      r0,r2
                  |L18.56|
000038  68d2              LDR      r2,[r2,#0xc]          ;1506
                  |L18.58|
00003a  2a00              CMP      r2,#0                 ;1506
00003c  d1f3              BNE      |L18.38|
;;;1511         }
;;;1512       }
;;;1513     }
;;;1514     if (inactive != NULL) {
00003e  2800              CMP      r0,#0
000040  d004              BEQ      |L18.76|
;;;1515       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_closing: killing oldest %s PCB %p (%"S32_F")\n",
;;;1516              tcp_state_str[state], (void *)inactive, inactivity));
;;;1517       /* Don't send a RST, since no data is lost. */
;;;1518       tcp_abandon(inactive, 0);
000042  e8bd4070          POP      {r4-r6,lr}
000046  2100              MOVS     r1,#0
000048  f7ffbffe          B.W      tcp_abandon
                  |L18.76|
;;;1519     }
;;;1520   }
00004c  bd70              POP      {r4-r6,pc}
;;;1521   
                          ENDP

00004e  0000              DCW      0x0000
                  |L18.80|
000050  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000054  6964646c
000058  65776172
00005c  65735c54
000060  68697264
000064  5f506172
000068  74795c4c
00006c  7749505c
000070  7372635c
000074  636f7265
000078  5c746370
00007c  2e6300  
00007f  00                DCB      0
                  |L18.128|
000080  696e7661          DCB      "invalid state",0
000084  6c696420
000088  73746174
00008c  6500    
00008e  00                DCB      0
00008f  00                DCB      0
                  |L18.144|
000090  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000094  7274696f
000098  6e202225
00009c  73222066
0000a0  61696c65
0000a4  64206174
0000a8  206c696e
0000ac  65202564
0000b0  20696e20
0000b4  25730a00
                  |L18.184|
                          DCD      ||.data||

                          AREA ||i.tcp_kill_timewait||, CODE, READONLY, ALIGN=2

                  tcp_kill_timewait PROC
;;;1526   static void
;;;1527   tcp_kill_timewait(void)
000000  b430              PUSH     {r4,r5}
;;;1528   {
;;;1529     struct tcp_pcb *pcb, *inactive;
;;;1530     u32_t inactivity;
;;;1531   
;;;1532     inactivity = 0;
000002  2300              MOVS     r3,#0
;;;1533     inactive = NULL;
000004  2000              MOVS     r0,#0
;;;1534     /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
;;;1535     for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
000006  490a              LDR      r1,|L19.48|
000008  69c9              LDR      r1,[r1,#0x1c]  ; tcp_tw_pcbs
00000a  4a09              LDR      r2,|L19.48|
;;;1536       if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
00000c  68d4              LDR      r4,[r2,#0xc]
00000e  e006              B        |L19.30|
                  |L19.16|
000010  6a0a              LDR      r2,[r1,#0x20]
000012  1aa2              SUBS     r2,r4,r2
000014  429a              CMP      r2,r3
000016  d301              BCC      |L19.28|
;;;1537         inactivity = tcp_ticks - pcb->tmr;
000018  4613              MOV      r3,r2
;;;1538         inactive = pcb;
00001a  4608              MOV      r0,r1
                  |L19.28|
00001c  68c9              LDR      r1,[r1,#0xc]          ;1535
                  |L19.30|
00001e  2900              CMP      r1,#0                 ;1535
000020  d1f6              BNE      |L19.16|
;;;1539       }
;;;1540     }
;;;1541     if (inactive != NULL) {
000022  2800              CMP      r0,#0
000024  d002              BEQ      |L19.44|
;;;1542       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
;;;1543              (void *)inactive, inactivity));
;;;1544       tcp_abort(inactive);
000026  bc30              POP      {r4,r5}
000028  f7ffbffe          B.W      tcp_abort
                  |L19.44|
;;;1545     }
;;;1546   }
00002c  bc30              POP      {r4,r5}
00002e  4770              BX       lr
;;;1547   
                          ENDP

                  |L19.48|
                          DCD      ||.data||

                          AREA ||i.tcp_listen_closed||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_listen_closed PROC
;;;187    static void
;;;188    tcp_listen_closed(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;189    {
000002  4606              MOV      r6,r0
;;;190    #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
;;;191      size_t i;
;;;192      LWIP_ASSERT("pcb != NULL", pcb != NULL);
000004  2e00              CMP      r6,#0
000006  d105              BNE      |L20.20|
000008  a30d              ADR      r3,|L20.64|
00000a  22c0              MOVS     r2,#0xc0
00000c  a118              ADR      r1,|L20.112|
00000e  a01b              ADR      r0,|L20.124|
000010  f7fffffe          BL       __2printf
                  |L20.20|
;;;193      LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
000014  7d30              LDRB     r0,[r6,#0x14]
000016  2801              CMP      r0,#1
000018  d005              BEQ      |L20.38|
00001a  a309              ADR      r3,|L20.64|
00001c  22c1              MOVS     r2,#0xc1
00001e  a121              ADR      r1,|L20.164|
000020  a016              ADR      r0,|L20.124|
000022  f7fffffe          BL       __2printf
                  |L20.38|
;;;194      for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
000026  2401              MOVS     r4,#1
;;;195        tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen*)pcb);
000028  4d24              LDR      r5,|L20.188|
                  |L20.42|
00002a  4631              MOV      r1,r6
00002c  f8550024          LDR      r0,[r5,r4,LSL #2]
000030  6800              LDR      r0,[r0,#0]
000032  f7fffffe          BL       tcp_remove_listener
000036  1c64              ADDS     r4,r4,#1              ;194
000038  2c04              CMP      r4,#4                 ;194
00003a  d3f6              BCC      |L20.42|
;;;196      }
;;;197    #endif
;;;198      LWIP_UNUSED_ARG(pcb);
;;;199    }
00003c  bd70              POP      {r4-r6,pc}
;;;200    
                          ENDP

00003e  0000              DCW      0x0000
                  |L20.64|
000040  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000044  6964646c
000048  65776172
00004c  65735c54
000050  68697264
000054  5f506172
000058  74795c4c
00005c  7749505c
000060  7372635c
000064  636f7265
000068  5c746370
00006c  2e6300  
00006f  00                DCB      0
                  |L20.112|
000070  70636220          DCB      "pcb != NULL",0
000074  213d204e
000078  554c4c00
                  |L20.124|
00007c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000080  7274696f
000084  6e202225
000088  73222066
00008c  61696c65
000090  64206174
000094  206c696e
000098  65202564
00009c  20696e20
0000a0  25730a00
                  |L20.164|
0000a4  7063622d          DCB      "pcb->state == LISTEN",0
0000a8  3e737461
0000ac  7465203d
0000b0  3d204c49
0000b4  5354454e
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L20.188|
                          DCD      ||.constdata||+0x44

                          AREA ||i.tcp_listen_with_backlog||, CODE, READONLY, ALIGN=1

                  tcp_listen_with_backlog PROC
;;;663    struct tcp_pcb *
;;;664    tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
000000  2200              MOVS     r2,#0
;;;665    {
;;;666      return tcp_listen_with_backlog_and_err(pcb, backlog, NULL);
000002  f7ffbffe          B.W      tcp_listen_with_backlog_and_err
;;;667    }
;;;668    
                          ENDP


                          AREA ||i.tcp_listen_with_backlog_and_err||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_listen_with_backlog_and_err PROC
;;;685    struct tcp_pcb *
;;;686    tcp_listen_with_backlog_and_err(struct tcp_pcb *pcb, u8_t backlog, err_t *err)
000000  b570              PUSH     {r4-r6,lr}
;;;687    {
000002  4604              MOV      r4,r0
000004  4616              MOV      r6,r2
;;;688      struct tcp_pcb_listen *lpcb = NULL;
000006  2500              MOVS     r5,#0
;;;689      err_t res;
;;;690    
;;;691      LWIP_UNUSED_ARG(backlog);
;;;692      LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, res = ERR_CLSD; goto done);
000008  7d20              LDRB     r0,[r4,#0x14]
00000a  2800              CMP      r0,#0
00000c  d009              BEQ      |L22.34|
00000e  a324              ADR      r3,|L22.160|
000010  f44f722d          MOV      r2,#0x2b4
000014  a12e              ADR      r1,|L22.208|
000016  a037              ADR      r0,|L22.244|
000018  f7fffffe          BL       __2printf
00001c  f06f000e          MVN      r0,#0xe
000020  e03a              B        |L22.152|
                  |L22.34|
;;;693    
;;;694      /* already listening? */
;;;695      if (pcb->state == LISTEN) {
;;;696        lpcb = (struct tcp_pcb_listen*)pcb;
;;;697        res = ERR_ALREADY;
;;;698        goto done;
;;;699      }
;;;700    #if SO_REUSE
;;;701      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;702        /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
;;;703           is declared (listen-/connection-pcb), we have to make sure now that
;;;704           this port is only used once for every local IP. */
;;;705        for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;706          if ((lpcb->local_port == pcb->local_port) &&
;;;707              ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
;;;708            /* this address/port is already used */
;;;709            lpcb = NULL;
;;;710            res = ERR_USE;
;;;711            goto done;
;;;712          }
;;;713        }
;;;714      }
;;;715    #endif /* SO_REUSE */
;;;716      lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
000022  2002              MOVS     r0,#2
000024  f7fffffe          BL       memp_malloc
000028  4605              MOV      r5,r0
;;;717      if (lpcb == NULL) {
00002a  0028              MOVS     r0,r5
00002c  d018              BEQ      |L22.96|
;;;718        res = ERR_MEM;
;;;719        goto done;
;;;720      }
;;;721      lpcb->callback_arg = pcb->callback_arg;
00002e  6920              LDR      r0,[r4,#0x10]
000030  6128              STR      r0,[r5,#0x10]
;;;722      lpcb->local_port = pcb->local_port;
000032  8ae0              LDRH     r0,[r4,#0x16]
000034  82e8              STRH     r0,[r5,#0x16]
;;;723      lpcb->state = LISTEN;
000036  2001              MOVS     r0,#1
000038  7528              STRB     r0,[r5,#0x14]
;;;724      lpcb->prio = pcb->prio;
00003a  7d60              LDRB     r0,[r4,#0x15]
00003c  7568              STRB     r0,[r5,#0x15]
;;;725      lpcb->so_options = pcb->so_options;
00003e  7a20              LDRB     r0,[r4,#8]
000040  7228              STRB     r0,[r5,#8]
;;;726      lpcb->ttl = pcb->ttl;
000042  7aa0              LDRB     r0,[r4,#0xa]
000044  72a8              STRB     r0,[r5,#0xa]
;;;727      lpcb->tos = pcb->tos;
000046  7a60              LDRB     r0,[r4,#9]
000048  7268              STRB     r0,[r5,#9]
;;;728    #if LWIP_IPV4 && LWIP_IPV6
;;;729      IP_SET_TYPE_VAL(lpcb->remote_ip, pcb->local_ip.type);
;;;730    #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;731      ip_addr_copy(lpcb->local_ip, pcb->local_ip);
00004a  6820              LDR      r0,[r4,#0]
00004c  6028              STR      r0,[r5,#0]
;;;732      if (pcb->local_port != 0) {
00004e  8ae0              LDRH     r0,[r4,#0x16]
000050  b1a0              CBZ      r0,|L22.124|
;;;733        TCP_RMV(&tcp_bound_pcbs, pcb);
000052  4932              LDR      r1,|L22.284|
000054  6908              LDR      r0,[r1,#0x10]  ; tcp_bound_pcbs
000056  42a0              CMP      r0,r4
000058  d10c              BNE      |L22.116|
00005a  68c0              LDR      r0,[r0,#0xc]
00005c  6108              STR      r0,[r1,#0x10]  ; tcp_bound_pcbs
00005e  e00b              B        |L22.120|
                  |L22.96|
000060  f04f30ff          MOV      r0,#0xffffffff        ;718
000064  e018              B        |L22.152|
                  |L22.102|
000066  68c1              LDR      r1,[r0,#0xc]
000068  42a1              CMP      r1,r4
00006a  d102              BNE      |L22.114|
00006c  68e1              LDR      r1,[r4,#0xc]
00006e  60c1              STR      r1,[r0,#0xc]
000070  e002              B        |L22.120|
                  |L22.114|
000072  4608              MOV      r0,r1
                  |L22.116|
000074  2800              CMP      r0,#0
000076  d1f6              BNE      |L22.102|
                  |L22.120|
000078  2000              MOVS     r0,#0
00007a  60e0              STR      r0,[r4,#0xc]
                  |L22.124|
;;;734      }
;;;735      memp_free(MEMP_TCP_PCB, pcb);
00007c  4621              MOV      r1,r4
00007e  2001              MOVS     r0,#1
000080  f7fffffe          BL       memp_free
;;;736    #if LWIP_CALLBACK_API
;;;737      lpcb->accept = tcp_accept_null;
000084  4826              LDR      r0,|L22.288|
000086  61a8              STR      r0,[r5,#0x18]
;;;738    #endif /* LWIP_CALLBACK_API */
;;;739    #if TCP_LISTEN_BACKLOG
;;;740      lpcb->accepts_pending = 0;
;;;741      tcp_backlog_set(lpcb, backlog);
;;;742    #endif /* TCP_LISTEN_BACKLOG */
;;;743      TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
000088  4824              LDR      r0,|L22.284|
00008a  3014              ADDS     r0,r0,#0x14
00008c  6801              LDR      r1,[r0,#0]  ; tcp_listen_pcbs
00008e  60e9              STR      r1,[r5,#0xc]
000090  6005              STR      r5,[r0,#0]  ; tcp_listen_pcbs
000092  f7fffffe          BL       tcp_timer_needed
;;;744      res = ERR_OK;
000096  2000              MOVS     r0,#0
                  |L22.152|
;;;745    done:
;;;746      if (err != NULL) {
000098  b106              CBZ      r6,|L22.156|
;;;747        *err = res;
00009a  7030              STRB     r0,[r6,#0]
                  |L22.156|
;;;748      }
;;;749      return (struct tcp_pcb *)lpcb;
00009c  4628              MOV      r0,r5
;;;750    }
00009e  bd70              POP      {r4-r6,pc}
;;;751    
                          ENDP

                  |L22.160|
0000a0  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
0000a4  6964646c
0000a8  65776172
0000ac  65735c54
0000b0  68697264
0000b4  5f506172
0000b8  74795c4c
0000bc  7749505c
0000c0  7372635c
0000c4  636f7265
0000c8  5c746370
0000cc  2e6300  
0000cf  00                DCB      0
                  |L22.208|
0000d0  7463705f          DCB      "tcp_listen: pcb already connected",0
0000d4  6c697374
0000d8  656e3a20
0000dc  70636220
0000e0  616c7265
0000e4  61647920
0000e8  636f6e6e
0000ec  65637465
0000f0  6400    
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L22.244|
0000f4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000f8  7274696f
0000fc  6e202225
000100  73222066
000104  61696c65
000108  64206174
00010c  206c696e
000110  65202564
000114  20696e20
000118  25730a00
                  |L22.284|
                          DCD      ||.data||
                  |L22.288|
                          DCD      tcp_accept_null

                          AREA ||i.tcp_netif_ip_addr_changed||, CODE, READONLY, ALIGN=2

                  tcp_netif_ip_addr_changed PROC
;;;2005   void
;;;2006   tcp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;2007   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2008     struct tcp_pcb_listen *lpcb, *next;
;;;2009   
;;;2010     if (!ip_addr_isany(old_addr)) {
000006  2c00              CMP      r4,#0
000008  d01e              BEQ      |L23.72|
00000a  6820              LDR      r0,[r4,#0]
00000c  2800              CMP      r0,#0
00000e  d01b              BEQ      |L23.72|
;;;2011       tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
000010  4e0e              LDR      r6,|L23.76|
000012  4620              MOV      r0,r4
000014  69b1              LDR      r1,[r6,#0x18]  ; tcp_active_pcbs
000016  f7fffffe          BL       tcp_netif_ip_addr_changed_pcblist
;;;2012       tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
00001a  4620              MOV      r0,r4
00001c  6931              LDR      r1,[r6,#0x10]  ; tcp_bound_pcbs
00001e  f7fffffe          BL       tcp_netif_ip_addr_changed_pcblist
;;;2013   
;;;2014       if (!ip_addr_isany(new_addr)) {
000022  2d00              CMP      r5,#0
000024  d010              BEQ      |L23.72|
000026  6828              LDR      r0,[r5,#0]
000028  2800              CMP      r0,#0
00002a  d00d              BEQ      |L23.72|
;;;2015         /* PCB bound to current local interface address? */
;;;2016         for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = next) {
00002c  f1060014          ADD      r0,r6,#0x14
000030  6802              LDR      r2,[r0,#0]  ; tcp_listen_pcbs
000032  e007              B        |L23.68|
                  |L23.52|
;;;2017           next = lpcb->next;
000034  68d0              LDR      r0,[r2,#0xc]
;;;2018           /* PCB bound to current local interface address? */
;;;2019           if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
000036  6811              LDR      r1,[r2,#0]
000038  6823              LDR      r3,[r4,#0]
00003a  4299              CMP      r1,r3
00003c  d101              BNE      |L23.66|
;;;2020             /* The PCB is listening to the old ipaddr and
;;;2021               * is set to listen to the new one instead */
;;;2022             ip_addr_copy(lpcb->local_ip, *new_addr);
00003e  6829              LDR      r1,[r5,#0]
000040  6011              STR      r1,[r2,#0]
                  |L23.66|
000042  4602              MOV      r2,r0                 ;2016
                  |L23.68|
000044  2a00              CMP      r2,#0                 ;2016
000046  d1f5              BNE      |L23.52|
                  |L23.72|
;;;2023           }
;;;2024         }
;;;2025       }
;;;2026     }
;;;2027   }
000048  bd70              POP      {r4-r6,pc}
;;;2028   
                          ENDP

00004a  0000              DCW      0x0000
                  |L23.76|
                          DCD      ||.data||

                          AREA ||i.tcp_netif_ip_addr_changed_pcblist||, CODE, READONLY, ALIGN=1

                  tcp_netif_ip_addr_changed_pcblist PROC
;;;1976   static void
;;;1977   tcp_netif_ip_addr_changed_pcblist(const ip_addr_t* old_addr, struct tcp_pcb* pcb_list)
000000  b570              PUSH     {r4-r6,lr}
;;;1978   {
000002  4605              MOV      r5,r0
000004  4608              MOV      r0,r1
;;;1979     struct tcp_pcb *pcb;
;;;1980     pcb = pcb_list;
;;;1981     while (pcb != NULL) {
;;;1982       /* PCB bound to current local interface address? */
;;;1983       if (ip_addr_cmp(&pcb->local_ip, old_addr)
;;;1984   #if LWIP_AUTOIP
;;;1985         /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
;;;1986         && (!IP_IS_V4_VAL(pcb->local_ip) || !ip4_addr_islinklocal(ip_2_ip4(&pcb->local_ip)))
;;;1987   #endif /* LWIP_AUTOIP */
;;;1988         ) {
;;;1989         /* this connection must be aborted */
;;;1990         struct tcp_pcb *next = pcb->next;
;;;1991         LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
;;;1992         tcp_abort(pcb);
;;;1993         pcb = next;
;;;1994       } else {
;;;1995         pcb = pcb->next;
000006  e009              B        |L24.28|
                  |L24.8|
000008  6801              LDR      r1,[r0,#0]            ;1983
00000a  682a              LDR      r2,[r5,#0]            ;1983
00000c  4291              CMP      r1,r2                 ;1983
00000e  d104              BNE      |L24.26|
000010  68c4              LDR      r4,[r0,#0xc]          ;1990
000012  f7fffffe          BL       tcp_abort
000016  4620              MOV      r0,r4                 ;1993
000018  e000              B        |L24.28|
                  |L24.26|
00001a  68c0              LDR      r0,[r0,#0xc]
                  |L24.28|
00001c  2800              CMP      r0,#0                 ;1981
00001e  d1f3              BNE      |L24.8|
;;;1996       }
;;;1997     }
;;;1998   }
000020  bd70              POP      {r4-r6,pc}
;;;1999   
                          ENDP


                          AREA ||i.tcp_new||, CODE, READONLY, ALIGN=1

                  tcp_new PROC
;;;1659   struct tcp_pcb *
;;;1660   tcp_new(void)
000000  2040              MOVS     r0,#0x40
;;;1661   {
;;;1662     return tcp_alloc(TCP_PRIO_NORMAL);
000002  f7ffbffe          B.W      tcp_alloc
;;;1663   }
;;;1664   
                          ENDP


                          AREA ||i.tcp_new_ip_type||, CODE, READONLY, ALIGN=1

                  tcp_new_ip_type PROC
;;;1676   struct tcp_pcb *
;;;1677   tcp_new_ip_type(u8_t type)
000000  2040              MOVS     r0,#0x40
;;;1678   {
;;;1679     struct tcp_pcb * pcb;
;;;1680     pcb = tcp_alloc(TCP_PRIO_NORMAL);
000002  f7ffbffe          B.W      tcp_alloc
;;;1681   #if LWIP_IPV4 && LWIP_IPV6
;;;1682     if (pcb != NULL) {
;;;1683       IP_SET_TYPE_VAL(pcb->local_ip, type);
;;;1684       IP_SET_TYPE_VAL(pcb->remote_ip, type);
;;;1685     }
;;;1686   #else
;;;1687     LWIP_UNUSED_ARG(type);
;;;1688   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1689     return pcb;
;;;1690   }
;;;1691   
                          ENDP


                          AREA ||i.tcp_new_port||, CODE, READONLY, ALIGN=2

                  tcp_new_port PROC
;;;837    static u16_t
;;;838    tcp_new_port(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;839    {
;;;840      u8_t i;
;;;841      u16_t n = 0;
000002  2400              MOVS     r4,#0
;;;842      struct tcp_pcb *pcb;
;;;843    
;;;844    again:
;;;845      if (tcp_port++ == TCP_LOCAL_PORT_RANGE_END) {
;;;846        tcp_port = TCP_LOCAL_PORT_RANGE_START;
;;;847      }
;;;848      /* Check all PCB lists. */
;;;849      for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
;;;850        for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
000004  4e12              LDR      r6,|L27.80|
000006  4d13              LDR      r5,|L27.84|
000008  f64f77ff          MOV      r7,#0xffff            ;845
                  |L27.12|
00000c  88a8              LDRH     r0,[r5,#4]            ;845  ; tcp_port
00000e  1c41              ADDS     r1,r0,#1              ;845
000010  80a9              STRH     r1,[r5,#4]            ;845
000012  42b8              CMP      r0,r7                 ;845
000014  d102              BNE      |L27.28|
000016  f44f4040          MOV      r0,#0xc000            ;846
00001a  80a8              STRH     r0,[r5,#4]            ;846
                  |L27.28|
00001c  2100              MOVS     r1,#0                 ;849
00001e  88aa              LDRH     r2,[r5,#4]            ;845
                  |L27.32|
000020  f8560021          LDR      r0,[r6,r1,LSL #2]
000024  6800              LDR      r0,[r0,#0]
000026  e00a              B        |L27.62|
                  |L27.40|
;;;851          if (pcb->local_port == tcp_port) {
000028  8ac3              LDRH     r3,[r0,#0x16]
00002a  4293              CMP      r3,r2
00002c  d106              BNE      |L27.60|
;;;852            if (++n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
00002e  1c64              ADDS     r4,r4,#1
000030  b2a4              UXTH     r4,r4
000032  f5b44f80          CMP      r4,#0x4000
000036  d3e9              BCC      |L27.12|
;;;853              return 0;
000038  2000              MOVS     r0,#0
;;;854            }
;;;855            goto again;
;;;856          }
;;;857        }
;;;858      }
;;;859      return tcp_port;
;;;860    }
00003a  bdf0              POP      {r4-r7,pc}
                  |L27.60|
00003c  68c0              LDR      r0,[r0,#0xc]          ;850
                  |L27.62|
00003e  2800              CMP      r0,#0                 ;850
000040  d1f2              BNE      |L27.40|
000042  1c49              ADDS     r1,r1,#1              ;849
000044  b2c9              UXTB     r1,r1                 ;849
000046  2904              CMP      r1,#4                 ;849
000048  d3ea              BCC      |L27.32|
00004a  88a8              LDRH     r0,[r5,#4]            ;859  ; tcp_port
00004c  bdf0              POP      {r4-r7,pc}
;;;861    
                          ENDP

00004e  0000              DCW      0x0000
                  |L27.80|
                          DCD      ||.constdata||+0x44
                  |L27.84|
                          DCD      ||.data||

                          AREA ||i.tcp_next_iss||, CODE, READONLY, ALIGN=2

                  tcp_next_iss PROC
;;;1894   u32_t
;;;1895   tcp_next_iss(struct tcp_pcb *pcb)
000000  4902              LDR      r1,|L28.12|
;;;1896   {
;;;1897   #ifdef LWIP_HOOK_TCP_ISN
;;;1898     return LWIP_HOOK_TCP_ISN(&pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
;;;1899   #else /* LWIP_HOOK_TCP_ISN */
;;;1900     static u32_t iss = 6510;
;;;1901   
;;;1902     LWIP_UNUSED_ARG(pcb);
;;;1903   
;;;1904     iss += tcp_ticks;       /* XXX */
000002  e9d10202          LDRD     r0,r2,[r1,#8]
000006  4410              ADD      r0,r0,r2
000008  6088              STR      r0,[r1,#8]  ; iss
;;;1905     return iss;
;;;1906   #endif /* LWIP_HOOK_TCP_ISN */
;;;1907   }
00000a  4770              BX       lr
;;;1908   
                          ENDP

                  |L28.12|
                          DCD      ||.data||

                          AREA ||i.tcp_pcb_purge||, CODE, READONLY, ALIGN=1

                  tcp_pcb_purge PROC
;;;1810   void
;;;1811   tcp_pcb_purge(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1812   {
000002  4604              MOV      r4,r0
;;;1813     if (pcb->state != CLOSED &&
000004  7d20              LDRB     r0,[r4,#0x14]
000006  2800              CMP      r0,#0
000008  d01a              BEQ      |L29.64|
;;;1814        pcb->state != TIME_WAIT &&
00000a  280a              CMP      r0,#0xa
00000c  d018              BEQ      |L29.64|
;;;1815        pcb->state != LISTEN) {
00000e  2801              CMP      r0,#1
000010  d016              BEQ      |L29.64|
;;;1816   
;;;1817       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
;;;1818   
;;;1819       tcp_backlog_accepted(pcb);
;;;1820   
;;;1821       if (pcb->refused_data != NULL) {
000012  6f60              LDR      r0,[r4,#0x74]
000014  2500              MOVS     r5,#0
000016  b110              CBZ      r0,|L29.30|
;;;1822         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
;;;1823         pbuf_free(pcb->refused_data);
000018  f7fffffe          BL       pbuf_free
;;;1824         pcb->refused_data = NULL;
00001c  6765              STR      r5,[r4,#0x74]
                  |L29.30|
;;;1825       }
;;;1826       if (pcb->unsent != NULL) {
;;;1827         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
;;;1828       }
;;;1829       if (pcb->unacked != NULL) {
;;;1830         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
;;;1831       }
;;;1832   #if TCP_QUEUE_OOSEQ
;;;1833       if (pcb->ooseq != NULL) {
;;;1834         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
;;;1835       }
;;;1836       tcp_segs_free(pcb->ooseq);
00001e  6f20              LDR      r0,[r4,#0x70]
000020  f7fffffe          BL       tcp_segs_free
;;;1837       pcb->ooseq = NULL;
000024  6725              STR      r5,[r4,#0x70]
;;;1838   #endif /* TCP_QUEUE_OOSEQ */
;;;1839   
;;;1840       /* Stop the retransmission timer as it will expect data on unacked
;;;1841          queue if it fires */
;;;1842       pcb->rtime = -1;
000026  f04f30ff          MOV      r0,#0xffffffff
00002a  8620              STRH     r0,[r4,#0x30]
;;;1843   
;;;1844       tcp_segs_free(pcb->unsent);
00002c  6ea0              LDR      r0,[r4,#0x68]
00002e  f7fffffe          BL       tcp_segs_free
;;;1845       tcp_segs_free(pcb->unacked);
000032  6ee0              LDR      r0,[r4,#0x6c]
000034  f7fffffe          BL       tcp_segs_free
;;;1846       pcb->unacked = pcb->unsent = NULL;
000038  66a5              STR      r5,[r4,#0x68]
00003a  66e5              STR      r5,[r4,#0x6c]
;;;1847   #if TCP_OVERSIZE
;;;1848       pcb->unsent_oversize = 0;
00003c  f8a45064          STRH     r5,[r4,#0x64]
                  |L29.64|
;;;1849   #endif /* TCP_OVERSIZE */
;;;1850     }
;;;1851   }
000040  bd70              POP      {r4-r6,pc}
;;;1852   
                          ENDP


                          AREA ||i.tcp_pcb_remove||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_pcb_remove PROC
;;;1859   void
;;;1860   tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1861   {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;1862     TCP_RMV(pcblist, pcb);
000006  6810              LDR      r0,[r2,#0]
000008  42a0              CMP      r0,r4
00000a  d109              BNE      |L30.32|
00000c  68c0              LDR      r0,[r0,#0xc]
00000e  6010              STR      r0,[r2,#0]
000010  e008              B        |L30.36|
                  |L30.18|
000012  68c1              LDR      r1,[r0,#0xc]
000014  42a1              CMP      r1,r4
000016  d102              BNE      |L30.30|
000018  68e1              LDR      r1,[r4,#0xc]
00001a  60c1              STR      r1,[r0,#0xc]
00001c  e002              B        |L30.36|
                  |L30.30|
00001e  4608              MOV      r0,r1
                  |L30.32|
000020  2800              CMP      r0,#0
000022  d1f6              BNE      |L30.18|
                  |L30.36|
000024  2500              MOVS     r5,#0
000026  60e5              STR      r5,[r4,#0xc]
;;;1863   
;;;1864     tcp_pcb_purge(pcb);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       tcp_pcb_purge
;;;1865   
;;;1866     /* if there is an outstanding delayed ACKs, send it */
;;;1867     if (pcb->state != TIME_WAIT &&
00002e  7d20              LDRB     r0,[r4,#0x14]
000030  280a              CMP      r0,#0xa
000032  d00a              BEQ      |L30.74|
;;;1868        pcb->state != LISTEN &&
000034  2801              CMP      r0,#1
000036  d008              BEQ      |L30.74|
;;;1869        pcb->flags & TF_ACK_DELAY) {
000038  7ea0              LDRB     r0,[r4,#0x1a]
00003a  07c1              LSLS     r1,r0,#31
00003c  d005              BEQ      |L30.74|
;;;1870       pcb->flags |= TF_ACK_NOW;
00003e  f0400002          ORR      r0,r0,#2
000042  76a0              STRB     r0,[r4,#0x1a]
;;;1871       tcp_output(pcb);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       tcp_output
                  |L30.74|
;;;1872     }
;;;1873   
;;;1874     if (pcb->state != LISTEN) {
00004a  7d20              LDRB     r0,[r4,#0x14]
00004c  2801              CMP      r0,#1
00004e  d01a              BEQ      |L30.134|
;;;1875       LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
000050  6ea0              LDR      r0,[r4,#0x68]
000052  b130              CBZ      r0,|L30.98|
000054  a30d              ADR      r3,|L30.140|
000056  f2407253          MOV      r2,#0x753
00005a  a118              ADR      r1,|L30.188|
00005c  a01d              ADR      r0,|L30.212|
00005e  f7fffffe          BL       __2printf
                  |L30.98|
;;;1876       LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
000062  6ee0              LDR      r0,[r4,#0x6c]
000064  b130              CBZ      r0,|L30.116|
000066  a309              ADR      r3,|L30.140|
000068  f2407254          MOV      r2,#0x754
00006c  a123              ADR      r1,|L30.252|
00006e  a019              ADR      r0,|L30.212|
000070  f7fffffe          BL       __2printf
                  |L30.116|
;;;1877   #if TCP_QUEUE_OOSEQ
;;;1878       LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
000074  6f20              LDR      r0,[r4,#0x70]
000076  b130              CBZ      r0,|L30.134|
000078  a304              ADR      r3,|L30.140|
00007a  f2407256          MOV      r2,#0x756
00007e  a126              ADR      r1,|L30.280|
000080  a014              ADR      r0,|L30.212|
000082  f7fffffe          BL       __2printf
                  |L30.134|
;;;1879   #endif /* TCP_QUEUE_OOSEQ */
;;;1880     }
;;;1881   
;;;1882     pcb->state = CLOSED;
000086  7525              STRB     r5,[r4,#0x14]
;;;1883     /* reset the local port to prevent the pcb from being 'bound' */
;;;1884     pcb->local_port = 0;
000088  82e5              STRH     r5,[r4,#0x16]
;;;1885   
;;;1886     LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;1887   }
00008a  bd70              POP      {r4-r6,pc}
;;;1888   
                          ENDP

                  |L30.140|
00008c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000090  6964646c
000094  65776172
000098  65735c54
00009c  68697264
0000a0  5f506172
0000a4  74795c4c
0000a8  7749505c
0000ac  7372635c
0000b0  636f7265
0000b4  5c746370
0000b8  2e6300  
0000bb  00                DCB      0
                  |L30.188|
0000bc  756e7365          DCB      "unsent segments leaking",0
0000c0  6e742073
0000c4  65676d65
0000c8  6e747320
0000cc  6c65616b
0000d0  696e6700
                  |L30.212|
0000d4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000d8  7274696f
0000dc  6e202225
0000e0  73222066
0000e4  61696c65
0000e8  64206174
0000ec  206c696e
0000f0  65202564
0000f4  20696e20
0000f8  25730a00
                  |L30.252|
0000fc  756e6163          DCB      "unacked segments leaking",0
000100  6b656420
000104  7365676d
000108  656e7473
00010c  206c6561
000110  6b696e67
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L30.280|
000118  6f6f7365          DCB      "ooseq segments leaking",0
00011c  71207365
000120  676d656e
000124  7473206c
000128  65616b69
00012c  6e6700  
00012f  00                DCB      0

                          AREA ||i.tcp_poll||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_poll PROC
;;;1792   void
;;;1793   tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
000000  b570              PUSH     {r4-r6,lr}
;;;1794   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;1795     LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
000008  7d20              LDRB     r0,[r4,#0x14]
00000a  2801              CMP      r0,#1
00000c  d106              BNE      |L31.28|
00000e  a305              ADR      r3,|L31.36|
000010  f2407203          MOV      r2,#0x703
000014  a10f              ADR      r1,|L31.84|
000016  a017              ADR      r0,|L31.116|
000018  f7fffffe          BL       __2printf
                  |L31.28|
;;;1796   #if LWIP_CALLBACK_API
;;;1797     pcb->poll = poll;
00001c  f8c45088          STR      r5,[r4,#0x88]
;;;1798   #else /* LWIP_CALLBACK_API */
;;;1799     LWIP_UNUSED_ARG(poll);
;;;1800   #endif /* LWIP_CALLBACK_API */
;;;1801     pcb->pollinterval = interval;
000020  7726              STRB     r6,[r4,#0x1c]
;;;1802   }
000022  bd70              POP      {r4-r6,pc}
;;;1803   
                          ENDP

                  |L31.36|
000024  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000028  6964646c
00002c  65776172
000030  65735c54
000034  68697264
000038  5f506172
00003c  74795c4c
000040  7749505c
000044  7372635c
000048  636f7265
00004c  5c746370
000050  2e6300  
000053  00                DCB      0
                  |L31.84|
000054  696e7661          DCB      "invalid socket state for poll",0
000058  6c696420
00005c  736f636b
000060  65742073
000064  74617465
000068  20666f72
00006c  20706f6c
000070  6c00    
000072  00                DCB      0
000073  00                DCB      0
                  |L31.116|
000074  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000078  7274696f
00007c  6e202225
000080  73222066
000084  61696c65
000088  64206174
00008c  206c696e
000090  65202564
000094  20696e20
000098  25730a00

                          AREA ||i.tcp_process_refused_data||, CODE, READONLY, ALIGN=1

                  tcp_process_refused_data PROC
;;;1310   err_t
;;;1311   tcp_process_refused_data(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1312   {
000004  4604              MOV      r4,r0
;;;1313   #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;1314     struct pbuf *rest;
;;;1315     while (pcb->refused_data != NULL)
;;;1316   #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;1317     {
;;;1318       err_t err;
;;;1319       u8_t refused_flags = pcb->refused_data->flags;
000006  6f65              LDR      r5,[r4,#0x74]
000008  7b6f              LDRB     r7,[r5,#0xd]
;;;1320       /* set pcb->refused_data to NULL in case the callback frees it and then
;;;1321          closes the pcb */
;;;1322       struct pbuf *refused_data = pcb->refused_data;
;;;1323   #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;1324       pbuf_split_64k(refused_data, &rest);
;;;1325       pcb->refused_data = rest;
;;;1326   #else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;1327       pcb->refused_data = NULL;
00000a  2000              MOVS     r0,#0
00000c  6760              STR      r0,[r4,#0x74]
;;;1328   #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;1329       /* Notify again application with data previously received. */
;;;1330       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
;;;1331       TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
00000e  f8d46080          LDR      r6,[r4,#0x80]
000012  2e00              CMP      r6,#0
000014  d005              BEQ      |L32.34|
000016  2300              MOVS     r3,#0
000018  462a              MOV      r2,r5
00001a  4621              MOV      r1,r4
00001c  6920              LDR      r0,[r4,#0x10]
00001e  47b0              BLX      r6
000020  e005              B        |L32.46|
                  |L32.34|
000022  2300              MOVS     r3,#0
000024  462a              MOV      r2,r5
000026  4621              MOV      r1,r4
000028  4618              MOV      r0,r3
00002a  f7fffffe          BL       tcp_recv_null
                  |L32.46|
;;;1332       if (err == ERR_OK) {
;;;1333         /* did refused_data include a FIN? */
;;;1334         if (refused_flags & PBUF_FLAG_TCP_FIN
;;;1335   #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;1336             && (rest == NULL)
;;;1337   #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;1338            ) {
;;;1339           /* correct rcv_wnd as the application won't call tcp_recved()
;;;1340              for the FIN's seqno */
;;;1341           if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
;;;1342             pcb->rcv_wnd++;
;;;1343           }
;;;1344           TCP_EVENT_CLOSED(pcb, err);
;;;1345           if (err == ERR_ABRT) {
00002e  f06f060c          MVN      r6,#0xc
000032  b130              CBZ      r0,|L32.66|
;;;1346             return ERR_ABRT;
;;;1347           }
;;;1348         }
;;;1349       } else if (err == ERR_ABRT) {
000034  300d              ADDS     r0,r0,#0xd
000036  d01a              BEQ      |L32.110|
;;;1350         /* if err == ERR_ABRT, 'pcb' is already deallocated */
;;;1351         /* Drop incoming packets because pcb is "full" (only if the incoming
;;;1352            segment contains data). */
;;;1353         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
;;;1354         return ERR_ABRT;
;;;1355       } else {
;;;1356         /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
;;;1357   #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;1358         if (rest != NULL) {
;;;1359           pbuf_cat(refused_data, rest);
;;;1360         }
;;;1361   #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;1362         pcb->refused_data = refused_data;
000038  6765              STR      r5,[r4,#0x74]
;;;1363         return ERR_INPROGRESS;
00003a  f06f0004          MVN      r0,#4
                  |L32.62|
;;;1364       }
;;;1365     }
;;;1366     return ERR_OK;
;;;1367   }
00003e  e8bd81f0          POP      {r4-r8,pc}
                  |L32.66|
000042  06b9              LSLS     r1,r7,#26             ;1334
000044  d50f              BPL      |L32.102|
000046  8d21              LDRH     r1,[r4,#0x28]         ;1341
000048  f5b16f06          CMP      r1,#0x860             ;1341
00004c  d001              BEQ      |L32.82|
00004e  1c49              ADDS     r1,r1,#1              ;1342
000050  8521              STRH     r1,[r4,#0x28]         ;1342
                  |L32.82|
000052  f8d45080          LDR      r5,[r4,#0x80]         ;1344
000056  b125              CBZ      r5,|L32.98|
000058  2300              MOVS     r3,#0                 ;1344
00005a  461a              MOV      r2,r3                 ;1344
00005c  4621              MOV      r1,r4                 ;1344
00005e  6920              LDR      r0,[r4,#0x10]         ;1344
000060  47a8              BLX      r5                    ;1344
                  |L32.98|
000062  300d              ADDS     r0,r0,#0xd            ;1345
000064  d001              BEQ      |L32.106|
                  |L32.102|
000066  2000              MOVS     r0,#0                 ;1366
000068  e7e9              B        |L32.62|
                  |L32.106|
00006a  4630              MOV      r0,r6                 ;1346
00006c  e7e7              B        |L32.62|
                  |L32.110|
00006e  4630              MOV      r0,r6                 ;1354
000070  e7e5              B        |L32.62|
;;;1368   
                          ENDP


                          AREA ||i.tcp_recv||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_recv PROC
;;;1719   void
;;;1720   tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
000000  b570              PUSH     {r4-r6,lr}
;;;1721   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1722     if (pcb != NULL) {
000006  2c00              CMP      r4,#0
000008  d00b              BEQ      |L33.34|
;;;1723       LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
00000a  7d20              LDRB     r0,[r4,#0x14]
00000c  2801              CMP      r0,#1
00000e  d106              BNE      |L33.30|
000010  a304              ADR      r3,|L33.36|
000012  f24062bb          MOV      r2,#0x6bb
000016  a10f              ADR      r1,|L33.84|
000018  a018              ADR      r0,|L33.124|
00001a  f7fffffe          BL       __2printf
                  |L33.30|
;;;1724       pcb->recv = recv;
00001e  f8c45080          STR      r5,[r4,#0x80]
                  |L33.34|
;;;1725     }
;;;1726   }
000022  bd70              POP      {r4-r6,pc}
;;;1727   
                          ENDP

                  |L33.36|
000024  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000028  6964646c
00002c  65776172
000030  65735c54
000034  68697264
000038  5f506172
00003c  74795c4c
000040  7749505c
000044  7372635c
000048  636f7265
00004c  5c746370
000050  2e6300  
000053  00                DCB      0
                  |L33.84|
000054  696e7661          DCB      "invalid socket state for recv callback",0
000058  6c696420
00005c  736f636b
000060  65742073
000064  74617465
000068  20666f72
00006c  20726563
000070  76206361
000074  6c6c6261
000078  636b00  
00007b  00                DCB      0
                  |L33.124|
00007c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000080  7274696f
000084  6e202225
000088  73222066
00008c  61696c65
000090  64206174
000094  206c696e
000098  65202564
00009c  20696e20
0000a0  25730a00

                          AREA ||i.tcp_recv_null||, CODE, READONLY, ALIGN=1

                  tcp_recv_null PROC
;;;1443   err_t
;;;1444   tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000000  b510              PUSH     {r4,lr}
;;;1445   {
000002  4608              MOV      r0,r1
000004  4614              MOV      r4,r2
;;;1446     LWIP_UNUSED_ARG(arg);
;;;1447     if (p != NULL) {
000006  2c00              CMP      r4,#0
000008  d006              BEQ      |L34.24|
;;;1448       tcp_recved(pcb, p->tot_len);
00000a  8921              LDRH     r1,[r4,#8]
00000c  f7fffffe          BL       tcp_recved
;;;1449       pbuf_free(p);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       pbuf_free
000016  e000              B        |L34.26|
                  |L34.24|
;;;1450     } else if (err == ERR_OK) {
000018  b10b              CBZ      r3,|L34.30|
                  |L34.26|
;;;1451       return tcp_close(pcb);
;;;1452     }
;;;1453     return ERR_OK;
00001a  2000              MOVS     r0,#0
;;;1454   }
00001c  bd10              POP      {r4,pc}
                  |L34.30|
00001e  e8bd4010          POP      {r4,lr}               ;1451
000022  f7ffbffe          B.W      tcp_close
;;;1455   #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_recved||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_recved PROC
;;;793    void
;;;794    tcp_recved(struct tcp_pcb *pcb, u16_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;795    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;796      int wnd_inflation;
;;;797    
;;;798      /* pcb->state LISTEN not allowed here */
;;;799      LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
000006  7d20              LDRB     r0,[r4,#0x14]
000008  2801              CMP      r0,#1
00000a  d106              BNE      |L35.26|
00000c  a318              ADR      r3,|L35.112|
00000e  f240321f          MOV      r2,#0x31f
000012  a123              ADR      r1,|L35.160|
000014  a02c              ADR      r0,|L35.200|
000016  f7fffffe          BL       __2printf
                  |L35.26|
;;;800        pcb->state != LISTEN);
;;;801    
;;;802      pcb->rcv_wnd += len;
00001a  8d20              LDRH     r0,[r4,#0x28]
00001c  4428              ADD      r0,r0,r5
00001e  b280              UXTH     r0,r0
000020  8520              STRH     r0,[r4,#0x28]
;;;803      if (pcb->rcv_wnd > TCP_WND_MAX(pcb)) {
000022  f44f6106          MOV      r1,#0x860
000026  4288              CMP      r0,r1
000028  d901              BLS      |L35.46|
;;;804        pcb->rcv_wnd = TCP_WND_MAX(pcb);
00002a  8521              STRH     r1,[r4,#0x28]
00002c  e00d              B        |L35.74|
                  |L35.46|
;;;805      } else if (pcb->rcv_wnd == 0) {
00002e  2800              CMP      r0,#0
000030  d10b              BNE      |L35.74|
;;;806        /* rcv_wnd overflowed */
;;;807        if ((pcb->state == CLOSE_WAIT) || (pcb->state == LAST_ACK)) {
000032  7d20              LDRB     r0,[r4,#0x14]
000034  2807              CMP      r0,#7
000036  d017              BEQ      |L35.104|
000038  2809              CMP      r0,#9
00003a  d015              BEQ      |L35.104|
;;;808          /* In passive close, we allow this, since the FIN bit is added to rcv_wnd
;;;809             by the stack itself, since it is not mandatory for an application
;;;810             to call tcp_recved() for the FIN bit, but e.g. the netconn API does so. */
;;;811          pcb->rcv_wnd = TCP_WND_MAX(pcb);
;;;812        } else {
;;;813          LWIP_ASSERT("tcp_recved: len wrapped rcv_wnd\n", 0);
00003c  a30c              ADR      r3,|L35.112|
00003e  f240322d          MOV      r2,#0x32d
000042  a12b              ADR      r1,|L35.240|
000044  a020              ADR      r0,|L35.200|
000046  f7fffffe          BL       __2printf
                  |L35.74|
;;;814        }
;;;815      }
;;;816    
;;;817      wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;818    
;;;819      /* If the change in the right edge of window is significant (default
;;;820       * watermark is TCP_WND/4), then send an explicit update now.
;;;821       * Otherwise wait for a packet to be sent in the normal course of
;;;822       * events (or more window to be available later) */
;;;823      if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
000050  f5b07f06          CMP      r0,#0x218
000054  db0a              BLT      |L35.108|
;;;824        tcp_ack_now(pcb);
000056  7ea0              LDRB     r0,[r4,#0x1a]
000058  f0400002          ORR      r0,r0,#2
00005c  76a0              STRB     r0,[r4,#0x1a]
;;;825        tcp_output(pcb);
00005e  4620              MOV      r0,r4
000060  e8bd4070          POP      {r4-r6,lr}
000064  f7ffbffe          B.W      tcp_output
                  |L35.104|
000068  8521              STRH     r1,[r4,#0x28]         ;811
00006a  e7ee              B        |L35.74|
                  |L35.108|
;;;826      }
;;;827    
;;;828      LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: received %"U16_F" bytes, wnd %"TCPWNDSIZE_F" (%"TCPWNDSIZE_F").\n",
;;;829             len, pcb->rcv_wnd, (u16_t)(TCP_WND_MAX(pcb) - pcb->rcv_wnd)));
;;;830    }
00006c  bd70              POP      {r4-r6,pc}
;;;831    
                          ENDP

00006e  0000              DCW      0x0000
                  |L35.112|
000070  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000074  6964646c
000078  65776172
00007c  65735c54
000080  68697264
000084  5f506172
000088  74795c4c
00008c  7749505c
000090  7372635c
000094  636f7265
000098  5c746370
00009c  2e6300  
00009f  00                DCB      0
                  |L35.160|
0000a0  646f6e27          DCB      "don't call tcp_recved for listen-pcbs",0
0000a4  74206361
0000a8  6c6c2074
0000ac  63705f72
0000b0  65637665
0000b4  6420666f
0000b8  72206c69
0000bc  7374656e
0000c0  2d706362
0000c4  7300    
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L35.200|
0000c8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000cc  7274696f
0000d0  6e202225
0000d4  73222066
0000d8  61696c65
0000dc  64206174
0000e0  206c696e
0000e4  65202564
0000e8  20696e20
0000ec  25730a00
                  |L35.240|
0000f0  7463705f          DCB      "tcp_recved: len wrapped rcv_wnd\n",0
0000f4  72656376
0000f8  65643a20
0000fc  6c656e20
000100  77726170
000104  70656420
000108  7263765f
00010c  776e640a
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0

                          AREA ||i.tcp_remove_listener||, CODE, READONLY, ALIGN=1

                  tcp_remove_listener PROC
;;;172    static void
;;;173    tcp_remove_listener(struct tcp_pcb *list, struct tcp_pcb_listen *lpcb)
000000  2200              MOVS     r2,#0
;;;174    {
000002  e004              B        |L36.14|
                  |L36.4|
;;;175       struct tcp_pcb *pcb;
;;;176       for (pcb = list; pcb != NULL; pcb = pcb->next) {
;;;177          if (pcb->listener == lpcb) {
000004  6f83              LDR      r3,[r0,#0x78]
000006  428b              CMP      r3,r1
000008  d100              BNE      |L36.12|
;;;178             pcb->listener = NULL;
00000a  6782              STR      r2,[r0,#0x78]
                  |L36.12|
00000c  68c0              LDR      r0,[r0,#0xc]          ;176
                  |L36.14|
00000e  2800              CMP      r0,#0                 ;176
000010  d1f8              BNE      |L36.4|
;;;179          }
;;;180       }
;;;181    }
000012  4770              BX       lr
;;;182    #endif
                          ENDP


                          AREA ||i.tcp_seg_copy||, CODE, READONLY, ALIGN=1

                  tcp_seg_copy PROC
;;;1423   struct tcp_seg *
;;;1424   tcp_seg_copy(struct tcp_seg *seg)
000000  b570              PUSH     {r4-r6,lr}
;;;1425   {
000002  4604              MOV      r4,r0
;;;1426     struct tcp_seg *cseg;
;;;1427   
;;;1428     cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
000004  2003              MOVS     r0,#3
000006  f7fffffe          BL       memp_malloc
00000a  4605              MOV      r5,r0
;;;1429     if (cseg == NULL) {
00000c  b14d              CBZ      r5,|L37.34|
;;;1430       return NULL;
;;;1431     }
;;;1432     SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
00000e  1d20              ADDS     r0,r4,#4
000010  6822              LDR      r2,[r4,#0]
000012  c80b              LDM      r0,{r0,r1,r3}
000014  1d2c              ADDS     r4,r5,#4
000016  c40b              STM      r4!,{r0,r1,r3}
000018  602a              STR      r2,[r5,#0]
;;;1433     pbuf_ref(cseg->p);
00001a  f7fffffe          BL       pbuf_ref
;;;1434     return cseg;
00001e  4628              MOV      r0,r5
;;;1435   }
000020  bd70              POP      {r4-r6,pc}
                  |L37.34|
000022  2000              MOVS     r0,#0                 ;1430
000024  bd70              POP      {r4-r6,pc}
;;;1436   #endif /* TCP_QUEUE_OOSEQ */
                          ENDP


                          AREA ||i.tcp_seg_free||, CODE, READONLY, ALIGN=1

                  tcp_seg_free PROC
;;;1389   void
;;;1390   tcp_seg_free(struct tcp_seg *seg)
000000  b510              PUSH     {r4,lr}
;;;1391   {
000002  4604              MOV      r4,r0
;;;1392     if (seg != NULL) {
000004  2c00              CMP      r4,#0
000006  d009              BEQ      |L38.28|
;;;1393       if (seg->p != NULL) {
000008  6860              LDR      r0,[r4,#4]
00000a  b108              CBZ      r0,|L38.16|
;;;1394         pbuf_free(seg->p);
00000c  f7fffffe          BL       pbuf_free
                  |L38.16|
;;;1395   #if TCP_DEBUG
;;;1396         seg->p = NULL;
;;;1397   #endif /* TCP_DEBUG */
;;;1398       }
;;;1399       memp_free(MEMP_TCP_SEG, seg);
000010  4621              MOV      r1,r4
000012  e8bd4010          POP      {r4,lr}
000016  2003              MOVS     r0,#3
000018  f7ffbffe          B.W      memp_free
                  |L38.28|
;;;1400     }
;;;1401   }
00001c  bd10              POP      {r4,pc}
;;;1402   
                          ENDP


                          AREA ||i.tcp_segs_free||, CODE, READONLY, ALIGN=1

                  tcp_segs_free PROC
;;;1374   void
;;;1375   tcp_segs_free(struct tcp_seg *seg)
000000  b510              PUSH     {r4,lr}
;;;1376   {
;;;1377     while (seg != NULL) {
;;;1378       struct tcp_seg *next = seg->next;
;;;1379       tcp_seg_free(seg);
;;;1380       seg = next;
;;;1381     }
000002  e003              B        |L39.12|
                  |L39.4|
000004  6804              LDR      r4,[r0,#0]            ;1378
000006  f7fffffe          BL       tcp_seg_free
00000a  4620              MOV      r0,r4                 ;1380
                  |L39.12|
00000c  2800              CMP      r0,#0                 ;1377
00000e  d1f9              BNE      |L39.4|
;;;1382   }
000010  bd10              POP      {r4,pc}
;;;1383   
                          ENDP


                          AREA ||i.tcp_sent||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_sent PROC
;;;1736   void
;;;1737   tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
000000  b570              PUSH     {r4-r6,lr}
;;;1738   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1739     if (pcb != NULL) {
000006  2c00              CMP      r4,#0
000008  d00a              BEQ      |L40.32|
;;;1740       LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
00000a  7d20              LDRB     r0,[r4,#0x14]
00000c  2801              CMP      r0,#1
00000e  d106              BNE      |L40.30|
000010  a304              ADR      r3,|L40.36|
000012  f24062cc          MOV      r2,#0x6cc
000016  a10f              ADR      r1,|L40.84|
000018  a018              ADR      r0,|L40.124|
00001a  f7fffffe          BL       __2printf
                  |L40.30|
;;;1741       pcb->sent = sent;
00001e  67e5              STR      r5,[r4,#0x7c]
                  |L40.32|
;;;1742     }
;;;1743   }
000020  bd70              POP      {r4-r6,pc}
;;;1744   
                          ENDP

000022  0000              DCW      0x0000
                  |L40.36|
000024  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000028  6964646c
00002c  65776172
000030  65735c54
000034  68697264
000038  5f506172
00003c  74795c4c
000040  7749505c
000044  7372635c
000048  636f7265
00004c  5c746370
000050  2e6300  
000053  00                DCB      0
                  |L40.84|
000054  696e7661          DCB      "invalid socket state for sent callback",0
000058  6c696420
00005c  736f636b
000060  65742073
000064  74617465
000068  20666f72
00006c  2073656e
000070  74206361
000074  6c6c6261
000078  636b00  
00007b  00                DCB      0
                  |L40.124|
00007c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000080  7274696f
000084  6e202225
000088  73222066
00008c  61696c65
000090  64206174
000094  206c696e
000098  65202564
00009c  20696e20
0000a0  25730a00

                          AREA ||i.tcp_setprio||, CODE, READONLY, ALIGN=1

                  tcp_setprio PROC
;;;1409   void
;;;1410   tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
000000  7541              STRB     r1,[r0,#0x15]
;;;1411   {
;;;1412     pcb->prio = prio;
;;;1413   }
000002  4770              BX       lr
;;;1414   
                          ENDP


                          AREA ||i.tcp_shutdown||, CODE, READONLY, ALIGN=1

                  tcp_shutdown PROC
;;;425    err_t
;;;426    tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;427    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;428      if (pcb->state == LISTEN) {
00000a  7d20              LDRB     r0,[r4,#0x14]
;;;429        return ERR_CONN;
00000c  f06f070a          MVN      r7,#0xa
000010  2801              CMP      r0,#1                 ;428
000012  d00b              BEQ      |L42.44|
;;;430      }
;;;431      if (shut_rx) {
000014  b19d              CBZ      r5,|L42.62|
;;;432        /* shut down the receive side: set a flag not to receive any more data... */
;;;433        pcb->flags |= TF_RXCLOSED;
000016  7ea0              LDRB     r0,[r4,#0x1a]
000018  f0400010          ORR      r0,r0,#0x10
00001c  76a0              STRB     r0,[r4,#0x1a]
;;;434        if (shut_tx) {
00001e  b146              CBZ      r6,|L42.50|
;;;435          /* shutting down the tx AND rx side is the same as closing for the raw API */
;;;436          return tcp_close_shutdown(pcb, 1);
000020  4620              MOV      r0,r4
000022  e8bd41f0          POP      {r4-r8,lr}
000026  2101              MOVS     r1,#1
000028  f7ffbffe          B.W      tcp_close_shutdown
                  |L42.44|
00002c  4638              MOV      r0,r7                 ;429
                  |L42.46|
;;;437        }
;;;438        /* ... and free buffered data */
;;;439        if (pcb->refused_data != NULL) {
;;;440          pbuf_free(pcb->refused_data);
;;;441          pcb->refused_data = NULL;
;;;442        }
;;;443      }
;;;444      if (shut_tx) {
;;;445        /* This can't happen twice since if it succeeds, the pcb's state is changed.
;;;446           Only close in these states as the others directly deallocate the PCB */
;;;447        switch (pcb->state) {
;;;448        case SYN_RCVD:
;;;449        case ESTABLISHED:
;;;450        case CLOSE_WAIT:
;;;451          return tcp_close_shutdown(pcb, (u8_t)shut_rx);
;;;452        default:
;;;453          /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
;;;454            into CLOSED state, where the PCB is deallocated. */
;;;455          return ERR_CONN;
;;;456        }
;;;457      }
;;;458      return ERR_OK;
;;;459    }
00002e  e8bd81f0          POP      {r4-r8,pc}
                  |L42.50|
000032  6f60              LDR      r0,[r4,#0x74]         ;439
000034  b118              CBZ      r0,|L42.62|
000036  f7fffffe          BL       pbuf_free
00003a  2000              MOVS     r0,#0                 ;441
00003c  6760              STR      r0,[r4,#0x74]         ;441
                  |L42.62|
00003e  b176              CBZ      r6,|L42.94|
000040  7d20              LDRB     r0,[r4,#0x14]         ;447
000042  2803              CMP      r0,#3                 ;447
000044  d005              BEQ      |L42.82|
000046  2804              CMP      r0,#4                 ;447
000048  d003              BEQ      |L42.82|
00004a  2807              CMP      r0,#7                 ;447
00004c  d001              BEQ      |L42.82|
00004e  4638              MOV      r0,r7                 ;455
000050  e7ed              B        |L42.46|
                  |L42.82|
000052  b2e9              UXTB     r1,r5                 ;451
000054  4620              MOV      r0,r4                 ;451
000056  e8bd41f0          POP      {r4-r8,lr}            ;451
00005a  f7ffbffe          B.W      tcp_close_shutdown
                  |L42.94|
00005e  2000              MOVS     r0,#0                 ;458
000060  e7e5              B        |L42.46|
;;;460    
                          ENDP


                          AREA ||i.tcp_slowtmr||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_slowtmr PROC
;;;985    void
;;;986    tcp_slowtmr(void)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;987    {
;;;988      struct tcp_pcb *pcb, *prev;
;;;989      tcpwnd_size_t eff_wnd;
;;;990      u8_t pcb_remove;      /* flag if a PCB should be removed */
;;;991      u8_t pcb_reset;       /* flag if a RST should be sent when removing */
;;;992      err_t err;
;;;993    
;;;994      err = ERR_OK;
;;;995    
;;;996      ++tcp_ticks;
000004  4fc7              LDR      r7,|L43.804|
000006  68f8              LDR      r0,[r7,#0xc]  ; tcp_ticks
000008  1c40              ADDS     r0,r0,#1
00000a  60f8              STR      r0,[r7,#0xc]  ; tcp_ticks
;;;997      ++tcp_timer_ctr;
00000c  78b8              LDRB     r0,[r7,#2]  ; tcp_timer_ctr
00000e  1c40              ADDS     r0,r0,#1
000010  70b8              STRB     r0,[r7,#2]
;;;998    
;;;999    tcp_slowtmr_start:
;;;1000     /* Steps through all of the active PCBs. */
;;;1001     prev = NULL;
;;;1002     pcb = tcp_active_pcbs;
;;;1003     if (pcb == NULL) {
;;;1004       LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
;;;1005     }
;;;1006     while (pcb != NULL) {
;;;1007       LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
;;;1008       LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
;;;1009       LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
;;;1010       LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
;;;1011       if (pcb->last_timer == tcp_timer_ctr) {
;;;1012         /* skip this pcb, we have already processed it */
;;;1013         pcb = pcb->next;
;;;1014         continue;
;;;1015       }
;;;1016       pcb->last_timer = tcp_timer_ctr;
;;;1017   
;;;1018       pcb_remove = 0;
;;;1019       pcb_reset = 0;
;;;1020   
;;;1021       if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
;;;1022         ++pcb_remove;
;;;1023         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
;;;1024       }
;;;1025       else if (pcb->nrtx >= TCP_MAXRTX) {
;;;1026         ++pcb_remove;
;;;1027         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
;;;1028       } else {
;;;1029         if (pcb->persist_backoff > 0) {
;;;1030           /* If snd_wnd is zero, use persist timer to send 1 byte probes
;;;1031            * instead of using the standard retransmission mechanism. */
;;;1032           u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff-1];
;;;1033           if (pcb->persist_cnt < backoff_cnt) {
;;;1034             pcb->persist_cnt++;
;;;1035           }
;;;1036           if (pcb->persist_cnt >= backoff_cnt) {
;;;1037             if (tcp_zero_window_probe(pcb) == ERR_OK) {
;;;1038               pcb->persist_cnt = 0;
;;;1039               if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
;;;1040                 pcb->persist_backoff++;
;;;1041               }
;;;1042             }
;;;1043           }
;;;1044         } else {
;;;1045           /* Increase the retransmission timer if it is running */
;;;1046           if (pcb->rtime >= 0) {
;;;1047             ++pcb->rtime;
;;;1048           }
;;;1049   
;;;1050           if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
;;;1051             /* Time for a retransmission. */
;;;1052             LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
;;;1053                                         " pcb->rto %"S16_F"\n",
;;;1054                                         pcb->rtime, pcb->rto));
;;;1055   
;;;1056             /* Double retransmission time-out unless we are trying to
;;;1057              * connect to somebody (i.e., we are in SYN_SENT). */
;;;1058             if (pcb->state != SYN_SENT) {
;;;1059               u8_t backoff_idx = LWIP_MIN(pcb->nrtx, sizeof(tcp_backoff)-1);
;;;1060               pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
;;;1061             }
;;;1062   
;;;1063             /* Reset the retransmission timer. */
;;;1064             pcb->rtime = 0;
;;;1065   
;;;1066             /* Reduce congestion window and ssthresh. */
;;;1067             eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
;;;1068             pcb->ssthresh = eff_wnd >> 1;
;;;1069             if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
000012  f64f7bff          MOV      r11,#0xffff
;;;1070               pcb->ssthresh = (pcb->mss << 1);
;;;1071             }
;;;1072             pcb->cwnd = pcb->mss;
;;;1073             LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"TCPWNDSIZE_F
;;;1074                                          " ssthresh %"TCPWNDSIZE_F"\n",
;;;1075                                          pcb->cwnd, pcb->ssthresh));
;;;1076   
;;;1077             /* The following needs to be called AFTER cwnd is set to one
;;;1078                mss - STJ */
;;;1079             tcp_rexmit_rto(pcb);
;;;1080           }
;;;1081         }
;;;1082       }
;;;1083       /* Check if this PCB has stayed too long in FIN-WAIT-2 */
;;;1084       if (pcb->state == FIN_WAIT_2) {
;;;1085         /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
;;;1086         if (pcb->flags & TF_RXCLOSED) {
;;;1087           /* PCB was fully closed (either through close() or SHUT_RDWR):
;;;1088              normal FIN-WAIT timeout handling. */
;;;1089           if ((u32_t)(tcp_ticks - pcb->tmr) >
;;;1090               TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;1091             ++pcb_remove;
;;;1092             LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
;;;1093           }
;;;1094         }
;;;1095       }
;;;1096   
;;;1097       /* Check if KEEPALIVE should be sent */
;;;1098       if (ip_get_option(pcb, SOF_KEEPALIVE) &&
;;;1099          ((pcb->state == ESTABLISHED) ||
;;;1100           (pcb->state == CLOSE_WAIT))) {
;;;1101         if ((u32_t)(tcp_ticks - pcb->tmr) >
000016  f44f7afa          MOV      r10,#0x1f4
00001a  f04f0900          MOV      r9,#0
                  |L43.30|
00001e  2600              MOVS     r6,#0                 ;1001
000020  69bc              LDR      r4,[r7,#0x18]         ;1002  ; tcp_active_pcbs
000022  e13d              B        |L43.672|
                  |L43.36|
000024  7d20              LDRB     r0,[r4,#0x14]         ;1008
000026  2800              CMP      r0,#0                 ;1008
000028  d106              BNE      |L43.56|
00002a  a3bf              ADR      r3,|L43.808|
00002c  f44f727c          MOV      r2,#0x3f0             ;1008
000030  a1c9              ADR      r1,|L43.856|
000032  a0d4              ADR      r0,|L43.900|
000034  f7fffffe          BL       __2printf
                  |L43.56|
000038  7d20              LDRB     r0,[r4,#0x14]         ;1009
00003a  2801              CMP      r0,#1                 ;1009
00003c  d106              BNE      |L43.76|
00003e  a3ba              ADR      r3,|L43.808|
000040  f24032f1          MOV      r2,#0x3f1             ;1009
000044  a1d9              ADR      r1,|L43.940|
000046  a0cf              ADR      r0,|L43.900|
000048  f7fffffe          BL       __2printf
                  |L43.76|
00004c  7d20              LDRB     r0,[r4,#0x14]         ;1010
00004e  280a              CMP      r0,#0xa               ;1010
000050  d106              BNE      |L43.96|
000052  a3b5              ADR      r3,|L43.808|
000054  f24032f2          MOV      r2,#0x3f2             ;1010
000058  a1df              ADR      r1,|L43.984|
00005a  a0ca              ADR      r0,|L43.900|
00005c  f7fffffe          BL       __2printf
                  |L43.96|
000060  7f61              LDRB     r1,[r4,#0x1d]         ;1011
000062  78b8              LDRB     r0,[r7,#2]            ;1011  ; tcp_timer_ctr
000064  4281              CMP      r1,r0                 ;1011
000066  d101              BNE      |L43.108|
000068  68e4              LDR      r4,[r4,#0xc]          ;1013
00006a  e119              B        |L43.672|
                  |L43.108|
00006c  7760              STRB     r0,[r4,#0x1d]         ;1016
00006e  2500              MOVS     r5,#0                 ;1018
000070  46a8              MOV      r8,r5                 ;1019
000072  7d22              LDRB     r2,[r4,#0x14]         ;1021
000074  2a02              CMP      r2,#2                 ;1021
000076  d105              BNE      |L43.132|
000078  f8940042          LDRB     r0,[r4,#0x42]         ;1021
00007c  2806              CMP      r0,#6                 ;1021
00007e  d301              BCC      |L43.132|
000080  2501              MOVS     r5,#1                 ;1022
000082  e055              B        |L43.304|
                  |L43.132|
000084  f8940042          LDRB     r0,[r4,#0x42]         ;1025
000088  280c              CMP      r0,#0xc               ;1025
00008a  d301              BCC      |L43.144|
00008c  2501              MOVS     r5,#1                 ;1026
00008e  e04f              B        |L43.304|
                  |L43.144|
000090  f8941095          LDRB     r1,[r4,#0x95]         ;1029
000094  b1d1              CBZ      r1,|L43.204|
000096  48dc              LDR      r0,|L43.1032|
000098  5c08              LDRB     r0,[r1,r0]            ;1032
00009a  f8941094          LDRB     r1,[r4,#0x94]         ;1033
00009e  4281              CMP      r1,r0                 ;1033
0000a0  d202              BCS      |L43.168|
0000a2  1c49              ADDS     r1,r1,#1              ;1034
0000a4  f8841094          STRB     r1,[r4,#0x94]         ;1034
                  |L43.168|
0000a8  f8941094          LDRB     r1,[r4,#0x94]         ;1036
0000ac  4281              CMP      r1,r0                 ;1036
0000ae  d33f              BCC      |L43.304|
0000b0  4620              MOV      r0,r4                 ;1037
0000b2  f7fffffe          BL       tcp_zero_window_probe
0000b6  bbd8              CBNZ     r0,|L43.304|
0000b8  f8849094          STRB     r9,[r4,#0x94]         ;1038
0000bc  f8940095          LDRB     r0,[r4,#0x95]         ;1039
0000c0  2807              CMP      r0,#7                 ;1039
0000c2  d235              BCS      |L43.304|
0000c4  1c40              ADDS     r0,r0,#1              ;1040
0000c6  f8840095          STRB     r0,[r4,#0x95]         ;1040
0000ca  e031              B        |L43.304|
                  |L43.204|
0000cc  f9b41030          LDRSH    r1,[r4,#0x30]         ;1046
0000d0  2900              CMP      r1,#0                 ;1046
0000d2  db01              BLT      |L43.216|
0000d4  1c49              ADDS     r1,r1,#1              ;1047
0000d6  8621              STRH     r1,[r4,#0x30]         ;1047
                  |L43.216|
0000d8  6ee1              LDR      r1,[r4,#0x6c]         ;1050
0000da  b349              CBZ      r1,|L43.304|
0000dc  f9b41030          LDRSH    r1,[r4,#0x30]         ;1050
0000e0  f9b43040          LDRSH    r3,[r4,#0x40]         ;1050
0000e4  4299              CMP      r1,r3                 ;1050
0000e6  db23              BLT      |L43.304|
0000e8  2a02              CMP      r2,#2                 ;1058
0000ea  d009              BEQ      |L43.256|
0000ec  8fe1              LDRH     r1,[r4,#0x3e]         ;1060
0000ee  f9b4203c          LDRSH    r2,[r4,#0x3c]         ;1060
0000f2  eb0101e2          ADD      r1,r1,r2,ASR #3       ;1060
0000f6  4ac5              LDR      r2,|L43.1036|
0000f8  5c10              LDRB     r0,[r2,r0]            ;1060
0000fa  4081              LSLS     r1,r1,r0              ;1060
0000fc  f8a41040          STRH     r1,[r4,#0x40]         ;1060
                  |L43.256|
000100  f8a49030          STRH     r9,[r4,#0x30]         ;1064
000104  f8b40048          LDRH     r0,[r4,#0x48]         ;1067
000108  f8b4105c          LDRH     r1,[r4,#0x5c]         ;1067
00010c  4288              CMP      r0,r1                 ;1067
00010e  d300              BCC      |L43.274|
000110  4608              MOV      r0,r1                 ;1067
                  |L43.274|
000112  0840              LSRS     r0,r0,#1              ;1068
000114  f8a4004a          STRH     r0,[r4,#0x4a]         ;1068
000118  8e61              LDRH     r1,[r4,#0x32]         ;1069
00011a  ea0b0241          AND      r2,r11,r1,LSL #1      ;1069
00011e  4290              CMP      r0,r2                 ;1069
000120  d201              BCS      |L43.294|
000122  f8a4204a          STRH     r2,[r4,#0x4a]         ;1070
                  |L43.294|
000126  f8a41048          STRH     r1,[r4,#0x48]         ;1072
00012a  4620              MOV      r0,r4                 ;1079
00012c  f7fffffe          BL       tcp_rexmit_rto
                  |L43.304|
000130  7d20              LDRB     r0,[r4,#0x14]         ;1084
000132  2806              CMP      r0,#6                 ;1084
000134  d109              BNE      |L43.330|
000136  7ea1              LDRB     r1,[r4,#0x1a]         ;1086
000138  06c9              LSLS     r1,r1,#27             ;1086
00013a  d506              BPL      |L43.330|
00013c  6a21              LDR      r1,[r4,#0x20]         ;1089
00013e  68fa              LDR      r2,[r7,#0xc]          ;1089  ; tcp_ticks
000140  1a51              SUBS     r1,r2,r1              ;1089
000142  2928              CMP      r1,#0x28              ;1089
000144  d901              BLS      |L43.330|
000146  1c6d              ADDS     r5,r5,#1              ;1091
000148  b2ed              UXTB     r5,r5                 ;1091
                  |L43.330|
00014a  7a21              LDRB     r1,[r4,#8]            ;1098
00014c  0709              LSLS     r1,r1,#28             ;1098
00014e  d527              BPL      |L43.416|
000150  2804              CMP      r0,#4                 ;1099
000152  d001              BEQ      |L43.344|
000154  2807              CMP      r0,#7                 ;1100
000156  d123              BNE      |L43.416|
                  |L43.344|
000158  48ad              LDR      r0,|L43.1040|
00015a  f8d41090          LDR      r1,[r4,#0x90]
00015e  68fb              LDR      r3,[r7,#0xc]  ; tcp_ticks
000160  4408              ADD      r0,r0,r1
000162  fbb0f2fa          UDIV     r2,r0,r10
000166  6a20              LDR      r0,[r4,#0x20]
000168  1a18              SUBS     r0,r3,r0
00016a  4282              CMP      r2,r0
00016c  d204              BCS      |L43.376|
;;;1102            (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL)
;;;1103         {
;;;1104           LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to "));
;;;1105           ip_addr_debug_print(TCP_DEBUG, &pcb->remote_ip);
;;;1106           LWIP_DEBUGF(TCP_DEBUG, ("\n"));
;;;1107   
;;;1108           ++pcb_remove;
00016e  1c6d              ADDS     r5,r5,#1
000170  b2ed              UXTB     r5,r5
;;;1109           ++pcb_reset;
000172  f04f0801          MOV      r8,#1
000176  e013              B        |L43.416|
                  |L43.376|
;;;1110         } else if ((u32_t)(tcp_ticks - pcb->tmr) >
000178  f8942096          LDRB     r2,[r4,#0x96]
00017c  f242439f          MOV      r3,#0x249f
000180  435a              MULS     r2,r3,r2
000182  eb0101c2          ADD      r1,r1,r2,LSL #3
000186  fbb1f1fa          UDIV     r1,r1,r10
00018a  4281              CMP      r1,r0
00018c  d208              BCS      |L43.416|
;;;1111                   (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
;;;1112                   / TCP_SLOW_INTERVAL)
;;;1113         {
;;;1114           err = tcp_keepalive(pcb);
00018e  4620              MOV      r0,r4
000190  f7fffffe          BL       tcp_keepalive
;;;1115           if (err == ERR_OK) {
000194  b920              CBNZ     r0,|L43.416|
;;;1116             pcb->keep_cnt_sent++;
000196  f8940096          LDRB     r0,[r4,#0x96]
00019a  1c40              ADDS     r0,r0,#1
00019c  f8840096          STRB     r0,[r4,#0x96]
                  |L43.416|
;;;1117           }
;;;1118         }
;;;1119       }
;;;1120   
;;;1121       /* If this PCB has queued out of sequence data, but has been
;;;1122          inactive for too long, will drop the data (it will eventually
;;;1123          be retransmitted). */
;;;1124   #if TCP_QUEUE_OOSEQ
;;;1125       if (pcb->ooseq != NULL &&
0001a0  6f20              LDR      r0,[r4,#0x70]
0001a2  b168              CBZ      r0,|L43.448|
;;;1126           (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
0001a4  6a21              LDR      r1,[r4,#0x20]
0001a6  68fa              LDR      r2,[r7,#0xc]  ; tcp_ticks
0001a8  1a52              SUBS     r2,r2,r1
0001aa  f9b41040          LDRSH    r1,[r4,#0x40]
0001ae  eb010141          ADD      r1,r1,r1,LSL #1
0001b2  ebb20f41          CMP      r2,r1,LSL #1
0001b6  d303              BCC      |L43.448|
;;;1127         tcp_segs_free(pcb->ooseq);
0001b8  f7fffffe          BL       tcp_segs_free
;;;1128         pcb->ooseq = NULL;
0001bc  f8c49070          STR      r9,[r4,#0x70]
                  |L43.448|
;;;1129         LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
;;;1130       }
;;;1131   #endif /* TCP_QUEUE_OOSEQ */
;;;1132   
;;;1133       /* Check if this PCB has stayed too long in SYN-RCVD */
;;;1134       if (pcb->state == SYN_RCVD) {
0001c0  7d20              LDRB     r0,[r4,#0x14]
0001c2  2803              CMP      r0,#3
0001c4  d106              BNE      |L43.468|
;;;1135         if ((u32_t)(tcp_ticks - pcb->tmr) >
0001c6  6a21              LDR      r1,[r4,#0x20]
0001c8  68fa              LDR      r2,[r7,#0xc]  ; tcp_ticks
0001ca  1a51              SUBS     r1,r2,r1
0001cc  2928              CMP      r1,#0x28
0001ce  d901              BLS      |L43.468|
;;;1136             TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;1137           ++pcb_remove;
0001d0  1c6d              ADDS     r5,r5,#1
0001d2  b2ed              UXTB     r5,r5
                  |L43.468|
;;;1138           LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
;;;1139         }
;;;1140       }
;;;1141   
;;;1142       /* Check if this PCB has stayed too long in LAST-ACK */
;;;1143       if (pcb->state == LAST_ACK) {
0001d4  2809              CMP      r0,#9
0001d6  d106              BNE      |L43.486|
;;;1144         if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
0001d8  6a20              LDR      r0,[r4,#0x20]
0001da  68f9              LDR      r1,[r7,#0xc]  ; tcp_ticks
0001dc  1a08              SUBS     r0,r1,r0
0001de  28f0              CMP      r0,#0xf0
0001e0  d901              BLS      |L43.486|
;;;1145           ++pcb_remove;
0001e2  1c6d              ADDS     r5,r5,#1
0001e4  b2ed              UXTB     r5,r5
                  |L43.486|
;;;1146           LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
;;;1147         }
;;;1148       }
;;;1149   
;;;1150       /* If the PCB should be removed, do it. */
;;;1151       if (pcb_remove) {
0001e6  2d00              CMP      r5,#0
0001e8  d03e              BEQ      |L43.616|
;;;1152         struct tcp_pcb *pcb2;
;;;1153   #if LWIP_CALLBACK_API
;;;1154         tcp_err_fn err_fn = pcb->errf;
0001ea  f8d4508c          LDR      r5,[r4,#0x8c]
;;;1155   #endif /* LWIP_CALLBACK_API */
;;;1156         void *err_arg;
;;;1157         enum tcp_state last_state;
;;;1158         tcp_pcb_purge(pcb);
0001ee  4620              MOV      r0,r4
0001f0  f7fffffe          BL       tcp_pcb_purge
;;;1159         /* Remove PCB from tcp_active_pcbs list. */
;;;1160         if (prev != NULL) {
0001f4  b166              CBZ      r6,|L43.528|
;;;1161           LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
0001f6  69b8              LDR      r0,[r7,#0x18]  ; tcp_active_pcbs
0001f8  4284              CMP      r4,r0
0001fa  d106              BNE      |L43.522|
0001fc  a34a              ADR      r3,|L43.808|
0001fe  f2404289          MOV      r2,#0x489
000202  a184              ADR      r1,|L43.1044|
000204  a05f              ADR      r0,|L43.900|
000206  f7fffffe          BL       __2printf
                  |L43.522|
;;;1162           prev->next = pcb->next;
00020a  68e0              LDR      r0,[r4,#0xc]
00020c  60f0              STR      r0,[r6,#0xc]
00020e  e00b              B        |L43.552|
                  |L43.528|
;;;1163         } else {
;;;1164           /* This PCB was the first. */
;;;1165           LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
000210  69b8              LDR      r0,[r7,#0x18]  ; tcp_active_pcbs
000212  42a0              CMP      r0,r4
000214  d006              BEQ      |L43.548|
000216  a344              ADR      r3,|L43.808|
000218  f240428d          MOV      r2,#0x48d
00021c  a188              ADR      r1,|L43.1088|
00021e  a059              ADR      r0,|L43.900|
000220  f7fffffe          BL       __2printf
                  |L43.548|
;;;1166           tcp_active_pcbs = pcb->next;
000224  68e0              LDR      r0,[r4,#0xc]
000226  61b8              STR      r0,[r7,#0x18]  ; tcp_active_pcbs
                  |L43.552|
;;;1167         }
;;;1168   
;;;1169         if (pcb_reset) {
000228  f1b80f00          CMP      r8,#0
00022c  d009              BEQ      |L43.578|
;;;1170           tcp_rst(pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
00022e  8b20              LDRH     r0,[r4,#0x18]
000230  8ae1              LDRH     r1,[r4,#0x16]
000232  e9cd1000          STRD     r1,r0,[sp,#0]
000236  1d23              ADDS     r3,r4,#4
000238  4622              MOV      r2,r4
00023a  6a61              LDR      r1,[r4,#0x24]
00023c  6ce0              LDR      r0,[r4,#0x4c]
00023e  f7fffffe          BL       tcp_rst
                  |L43.578|
;;;1171                    pcb->local_port, pcb->remote_port);
;;;1172         }
;;;1173   
;;;1174         err_arg = pcb->callback_arg;
000242  f8d48010          LDR      r8,[r4,#0x10]
;;;1175         last_state = pcb->state;
;;;1176         pcb2 = pcb;
;;;1177         pcb = pcb->next;
000246  4621              MOV      r1,r4
000248  68e4              LDR      r4,[r4,#0xc]
;;;1178         memp_free(MEMP_TCP_PCB, pcb2);
00024a  2001              MOVS     r0,#1
00024c  f7fffffe          BL       memp_free
;;;1179   
;;;1180         tcp_active_pcbs_changed = 0;
000250  f8879000          STRB     r9,[r7,#0]
;;;1181         TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
000254  b11d              CBZ      r5,|L43.606|
000256  f06f010c          MVN      r1,#0xc
00025a  4640              MOV      r0,r8
00025c  47a8              BLX      r5
                  |L43.606|
;;;1182         if (tcp_active_pcbs_changed) {
00025e  7838              LDRB     r0,[r7,#0]  ; tcp_active_pcbs_changed
000260  2800              CMP      r0,#0
                  |L43.610|
000262  f47faedc          BNE      |L43.30|
000266  e01b              B        |L43.672|
                  |L43.616|
;;;1183           goto tcp_slowtmr_start;
;;;1184         }
;;;1185       } else {
;;;1186         /* get the 'next' element now and work with 'prev' below (in case of abort) */
;;;1187         prev = pcb;
000268  4626              MOV      r6,r4
;;;1188         pcb = pcb->next;
00026a  68e4              LDR      r4,[r4,#0xc]
;;;1189   
;;;1190         /* We check if we should poll the connection. */
;;;1191         ++prev->polltmr;
00026c  7ef0              LDRB     r0,[r6,#0x1b]
00026e  1c40              ADDS     r0,r0,#1
000270  b2c0              UXTB     r0,r0
000272  76f0              STRB     r0,[r6,#0x1b]
;;;1192         if (prev->polltmr >= prev->pollinterval) {
000274  7f31              LDRB     r1,[r6,#0x1c]
000276  4288              CMP      r0,r1
000278  d312              BCC      |L43.672|
;;;1193           prev->polltmr = 0;
00027a  f886901b          STRB     r9,[r6,#0x1b]
;;;1194           LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
;;;1195           tcp_active_pcbs_changed = 0;
00027e  f8879000          STRB     r9,[r7,#0]
;;;1196           TCP_EVENT_POLL(prev, err);
000282  f8d62088          LDR      r2,[r6,#0x88]
000286  b11a              CBZ      r2,|L43.656|
000288  4631              MOV      r1,r6
00028a  6930              LDR      r0,[r6,#0x10]
00028c  4790              BLX      r2
00028e  e000              B        |L43.658|
                  |L43.656|
000290  2000              MOVS     r0,#0
                  |L43.658|
;;;1197           if (tcp_active_pcbs_changed) {
000292  7839              LDRB     r1,[r7,#0]  ; tcp_active_pcbs_changed
000294  2900              CMP      r1,#0
000296  d1e4              BNE      |L43.610|
;;;1198             goto tcp_slowtmr_start;
;;;1199           }
;;;1200           /* if err == ERR_ABRT, 'prev' is already deallocated */
;;;1201           if (err == ERR_OK) {
000298  b910              CBNZ     r0,|L43.672|
;;;1202             tcp_output(prev);
00029a  4630              MOV      r0,r6
00029c  f7fffffe          BL       tcp_output
                  |L43.672|
0002a0  2c00              CMP      r4,#0                 ;1006
0002a2  f47faebf          BNE      |L43.36|
;;;1203           }
;;;1204         }
;;;1205       }
;;;1206     }
;;;1207   
;;;1208   
;;;1209     /* Steps through all of the TIME-WAIT PCBs. */
;;;1210     prev = NULL;
0002a6  2500              MOVS     r5,#0
;;;1211     pcb = tcp_tw_pcbs;
0002a8  69fc              LDR      r4,[r7,#0x1c]  ; tcp_tw_pcbs
;;;1212     while (pcb != NULL) {
0002aa  e037              B        |L43.796|
                  |L43.684|
;;;1213       LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
0002ac  7d20              LDRB     r0,[r4,#0x14]
0002ae  280a              CMP      r0,#0xa
0002b0  d006              BEQ      |L43.704|
0002b2  a31d              ADR      r3,|L43.808|
0002b4  f24042bd          MOV      r2,#0x4bd
0002b8  a16c              ADR      r1,|L43.1132|
0002ba  a032              ADR      r0,|L43.900|
0002bc  f7fffffe          BL       __2printf
                  |L43.704|
;;;1214       pcb_remove = 0;
0002c0  2000              MOVS     r0,#0
;;;1215   
;;;1216       /* Check if this PCB has stayed long enough in TIME-WAIT */
;;;1217       if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
0002c2  6a21              LDR      r1,[r4,#0x20]
0002c4  68fa              LDR      r2,[r7,#0xc]  ; tcp_ticks
0002c6  1a51              SUBS     r1,r2,r1
0002c8  29f0              CMP      r1,#0xf0
0002ca  d900              BLS      |L43.718|
;;;1218         ++pcb_remove;
0002cc  2001              MOVS     r0,#1
                  |L43.718|
;;;1219       }
;;;1220   
;;;1221       /* If the PCB should be removed, do it. */
;;;1222       if (pcb_remove) {
0002ce  2800              CMP      r0,#0
0002d0  d022              BEQ      |L43.792|
;;;1223         struct tcp_pcb *pcb2;
;;;1224         tcp_pcb_purge(pcb);
0002d2  4620              MOV      r0,r4
0002d4  f7fffffe          BL       tcp_pcb_purge
;;;1225         /* Remove PCB from tcp_tw_pcbs list. */
;;;1226         if (prev != NULL) {
0002d8  b165              CBZ      r5,|L43.756|
;;;1227           LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
0002da  69f8              LDR      r0,[r7,#0x1c]  ; tcp_tw_pcbs
0002dc  4284              CMP      r4,r0
0002de  d106              BNE      |L43.750|
0002e0  a311              ADR      r3,|L43.808|
0002e2  f24042cb          MOV      r2,#0x4cb
0002e6  a16d              ADR      r1,|L43.1180|
0002e8  a026              ADR      r0,|L43.900|
0002ea  f7fffffe          BL       __2printf
                  |L43.750|
;;;1228           prev->next = pcb->next;
0002ee  68e0              LDR      r0,[r4,#0xc]
0002f0  60e8              STR      r0,[r5,#0xc]
0002f2  e00b              B        |L43.780|
                  |L43.756|
;;;1229         } else {
;;;1230           /* This PCB was the first. */
;;;1231           LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
0002f4  69f8              LDR      r0,[r7,#0x1c]  ; tcp_tw_pcbs
0002f6  42a0              CMP      r0,r4
0002f8  d006              BEQ      |L43.776|
0002fa  a30b              ADR      r3,|L43.808|
0002fc  f24042cf          MOV      r2,#0x4cf
000300  a170              ADR      r1,|L43.1220|
000302  a020              ADR      r0,|L43.900|
000304  f7fffffe          BL       __2printf
                  |L43.776|
;;;1232           tcp_tw_pcbs = pcb->next;
000308  68e0              LDR      r0,[r4,#0xc]
00030a  61f8              STR      r0,[r7,#0x1c]  ; tcp_tw_pcbs
                  |L43.780|
;;;1233         }
;;;1234         pcb2 = pcb;
;;;1235         pcb = pcb->next;
00030c  4621              MOV      r1,r4
00030e  68e4              LDR      r4,[r4,#0xc]
;;;1236         memp_free(MEMP_TCP_PCB, pcb2);
000310  2001              MOVS     r0,#1
000312  f7fffffe          BL       memp_free
;;;1237       } else {
000316  e001              B        |L43.796|
                  |L43.792|
;;;1238         prev = pcb;
000318  4625              MOV      r5,r4
;;;1239         pcb = pcb->next;
00031a  68e4              LDR      r4,[r4,#0xc]
                  |L43.796|
00031c  2c00              CMP      r4,#0                 ;1212
00031e  d1c5              BNE      |L43.684|
;;;1240       }
;;;1241     }
;;;1242   }
000320  e8bd9ffc          POP      {r2-r12,pc}
;;;1243   
                          ENDP

                  |L43.804|
                          DCD      ||.data||
                  |L43.808|
000328  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
00032c  6964646c
000330  65776172
000334  65735c54
000338  68697264
00033c  5f506172
000340  74795c4c
000344  7749505c
000348  7372635c
00034c  636f7265
000350  5c746370
000354  2e6300  
000357  00                DCB      0
                  |L43.856|
000358  7463705f          DCB      "tcp_slowtmr: active pcb->state != CLOSED\n",0
00035c  736c6f77
000360  746d723a
000364  20616374
000368  69766520
00036c  7063622d
000370  3e737461
000374  74652021
000378  3d20434c
00037c  4f534544
000380  0a00    
000382  00                DCB      0
000383  00                DCB      0
                  |L43.900|
000384  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000388  7274696f
00038c  6e202225
000390  73222066
000394  61696c65
000398  64206174
00039c  206c696e
0003a0  65202564
0003a4  20696e20
0003a8  25730a00
                  |L43.940|
0003ac  7463705f          DCB      "tcp_slowtmr: active pcb->state != LISTEN\n",0
0003b0  736c6f77
0003b4  746d723a
0003b8  20616374
0003bc  69766520
0003c0  7063622d
0003c4  3e737461
0003c8  74652021
0003cc  3d204c49
0003d0  5354454e
0003d4  0a00    
0003d6  00                DCB      0
0003d7  00                DCB      0
                  |L43.984|
0003d8  7463705f          DCB      "tcp_slowtmr: active pcb->state != TIME-WAIT\n",0
0003dc  736c6f77
0003e0  746d723a
0003e4  20616374
0003e8  69766520
0003ec  7063622d
0003f0  3e737461
0003f4  74652021
0003f8  3d205449
0003fc  4d452d57
000400  4149540a
000404  00      
000405  00                DCB      0
000406  00                DCB      0
000407  00                DCB      0
                  |L43.1032|
                          DCD      ||.constdata||-0x1
                  |L43.1036|
                          DCD      ||.constdata||+0x34
                  |L43.1040|
                          DCD      0x000a4cb8
                  |L43.1044|
000414  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_active_pcbs",0
000418  736c6f77
00041c  746d723a
000420  206d6964
000424  646c6520
000428  74637020
00042c  213d2074
000430  63705f61
000434  63746976
000438  655f7063
00043c  627300  
00043f  00                DCB      0
                  |L43.1088|
000440  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_active_pcbs",0
000444  736c6f77
000448  746d723a
00044c  20666972
000450  73742070
000454  6362203d
000458  3d207463
00045c  705f6163
000460  74697665
000464  5f706362
000468  7300    
00046a  00                DCB      0
00046b  00                DCB      0
                  |L43.1132|
00046c  7463705f          DCB      "tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT",0
000470  736c6f77
000474  746d723a
000478  2054494d
00047c  452d5741
000480  49542070
000484  63622d3e
000488  73746174
00048c  65203d3d
000490  2054494d
000494  452d5741
000498  495400  
00049b  00                DCB      0
                  |L43.1180|
00049c  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_tw_pcbs",0
0004a0  736c6f77
0004a4  746d723a
0004a8  206d6964
0004ac  646c6520
0004b0  74637020
0004b4  213d2074
0004b8  63705f74
0004bc  775f7063
0004c0  627300  
0004c3  00                DCB      0
                  |L43.1220|
0004c4  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_tw_pcbs",0
0004c8  736c6f77
0004cc  746d723a
0004d0  20666972
0004d4  73742070
0004d8  6362203d
0004dc  3d207463
0004e0  705f7477
0004e4  5f706362
0004e8  7300    
0004ea  00                DCB      0
0004eb  00                DCB      0

                          AREA ||i.tcp_tmr||, CODE, READONLY, ALIGN=2

                  tcp_tmr PROC
;;;155    void
;;;156    tcp_tmr(void)
000000  b510              PUSH     {r4,lr}
;;;157    {
;;;158      /* Call tcp_fasttmr() every 250 ms */
;;;159      tcp_fasttmr();
000002  f7fffffe          BL       tcp_fasttmr
;;;160    
;;;161      if (++tcp_timer & 1) {
000006  4905              LDR      r1,|L44.28|
000008  7848              LDRB     r0,[r1,#1]  ; tcp_timer
00000a  1c40              ADDS     r0,r0,#1
00000c  7048              STRB     r0,[r1,#1]
00000e  07c0              LSLS     r0,r0,#31
000010  d003              BEQ      |L44.26|
;;;162        /* Call tcp_slowtmr() every 500 ms, i.e., every other timer
;;;163           tcp_tmr() is called. */
;;;164        tcp_slowtmr();
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      tcp_slowtmr
                  |L44.26|
;;;165      }
;;;166    }
00001a  bd10              POP      {r4,pc}
;;;167    
                          ENDP

                  |L44.28|
                          DCD      ||.data||

                          AREA ||i.tcp_txnow||, CODE, READONLY, ALIGN=2

                  tcp_txnow PROC
;;;1297   void
;;;1298   tcp_txnow(void)
000000  b510              PUSH     {r4,lr}
;;;1299   {
;;;1300     struct tcp_pcb *pcb;
;;;1301   
;;;1302     for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000002  4806              LDR      r0,|L45.28|
000004  6984              LDR      r4,[r0,#0x18]  ; tcp_active_pcbs
000006  e006              B        |L45.22|
                  |L45.8|
;;;1303       if (pcb->flags & TF_NAGLEMEMERR) {
000008  7ea0              LDRB     r0,[r4,#0x1a]
00000a  0600              LSLS     r0,r0,#24
00000c  d502              BPL      |L45.20|
;;;1304         tcp_output(pcb);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       tcp_output
                  |L45.20|
000014  68e4              LDR      r4,[r4,#0xc]          ;1302
                  |L45.22|
000016  2c00              CMP      r4,#0                 ;1302
000018  d1f6              BNE      |L45.8|
;;;1305       }
;;;1306     }
;;;1307   }
00001a  bd10              POP      {r4,pc}
;;;1308   
                          ENDP

                  |L45.28|
                          DCD      ||.data||

                          AREA ||i.tcp_update_rcv_ann_wnd||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_update_rcv_ann_wnd PROC
;;;758    u32_t
;;;759    tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;760    {
000002  4604              MOV      r4,r0
;;;761      u32_t new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
000004  8d25              LDRH     r5,[r4,#0x28]
000006  6a62              LDR      r2,[r4,#0x24]
000008  1951              ADDS     r1,r2,r5
;;;762    
;;;763      if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
00000a  8e63              LDRH     r3,[r4,#0x32]
00000c  f44f6686          MOV      r6,#0x430
000010  6ae0              LDR      r0,[r4,#0x2c]
000012  42b3              CMP      r3,r6
000014  d900              BLS      |L46.24|
000016  4633              MOV      r3,r6
                  |L46.24|
000018  4403              ADD      r3,r3,r0
00001a  1acb              SUBS     r3,r1,r3
00001c  d402              BMI      |L46.36|
;;;764        /* we can advertise more window */
;;;765        pcb->rcv_ann_wnd = pcb->rcv_wnd;
00001e  8565              STRH     r5,[r4,#0x2a]
;;;766        return new_right_edge - pcb->rcv_ann_right_edge;
000020  1a08              SUBS     r0,r1,r0
;;;767      } else {
;;;768        if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
;;;769          /* Can happen due to other end sending out of advertised window,
;;;770           * but within actual available (but not yet advertised) window */
;;;771          pcb->rcv_ann_wnd = 0;
;;;772        } else {
;;;773          /* keep the right edge of window constant */
;;;774          u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
;;;775    #if !LWIP_WND_SCALE
;;;776          LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
;;;777    #endif
;;;778          pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
;;;779        }
;;;780        return 0;
;;;781      }
;;;782    }
000022  bd70              POP      {r4-r6,pc}
                  |L46.36|
000024  1a11              SUBS     r1,r2,r0              ;768
000026  2900              CMP      r1,#0                 ;768
000028  dd02              BLE      |L46.48|
00002a  2000              MOVS     r0,#0                 ;771
00002c  8560              STRH     r0,[r4,#0x2a]         ;771
00002e  e00b              B        |L46.72|
                  |L46.48|
000030  1a85              SUBS     r5,r0,r2              ;774
000032  f5b53f80          CMP      r5,#0x10000           ;776
000036  d306              BCC      |L46.70|
000038  a304              ADR      r3,|L46.76|
00003a  f44f7242          MOV      r2,#0x308             ;776
00003e  a10f              ADR      r1,|L46.124|
000040  a015              ADR      r0,|L46.152|
000042  f7fffffe          BL       __2printf
                  |L46.70|
000046  8565              STRH     r5,[r4,#0x2a]         ;778
                  |L46.72|
000048  2000              MOVS     r0,#0                 ;780
00004a  bd70              POP      {r4-r6,pc}
;;;783    
                          ENDP

                  |L46.76|
00004c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000050  6964646c
000054  65776172
000058  65735c54
00005c  68697264
000060  5f506172
000064  74795c4c
000068  7749505c
00006c  7372635c
000070  636f7265
000074  5c746370
000078  2e6300  
00007b  00                DCB      0
                  |L46.124|
00007c  6e65775f          DCB      "new_rcv_ann_wnd <= 0xffff",0
000080  7263765f
000084  616e6e5f
000088  776e6420
00008c  3c3d2030
000090  78666666
000094  6600    
000096  00                DCB      0
000097  00                DCB      0
                  |L46.152|
000098  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00009c  7274696f
0000a0  6e202225
0000a4  73222066
0000a8  61696c65
0000ac  64206174
0000b0  206c696e
0000b4  65202564
0000b8  20696e20
0000bc  25730a00

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  tcp_persist_backoff
000000  03060c18          DCB      0x03,0x06,0x0c,0x18
000004  30607800          DCB      0x30,0x60,0x78,0x00
                  tcp_state_str
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0x10
                          DCD      ||.conststring||+0x1c
                          DCD      ||.conststring||+0x28
                          DCD      ||.conststring||+0x34
                          DCD      ||.conststring||+0x40
                          DCD      ||.conststring||+0x4c
                          DCD      ||.conststring||+0x58
                          DCD      ||.conststring||+0x60
                          DCD      ||.conststring||+0x6c
                  tcp_backoff
000034  01020304          DCB      0x01,0x02,0x03,0x04
000038  05060707          DCB      0x05,0x06,0x07,0x07
00003c  07070707          DCB      0x07,0x07,0x07,0x07
000040  07000000          DCB      0x07,0x00,0x00,0x00
                  tcp_pcb_lists
                          DCD      tcp_listen_pcbs
                          DCD      tcp_bound_pcbs
                          DCD      tcp_active_pcbs
                          DCD      tcp_tw_pcbs

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  434c4f53          DCB      "CLOSED",0
000004  454400  
000007  00                DCB      0
000008  4c495354          DCB      "LISTEN",0
00000c  454e00  
00000f  00                DCB      0
000010  53594e5f          DCB      "SYN_SENT",0
000014  53454e54
000018  00      
000019  00                DCB      0
00001a  00                DCB      0
00001b  00                DCB      0
00001c  53594e5f          DCB      "SYN_RCVD",0
000020  52435644
000024  00      
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0
000028  45535441          DCB      "ESTABLISHED",0
00002c  424c4953
000030  48454400
000034  46494e5f          DCB      "FIN_WAIT_1",0
000038  57414954
00003c  5f3100  
00003f  00                DCB      0
000040  46494e5f          DCB      "FIN_WAIT_2",0
000044  57414954
000048  5f3200  
00004b  00                DCB      0
00004c  434c4f53          DCB      "CLOSE_WAIT",0
000050  455f5741
000054  495400  
000057  00                DCB      0
000058  434c4f53          DCB      "CLOSING",0
00005c  494e4700
000060  4c415354          DCB      "LAST_ACK",0
000064  5f41434b
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
00006c  54494d45          DCB      "TIME_WAIT",0
000070  5f574149
000074  5400    

                          AREA ||.data||, DATA, ALIGN=2

                  tcp_active_pcbs_changed
000000  00                DCB      0x00
                  tcp_timer
000001  00                DCB      0x00
                  tcp_timer_ctr
000002  0000              DCB      0x00,0x00
                  tcp_port
000004  c000              DCW      0xc000
000006  0000              DCB      0x00,0x00
                  iss
                          DCD      0x0000196e
                  tcp_ticks
                          DCD      0x00000000
                  tcp_bound_pcbs
                          DCD      0x00000000
                  tcp_listen_pcbs
                          DCD      0x00000000
                  tcp_active_pcbs
                          DCD      0x00000000
                  tcp_tw_pcbs
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_tcp_c_1dfa8a85____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_tcp_c_1dfa8a85____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_tcp_c_1dfa8a85____REVSH|
#line 478
|__asm___5_tcp_c_1dfa8a85____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_tcp_c_1dfa8a85____RRX|
#line 665
|__asm___5_tcp_c_1dfa8a85____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
