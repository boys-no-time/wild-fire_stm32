; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\tcp.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\tcp.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\tcp.crf ..\Middlewares\Third_Party\LwIP\src\core\tcp.c]
                          THUMB

                          AREA ||i.tcp_abandon||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_abandon PROC
;;;562    void
;;;563    tcp_abandon(struct tcp_pcb *pcb, int reset)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;564    {
000004  4604              MOV      r4,r0
000006  468b              MOV      r11,r1
;;;565      u32_t seqno, ackno;
;;;566    #if LWIP_CALLBACK_API
;;;567      tcp_err_fn errf;
;;;568    #endif /* LWIP_CALLBACK_API */
;;;569      void *errf_arg;
;;;570    
;;;571      LWIP_ASSERT_CORE_LOCKED();
;;;572    
;;;573      LWIP_ERROR("tcp_abandon: invalid pcb", pcb != NULL, return);
000008  2c00              CMP      r4,#0
00000a  d003              BEQ      |L1.20|
;;;574    
;;;575      /* pcb->state LISTEN not allowed here */
;;;576      LWIP_ASSERT("don't call tcp_abort/tcp_abandon for listen-pcbs",
00000c  7d20              LDRB     r0,[r4,#0x14]
00000e  2801              CMP      r0,#1
000010  d00a              BEQ      |L1.40|
000012  e010              B        |L1.54|
                  |L1.20|
000014  b004              ADD      sp,sp,#0x10           ;573
000016  a33b              ADR      r3,|L1.260|
000018  e8bd5ff0          POP      {r4-r12,lr}           ;573
00001c  f240223d          MOV      r2,#0x23d             ;573
000020  a144              ADR      r1,|L1.308|
000022  a04b              ADR      r0,|L1.336|
000024  f7ffbffe          B.W      __2printf
                  |L1.40|
000028  a336              ADR      r3,|L1.260|
00002a  f44f7210          MOV      r2,#0x240
00002e  a152              ADR      r1,|L1.376|
000030  a047              ADR      r0,|L1.336|
000032  f7fffffe          BL       __2printf
                  |L1.54|
;;;577                  pcb->state != LISTEN);
;;;578      /* Figure out on which TCP PCB list we are, and remove us. If we
;;;579         are in an active state, call the receive function associated with
;;;580         the PCB with a NULL argument, and send an RST to the remote end. */
;;;581      if (pcb->state == TIME_WAIT) {
000036  7d20              LDRB     r0,[r4,#0x14]
000038  280a              CMP      r0,#0xa
00003a  d03e              BEQ      |L1.186|
;;;582        tcp_pcb_remove(&tcp_tw_pcbs, pcb);
;;;583        tcp_free(pcb);
;;;584      } else {
;;;585        int send_rst = 0;
00003c  2500              MOVS     r5,#0
;;;586        u16_t local_port = 0;
00003e  2700              MOVS     r7,#0
;;;587        enum tcp_state last_state;
;;;588        seqno = pcb->snd_nxt;
000040  6d21              LDR      r1,[r4,#0x50]
000042  9103              STR      r1,[sp,#0xc]
;;;589        ackno = pcb->rcv_nxt;
000044  f8d48024          LDR      r8,[r4,#0x24]
;;;590    #if LWIP_CALLBACK_API
;;;591        errf = pcb->errf;
000048  f8d46090          LDR      r6,[r4,#0x90]
;;;592    #endif /* LWIP_CALLBACK_API */
;;;593        errf_arg = pcb->callback_arg;
00004c  f8d49010          LDR      r9,[r4,#0x10]
;;;594        if (pcb->state == CLOSED) {
;;;595          if (pcb->local_port != 0) {
;;;596            /* bound, not yet opened */
;;;597            TCP_RMV(&tcp_bound_pcbs, pcb);
000050  f8dfa158          LDR      r10,|L1.428|
000054  b380              CBZ      r0,|L1.184|
;;;598          }
;;;599        } else {
;;;600          send_rst = reset;
000056  465d              MOV      r5,r11
;;;601          local_port = pcb->local_port;
000058  8ae7              LDRH     r7,[r4,#0x16]
;;;602          TCP_PCB_REMOVE_ACTIVE(pcb);
00005a  4621              MOV      r1,r4
00005c  f10a0018          ADD      r0,r10,#0x18
000060  f7fffffe          BL       tcp_pcb_remove
000064  2001              MOVS     r0,#1
000066  f88a0000          STRB     r0,[r10,#0]
                  |L1.106|
;;;603        }
;;;604        if (pcb->unacked != NULL) {
00006a  6f20              LDR      r0,[r4,#0x70]
00006c  b108              CBZ      r0,|L1.114|
;;;605          tcp_segs_free(pcb->unacked);
00006e  f7fffffe          BL       tcp_segs_free
                  |L1.114|
;;;606        }
;;;607        if (pcb->unsent != NULL) {
000072  6ee0              LDR      r0,[r4,#0x6c]
000074  b108              CBZ      r0,|L1.122|
;;;608          tcp_segs_free(pcb->unsent);
000076  f7fffffe          BL       tcp_segs_free
                  |L1.122|
;;;609        }
;;;610    #if TCP_QUEUE_OOSEQ
;;;611        if (pcb->ooseq != NULL) {
00007a  6f60              LDR      r0,[r4,#0x74]
00007c  b108              CBZ      r0,|L1.130|
;;;612          tcp_segs_free(pcb->ooseq);
00007e  f7fffffe          BL       tcp_segs_free
                  |L1.130|
;;;613        }
;;;614    #endif /* TCP_QUEUE_OOSEQ */
;;;615        tcp_backlog_accepted(pcb);
;;;616        if (send_rst) {
000082  b155              CBZ      r5,|L1.154|
;;;617          LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abandon: sending RST\n"));
;;;618          tcp_rst(pcb, seqno, ackno, &pcb->local_ip, &pcb->remote_ip, local_port, pcb->remote_port);
000084  8b20              LDRH     r0,[r4,#0x18]
000086  1d21              ADDS     r1,r4,#4
000088  e9cd1700          STRD     r1,r7,[sp,#0]
00008c  9002              STR      r0,[sp,#8]
00008e  4623              MOV      r3,r4
000090  4642              MOV      r2,r8
000092  4620              MOV      r0,r4
000094  9903              LDR      r1,[sp,#0xc]
000096  f7fffffe          BL       tcp_rst
                  |L1.154|
;;;619        }
;;;620        last_state = pcb->state;
;;;621        tcp_free(pcb);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       tcp_free
;;;622        TCP_EVENT_ERR(last_state, errf, errf_arg, ERR_ABRT);
0000a0  2e00              CMP      r6,#0
0000a2  d02c              BEQ      |L1.254|
0000a4  b004              ADD      sp,sp,#0x10
0000a6  4648              MOV      r0,r9
0000a8  46b4              MOV      r12,r6
0000aa  e8bd4ff0          POP      {r4-r11,lr}
0000ae  f06f010c          MVN      r1,#0xc
0000b2  f85deb04          POP      {lr}
0000b6  4760              BX       r12
                  |L1.184|
0000b8  e00a              B        |L1.208|
                  |L1.186|
0000ba  483c              LDR      r0,|L1.428|
0000bc  4621              MOV      r1,r4                 ;582
0000be  301c              ADDS     r0,r0,#0x1c           ;582
0000c0  f7fffffe          BL       tcp_pcb_remove
0000c4  b004              ADD      sp,sp,#0x10           ;583
0000c6  4620              MOV      r0,r4                 ;583
0000c8  e8bd5ff0          POP      {r4-r12,lr}           ;583
0000cc  f7ffbffe          B.W      tcp_free
                  |L1.208|
0000d0  8ae0              LDRH     r0,[r4,#0x16]         ;595
0000d2  2800              CMP      r0,#0                 ;595
0000d4  d0c9              BEQ      |L1.106|
0000d6  f8da0010          LDR      r0,[r10,#0x10]        ;597  ; tcp_bound_pcbs
0000da  42a0              CMP      r0,r4                 ;597
0000dc  d10a              BNE      |L1.244|
0000de  68c0              LDR      r0,[r0,#0xc]          ;597
0000e0  f8ca0010          STR      r0,[r10,#0x10]        ;597  ; tcp_bound_pcbs
0000e4  e008              B        |L1.248|
                  |L1.230|
0000e6  68c1              LDR      r1,[r0,#0xc]          ;597
0000e8  42a1              CMP      r1,r4                 ;597
0000ea  d102              BNE      |L1.242|
0000ec  68e1              LDR      r1,[r4,#0xc]          ;597
0000ee  60c1              STR      r1,[r0,#0xc]          ;597
0000f0  e002              B        |L1.248|
                  |L1.242|
0000f2  4608              MOV      r0,r1                 ;597
                  |L1.244|
0000f4  2800              CMP      r0,#0                 ;597
0000f6  d1f6              BNE      |L1.230|
                  |L1.248|
0000f8  2000              MOVS     r0,#0                 ;597
0000fa  60e0              STR      r0,[r4,#0xc]          ;597
0000fc  e7b5              B        |L1.106|
                  |L1.254|
;;;623      }
;;;624    }
0000fe  e8bd9fff          POP      {r0-r12,pc}
;;;625    
                          ENDP

000102  0000              DCW      0x0000
                  |L1.260|
000104  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000108  6964646c
00010c  65776172
000110  65735c54
000114  68697264
000118  5f506172
00011c  74795c4c
000120  7749505c
000124  7372635c
000128  636f7265
00012c  5c746370
000130  2e6300  
000133  00                DCB      0
                  |L1.308|
000134  7463705f          DCB      "tcp_abandon: invalid pcb",0
000138  6162616e
00013c  646f6e3a
000140  20696e76
000144  616c6964
000148  20706362
00014c  00      
00014d  00                DCB      0
00014e  00                DCB      0
00014f  00                DCB      0
                  |L1.336|
000150  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000154  7274696f
000158  6e202225
00015c  73222066
000160  61696c65
000164  64206174
000168  206c696e
00016c  65202564
000170  20696e20
000174  25730a00
                  |L1.376|
000178  646f6e27          DCB      "don't call tcp_abort/tcp_abandon for listen-pcbs",0
00017c  74206361
000180  6c6c2074
000184  63705f61
000188  626f7274
00018c  2f746370
000190  5f616261
000194  6e646f6e
000198  20666f72
00019c  206c6973
0001a0  74656e2d
0001a4  70636273
0001a8  00      
0001a9  00                DCB      0
0001aa  00                DCB      0
0001ab  00                DCB      0
                  |L1.428|
                          DCD      ||.data||

                          AREA ||i.tcp_abort||, CODE, READONLY, ALIGN=1

                  tcp_abort PROC
;;;637    void
;;;638    tcp_abort(struct tcp_pcb *pcb)
000000  2101              MOVS     r1,#1
;;;639    {
;;;640      tcp_abandon(pcb, 1);
000002  f7ffbffe          B.W      tcp_abandon
;;;641    }
;;;642    
                          ENDP


                          AREA ||i.tcp_accept||, CODE, READONLY, ALIGN=1

                  tcp_accept PROC
;;;2075   void
;;;2076   tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept)
000000  2800              CMP      r0,#0
;;;2077   {
000002  d003              BEQ      |L3.12|
;;;2078     LWIP_ASSERT_CORE_LOCKED();
;;;2079     if ((pcb != NULL) && (pcb->state == LISTEN)) {
000004  7d02              LDRB     r2,[r0,#0x14]
000006  2a01              CMP      r2,#1
000008  d100              BNE      |L3.12|
;;;2080       struct tcp_pcb_listen *lpcb = (struct tcp_pcb_listen *)pcb;
;;;2081       lpcb->accept = accept;
00000a  6181              STR      r1,[r0,#0x18]
                  |L3.12|
;;;2082     }
;;;2083   }
00000c  4770              BX       lr
;;;2084   #endif /* LWIP_CALLBACK_API */
                          ENDP


                          AREA ||i.tcp_accept_null||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_accept_null PROC
;;;777    static err_t
;;;778    tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
000000  b510              PUSH     {r4,lr}
;;;779    {
000002  460c              MOV      r4,r1
;;;780      LWIP_UNUSED_ARG(arg);
;;;781      LWIP_UNUSED_ARG(err);
;;;782    
;;;783      LWIP_ASSERT("tcp_accept_null: invalid pcb", pcb != NULL);
000004  2c00              CMP      r4,#0
000006  d106              BNE      |L4.22|
000008  a306              ADR      r3,|L4.36|
00000a  f240320f          MOV      r2,#0x30f
00000e  a111              ADR      r1,|L4.84|
000010  a018              ADR      r0,|L4.116|
000012  f7fffffe          BL       __2printf
                  |L4.22|
;;;784    
;;;785      tcp_abort(pcb);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       tcp_abort
;;;786    
;;;787      return ERR_ABRT;
00001c  f06f000c          MVN      r0,#0xc
;;;788    }
000020  bd10              POP      {r4,pc}
;;;789    #endif /* LWIP_CALLBACK_API */
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
000024  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000028  6964646c
00002c  65776172
000030  65735c54
000034  68697264
000038  5f506172
00003c  74795c4c
000040  7749505c
000044  7372635c
000048  636f7265
00004c  5c746370
000050  2e6300  
000053  00                DCB      0
                  |L4.84|
000054  7463705f          DCB      "tcp_accept_null: invalid pcb",0
000058  61636365
00005c  70745f6e
000060  756c6c3a
000064  20696e76
000068  616c6964
00006c  20706362
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L4.116|
000074  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000078  7274696f
00007c  6e202225
000080  73222066
000084  61696c65
000088  64206174
00008c  206c696e
000090  65202564
000094  20696e20
000098  25730a00

                          AREA ||i.tcp_alloc||, CODE, READONLY, ALIGN=2

                  tcp_alloc PROC
;;;1833   struct tcp_pcb *
;;;1834   tcp_alloc(u8_t prio)
000000  b570              PUSH     {r4-r6,lr}
;;;1835   {
000002  4605              MOV      r5,r0
;;;1836     struct tcp_pcb *pcb;
;;;1837   
;;;1838     LWIP_ASSERT_CORE_LOCKED();
;;;1839   
;;;1840     pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       memp_malloc
00000a  4604              MOV      r4,r0
;;;1841     if (pcb == NULL) {
00000c  b9fc              CBNZ     r4,|L5.78|
;;;1842       /* Try to send FIN for all pcbs stuck in TF_CLOSEPEND first */
;;;1843       tcp_handle_closepend();
00000e  f7fffffe          BL       tcp_handle_closepend
;;;1844   
;;;1845       /* Try killing oldest connection in TIME-WAIT. */
;;;1846       LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
;;;1847       tcp_kill_timewait();
000012  f7fffffe          BL       tcp_kill_timewait
;;;1848       /* Try to allocate a tcp_pcb again. */
;;;1849       pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       memp_malloc
00001c  4604              MOV      r4,r0
;;;1850       if (pcb == NULL) {
00001e  b9b4              CBNZ     r4,|L5.78|
;;;1851         /* Try killing oldest connection in LAST-ACK (these wouldn't go to TIME-WAIT). */
;;;1852         LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest LAST-ACK connection\n"));
;;;1853         tcp_kill_state(LAST_ACK);
000020  2009              MOVS     r0,#9
000022  f7fffffe          BL       tcp_kill_state
;;;1854         /* Try to allocate a tcp_pcb again. */
;;;1855         pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       memp_malloc
00002c  4604              MOV      r4,r0
;;;1856         if (pcb == NULL) {
00002e  b974              CBNZ     r4,|L5.78|
;;;1857           /* Try killing oldest connection in CLOSING. */
;;;1858           LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest CLOSING connection\n"));
;;;1859           tcp_kill_state(CLOSING);
000030  2008              MOVS     r0,#8
000032  f7fffffe          BL       tcp_kill_state
;;;1860           /* Try to allocate a tcp_pcb again. */
;;;1861           pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       memp_malloc
00003c  4604              MOV      r4,r0
;;;1862           if (pcb == NULL) {
00003e  b934              CBNZ     r4,|L5.78|
;;;1863             /* Try killing oldest active connection with lower priority than the new one. */
;;;1864             LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing oldest connection with prio lower than %d\n", prio));
;;;1865             tcp_kill_prio(prio);
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       tcp_kill_prio
;;;1866             /* Try to allocate a tcp_pcb again. */
;;;1867             pcb = (struct tcp_pcb *)memp_malloc(MEMP_TCP_PCB);
000046  2001              MOVS     r0,#1
000048  f7fffffe          BL       memp_malloc
00004c  4604              MOV      r4,r0
                  |L5.78|
;;;1868             if (pcb != NULL) {
;;;1869               /* adjust err stats: memp_malloc failed multiple times before */
;;;1870               MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1871             }
;;;1872           }
;;;1873           if (pcb != NULL) {
;;;1874             /* adjust err stats: memp_malloc failed multiple times before */
;;;1875             MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1876           }
;;;1877         }
;;;1878         if (pcb != NULL) {
;;;1879           /* adjust err stats: memp_malloc failed multiple times before */
;;;1880           MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1881         }
;;;1882       }
;;;1883       if (pcb != NULL) {
;;;1884         /* adjust err stats: memp_malloc failed above */
;;;1885         MEMP_STATS_DEC(err, MEMP_TCP_PCB);
;;;1886       }
;;;1887     }
;;;1888     if (pcb != NULL) {
00004e  b324              CBZ      r4,|L5.154|
;;;1889       /* zero out the whole pcb, so there is no need to initialize members to zero */
;;;1890       memset(pcb, 0, sizeof(struct tcp_pcb));
000050  219c              MOVS     r1,#0x9c
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       __aeabi_memclr4
;;;1891       pcb->prio = prio;
000058  340c              ADDS     r4,r4,#0xc
00005a  7265              STRB     r5,[r4,#9]
;;;1892       pcb->snd_buf = TCP_SND_BUF;
00005c  f44f6186          MOV      r1,#0x430
000060  f8a41058          STRH     r1,[r4,#0x58]
;;;1893       /* Start with a window that does not need scaling. When window scaling is
;;;1894          enabled and used, the window is enlarged when both sides agree on scaling. */
;;;1895       pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
000064  0048              LSLS     r0,r1,#1
000066  83e0              STRH     r0,[r4,#0x1e]
000068  83a0              STRH     r0,[r4,#0x1c]
;;;1896       pcb->ttl = TCP_TTL;
00006a  20ff              MOVS     r0,#0xff
00006c  f8040c01          STRB     r0,[r4,#-1]
;;;1897       /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;1898          The send MSS is updated when an MSS option is received. */
;;;1899       pcb->mss = INITIAL_MSS;
000070  1048              ASRS     r0,r1,#1
000072  84e0              STRH     r0,[r4,#0x26]
;;;1900       pcb->rto = 3000 / TCP_SLOW_INTERVAL;
000074  2006              MOVS     r0,#6
000076  86a0              STRH     r0,[r4,#0x34]
;;;1901       pcb->sv = 3000 / TCP_SLOW_INTERVAL;
000078  8660              STRH     r0,[r4,#0x32]
;;;1902       pcb->rtime = -1;
00007a  1fc0              SUBS     r0,r0,#7
00007c  84a0              STRH     r0,[r4,#0x24]
;;;1903       pcb->cwnd = 1;
00007e  2001              MOVS     r0,#1
000080  87a0              STRH     r0,[r4,#0x3c]
;;;1904       pcb->tmr = tcp_ticks;
000082  4807              LDR      r0,|L5.160|
000084  68c2              LDR      r2,[r0,#0xc]  ; tcp_ticks
000086  6162              STR      r2,[r4,#0x14]
;;;1905       pcb->last_timer = tcp_timer_ctr;
000088  7880              LDRB     r0,[r0,#2]  ; tcp_timer_ctr
00008a  74a0              STRB     r0,[r4,#0x12]
;;;1906   
;;;1907       /* RFC 5681 recommends setting ssthresh abritrarily high and gives an example
;;;1908       of using the largest advertised receive window.  We've seen complications with
;;;1909       receiving TCPs that use window scaling and/or window auto-tuning where the
;;;1910       initial advertised window is very small and then grows rapidly once the
;;;1911       connection is established. To avoid these complications, we set ssthresh to the
;;;1912       largest effective cwnd (amount of in-flight data) that the sender can have. */
;;;1913       pcb->ssthresh = TCP_SND_BUF;
00008c  87e1              STRH     r1,[r4,#0x3e]
;;;1914   
;;;1915   #if LWIP_CALLBACK_API
;;;1916       pcb->recv = tcp_recv_null;
00008e  4805              LDR      r0,|L5.164|
000090  67a0              STR      r0,[r4,#0x78]
;;;1917   #endif /* LWIP_CALLBACK_API */
;;;1918   
;;;1919       /* Init KEEPALIVE timer */
;;;1920       pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
000092  4805              LDR      r0,|L5.168|
000094  f8c40088          STR      r0,[r4,#0x88]
000098  3c0c              SUBS     r4,r4,#0xc
                  |L5.154|
;;;1921   
;;;1922   #if LWIP_TCP_KEEPALIVE
;;;1923       pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
;;;1924       pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
;;;1925   #endif /* LWIP_TCP_KEEPALIVE */
;;;1926     }
;;;1927     return pcb;
00009a  4620              MOV      r0,r4
;;;1928   }
00009c  bd70              POP      {r4-r6,pc}
;;;1929   
                          ENDP

00009e  0000              DCW      0x0000
                  |L5.160|
                          DCD      ||.data||
                  |L5.164|
                          DCD      tcp_recv_null
                  |L5.168|
                          DCD      0x006ddd00

                          AREA ||i.tcp_arg||, CODE, READONLY, ALIGN=1

                  tcp_arg PROC
;;;1987   void
;;;1988   tcp_arg(struct tcp_pcb *pcb, void *arg)
000000  2800              CMP      r0,#0
;;;1989   {
000002  d000              BEQ      |L6.6|
;;;1990     LWIP_ASSERT_CORE_LOCKED();
;;;1991     /* This function is allowed to be called for both listen pcbs and
;;;1992        connection pcbs. */
;;;1993     if (pcb != NULL) {
;;;1994       pcb->callback_arg = arg;
000004  6101              STR      r1,[r0,#0x10]
                  |L6.6|
;;;1995     }
;;;1996   }
000006  4770              BX       lr
;;;1997   #if LWIP_CALLBACK_API
                          ENDP


                          AREA ||i.tcp_bind||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_bind PROC
;;;660    err_t
;;;661    tcp_bind(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;662    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;663      int i;
;;;664      int max_pcb_list = NUM_TCP_PCB_LISTS;
000008  2004              MOVS     r0,#4
;;;665      struct tcp_pcb *cpcb;
;;;666    #if LWIP_IPV6 && LWIP_IPV6_SCOPES
;;;667      ip_addr_t zoned_ipaddr;
;;;668    #endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */
;;;669    
;;;670      LWIP_ASSERT_CORE_LOCKED();
;;;671    
;;;672    #if LWIP_IPV4
;;;673      /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
;;;674      if (ipaddr == NULL) {
00000a  2c00              CMP      r4,#0
00000c  d100              BNE      |L7.16|
;;;675        ipaddr = IP4_ADDR_ANY;
00000e  4c26              LDR      r4,|L7.168|
                  |L7.16|
;;;676      }
;;;677    #else /* LWIP_IPV4 */
;;;678      LWIP_ERROR("tcp_bind: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
;;;679    #endif /* LWIP_IPV4 */
;;;680    
;;;681      LWIP_ERROR("tcp_bind: invalid pcb", pcb != NULL, return ERR_ARG);
000010  2f00              CMP      r7,#0
000012  d00d              BEQ      |L7.48|
;;;682    
;;;683      LWIP_ERROR("tcp_bind: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_VAL);
000014  7d39              LDRB     r1,[r7,#0x14]
000016  2900              CMP      r1,#0
000018  d014              BEQ      |L7.68|
00001a  a324              ADR      r3,|L7.172|
00001c  f24022ab          MOV      r2,#0x2ab
000020  a12e              ADR      r1,|L7.220|
000022  a038              ADR      r0,|L7.260|
000024  f7fffffe          BL       __2printf
000028  f06f0005          MVN      r0,#5
                  |L7.44|
;;;684    
;;;685    #if SO_REUSE
;;;686      /* Unless the REUSEADDR flag is set,
;;;687         we have to check the pcbs in TIME-WAIT state, also.
;;;688         We do not dump TIME_WAIT pcb's; they can still be matched by incoming
;;;689         packets using both local and remote IP addresses and ports to distinguish.
;;;690       */
;;;691      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;692        max_pcb_list = NUM_TCP_PCB_LISTS_NO_TIME_WAIT;
;;;693      }
;;;694    #endif /* SO_REUSE */
;;;695    
;;;696    #if LWIP_IPV6 && LWIP_IPV6_SCOPES
;;;697      /* If the given IP address should have a zone but doesn't, assign one now.
;;;698       * This is legacy support: scope-aware callers should always provide properly
;;;699       * zoned source addresses. Do the zone selection before the address-in-use
;;;700       * check below; as such we have to make a temporary copy of the address. */
;;;701      if (IP_IS_V6(ipaddr) && ip6_addr_lacks_zone(ip_2_ip6(ipaddr), IP6_UNICAST)) {
;;;702        ip_addr_copy(zoned_ipaddr, *ipaddr);
;;;703        ip6_addr_select_zone(ip_2_ip6(&zoned_ipaddr), ip_2_ip6(&zoned_ipaddr));
;;;704        ipaddr = &zoned_ipaddr;
;;;705      }
;;;706    #endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */
;;;707    
;;;708      if (port == 0) {
;;;709        port = tcp_new_port();
;;;710        if (port == 0) {
;;;711          return ERR_BUF;
;;;712        }
;;;713      } else {
;;;714        /* Check if the address already is in use (on all lists) */
;;;715        for (i = 0; i < max_pcb_list; i++) {
;;;716          for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;717            if (cpcb->local_port == port) {
;;;718    #if SO_REUSE
;;;719              /* Omit checking for the same port if both pcbs have REUSEADDR set.
;;;720                 For SO_REUSEADDR, the duplicate-check for a 5-tuple is done in
;;;721                 tcp_connect. */
;;;722              if (!ip_get_option(pcb, SOF_REUSEADDR) ||
;;;723                  !ip_get_option(cpcb, SOF_REUSEADDR))
;;;724    #endif /* SO_REUSE */
;;;725              {
;;;726                /* @todo: check accept_any_ip_version */
;;;727                if ((IP_IS_V6(ipaddr) == IP_IS_V6_VAL(cpcb->local_ip)) &&
;;;728                    (ip_addr_isany(&cpcb->local_ip) ||
;;;729                     ip_addr_isany(ipaddr) ||
;;;730                     ip_addr_cmp(&cpcb->local_ip, ipaddr))) {
;;;731                  return ERR_USE;
;;;732                }
;;;733              }
;;;734            }
;;;735          }
;;;736        }
;;;737      }
;;;738    
;;;739      if (!ip_addr_isany(ipaddr)
;;;740    #if LWIP_IPV4 && LWIP_IPV6
;;;741          || (IP_GET_TYPE(ipaddr) != IP_GET_TYPE(&pcb->local_ip))
;;;742    #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;743         ) {
;;;744        ip_addr_set(&pcb->local_ip, ipaddr);
;;;745      }
;;;746      pcb->local_port = port;
;;;747      TCP_REG(&tcp_bound_pcbs, pcb);
;;;748      LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
;;;749      return ERR_OK;
;;;750    }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L7.48|
000030  a31e              ADR      r3,|L7.172|
000032  f24022a9          MOV      r2,#0x2a9             ;681
000036  a13d              ADR      r1,|L7.300|
000038  a032              ADR      r0,|L7.260|
00003a  f7fffffe          BL       __2printf
00003e  f06f000f          MVN      r0,#0xf               ;681
000042  e7f3              B        |L7.44|
                  |L7.68|
000044  b11a              CBZ      r2,|L7.78|
000046  2100              MOVS     r1,#0                 ;715
000048  f8dfc0f8          LDR      r12,|L7.324|
00004c  e01c              B        |L7.136|
                  |L7.78|
00004e  f7fffffe          BL       tcp_new_port
000052  4602              MOV      r2,r0                 ;709
000054  0010              MOVS     r0,r2                 ;710
000056  d119              BNE      |L7.140|
000058  1e80              SUBS     r0,r0,#2              ;711
00005a  e7e7              B        |L7.44|
                  |L7.92|
00005c  f85c3021          LDR      r3,[r12,r1,LSL #2]    ;716
000060  681b              LDR      r3,[r3,#0]            ;716
000062  e00e              B        |L7.130|
                  |L7.100|
000064  8add              LDRH     r5,[r3,#0x16]         ;717
000066  4295              CMP      r5,r2                 ;717
000068  d10a              BNE      |L7.128|
00006a  b133              CBZ      r3,|L7.122|
00006c  681d              LDR      r5,[r3,#0]            ;728
00006e  b125              CBZ      r5,|L7.122|
000070  b11c              CBZ      r4,|L7.122|
000072  6826              LDR      r6,[r4,#0]            ;729
000074  b10e              CBZ      r6,|L7.122|
000076  42b5              CMP      r5,r6                 ;730
000078  d102              BNE      |L7.128|
                  |L7.122|
00007a  f06f0007          MVN      r0,#7                 ;731
00007e  e7d5              B        |L7.44|
                  |L7.128|
000080  68db              LDR      r3,[r3,#0xc]          ;716
                  |L7.130|
000082  2b00              CMP      r3,#0                 ;716
000084  d1ee              BNE      |L7.100|
000086  1c49              ADDS     r1,r1,#1              ;715
                  |L7.136|
000088  4281              CMP      r1,r0                 ;715
00008a  dbe7              BLT      |L7.92|
                  |L7.140|
00008c  b114              CBZ      r4,|L7.148|
00008e  6820              LDR      r0,[r4,#0]            ;739
000090  b100              CBZ      r0,|L7.148|
000092  6038              STR      r0,[r7,#0]            ;744
                  |L7.148|
000094  82fa              STRH     r2,[r7,#0x16]         ;746
000096  482c              LDR      r0,|L7.328|
000098  6901              LDR      r1,[r0,#0x10]         ;747  ; tcp_bound_pcbs
00009a  60f9              STR      r1,[r7,#0xc]          ;747
00009c  6107              STR      r7,[r0,#0x10]         ;747  ; tcp_bound_pcbs
00009e  f7fffffe          BL       tcp_timer_needed
0000a2  2000              MOVS     r0,#0                 ;749
0000a4  e7c2              B        |L7.44|
;;;751    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L7.168|
                          DCD      ip_addr_any
                  |L7.172|
0000ac  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
0000b0  6964646c
0000b4  65776172
0000b8  65735c54
0000bc  68697264
0000c0  5f506172
0000c4  74795c4c
0000c8  7749505c
0000cc  7372635c
0000d0  636f7265
0000d4  5c746370
0000d8  2e6300  
0000db  00                DCB      0
                  |L7.220|
0000dc  7463705f          DCB      "tcp_bind: can only bind in state CLOSED",0
0000e0  62696e64
0000e4  3a206361
0000e8  6e206f6e
0000ec  6c792062
0000f0  696e6420
0000f4  696e2073
0000f8  74617465
0000fc  20434c4f
000100  53454400
                  |L7.260|
000104  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000108  7274696f
00010c  6e202225
000110  73222066
000114  61696c65
000118  64206174
00011c  206c696e
000120  65202564
000124  20696e20
000128  25730a00
                  |L7.300|
00012c  7463705f          DCB      "tcp_bind: invalid pcb",0
000130  62696e64
000134  3a20696e
000138  76616c69
00013c  64207063
000140  6200    
000142  00                DCB      0
000143  00                DCB      0
                  |L7.324|
                          DCD      ||.constdata||+0x44
                  |L7.328|
                          DCD      ||.data||

                          AREA ||i.tcp_bind_netif||, CODE, READONLY, ALIGN=1

                  tcp_bind_netif PROC
;;;762    void
;;;763    tcp_bind_netif(struct tcp_pcb *pcb, const struct netif *netif)
000000  2900              CMP      r1,#0
;;;764    {
000002  d004              BEQ      |L8.14|
;;;765      LWIP_ASSERT_CORE_LOCKED();
;;;766      if (netif != NULL) {
;;;767        pcb->netif_idx = netif_get_index(netif);
000004  f8911038          LDRB     r1,[r1,#0x38]
000008  1c49              ADDS     r1,r1,#1
00000a  7201              STRB     r1,[r0,#8]
;;;768      } else {
;;;769        pcb->netif_idx = NETIF_NO_INDEX;
;;;770      }
;;;771    }
00000c  4770              BX       lr
                  |L8.14|
00000e  2100              MOVS     r1,#0                 ;769
000010  7201              STRB     r1,[r0,#8]            ;769
000012  4770              BX       lr
;;;772    
                          ENDP


                          AREA ||i.tcp_close||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_close PROC
;;;483    err_t
;;;484    tcp_close(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;485    {
;;;486      LWIP_ASSERT_CORE_LOCKED();
;;;487    
;;;488      LWIP_ERROR("tcp_close: invalid pcb", pcb != NULL, return ERR_ARG);
000002  2800              CMP      r0,#0
000004  d00b              BEQ      |L9.30|
;;;489      LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
;;;490    
;;;491      tcp_debug_print_state(pcb->state);
;;;492    
;;;493      if (pcb->state != LISTEN) {
000006  7d01              LDRB     r1,[r0,#0x14]
000008  2901              CMP      r1,#1
00000a  d003              BEQ      |L9.20|
;;;494        /* Set a flag not to receive any more data... */
;;;495        tcp_set_flags(pcb, TF_RXCLOSED);
00000c  8b41              LDRH     r1,[r0,#0x1a]
00000e  f0410110          ORR      r1,r1,#0x10
000012  8341              STRH     r1,[r0,#0x1a]
                  |L9.20|
;;;496      }
;;;497      /* ... and close */
;;;498      return tcp_close_shutdown(pcb, 1);
000014  e8bd4010          POP      {r4,lr}
000018  2101              MOVS     r1,#1
00001a  f7ffbffe          B.W      tcp_close_shutdown
                  |L9.30|
00001e  a305              ADR      r3,|L9.52|
000020  f44f72f4          MOV      r2,#0x1e8             ;488
000024  a10f              ADR      r1,|L9.100|
000026  a015              ADR      r0,|L9.124|
000028  f7fffffe          BL       __2printf
00002c  f06f000f          MVN      r0,#0xf               ;488
;;;499    }
000030  bd10              POP      {r4,pc}
;;;500    
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
000034  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000038  6964646c
00003c  65776172
000040  65735c54
000044  68697264
000048  5f506172
00004c  74795c4c
000050  7749505c
000054  7372635c
000058  636f7265
00005c  5c746370
000060  2e6300  
000063  00                DCB      0
                  |L9.100|
000064  7463705f          DCB      "tcp_close: invalid pcb",0
000068  636c6f73
00006c  653a2069
000070  6e76616c
000074  69642070
000078  636200  
00007b  00                DCB      0
                  |L9.124|
00007c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000080  7274696f
000084  6e202225
000088  73222066
00008c  61696c65
000090  64206174
000094  206c696e
000098  65202564
00009c  20696e20
0000a0  25730a00

                          AREA ||i.tcp_close_shutdown||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_close_shutdown PROC
;;;347    static err_t
;;;348    tcp_close_shutdown(struct tcp_pcb *pcb, u8_t rst_on_unacked_data)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;349    {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;350      LWIP_ASSERT("tcp_close_shutdown: invalid pcb", pcb != NULL);
000008  2c00              CMP      r4,#0
00000a  d106              BNE      |L10.26|
00000c  a343              ADR      r3,|L10.284|
00000e  f44f72af          MOV      r2,#0x15e
000012  a14e              ADR      r1,|L10.332|
000014  a055              ADR      r0,|L10.364|
000016  f7fffffe          BL       __2printf
                  |L10.26|
;;;351    
;;;352      if (rst_on_unacked_data && ((pcb->state == ESTABLISHED) || (pcb->state == CLOSE_WAIT))) {
00001a  2500              MOVS     r5,#0
;;;353        if ((pcb->refused_data != NULL) || (pcb->rcv_wnd != TCP_WND_MAX(pcb))) {
;;;354          /* Not all data received by application, send RST to tell the remote
;;;355             side about this. */
;;;356          LWIP_ASSERT("pcb->flags & TF_RXCLOSED", pcb->flags & TF_RXCLOSED);
;;;357    
;;;358          /* don't call tcp_abort here: we must not deallocate the pcb since
;;;359             that might not be expected when calling tcp_close */
;;;360          tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
;;;361                  pcb->local_port, pcb->remote_port);
;;;362    
;;;363          tcp_pcb_purge(pcb);
;;;364          TCP_RMV_ACTIVE(pcb);
00001c  2701              MOVS     r7,#1
00001e  4e5d              LDR      r6,|L10.404|
000020  f1b80f00          CMP      r8,#0                 ;352
000024  d041              BEQ      |L10.170|
000026  7d20              LDRB     r0,[r4,#0x14]         ;352
000028  2804              CMP      r0,#4                 ;352
00002a  d001              BEQ      |L10.48|
00002c  2807              CMP      r0,#7                 ;352
00002e  d13c              BNE      |L10.170|
                  |L10.48|
000030  6fa0              LDR      r0,[r4,#0x78]         ;353
000032  b918              CBNZ     r0,|L10.60|
000034  8d20              LDRH     r0,[r4,#0x28]         ;353
000036  f5b06f06          CMP      r0,#0x860             ;353
00003a  d036              BEQ      |L10.170|
                  |L10.60|
00003c  7ea0              LDRB     r0,[r4,#0x1a]         ;356
00003e  06c0              LSLS     r0,r0,#27             ;356
000040  d406              BMI      |L10.80|
000042  a336              ADR      r3,|L10.284|
000044  f44f72b2          MOV      r2,#0x164             ;356
000048  a153              ADR      r1,|L10.408|
00004a  a048              ADR      r0,|L10.364|
00004c  f7fffffe          BL       __2printf
                  |L10.80|
000050  8ae1              LDRH     r1,[r4,#0x16]         ;360
000052  8b20              LDRH     r0,[r4,#0x18]         ;360
000054  1d22              ADDS     r2,r4,#4              ;360
000056  e9cd2100          STRD     r2,r1,[sp,#0]         ;360
00005a  9002              STR      r0,[sp,#8]            ;360
00005c  4623              MOV      r3,r4                 ;360
00005e  4620              MOV      r0,r4                 ;360
000060  6a62              LDR      r2,[r4,#0x24]         ;360
000062  6d21              LDR      r1,[r4,#0x50]         ;360
000064  f7fffffe          BL       tcp_rst
000068  4620              MOV      r0,r4                 ;363
00006a  f7fffffe          BL       tcp_pcb_purge
00006e  69b0              LDR      r0,[r6,#0x18]  ; tcp_active_pcbs
000070  42a0              CMP      r0,r4
000072  d109              BNE      |L10.136|
000074  68c0              LDR      r0,[r0,#0xc]
000076  61b0              STR      r0,[r6,#0x18]  ; tcp_active_pcbs
000078  e008              B        |L10.140|
                  |L10.122|
00007a  68c1              LDR      r1,[r0,#0xc]
00007c  42a1              CMP      r1,r4
00007e  d102              BNE      |L10.134|
000080  68e1              LDR      r1,[r4,#0xc]
000082  60c1              STR      r1,[r0,#0xc]
000084  e002              B        |L10.140|
                  |L10.134|
000086  4608              MOV      r0,r1
                  |L10.136|
000088  2800              CMP      r0,#0
00008a  d1f6              BNE      |L10.122|
                  |L10.140|
00008c  60e5              STR      r5,[r4,#0xc]
00008e  7037              STRB     r7,[r6,#0]
;;;365          /* Deallocate the pcb since we already sent a RST for it */
;;;366          if (tcp_input_pcb == pcb) {
000090  4848              LDR      r0,|L10.436|
000092  6800              LDR      r0,[r0,#0]  ; tcp_input_pcb
000094  42a0              CMP      r0,r4
000096  d102              BNE      |L10.158|
;;;367            /* prevent using a deallocated pcb: free it from tcp_input later */
;;;368            tcp_trigger_input_pcb_close();
000098  f7fffffe          BL       tcp_trigger_input_pcb_close
00009c  e002              B        |L10.164|
                  |L10.158|
;;;369          } else {
;;;370            tcp_free(pcb);
00009e  4620              MOV      r0,r4
0000a0  f7fffffe          BL       tcp_free
                  |L10.164|
;;;371          }
;;;372          return ERR_OK;
0000a4  2000              MOVS     r0,#0
                  |L10.166|
;;;373        }
;;;374      }
;;;375    
;;;376      /* - states which free the pcb are handled here,
;;;377         - states which send FIN and change state are handled in tcp_close_shutdown_fin() */
;;;378      switch (pcb->state) {
;;;379        case CLOSED:
;;;380          /* Closing a pcb in the CLOSED state might seem erroneous,
;;;381           * however, it is in this state once allocated and as yet unused
;;;382           * and the user needs some way to free it should the need arise.
;;;383           * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
;;;384           * or for a pcb that has been used and then entered the CLOSED state
;;;385           * is erroneous, but this should never happen as the pcb has in those cases
;;;386           * been freed, and so any remaining handles are bogus. */
;;;387          if (pcb->local_port != 0) {
;;;388            TCP_RMV(&tcp_bound_pcbs, pcb);
;;;389          }
;;;390          tcp_free(pcb);
;;;391          break;
;;;392        case LISTEN:
;;;393          tcp_listen_closed(pcb);
;;;394          tcp_pcb_remove(&tcp_listen_pcbs.pcbs, pcb);
;;;395          tcp_free_listen(pcb);
;;;396          break;
;;;397        case SYN_SENT:
;;;398          TCP_PCB_REMOVE_ACTIVE(pcb);
;;;399          tcp_free(pcb);
;;;400          MIB2_STATS_INC(mib2.tcpattemptfails);
;;;401          break;
;;;402        default:
;;;403          return tcp_close_shutdown_fin(pcb);
;;;404      }
;;;405      return ERR_OK;
;;;406    }
0000a6  e8bd83fe          POP      {r1-r9,pc}
                  |L10.170|
0000aa  7d20              LDRB     r0,[r4,#0x14]         ;378
0000ac  b140              CBZ      r0,|L10.192|
0000ae  2801              CMP      r0,#1                 ;378
0000b0  d01c              BEQ      |L10.236|
0000b2  2802              CMP      r0,#2                 ;378
0000b4  d026              BEQ      |L10.260|
0000b6  4620              MOV      r0,r4                 ;403
0000b8  e8bd43fe          POP      {r1-r9,lr}            ;403
0000bc  f7ffbffe          B.W      tcp_close_shutdown_fin
                  |L10.192|
0000c0  8ae0              LDRH     r0,[r4,#0x16]         ;387
0000c2  b178              CBZ      r0,|L10.228|
0000c4  6930              LDR      r0,[r6,#0x10]         ;388  ; tcp_bound_pcbs
0000c6  42a0              CMP      r0,r4                 ;388
0000c8  d109              BNE      |L10.222|
0000ca  68c0              LDR      r0,[r0,#0xc]          ;388
0000cc  6130              STR      r0,[r6,#0x10]         ;388  ; tcp_bound_pcbs
0000ce  e008              B        |L10.226|
                  |L10.208|
0000d0  68c1              LDR      r1,[r0,#0xc]          ;388
0000d2  42a1              CMP      r1,r4                 ;388
0000d4  d102              BNE      |L10.220|
0000d6  68e1              LDR      r1,[r4,#0xc]          ;388
0000d8  60c1              STR      r1,[r0,#0xc]          ;388
0000da  e002              B        |L10.226|
                  |L10.220|
0000dc  4608              MOV      r0,r1                 ;388
                  |L10.222|
0000de  2800              CMP      r0,#0                 ;388
0000e0  d1f6              BNE      |L10.208|
                  |L10.226|
0000e2  60e5              STR      r5,[r4,#0xc]          ;388
                  |L10.228|
0000e4  4620              MOV      r0,r4                 ;390
0000e6  f7fffffe          BL       tcp_free
0000ea  e014              B        |L10.278|
                  |L10.236|
0000ec  4620              MOV      r0,r4                 ;393
0000ee  f7fffffe          BL       tcp_listen_closed
0000f2  4828              LDR      r0,|L10.404|
0000f4  4621              MOV      r1,r4                 ;394
0000f6  3014              ADDS     r0,r0,#0x14           ;394
0000f8  f7fffffe          BL       tcp_pcb_remove
0000fc  4620              MOV      r0,r4                 ;395
0000fe  f7fffffe          BL       tcp_free_listen
000102  e008              B        |L10.278|
                  |L10.260|
000104  4823              LDR      r0,|L10.404|
000106  4621              MOV      r1,r4                 ;398
000108  3018              ADDS     r0,r0,#0x18           ;398
00010a  f7fffffe          BL       tcp_pcb_remove
00010e  7037              STRB     r7,[r6,#0]            ;398
000110  4620              MOV      r0,r4                 ;399
000112  f7fffffe          BL       tcp_free
                  |L10.278|
000116  2000              MOVS     r0,#0                 ;405
000118  e7c5              B        |L10.166|
;;;407    
                          ENDP

00011a  0000              DCW      0x0000
                  |L10.284|
00011c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000120  6964646c
000124  65776172
000128  65735c54
00012c  68697264
000130  5f506172
000134  74795c4c
000138  7749505c
00013c  7372635c
000140  636f7265
000144  5c746370
000148  2e6300  
00014b  00                DCB      0
                  |L10.332|
00014c  7463705f          DCB      "tcp_close_shutdown: invalid pcb",0
000150  636c6f73
000154  655f7368
000158  7574646f
00015c  776e3a20
000160  696e7661
000164  6c696420
000168  70636200
                  |L10.364|
00016c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000170  7274696f
000174  6e202225
000178  73222066
00017c  61696c65
000180  64206174
000184  206c696e
000188  65202564
00018c  20696e20
000190  25730a00
                  |L10.404|
                          DCD      ||.data||
                  |L10.408|
000198  7063622d          DCB      "pcb->flags & TF_RXCLOSED",0
00019c  3e666c61
0001a0  67732026
0001a4  2054465f
0001a8  5258434c
0001ac  4f534544
0001b0  00      
0001b1  00                DCB      0
0001b2  00                DCB      0
0001b3  00                DCB      0
                  |L10.436|
                          DCD      tcp_input_pcb

                          AREA ||i.tcp_close_shutdown_fin||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_close_shutdown_fin PROC
;;;408    static err_t
;;;409    tcp_close_shutdown_fin(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;410    {
000002  4605              MOV      r5,r0
;;;411      err_t err;
;;;412      LWIP_ASSERT("pcb != NULL", pcb != NULL);
000004  2d00              CMP      r5,#0
000006  d106              BNE      |L11.22|
000008  a31a              ADR      r3,|L11.116|
00000a  f44f72ce          MOV      r2,#0x19c
00000e  a125              ADR      r1,|L11.164|
000010  a027              ADR      r0,|L11.176|
000012  f7fffffe          BL       __2printf
                  |L11.22|
;;;413    
;;;414      switch (pcb->state) {
000016  7d28              LDRB     r0,[r5,#0x14]
;;;415        case SYN_RCVD:
;;;416          err = tcp_send_fin(pcb);
;;;417          if (err == ERR_OK) {
;;;418            tcp_backlog_accepted(pcb);
;;;419            MIB2_STATS_INC(mib2.tcpattemptfails);
;;;420            pcb->state = FIN_WAIT_1;
000018  2605              MOVS     r6,#5
00001a  2803              CMP      r0,#3                 ;414
00001c  d005              BEQ      |L11.42|
00001e  2804              CMP      r0,#4                 ;414
000020  d00a              BEQ      |L11.56|
000022  2807              CMP      r0,#7                 ;414
000024  d00f              BEQ      |L11.70|
;;;421          }
;;;422          break;
;;;423        case ESTABLISHED:
;;;424          err = tcp_send_fin(pcb);
;;;425          if (err == ERR_OK) {
;;;426            MIB2_STATS_INC(mib2.tcpestabresets);
;;;427            pcb->state = FIN_WAIT_1;
;;;428          }
;;;429          break;
;;;430        case CLOSE_WAIT:
;;;431          err = tcp_send_fin(pcb);
;;;432          if (err == ERR_OK) {
;;;433            MIB2_STATS_INC(mib2.tcpestabresets);
;;;434            pcb->state = LAST_ACK;
;;;435          }
;;;436          break;
;;;437        default:
;;;438          /* Has already been closed, do nothing. */
;;;439          return ERR_OK;
000026  2000              MOVS     r0,#0
;;;440      }
;;;441    
;;;442      if (err == ERR_OK) {
;;;443        /* To ensure all data has been sent when tcp_close returns, we have
;;;444           to make sure tcp_output doesn't fail.
;;;445           Since we don't really have to ensure all data has been sent when tcp_close
;;;446           returns (unsent data is sent from tcp timer functions, also), we don't care
;;;447           for the return value of tcp_output for now. */
;;;448        tcp_output(pcb);
;;;449      } else if (err == ERR_MEM) {
;;;450        /* Mark this pcb for closing. Closing is retried from tcp_tmr. */
;;;451        tcp_set_flags(pcb, TF_CLOSEPEND);
;;;452        /* We have to return ERR_OK from here to indicate to the callers that this
;;;453           pcb should not be used any more as it will be freed soon via tcp_tmr.
;;;454           This is OK here since sending FIN does not guarantee a time frime for
;;;455           actually freeing the pcb, either (it is left in closure states for
;;;456           remote ACK or timeout) */
;;;457        return ERR_OK;
;;;458      }
;;;459      return err;
;;;460    }
000028  bd70              POP      {r4-r6,pc}
                  |L11.42|
00002a  4628              MOV      r0,r5                 ;416
00002c  f7fffffe          BL       tcp_send_fin
000030  4604              MOV      r4,r0                 ;416
000032  b97c              CBNZ     r4,|L11.84|
000034  752e              STRB     r6,[r5,#0x14]         ;420
000036  e00d              B        |L11.84|
                  |L11.56|
000038  4628              MOV      r0,r5                 ;424
00003a  f7fffffe          BL       tcp_send_fin
00003e  4604              MOV      r4,r0                 ;424
000040  b944              CBNZ     r4,|L11.84|
000042  752e              STRB     r6,[r5,#0x14]         ;427
000044  e006              B        |L11.84|
                  |L11.70|
000046  4628              MOV      r0,r5                 ;431
000048  f7fffffe          BL       tcp_send_fin
00004c  4604              MOV      r4,r0                 ;431
00004e  b90c              CBNZ     r4,|L11.84|
000050  2009              MOVS     r0,#9                 ;434
000052  7528              STRB     r0,[r5,#0x14]         ;434
                  |L11.84|
000054  b114              CBZ      r4,|L11.92|
000056  1c60              ADDS     r0,r4,#1              ;449
000058  d005              BEQ      |L11.102|
00005a  e002              B        |L11.98|
                  |L11.92|
00005c  4628              MOV      r0,r5                 ;448
00005e  f7fffffe          BL       tcp_output
                  |L11.98|
000062  4620              MOV      r0,r4                 ;459
000064  bd70              POP      {r4-r6,pc}
                  |L11.102|
000066  8b68              LDRH     r0,[r5,#0x1a]         ;451
000068  f0400008          ORR      r0,r0,#8              ;451
00006c  8368              STRH     r0,[r5,#0x1a]         ;451
00006e  2000              MOVS     r0,#0                 ;457
000070  bd70              POP      {r4-r6,pc}
;;;461    
                          ENDP

000072  0000              DCW      0x0000
                  |L11.116|
000074  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000078  6964646c
00007c  65776172
000080  65735c54
000084  68697264
000088  5f506172
00008c  74795c4c
000090  7749505c
000094  7372635c
000098  636f7265
00009c  5c746370
0000a0  2e6300  
0000a3  00                DCB      0
                  |L11.164|
0000a4  70636220          DCB      "pcb != NULL",0
0000a8  213d204e
0000ac  554c4c00
                  |L11.176|
0000b0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000b4  7274696f
0000b8  6e202225
0000bc  73222066
0000c0  61696c65
0000c4  64206174
0000c8  206c696e
0000cc  65202564
0000d0  20696e20
0000d4  25730a00

                          AREA ||i.tcp_connect||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_connect PROC
;;;1066   err_t
;;;1067   tcp_connect(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1068               tcp_connected_fn connected)
;;;1069   {
000004  4604              MOV      r4,r0
000006  461e              MOV      r6,r3
;;;1070     struct netif *netif = NULL;
;;;1071     err_t ret;
;;;1072     u32_t iss;
;;;1073     u16_t old_local_port;
;;;1074   
;;;1075     LWIP_ASSERT_CORE_LOCKED();
;;;1076   
;;;1077     LWIP_ERROR("tcp_connect: invalid pcb", pcb != NULL, return ERR_ARG);
000008  f06f050f          MVN      r5,#0xf
00000c  2c00              CMP      r4,#0
00000e  d00e              BEQ      |L12.46|
;;;1078     LWIP_ERROR("tcp_connect: invalid ipaddr", ipaddr != NULL, return ERR_ARG);
000010  2900              CMP      r1,#0
000012  d015              BEQ      |L12.64|
;;;1079   
;;;1080     LWIP_ERROR("tcp_connect: can only connect from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
000014  7d20              LDRB     r0,[r4,#0x14]
000016  2800              CMP      r0,#0
000018  d01b              BEQ      |L12.82|
00001a  a346              ADR      r3,|L12.308|
00001c  f44f6287          MOV      r2,#0x438
000020  a150              ADR      r1,|L12.356|
000022  a05c              ADR      r0,|L12.404|
000024  f7fffffe          BL       __2printf
000028  1da8              ADDS     r0,r5,#6
                  |L12.42|
;;;1081   
;;;1082     LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
;;;1083     ip_addr_set(&pcb->remote_ip, ipaddr);
;;;1084     pcb->remote_port = port;
;;;1085   
;;;1086     if (pcb->netif_idx != NETIF_NO_INDEX) {
;;;1087       netif = netif_get_by_index(pcb->netif_idx);
;;;1088     } else {
;;;1089       /* check if we have a route to the remote host */
;;;1090       netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
;;;1091     }
;;;1092     if (netif == NULL) {
;;;1093       /* Don't even try to send a SYN packet if we have no route since that will fail. */
;;;1094       return ERR_RTE;
;;;1095     }
;;;1096   
;;;1097     /* check if local IP has been assigned to pcb, if not, get one */
;;;1098     if (ip_addr_isany(&pcb->local_ip)) {
;;;1099       const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, ipaddr);
;;;1100       if (local_ip == NULL) {
;;;1101         return ERR_RTE;
;;;1102       }
;;;1103       ip_addr_copy(pcb->local_ip, *local_ip);
;;;1104     }
;;;1105   
;;;1106   #if LWIP_IPV6 && LWIP_IPV6_SCOPES
;;;1107     /* If the given IP address should have a zone but doesn't, assign one now.
;;;1108      * Given that we already have the target netif, this is easy and cheap. */
;;;1109     if (IP_IS_V6(&pcb->remote_ip) &&
;;;1110         ip6_addr_lacks_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNICAST)) {
;;;1111       ip6_addr_assign_zone(ip_2_ip6(&pcb->remote_ip), IP6_UNICAST, netif);
;;;1112     }
;;;1113   #endif /* LWIP_IPV6 && LWIP_IPV6_SCOPES */
;;;1114   
;;;1115     old_local_port = pcb->local_port;
;;;1116     if (pcb->local_port == 0) {
;;;1117       pcb->local_port = tcp_new_port();
;;;1118       if (pcb->local_port == 0) {
;;;1119         return ERR_BUF;
;;;1120       }
;;;1121     } else {
;;;1122   #if SO_REUSE
;;;1123       if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;1124         /* Since SOF_REUSEADDR allows reusing a local address, we have to make sure
;;;1125            now that the 5-tuple is unique. */
;;;1126         struct tcp_pcb *cpcb;
;;;1127         int i;
;;;1128         /* Don't check listen- and bound-PCBs, check active- and TIME-WAIT PCBs. */
;;;1129         for (i = 2; i < NUM_TCP_PCB_LISTS; i++) {
;;;1130           for (cpcb = *tcp_pcb_lists[i]; cpcb != NULL; cpcb = cpcb->next) {
;;;1131             if ((cpcb->local_port == pcb->local_port) &&
;;;1132                 (cpcb->remote_port == port) &&
;;;1133                 ip_addr_cmp(&cpcb->local_ip, &pcb->local_ip) &&
;;;1134                 ip_addr_cmp(&cpcb->remote_ip, ipaddr)) {
;;;1135               /* linux returns EISCONN here, but ERR_USE should be OK for us */
;;;1136               return ERR_USE;
;;;1137             }
;;;1138           }
;;;1139         }
;;;1140       }
;;;1141   #endif /* SO_REUSE */
;;;1142     }
;;;1143   
;;;1144     iss = tcp_next_iss(pcb);
;;;1145     pcb->rcv_nxt = 0;
;;;1146     pcb->snd_nxt = iss;
;;;1147     pcb->lastack = iss - 1;
;;;1148     pcb->snd_wl2 = iss - 1;
;;;1149     pcb->snd_lbb = iss - 1;
;;;1150     /* Start with a window that does not need scaling. When window scaling is
;;;1151        enabled and used, the window is enlarged when both sides agree on scaling. */
;;;1152     pcb->rcv_wnd = pcb->rcv_ann_wnd = TCPWND_MIN16(TCP_WND);
;;;1153     pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;1154     pcb->snd_wnd = TCP_WND;
;;;1155     /* As initial send MSS, we use TCP_MSS but limit it to 536.
;;;1156        The send MSS is updated when an MSS option is received. */
;;;1157     pcb->mss = INITIAL_MSS;
;;;1158   #if TCP_CALCULATE_EFF_SEND_MSS
;;;1159     pcb->mss = tcp_eff_send_mss_netif(pcb->mss, netif, &pcb->remote_ip);
;;;1160   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1161     pcb->cwnd = 1;
;;;1162   #if LWIP_CALLBACK_API
;;;1163     pcb->connected = connected;
;;;1164   #else /* LWIP_CALLBACK_API */
;;;1165     LWIP_UNUSED_ARG(connected);
;;;1166   #endif /* LWIP_CALLBACK_API */
;;;1167   
;;;1168     /* Send a SYN together with the MSS option. */
;;;1169     ret = tcp_enqueue_flags(pcb, TCP_SYN);
;;;1170     if (ret == ERR_OK) {
;;;1171       /* SYN segment was enqueued, changed the pcbs state now */
;;;1172       pcb->state = SYN_SENT;
;;;1173       if (old_local_port != 0) {
;;;1174         TCP_RMV(&tcp_bound_pcbs, pcb);
;;;1175       }
;;;1176       TCP_REG_ACTIVE(pcb);
;;;1177       MIB2_STATS_INC(mib2.tcpactiveopens);
;;;1178   
;;;1179       tcp_output(pcb);
;;;1180     }
;;;1181     return ret;
;;;1182   }
00002a  e8bd87f0          POP      {r4-r10,pc}
                  |L12.46|
00002e  a341              ADR      r3,|L12.308|
000030  f2404235          MOV      r2,#0x435             ;1077
000034  a161              ADR      r1,|L12.444|
000036  a057              ADR      r0,|L12.404|
000038  f7fffffe          BL       __2printf
00003c  4628              MOV      r0,r5                 ;1077
00003e  e7f4              B        |L12.42|
                  |L12.64|
000040  a33c              ADR      r3,|L12.308|
000042  f2404236          MOV      r2,#0x436             ;1078
000046  a164              ADR      r1,|L12.472|
000048  a052              ADR      r0,|L12.404|
00004a  f7fffffe          BL       __2printf
00004e  4628              MOV      r0,r5                 ;1078
000050  e7eb              B        |L12.42|
                  |L12.82|
000052  6808              LDR      r0,[r1,#0]            ;1083
000054  6060              STR      r0,[r4,#4]            ;1083
000056  8322              STRH     r2,[r4,#0x18]         ;1084
000058  7a20              LDRB     r0,[r4,#8]            ;1086
00005a  b118              CBZ      r0,|L12.100|
00005c  f7fffffe          BL       netif_get_by_index
000060  4605              MOV      r5,r0                 ;1087
000062  e003              B        |L12.108|
                  |L12.100|
000064  1d20              ADDS     r0,r4,#4              ;1090
000066  f7fffffe          BL       ip4_route
00006a  4605              MOV      r5,r0                 ;1090
                  |L12.108|
00006c  f06f0103          MVN      r1,#3                 ;1094
000070  b115              CBZ      r5,|L12.120|
000072  6820              LDR      r0,[r4,#0]            ;1098
000074  b110              CBZ      r0,|L12.124|
000076  e005              B        |L12.132|
                  |L12.120|
000078  4608              MOV      r0,r1                 ;1094
00007a  e7d6              B        |L12.42|
                  |L12.124|
00007c  1d28              ADDS     r0,r5,#4              ;1099
00007e  b138              CBZ      r0,|L12.144|
000080  6800              LDR      r0,[r0,#0]            ;1103
000082  6020              STR      r0,[r4,#0]            ;1103
                  |L12.132|
000084  f8b49016          LDRH     r9,[r4,#0x16]         ;1115
000088  f1b90f00          CMP      r9,#0                 ;1116
00008c  d002              BEQ      |L12.148|
00008e  e005              B        |L12.156|
                  |L12.144|
000090  4608              MOV      r0,r1                 ;1101
000092  e7ca              B        |L12.42|
                  |L12.148|
000094  f7fffffe          BL       tcp_new_port
000098  82e0              STRH     r0,[r4,#0x16]         ;1117
00009a  b328              CBZ      r0,|L12.232|
                  |L12.156|
00009c  4620              MOV      r0,r4                 ;1144
00009e  f7fffffe          BL       tcp_next_iss
0000a2  2700              MOVS     r7,#0                 ;1145
0000a4  6267              STR      r7,[r4,#0x24]         ;1145
0000a6  6520              STR      r0,[r4,#0x50]         ;1146
0000a8  1e40              SUBS     r0,r0,#1              ;1147
0000aa  6460              STR      r0,[r4,#0x44]         ;1147
0000ac  65a0              STR      r0,[r4,#0x58]         ;1148
0000ae  65e0              STR      r0,[r4,#0x5c]         ;1149
0000b0  f44f6006          MOV      r0,#0x860             ;1152
0000b4  8560              STRH     r0,[r4,#0x2a]         ;1152
0000b6  8520              STRH     r0,[r4,#0x28]         ;1152
0000b8  62e7              STR      r7,[r4,#0x2c]         ;1153
0000ba  f8a40060          STRH     r0,[r4,#0x60]         ;1154
0000be  1080              ASRS     r0,r0,#2              ;1157
0000c0  8660              STRH     r0,[r4,#0x32]         ;1157
0000c2  1d22              ADDS     r2,r4,#4              ;1159
0000c4  4629              MOV      r1,r5                 ;1159
0000c6  f7fffffe          BL       tcp_eff_send_mss_netif
0000ca  8660              STRH     r0,[r4,#0x32]         ;1159
0000cc  f04f0801          MOV      r8,#1                 ;1161
0000d0  f8a48048          STRH     r8,[r4,#0x48]         ;1161
0000d4  f8c46088          STR      r6,[r4,#0x88]         ;1163
0000d8  2102              MOVS     r1,#2                 ;1169
0000da  4620              MOV      r0,r4                 ;1169
0000dc  f7fffffe          BL       tcp_enqueue_flags
0000e0  4605              MOV      r5,r0                 ;1169
0000e2  0028              MOVS     r0,r5                 ;1170
0000e4  d003              BEQ      |L12.238|
0000e6  e022              B        |L12.302|
                  |L12.232|
0000e8  f06f0001          MVN      r0,#1                 ;1119
0000ec  e79d              B        |L12.42|
                  |L12.238|
0000ee  2002              MOVS     r0,#2                 ;1172
0000f0  7520              STRB     r0,[r4,#0x14]         ;1172
0000f2  4e40              LDR      r6,|L12.500|
0000f4  f1b90f00          CMP      r9,#0                 ;1173
0000f8  d00f              BEQ      |L12.282|
0000fa  6930              LDR      r0,[r6,#0x10]         ;1174  ; tcp_bound_pcbs
0000fc  42a0              CMP      r0,r4                 ;1174
0000fe  d109              BNE      |L12.276|
000100  68c0              LDR      r0,[r0,#0xc]          ;1174
000102  6130              STR      r0,[r6,#0x10]         ;1174  ; tcp_bound_pcbs
000104  e008              B        |L12.280|
                  |L12.262|
000106  68c1              LDR      r1,[r0,#0xc]          ;1174
000108  42a1              CMP      r1,r4                 ;1174
00010a  d102              BNE      |L12.274|
00010c  68e1              LDR      r1,[r4,#0xc]          ;1174
00010e  60c1              STR      r1,[r0,#0xc]          ;1174
000110  e002              B        |L12.280|
                  |L12.274|
000112  4608              MOV      r0,r1                 ;1174
                  |L12.276|
000114  2800              CMP      r0,#0                 ;1174
000116  d1f6              BNE      |L12.262|
                  |L12.280|
000118  60e7              STR      r7,[r4,#0xc]          ;1174
                  |L12.282|
00011a  69b0              LDR      r0,[r6,#0x18]         ;1176  ; tcp_active_pcbs
00011c  60e0              STR      r0,[r4,#0xc]          ;1176
00011e  61b4              STR      r4,[r6,#0x18]         ;1176  ; tcp_active_pcbs
000120  f7fffffe          BL       tcp_timer_needed
000124  f8868000          STRB     r8,[r6,#0]            ;1176
000128  4620              MOV      r0,r4                 ;1179
00012a  f7fffffe          BL       tcp_output
                  |L12.302|
00012e  4628              MOV      r0,r5                 ;1181
000130  e77b              B        |L12.42|
;;;1183   
                          ENDP

000132  0000              DCW      0x0000
                  |L12.308|
000134  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000138  6964646c
00013c  65776172
000140  65735c54
000144  68697264
000148  5f506172
00014c  74795c4c
000150  7749505c
000154  7372635c
000158  636f7265
00015c  5c746370
000160  2e6300  
000163  00                DCB      0
                  |L12.356|
000164  7463705f          DCB      "tcp_connect: can only connect from state CLOSED",0
000168  636f6e6e
00016c  6563743a
000170  2063616e
000174  206f6e6c
000178  7920636f
00017c  6e6e6563
000180  74206672
000184  6f6d2073
000188  74617465
00018c  20434c4f
000190  53454400
                  |L12.404|
000194  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000198  7274696f
00019c  6e202225
0001a0  73222066
0001a4  61696c65
0001a8  64206174
0001ac  206c696e
0001b0  65202564
0001b4  20696e20
0001b8  25730a00
                  |L12.444|
0001bc  7463705f          DCB      "tcp_connect: invalid pcb",0
0001c0  636f6e6e
0001c4  6563743a
0001c8  20696e76
0001cc  616c6964
0001d0  20706362
0001d4  00      
0001d5  00                DCB      0
0001d6  00                DCB      0
0001d7  00                DCB      0
                  |L12.472|
0001d8  7463705f          DCB      "tcp_connect: invalid ipaddr",0
0001dc  636f6e6e
0001e0  6563743a
0001e4  20696e76
0001e8  616c6964
0001ec  20697061
0001f0  64647200
                  |L12.500|
                          DCD      ||.data||

                          AREA ||i.tcp_debug_state_str||, CODE, READONLY, ALIGN=2

                  tcp_debug_state_str PROC
;;;2353   const char *
;;;2354   tcp_debug_state_str(enum tcp_state s)
000000  4901              LDR      r1,|L13.8|
;;;2355   {
;;;2356     return tcp_state_str[s];
000002  f8510020          LDR      r0,[r1,r0,LSL #2]
;;;2357   }
000006  4770              BX       lr
;;;2358   
                          ENDP

                  |L13.8|
                          DCD      ||.constdata||+0x8

                          AREA ||i.tcp_eff_send_mss_netif||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_eff_send_mss_netif PROC
;;;2237   u16_t
;;;2238   tcp_eff_send_mss_netif(u16_t sendmss, struct netif *outif, const ip_addr_t *dest)
000000  b570              PUSH     {r4-r6,lr}
;;;2239   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2240     u16_t mss_s;
;;;2241     u16_t mtu;
;;;2242   
;;;2243     LWIP_UNUSED_ARG(dest); /* in case IPv6 is disabled */
;;;2244   
;;;2245     LWIP_ASSERT("tcp_eff_send_mss_netif: invalid dst_ip", dest != NULL);
000006  2a00              CMP      r2,#0
000008  d106              BNE      |L14.24|
00000a  a30c              ADR      r3,|L14.60|
00000c  f64002c5          MOV      r2,#0x8c5
000010  a116              ADR      r1,|L14.108|
000012  a020              ADR      r0,|L14.148|
000014  f7fffffe          BL       __2printf
                  |L14.24|
;;;2246   
;;;2247   #if LWIP_IPV6
;;;2248   #if LWIP_IPV4
;;;2249     if (IP_IS_V6(dest))
;;;2250   #endif /* LWIP_IPV4 */
;;;2251     {
;;;2252       /* First look in destination cache, to see if there is a Path MTU. */
;;;2253       mtu = nd6_get_destination_mtu(ip_2_ip6(dest), outif);
;;;2254     }
;;;2255   #if LWIP_IPV4
;;;2256     else
;;;2257   #endif /* LWIP_IPV4 */
;;;2258   #endif /* LWIP_IPV6 */
;;;2259   #if LWIP_IPV4
;;;2260     {
;;;2261       if (outif == NULL) {
000018  b135              CBZ      r5,|L14.40|
;;;2262         return sendmss;
;;;2263       }
;;;2264       mtu = outif->mtu;
00001a  8da9              LDRH     r1,[r5,#0x2c]
;;;2265     }
;;;2266   #endif /* LWIP_IPV4 */
;;;2267   
;;;2268     if (mtu != 0) {
00001c  b159              CBZ      r1,|L14.54|
;;;2269       u16_t offset;
;;;2270   #if LWIP_IPV6
;;;2271   #if LWIP_IPV4
;;;2272       if (IP_IS_V6(dest))
;;;2273   #endif /* LWIP_IPV4 */
;;;2274       {
;;;2275         offset = IP6_HLEN + TCP_HLEN;
;;;2276       }
;;;2277   #if LWIP_IPV4
;;;2278       else
;;;2279   #endif /* LWIP_IPV4 */
;;;2280   #endif /* LWIP_IPV6 */
;;;2281   #if LWIP_IPV4
;;;2282       {
;;;2283         offset = IP_HLEN + TCP_HLEN;
;;;2284       }
;;;2285   #endif /* LWIP_IPV4 */
;;;2286       mss_s = (mtu > offset) ? (u16_t)(mtu - offset) : 0;
00001e  2928              CMP      r1,#0x28
000020  d904              BLS      |L14.44|
000022  3928              SUBS     r1,r1,#0x28
000024  b288              UXTH     r0,r1
000026  e002              B        |L14.46|
                  |L14.40|
000028  4620              MOV      r0,r4                 ;2262
;;;2287       /* RFC 1122, chap 4.2.2.6:
;;;2288        * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
;;;2289        * We correct for TCP options in tcp_write(), and don't support IP options.
;;;2290        */
;;;2291       sendmss = LWIP_MIN(sendmss, mss_s);
;;;2292     }
;;;2293     return sendmss;
;;;2294   }
00002a  bd70              POP      {r4-r6,pc}
                  |L14.44|
00002c  2000              MOVS     r0,#0                 ;2286
                  |L14.46|
00002e  4284              CMP      r4,r0                 ;2291
000030  d200              BCS      |L14.52|
000032  4620              MOV      r0,r4                 ;2291
                  |L14.52|
000034  4604              MOV      r4,r0                 ;2291
                  |L14.54|
000036  4620              MOV      r0,r4                 ;2293
000038  bd70              POP      {r4-r6,pc}
;;;2295   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
                          ENDP

00003a  0000              DCW      0x0000
                  |L14.60|
00003c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000040  6964646c
000044  65776172
000048  65735c54
00004c  68697264
000050  5f506172
000054  74795c4c
000058  7749505c
00005c  7372635c
000060  636f7265
000064  5c746370
000068  2e6300  
00006b  00                DCB      0
                  |L14.108|
00006c  7463705f          DCB      "tcp_eff_send_mss_netif: invalid dst_ip",0
000070  6566665f
000074  73656e64
000078  5f6d7373
00007c  5f6e6574
000080  69663a20
000084  696e7661
000088  6c696420
00008c  6473745f
000090  697000  
000093  00                DCB      0
                  |L14.148|
000094  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000098  7274696f
00009c  6e202225
0000a0  73222066
0000a4  61696c65
0000a8  64206174
0000ac  206c696e
0000b0  65202564
0000b4  20696e20
0000b8  25730a00

                          AREA ||i.tcp_err||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_err PROC
;;;2056   void
;;;2057   tcp_err(struct tcp_pcb *pcb, tcp_err_fn err)
000000  b570              PUSH     {r4-r6,lr}
;;;2058   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2059     LWIP_ASSERT_CORE_LOCKED();
;;;2060     if (pcb != NULL) {
000006  2c00              CMP      r4,#0
000008  d00b              BEQ      |L15.34|
;;;2061       LWIP_ASSERT("invalid socket state for err callback", pcb->state != LISTEN);
00000a  7d20              LDRB     r0,[r4,#0x14]
00000c  2801              CMP      r0,#1
00000e  d106              BNE      |L15.30|
000010  a304              ADR      r3,|L15.36|
000012  f640020d          MOV      r2,#0x80d
000016  a10f              ADR      r1,|L15.84|
000018  a018              ADR      r0,|L15.124|
00001a  f7fffffe          BL       __2printf
                  |L15.30|
;;;2062       pcb->errf = err;
00001e  f8c45090          STR      r5,[r4,#0x90]
                  |L15.34|
;;;2063     }
;;;2064   }
000022  bd70              POP      {r4-r6,pc}
;;;2065   
                          ENDP

                  |L15.36|
000024  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000028  6964646c
00002c  65776172
000030  65735c54
000034  68697264
000038  5f506172
00003c  74795c4c
000040  7749505c
000044  7372635c
000048  636f7265
00004c  5c746370
000050  2e6300  
000053  00                DCB      0
                  |L15.84|
000054  696e7661          DCB      "invalid socket state for err callback",0
000058  6c696420
00005c  736f636b
000060  65742073
000064  74617465
000068  20666f72
00006c  20657272
000070  2063616c
000074  6c626163
000078  6b00    
00007a  00                DCB      0
00007b  00                DCB      0
                  |L15.124|
00007c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000080  7274696f
000084  6e202225
000088  73222066
00008c  61696c65
000090  64206174
000094  206c696e
000098  65202564
00009c  20696e20
0000a0  25730a00

                          AREA ||i.tcp_fasttmr||, CODE, READONLY, ALIGN=2

                  tcp_fasttmr PROC
;;;1478   void
;;;1479   tcp_fasttmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1480   {
;;;1481     struct tcp_pcb *pcb;
;;;1482   
;;;1483     ++tcp_timer_ctr;
000002  4e19              LDR      r6,|L16.104|
000004  78b0              LDRB     r0,[r6,#2]  ; tcp_timer_ctr
000006  1c40              ADDS     r0,r0,#1
000008  70b0              STRB     r0,[r6,#2]
                  |L16.10|
;;;1484   
;;;1485   tcp_fasttmr_start:
;;;1486     pcb = tcp_active_pcbs;
00000a  69b4              LDR      r4,[r6,#0x18]  ; tcp_active_pcbs
;;;1487   
;;;1488     while (pcb != NULL) {
00000c  e028              B        |L16.96|
                  |L16.14|
;;;1489       if (pcb->last_timer != tcp_timer_ctr) {
00000e  7fa1              LDRB     r1,[r4,#0x1e]
000010  78b0              LDRB     r0,[r6,#2]  ; tcp_timer_ctr
000012  4281              CMP      r1,r0
000014  d023              BEQ      |L16.94|
;;;1490         struct tcp_pcb *next;
;;;1491         pcb->last_timer = tcp_timer_ctr;
000016  77a0              STRB     r0,[r4,#0x1e]
;;;1492         /* send delayed ACKs */
;;;1493         if (pcb->flags & TF_ACK_DELAY) {
000018  8b60              LDRH     r0,[r4,#0x1a]
00001a  07c1              LSLS     r1,r0,#31
00001c  d009              BEQ      |L16.50|
;;;1494           LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
;;;1495           tcp_ack_now(pcb);
00001e  f0400002          ORR      r0,r0,#2
000022  8360              STRH     r0,[r4,#0x1a]
;;;1496           tcp_output(pcb);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       tcp_output
;;;1497           tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
00002a  8b60              LDRH     r0,[r4,#0x1a]
00002c  f0200003          BIC      r0,r0,#3
000030  8360              STRH     r0,[r4,#0x1a]
                  |L16.50|
;;;1498         }
;;;1499         /* send pending FIN */
;;;1500         if (pcb->flags & TF_CLOSEPEND) {
000032  8b60              LDRH     r0,[r4,#0x1a]
000034  0701              LSLS     r1,r0,#28
000036  d505              BPL      |L16.68|
;;;1501           LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: pending FIN\n"));
;;;1502           tcp_clear_flags(pcb, TF_CLOSEPEND);
000038  f0200008          BIC      r0,r0,#8
00003c  8360              STRH     r0,[r4,#0x1a]
;;;1503           tcp_close_shutdown_fin(pcb);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       tcp_close_shutdown_fin
                  |L16.68|
;;;1504         }
;;;1505   
;;;1506         next = pcb->next;
000044  68e5              LDR      r5,[r4,#0xc]
;;;1507   
;;;1508         /* If there is data which was previously "refused" by upper layer */
;;;1509         if (pcb->refused_data != NULL) {
000046  6fa0              LDR      r0,[r4,#0x78]
000048  b138              CBZ      r0,|L16.90|
;;;1510           tcp_active_pcbs_changed = 0;
00004a  2000              MOVS     r0,#0
00004c  7030              STRB     r0,[r6,#0]
;;;1511           tcp_process_refused_data(pcb);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       tcp_process_refused_data
;;;1512           if (tcp_active_pcbs_changed) {
000054  7830              LDRB     r0,[r6,#0]  ; tcp_active_pcbs_changed
000056  2800              CMP      r0,#0
000058  d1d7              BNE      |L16.10|
                  |L16.90|
;;;1513             /* application callback has changed the pcb list: restart the loop */
;;;1514             goto tcp_fasttmr_start;
;;;1515           }
;;;1516         }
;;;1517         pcb = next;
00005a  462c              MOV      r4,r5
;;;1518       } else {
00005c  e000              B        |L16.96|
                  |L16.94|
;;;1519         pcb = pcb->next;
00005e  68e4              LDR      r4,[r4,#0xc]
                  |L16.96|
000060  2c00              CMP      r4,#0                 ;1488
000062  d1d4              BNE      |L16.14|
;;;1520       }
;;;1521     }
;;;1522   }
000064  bd70              POP      {r4-r6,pc}
;;;1523   
                          ENDP

000066  0000              DCW      0x0000
                  |L16.104|
                          DCD      ||.data||

                          AREA ||i.tcp_free||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_free PROC
;;;209    void
;;;210    tcp_free(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;211    {
000002  4604              MOV      r4,r0
;;;212      LWIP_ASSERT("tcp_free: LISTEN", pcb->state != LISTEN);
000004  7d22              LDRB     r2,[r4,#0x14]
000006  2a01              CMP      r2,#1
000008  d105              BNE      |L17.22|
00000a  a306              ADR      r3,|L17.36|
00000c  22d4              MOVS     r2,#0xd4
00000e  a111              ADR      r1,|L17.84|
000010  a015              ADR      r0,|L17.104|
000012  f7fffffe          BL       __2printf
                  |L17.22|
;;;213    #if LWIP_TCP_PCB_NUM_EXT_ARGS
;;;214      tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
;;;215    #endif
;;;216      memp_free(MEMP_TCP_PCB, pcb);
000016  4621              MOV      r1,r4
000018  e8bd4010          POP      {r4,lr}
00001c  2001              MOVS     r0,#1
00001e  f7ffbffe          B.W      memp_free
;;;217    }
;;;218    
                          ENDP

000022  0000              DCW      0x0000
                  |L17.36|
000024  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000028  6964646c
00002c  65776172
000030  65735c54
000034  68697264
000038  5f506172
00003c  74795c4c
000040  7749505c
000044  7372635c
000048  636f7265
00004c  5c746370
000050  2e6300  
000053  00                DCB      0
                  |L17.84|
000054  7463705f          DCB      "tcp_free: LISTEN",0
000058  66726565
00005c  3a204c49
000060  5354454e
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L17.104|
000068  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00006c  7274696f
000070  6e202225
000074  73222066
000078  61696c65
00007c  64206174
000080  206c696e
000084  65202564
000088  20696e20
00008c  25730a00

                          AREA ||i.tcp_free_listen||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_free_listen PROC
;;;220    static void
;;;221    tcp_free_listen(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;222    {
000002  4604              MOV      r4,r0
;;;223      LWIP_ASSERT("tcp_free_listen: !LISTEN", pcb->state != LISTEN);
000004  7d22              LDRB     r2,[r4,#0x14]
000006  2a01              CMP      r2,#1
000008  d105              BNE      |L18.22|
00000a  a306              ADR      r3,|L18.36|
00000c  22df              MOVS     r2,#0xdf
00000e  a111              ADR      r1,|L18.84|
000010  a017              ADR      r0,|L18.112|
000012  f7fffffe          BL       __2printf
                  |L18.22|
;;;224    #if LWIP_TCP_PCB_NUM_EXT_ARGS
;;;225      tcp_ext_arg_invoke_callbacks_destroyed(pcb->ext_args);
;;;226    #endif
;;;227      memp_free(MEMP_TCP_PCB_LISTEN, pcb);
000016  4621              MOV      r1,r4
000018  e8bd4010          POP      {r4,lr}
00001c  2002              MOVS     r0,#2
00001e  f7ffbffe          B.W      memp_free
;;;228    }
;;;229    
                          ENDP

000022  0000              DCW      0x0000
                  |L18.36|
000024  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000028  6964646c
00002c  65776172
000030  65735c54
000034  68697264
000038  5f506172
00003c  74795c4c
000040  7749505c
000044  7372635c
000048  636f7265
00004c  5c746370
000050  2e6300  
000053  00                DCB      0
                  |L18.84|
000054  7463705f          DCB      "tcp_free_listen: !LISTEN",0
000058  66726565
00005c  5f6c6973
000060  74656e3a
000064  20214c49
000068  5354454e
00006c  00      
00006d  00                DCB      0
00006e  00                DCB      0
00006f  00                DCB      0
                  |L18.112|
000070  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000074  7274696f
000078  6e202225
00007c  73222066
000080  61696c65
000084  64206174
000088  206c696e
00008c  65202564
000090  20696e20
000094  25730a00

                          AREA ||i.tcp_free_ooseq||, CODE, READONLY, ALIGN=1

                  tcp_free_ooseq PROC
;;;2385   void
;;;2386   tcp_free_ooseq(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;2387   {
000002  4604              MOV      r4,r0
;;;2388     if (pcb->ooseq) {
000004  6f60              LDR      r0,[r4,#0x74]
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L19.18|
;;;2389       tcp_segs_free(pcb->ooseq);
00000a  f7fffffe          BL       tcp_segs_free
;;;2390       pcb->ooseq = NULL;
00000e  2000              MOVS     r0,#0
000010  6760              STR      r0,[r4,#0x74]
                  |L19.18|
;;;2391   #if LWIP_TCP_SACK_OUT
;;;2392       memset(pcb->rcv_sacks, 0, sizeof(pcb->rcv_sacks));
;;;2393   #endif /* LWIP_TCP_SACK_OUT */
;;;2394     }
;;;2395   }
000012  bd10              POP      {r4,pc}
;;;2396   #endif /* TCP_QUEUE_OOSEQ */
                          ENDP


                          AREA ||i.tcp_handle_closepend||, CODE, READONLY, ALIGN=2

                  tcp_handle_closepend PROC
;;;1810   static void
;;;1811   tcp_handle_closepend(void)
000000  b510              PUSH     {r4,lr}
;;;1812   {
;;;1813     struct tcp_pcb *pcb = tcp_active_pcbs;
000002  4808              LDR      r0,|L20.36|
000004  6980              LDR      r0,[r0,#0x18]  ; tcp_active_pcbs
000006  e009              B        |L20.28|
                  |L20.8|
;;;1814   
;;;1815     while (pcb != NULL) {
;;;1816       struct tcp_pcb *next = pcb->next;
000008  68c4              LDR      r4,[r0,#0xc]
;;;1817       /* send pending FIN */
;;;1818       if (pcb->flags & TF_CLOSEPEND) {
00000a  8b41              LDRH     r1,[r0,#0x1a]
00000c  070a              LSLS     r2,r1,#28
00000e  d504              BPL      |L20.26|
;;;1819         LWIP_DEBUGF(TCP_DEBUG, ("tcp_handle_closepend: pending FIN\n"));
;;;1820         tcp_clear_flags(pcb, TF_CLOSEPEND);
000010  f0210108          BIC      r1,r1,#8
000014  8341              STRH     r1,[r0,#0x1a]
;;;1821         tcp_close_shutdown_fin(pcb);
000016  f7fffffe          BL       tcp_close_shutdown_fin
                  |L20.26|
;;;1822       }
;;;1823       pcb = next;
00001a  4620              MOV      r0,r4
                  |L20.28|
00001c  2800              CMP      r0,#0                 ;1815
00001e  d1f3              BNE      |L20.8|
;;;1824     }
;;;1825   }
000020  bd10              POP      {r4,pc}
;;;1826   
                          ENDP

000022  0000              DCW      0x0000
                  |L20.36|
                          DCD      ||.data||

                          AREA ||i.tcp_init||, CODE, READONLY, ALIGN=2

                  tcp_init PROC
;;;200    void
;;;201    tcp_init(void)
000000  b510              PUSH     {r4,lr}
;;;202    {
;;;203    #ifdef LWIP_RAND
;;;204      tcp_port = TCP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
000002  f7fffffe          BL       rand
000006  4903              LDR      r1,|L21.20|
000008  f3c0000d          UBFX     r0,r0,#0,#14
00000c  f5004040          ADD      r0,r0,#0xc000
000010  8088              STRH     r0,[r1,#4]
;;;205    #endif /* LWIP_RAND */
;;;206    }
000012  bd10              POP      {r4,pc}
;;;207    
                          ENDP

                  |L21.20|
                          DCD      ||.data||

                          AREA ||i.tcp_kill_prio||, CODE, READONLY, ALIGN=2

                  tcp_kill_prio PROC
;;;1705   static void
;;;1706   tcp_kill_prio(u8_t prio)
000000  b4f0              PUSH     {r4-r7}
;;;1707   {
;;;1708     struct tcp_pcb *pcb, *inactive;
;;;1709     u32_t inactivity;
;;;1710     u8_t mprio;
;;;1711   
;;;1712     mprio = LWIP_MIN(TCP_PRIO_MAX, prio);
000002  287f              CMP      r0,#0x7f
000004  d900              BLS      |L22.8|
000006  207f              MOVS     r0,#0x7f
                  |L22.8|
;;;1713   
;;;1714     /* We want to kill connections with a lower prio, so bail out if 
;;;1715      * supplied prio is 0 - there can never be a lower prio
;;;1716      */
;;;1717     if (mprio == 0) {
000008  2800              CMP      r0,#0
00000a  d01d              BEQ      |L22.72|
;;;1718       return;
;;;1719     }
;;;1720   
;;;1721     /* We only want kill connections with a lower prio, so decrement prio by one 
;;;1722      * and start searching for oldest connection with same or lower priority than mprio.
;;;1723      * We want to find the connections with the lowest possible prio, and among
;;;1724      * these the one with the longest inactivity time.
;;;1725      */
;;;1726     mprio--;
00000c  1e40              SUBS     r0,r0,#1
00000e  b2c4              UXTB     r4,r0
;;;1727   
;;;1728     inactivity = 0;
000010  2500              MOVS     r5,#0
;;;1729     inactive = NULL;
000012  2000              MOVS     r0,#0
;;;1730     for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000014  490d              LDR      r1,|L22.76|
000016  6989              LDR      r1,[r1,#0x18]  ; tcp_active_pcbs
000018  4a0c              LDR      r2,|L22.76|
00001a  68d3              LDR      r3,[r2,#0xc]
00001c  e00d              B        |L22.58|
                  |L22.30|
;;;1731           /* lower prio is always a kill candidate */
;;;1732       if ((pcb->prio < mprio) ||
00001e  7d4a              LDRB     r2,[r1,#0x15]
000020  42a2              CMP      r2,r4
000022  d305              BCC      |L22.48|
;;;1733           /* longer inactivity is also a kill candidate */
;;;1734           ((pcb->prio == mprio) && ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity))) {
000024  d108              BNE      |L22.56|
000026  6a0e              LDR      r6,[r1,#0x20]
000028  eba30606          SUB      r6,r3,r6
00002c  42ae              CMP      r6,r5
00002e  d303              BCC      |L22.56|
                  |L22.48|
;;;1735         inactivity = tcp_ticks - pcb->tmr;
000030  6a08              LDR      r0,[r1,#0x20]
000032  1a1d              SUBS     r5,r3,r0
;;;1736         inactive   = pcb;
000034  4608              MOV      r0,r1
;;;1737         mprio      = pcb->prio;
000036  4614              MOV      r4,r2
                  |L22.56|
000038  68c9              LDR      r1,[r1,#0xc]          ;1730
                  |L22.58|
00003a  2900              CMP      r1,#0                 ;1730
00003c  d1ef              BNE      |L22.30|
;;;1738       }
;;;1739     }
;;;1740     if (inactive != NULL) {
00003e  2800              CMP      r0,#0
000040  d002              BEQ      |L22.72|
;;;1741       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
;;;1742                               (void *)inactive, inactivity));
;;;1743       tcp_abort(inactive);
000042  bcf0              POP      {r4-r7}
000044  f7ffbffe          B.W      tcp_abort
                  |L22.72|
;;;1744     }
;;;1745   }
000048  bcf0              POP      {r4-r7}
00004a  4770              BX       lr
;;;1746   
                          ENDP

                  |L22.76|
                          DCD      ||.data||

                          AREA ||i.tcp_kill_state||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_kill_state PROC
;;;1751   static void
;;;1752   tcp_kill_state(enum tcp_state state)
000000  b570              PUSH     {r4-r6,lr}
;;;1753   {
000002  4604              MOV      r4,r0
;;;1754     struct tcp_pcb *pcb, *inactive;
;;;1755     u32_t inactivity;
;;;1756   
;;;1757     LWIP_ASSERT("invalid state", (state == CLOSING) || (state == LAST_ACK));
000004  2c08              CMP      r4,#8
000006  d008              BEQ      |L23.26|
000008  2c09              CMP      r4,#9
00000a  d006              BEQ      |L23.26|
00000c  a310              ADR      r3,|L23.80|
00000e  f24062dd          MOV      r2,#0x6dd
000012  a11b              ADR      r1,|L23.128|
000014  a01e              ADR      r0,|L23.144|
000016  f7fffffe          BL       __2printf
                  |L23.26|
;;;1758   
;;;1759     inactivity = 0;
00001a  2300              MOVS     r3,#0
;;;1760     inactive = NULL;
00001c  2000              MOVS     r0,#0
;;;1761     /* Go through the list of active pcbs and get the oldest pcb that is in state
;;;1762        CLOSING/LAST_ACK. */
;;;1763     for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
00001e  4926              LDR      r1,|L23.184|
000020  698a              LDR      r2,[r1,#0x18]  ; tcp_active_pcbs
;;;1764       if (pcb->state == state) {
;;;1765         if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
000022  68cd              LDR      r5,[r1,#0xc]
000024  e009              B        |L23.58|
                  |L23.38|
000026  7d11              LDRB     r1,[r2,#0x14]         ;1764
000028  42a1              CMP      r1,r4                 ;1764
00002a  d105              BNE      |L23.56|
00002c  6a11              LDR      r1,[r2,#0x20]
00002e  1a69              SUBS     r1,r5,r1
000030  4299              CMP      r1,r3
000032  d301              BCC      |L23.56|
;;;1766           inactivity = tcp_ticks - pcb->tmr;
000034  460b              MOV      r3,r1
;;;1767           inactive = pcb;
000036  4610              MOV      r0,r2
                  |L23.56|
000038  68d2              LDR      r2,[r2,#0xc]          ;1763
                  |L23.58|
00003a  2a00              CMP      r2,#0                 ;1763
00003c  d1f3              BNE      |L23.38|
;;;1768         }
;;;1769       }
;;;1770     }
;;;1771     if (inactive != NULL) {
00003e  2800              CMP      r0,#0
000040  d004              BEQ      |L23.76|
;;;1772       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_closing: killing oldest %s PCB %p (%"S32_F")\n",
;;;1773                               tcp_state_str[state], (void *)inactive, inactivity));
;;;1774       /* Don't send a RST, since no data is lost. */
;;;1775       tcp_abandon(inactive, 0);
000042  e8bd4070          POP      {r4-r6,lr}
000046  2100              MOVS     r1,#0
000048  f7ffbffe          B.W      tcp_abandon
                  |L23.76|
;;;1776     }
;;;1777   }
00004c  bd70              POP      {r4-r6,pc}
;;;1778   
                          ENDP

00004e  0000              DCW      0x0000
                  |L23.80|
000050  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000054  6964646c
000058  65776172
00005c  65735c54
000060  68697264
000064  5f506172
000068  74795c4c
00006c  7749505c
000070  7372635c
000074  636f7265
000078  5c746370
00007c  2e6300  
00007f  00                DCB      0
                  |L23.128|
000080  696e7661          DCB      "invalid state",0
000084  6c696420
000088  73746174
00008c  6500    
00008e  00                DCB      0
00008f  00                DCB      0
                  |L23.144|
000090  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000094  7274696f
000098  6e202225
00009c  73222066
0000a0  61696c65
0000a4  64206174
0000a8  206c696e
0000ac  65202564
0000b0  20696e20
0000b4  25730a00
                  |L23.184|
                          DCD      ||.data||

                          AREA ||i.tcp_kill_timewait||, CODE, READONLY, ALIGN=2

                  tcp_kill_timewait PROC
;;;1783   static void
;;;1784   tcp_kill_timewait(void)
000000  b430              PUSH     {r4,r5}
;;;1785   {
;;;1786     struct tcp_pcb *pcb, *inactive;
;;;1787     u32_t inactivity;
;;;1788   
;;;1789     inactivity = 0;
000002  2300              MOVS     r3,#0
;;;1790     inactive = NULL;
000004  2000              MOVS     r0,#0
;;;1791     /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
;;;1792     for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
000006  490a              LDR      r1,|L24.48|
000008  69c9              LDR      r1,[r1,#0x1c]  ; tcp_tw_pcbs
00000a  4a09              LDR      r2,|L24.48|
;;;1793       if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
00000c  68d4              LDR      r4,[r2,#0xc]
00000e  e006              B        |L24.30|
                  |L24.16|
000010  6a0a              LDR      r2,[r1,#0x20]
000012  1aa2              SUBS     r2,r4,r2
000014  429a              CMP      r2,r3
000016  d301              BCC      |L24.28|
;;;1794         inactivity = tcp_ticks - pcb->tmr;
000018  4613              MOV      r3,r2
;;;1795         inactive = pcb;
00001a  4608              MOV      r0,r1
                  |L24.28|
00001c  68c9              LDR      r1,[r1,#0xc]          ;1792
                  |L24.30|
00001e  2900              CMP      r1,#0                 ;1792
000020  d1f6              BNE      |L24.16|
;;;1796       }
;;;1797     }
;;;1798     if (inactive != NULL) {
000022  2800              CMP      r0,#0
000024  d002              BEQ      |L24.44|
;;;1799       LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
;;;1800                               (void *)inactive, inactivity));
;;;1801       tcp_abort(inactive);
000026  bc30              POP      {r4,r5}
000028  f7ffbffe          B.W      tcp_abort
                  |L24.44|
;;;1802     }
;;;1803   }
00002c  bc30              POP      {r4,r5}
00002e  4770              BX       lr
;;;1804   
                          ENDP

                  |L24.48|
                          DCD      ||.data||

                          AREA ||i.tcp_listen_closed||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_listen_closed PROC
;;;268    static void
;;;269    tcp_listen_closed(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;270    {
000002  4606              MOV      r6,r0
;;;271    #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
;;;272      size_t i;
;;;273      LWIP_ASSERT("pcb != NULL", pcb != NULL);
000004  2e00              CMP      r6,#0
000006  d106              BNE      |L25.22|
000008  a30e              ADR      r3,|L25.68|
00000a  f2401211          MOV      r2,#0x111
00000e  a119              ADR      r1,|L25.116|
000010  a01b              ADR      r0,|L25.128|
000012  f7fffffe          BL       __2printf
                  |L25.22|
;;;274      LWIP_ASSERT("pcb->state == LISTEN", pcb->state == LISTEN);
000016  7d30              LDRB     r0,[r6,#0x14]
000018  2801              CMP      r0,#1
00001a  d006              BEQ      |L25.42|
00001c  a309              ADR      r3,|L25.68|
00001e  f44f7289          MOV      r2,#0x112
000022  a121              ADR      r1,|L25.168|
000024  a016              ADR      r0,|L25.128|
000026  f7fffffe          BL       __2printf
                  |L25.42|
;;;275      for (i = 1; i < LWIP_ARRAYSIZE(tcp_pcb_lists); i++) {
00002a  2401              MOVS     r4,#1
;;;276        tcp_remove_listener(*tcp_pcb_lists[i], (struct tcp_pcb_listen *)pcb);
00002c  4d24              LDR      r5,|L25.192|
                  |L25.46|
00002e  4631              MOV      r1,r6
000030  f8550024          LDR      r0,[r5,r4,LSL #2]
000034  6800              LDR      r0,[r0,#0]
000036  f7fffffe          BL       tcp_remove_listener
00003a  1c64              ADDS     r4,r4,#1              ;275
00003c  2c04              CMP      r4,#4                 ;275
00003e  d3f6              BCC      |L25.46|
;;;277      }
;;;278    #endif
;;;279      LWIP_UNUSED_ARG(pcb);
;;;280    }
000040  bd70              POP      {r4-r6,pc}
;;;281    
                          ENDP

000042  0000              DCW      0x0000
                  |L25.68|
000044  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000048  6964646c
00004c  65776172
000050  65735c54
000054  68697264
000058  5f506172
00005c  74795c4c
000060  7749505c
000064  7372635c
000068  636f7265
00006c  5c746370
000070  2e6300  
000073  00                DCB      0
                  |L25.116|
000074  70636220          DCB      "pcb != NULL",0
000078  213d204e
00007c  554c4c00
                  |L25.128|
000080  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000084  7274696f
000088  6e202225
00008c  73222066
000090  61696c65
000094  64206174
000098  206c696e
00009c  65202564
0000a0  20696e20
0000a4  25730a00
                  |L25.168|
0000a8  7063622d          DCB      "pcb->state == LISTEN",0
0000ac  3e737461
0000b0  7465203d
0000b4  3d204c49
0000b8  5354454e
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L25.192|
                          DCD      ||.constdata||+0x44

                          AREA ||i.tcp_listen_with_backlog||, CODE, READONLY, ALIGN=1

                  tcp_listen_with_backlog PROC
;;;824    struct tcp_pcb *
;;;825    tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
000000  2200              MOVS     r2,#0
;;;826    {
;;;827      LWIP_ASSERT_CORE_LOCKED();
;;;828      return tcp_listen_with_backlog_and_err(pcb, backlog, NULL);
000002  f7ffbffe          B.W      tcp_listen_with_backlog_and_err
;;;829    }
;;;830    
                          ENDP


                          AREA ||i.tcp_listen_with_backlog_and_err||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_listen_with_backlog_and_err PROC
;;;847    struct tcp_pcb *
;;;848    tcp_listen_with_backlog_and_err(struct tcp_pcb *pcb, u8_t backlog, err_t *err)
000000  b570              PUSH     {r4-r6,lr}
;;;849    {
000002  4604              MOV      r4,r0
000004  4616              MOV      r6,r2
;;;850      struct tcp_pcb_listen *lpcb = NULL;
000006  2500              MOVS     r5,#0
;;;851      err_t res;
;;;852    
;;;853      LWIP_UNUSED_ARG(backlog);
;;;854    
;;;855      LWIP_ASSERT_CORE_LOCKED();
;;;856    
;;;857      LWIP_ERROR("tcp_listen_with_backlog_and_err: invalid pcb", pcb != NULL, res = ERR_ARG; goto done);
000008  2c00              CMP      r4,#0
00000a  d00c              BEQ      |L27.38|
;;;858      LWIP_ERROR("tcp_listen_with_backlog_and_err: pcb already connected", pcb->state == CLOSED, res = ERR_CLSD; goto done);
00000c  7d20              LDRB     r0,[r4,#0x14]
00000e  2800              CMP      r0,#0
000010  d013              BEQ      |L27.58|
000012  a329              ADR      r3,|L27.184|
000014  f240325a          MOV      r2,#0x35a
000018  a133              ADR      r1,|L27.232|
00001a  a041              ADR      r0,|L27.288|
00001c  f7fffffe          BL       __2printf
000020  f06f000e          MVN      r0,#0xe
000024  e044              B        |L27.176|
                  |L27.38|
000026  a324              ADR      r3,|L27.184|
000028  f2403259          MOV      r2,#0x359             ;857
00002c  a146              ADR      r1,|L27.328|
00002e  a03c              ADR      r0,|L27.288|
000030  f7fffffe          BL       __2printf
000034  f06f000f          MVN      r0,#0xf               ;857
000038  e03a              B        |L27.176|
                  |L27.58|
;;;859    
;;;860      /* already listening? */
;;;861      if (pcb->state == LISTEN) {
;;;862        lpcb = (struct tcp_pcb_listen *)pcb;
;;;863        res = ERR_ALREADY;
;;;864        goto done;
;;;865      }
;;;866    #if SO_REUSE
;;;867      if (ip_get_option(pcb, SOF_REUSEADDR)) {
;;;868        /* Since SOF_REUSEADDR allows reusing a local address before the pcb's usage
;;;869           is declared (listen-/connection-pcb), we have to make sure now that
;;;870           this port is only used once for every local IP. */
;;;871        for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
;;;872          if ((lpcb->local_port == pcb->local_port) &&
;;;873              ip_addr_cmp(&lpcb->local_ip, &pcb->local_ip)) {
;;;874            /* this address/port is already used */
;;;875            lpcb = NULL;
;;;876            res = ERR_USE;
;;;877            goto done;
;;;878          }
;;;879        }
;;;880      }
;;;881    #endif /* SO_REUSE */
;;;882      lpcb = (struct tcp_pcb_listen *)memp_malloc(MEMP_TCP_PCB_LISTEN);
00003a  2002              MOVS     r0,#2
00003c  f7fffffe          BL       memp_malloc
000040  4605              MOV      r5,r0
;;;883      if (lpcb == NULL) {
000042  0028              MOVS     r0,r5
000044  d01a              BEQ      |L27.124|
;;;884        res = ERR_MEM;
;;;885        goto done;
;;;886      }
;;;887      lpcb->callback_arg = pcb->callback_arg;
000046  6920              LDR      r0,[r4,#0x10]
000048  6128              STR      r0,[r5,#0x10]
;;;888      lpcb->local_port = pcb->local_port;
00004a  8ae0              LDRH     r0,[r4,#0x16]
00004c  82e8              STRH     r0,[r5,#0x16]
;;;889      lpcb->state = LISTEN;
00004e  2001              MOVS     r0,#1
000050  7528              STRB     r0,[r5,#0x14]
;;;890      lpcb->prio = pcb->prio;
000052  7d60              LDRB     r0,[r4,#0x15]
000054  7568              STRB     r0,[r5,#0x15]
;;;891      lpcb->so_options = pcb->so_options;
000056  7a60              LDRB     r0,[r4,#9]
000058  7268              STRB     r0,[r5,#9]
;;;892      lpcb->netif_idx = NETIF_NO_INDEX;
00005a  2200              MOVS     r2,#0
00005c  722a              STRB     r2,[r5,#8]
;;;893      lpcb->ttl = pcb->ttl;
00005e  7ae0              LDRB     r0,[r4,#0xb]
000060  72e8              STRB     r0,[r5,#0xb]
;;;894      lpcb->tos = pcb->tos;
000062  7aa0              LDRB     r0,[r4,#0xa]
000064  72a8              STRB     r0,[r5,#0xa]
;;;895    #if LWIP_IPV4 && LWIP_IPV6
;;;896      IP_SET_TYPE_VAL(lpcb->remote_ip, pcb->local_ip.type);
;;;897    #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;898      ip_addr_copy(lpcb->local_ip, pcb->local_ip);
000066  6820              LDR      r0,[r4,#0]
000068  6028              STR      r0,[r5,#0]
;;;899      if (pcb->local_port != 0) {
00006a  8ae0              LDRH     r0,[r4,#0x16]
00006c  b198              CBZ      r0,|L27.150|
;;;900        TCP_RMV(&tcp_bound_pcbs, pcb);
00006e  4942              LDR      r1,|L27.376|
000070  6908              LDR      r0,[r1,#0x10]  ; tcp_bound_pcbs
000072  42a0              CMP      r0,r4
000074  d10c              BNE      |L27.144|
000076  68c0              LDR      r0,[r0,#0xc]
000078  6108              STR      r0,[r1,#0x10]  ; tcp_bound_pcbs
00007a  e00b              B        |L27.148|
                  |L27.124|
00007c  f04f30ff          MOV      r0,#0xffffffff        ;884
000080  e016              B        |L27.176|
                  |L27.130|
000082  68c1              LDR      r1,[r0,#0xc]
000084  42a1              CMP      r1,r4
000086  d102              BNE      |L27.142|
000088  68e1              LDR      r1,[r4,#0xc]
00008a  60c1              STR      r1,[r0,#0xc]
00008c  e002              B        |L27.148|
                  |L27.142|
00008e  4608              MOV      r0,r1
                  |L27.144|
000090  2800              CMP      r0,#0
000092  d1f6              BNE      |L27.130|
                  |L27.148|
000094  60e2              STR      r2,[r4,#0xc]
                  |L27.150|
;;;901      }
;;;902    #if LWIP_TCP_PCB_NUM_EXT_ARGS
;;;903      /* copy over ext_args to listening pcb  */
;;;904      memcpy(&lpcb->ext_args, &pcb->ext_args, sizeof(pcb->ext_args));
;;;905    #endif
;;;906      tcp_free(pcb);
000096  4620              MOV      r0,r4
000098  f7fffffe          BL       tcp_free
;;;907    #if LWIP_CALLBACK_API
;;;908      lpcb->accept = tcp_accept_null;
00009c  4837              LDR      r0,|L27.380|
00009e  61a8              STR      r0,[r5,#0x18]
;;;909    #endif /* LWIP_CALLBACK_API */
;;;910    #if TCP_LISTEN_BACKLOG
;;;911      lpcb->accepts_pending = 0;
;;;912      tcp_backlog_set(lpcb, backlog);
;;;913    #endif /* TCP_LISTEN_BACKLOG */
;;;914      TCP_REG(&tcp_listen_pcbs.pcbs, (struct tcp_pcb *)lpcb);
0000a0  4835              LDR      r0,|L27.376|
0000a2  3014              ADDS     r0,r0,#0x14
0000a4  6801              LDR      r1,[r0,#0]  ; tcp_listen_pcbs
0000a6  60e9              STR      r1,[r5,#0xc]
0000a8  6005              STR      r5,[r0,#0]  ; tcp_listen_pcbs
0000aa  f7fffffe          BL       tcp_timer_needed
;;;915      res = ERR_OK;
0000ae  2000              MOVS     r0,#0
                  |L27.176|
;;;916    done:
;;;917      if (err != NULL) {
0000b0  b106              CBZ      r6,|L27.180|
;;;918        *err = res;
0000b2  7030              STRB     r0,[r6,#0]
                  |L27.180|
;;;919      }
;;;920      return (struct tcp_pcb *)lpcb;
0000b4  4628              MOV      r0,r5
;;;921    }
0000b6  bd70              POP      {r4-r6,pc}
;;;922    
                          ENDP

                  |L27.184|
0000b8  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
0000bc  6964646c
0000c0  65776172
0000c4  65735c54
0000c8  68697264
0000cc  5f506172
0000d0  74795c4c
0000d4  7749505c
0000d8  7372635c
0000dc  636f7265
0000e0  5c746370
0000e4  2e6300  
0000e7  00                DCB      0
                  |L27.232|
0000e8  7463705f          DCB      "tcp_listen_with_backlog_and_err: pcb already connected",0
0000ec  6c697374
0000f0  656e5f77
0000f4  6974685f
0000f8  6261636b
0000fc  6c6f675f
000100  616e645f
000104  6572723a
000108  20706362
00010c  20616c72
000110  65616479
000114  20636f6e
000118  6e656374
00011c  656400  
00011f  00                DCB      0
                  |L27.288|
000120  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000124  7274696f
000128  6e202225
00012c  73222066
000130  61696c65
000134  64206174
000138  206c696e
00013c  65202564
000140  20696e20
000144  25730a00
                  |L27.328|
000148  7463705f          DCB      "tcp_listen_with_backlog_and_err: invalid pcb",0
00014c  6c697374
000150  656e5f77
000154  6974685f
000158  6261636b
00015c  6c6f675f
000160  616e645f
000164  6572723a
000168  20696e76
00016c  616c6964
000170  20706362
000174  00      
000175  00                DCB      0
000176  00                DCB      0
000177  00                DCB      0
                  |L27.376|
                          DCD      ||.data||
                  |L27.380|
                          DCD      tcp_accept_null

                          AREA ||i.tcp_netif_ip_addr_changed||, CODE, READONLY, ALIGN=2

                  tcp_netif_ip_addr_changed PROC
;;;2330   void
;;;2331   tcp_netif_ip_addr_changed(const ip_addr_t *old_addr, const ip_addr_t *new_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;2332   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2333     struct tcp_pcb_listen *lpcb;
;;;2334   
;;;2335     if (!ip_addr_isany(old_addr)) {
000006  2c00              CMP      r4,#0
000008  d01d              BEQ      |L28.70|
00000a  6820              LDR      r0,[r4,#0]
00000c  2800              CMP      r0,#0
00000e  d01a              BEQ      |L28.70|
;;;2336       tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_active_pcbs);
000010  4e0d              LDR      r6,|L28.72|
000012  4620              MOV      r0,r4
000014  69b1              LDR      r1,[r6,#0x18]  ; tcp_active_pcbs
000016  f7fffffe          BL       tcp_netif_ip_addr_changed_pcblist
;;;2337       tcp_netif_ip_addr_changed_pcblist(old_addr, tcp_bound_pcbs);
00001a  4620              MOV      r0,r4
00001c  6931              LDR      r1,[r6,#0x10]  ; tcp_bound_pcbs
00001e  f7fffffe          BL       tcp_netif_ip_addr_changed_pcblist
;;;2338   
;;;2339       if (!ip_addr_isany(new_addr)) {
000022  2d00              CMP      r5,#0
000024  d00f              BEQ      |L28.70|
000026  6828              LDR      r0,[r5,#0]
000028  2800              CMP      r0,#0
00002a  d00c              BEQ      |L28.70|
;;;2340         /* PCB bound to current local interface address? */
;;;2341         for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
00002c  f1060014          ADD      r0,r6,#0x14
000030  6802              LDR      r2,[r0,#0]  ; tcp_listen_pcbs
000032  e006              B        |L28.66|
                  |L28.52|
;;;2342           /* PCB bound to current local interface address? */
;;;2343           if (ip_addr_cmp(&lpcb->local_ip, old_addr)) {
000034  6810              LDR      r0,[r2,#0]
000036  6821              LDR      r1,[r4,#0]
000038  4288              CMP      r0,r1
00003a  d101              BNE      |L28.64|
;;;2344             /* The PCB is listening to the old ipaddr and
;;;2345               * is set to listen to the new one instead */
;;;2346             ip_addr_copy(lpcb->local_ip, *new_addr);
00003c  6828              LDR      r0,[r5,#0]
00003e  6010              STR      r0,[r2,#0]
                  |L28.64|
000040  68d2              LDR      r2,[r2,#0xc]          ;2341
                  |L28.66|
000042  2a00              CMP      r2,#0                 ;2341
000044  d1f6              BNE      |L28.52|
                  |L28.70|
;;;2347           }
;;;2348         }
;;;2349       }
;;;2350     }
;;;2351   }
000046  bd70              POP      {r4-r6,pc}
;;;2352   
                          ENDP

                  |L28.72|
                          DCD      ||.data||

                          AREA ||i.tcp_netif_ip_addr_changed_pcblist||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_netif_ip_addr_changed_pcblist PROC
;;;2298   static void
;;;2299   tcp_netif_ip_addr_changed_pcblist(const ip_addr_t *old_addr, struct tcp_pcb *pcb_list)
000000  b570              PUSH     {r4-r6,lr}
;;;2300   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;2301     struct tcp_pcb *pcb;
;;;2302     pcb = pcb_list;
;;;2303   
;;;2304     LWIP_ASSERT("tcp_netif_ip_addr_changed_pcblist: invalid old_addr", old_addr != NULL);
000006  2e00              CMP      r6,#0
000008  d112              BNE      |L29.48|
00000a  a30b              ADR      r3,|L29.56|
00000c  f44f6210          MOV      r2,#0x900
000010  a115              ADR      r1,|L29.104|
000012  a022              ADR      r0,|L29.156|
000014  f7fffffe          BL       __2printf
000018  e00a              B        |L29.48|
                  |L29.26|
;;;2305   
;;;2306     while (pcb != NULL) {
;;;2307       /* PCB bound to current local interface address? */
;;;2308       if (ip_addr_cmp(&pcb->local_ip, old_addr)
00001a  6820              LDR      r0,[r4,#0]
00001c  6831              LDR      r1,[r6,#0]
00001e  4288              CMP      r0,r1
000020  d105              BNE      |L29.46|
;;;2309   #if LWIP_AUTOIP
;;;2310           /* connections to link-local addresses must persist (RFC3927 ch. 1.9) */
;;;2311           && (!IP_IS_V4_VAL(pcb->local_ip) || !ip4_addr_islinklocal(ip_2_ip4(&pcb->local_ip)))
;;;2312   #endif /* LWIP_AUTOIP */
;;;2313          ) {
;;;2314         /* this connection must be aborted */
;;;2315         struct tcp_pcb *next = pcb->next;
000022  68e5              LDR      r5,[r4,#0xc]
;;;2316         LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
;;;2317         tcp_abort(pcb);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       tcp_abort
;;;2318         pcb = next;
00002a  462c              MOV      r4,r5
;;;2319       } else {
00002c  e000              B        |L29.48|
                  |L29.46|
;;;2320         pcb = pcb->next;
00002e  68e4              LDR      r4,[r4,#0xc]
                  |L29.48|
000030  2c00              CMP      r4,#0                 ;2306
000032  d1f2              BNE      |L29.26|
;;;2321       }
;;;2322     }
;;;2323   }
000034  bd70              POP      {r4-r6,pc}
;;;2324   
                          ENDP

000036  0000              DCW      0x0000
                  |L29.56|
000038  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
00003c  6964646c
000040  65776172
000044  65735c54
000048  68697264
00004c  5f506172
000050  74795c4c
000054  7749505c
000058  7372635c
00005c  636f7265
000060  5c746370
000064  2e6300  
000067  00                DCB      0
                  |L29.104|
000068  7463705f          DCB      "tcp_netif_ip_addr_changed_pcblist: invalid old_addr",0
00006c  6e657469
000070  665f6970
000074  5f616464
000078  725f6368
00007c  616e6765
000080  645f7063
000084  626c6973
000088  743a2069
00008c  6e76616c
000090  6964206f
000094  6c645f61
000098  64647200
                  |L29.156|
00009c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000a0  7274696f
0000a4  6e202225
0000a8  73222066
0000ac  61696c65
0000b0  64206174
0000b4  206c696e
0000b8  65202564
0000bc  20696e20
0000c0  25730a00

                          AREA ||i.tcp_new||, CODE, READONLY, ALIGN=1

                  tcp_new PROC
;;;1944   struct tcp_pcb *
;;;1945   tcp_new(void)
000000  2040              MOVS     r0,#0x40
;;;1946   {
;;;1947     return tcp_alloc(TCP_PRIO_NORMAL);
000002  f7ffbffe          B.W      tcp_alloc
;;;1948   }
;;;1949   
                          ENDP


                          AREA ||i.tcp_new_ip_type||, CODE, READONLY, ALIGN=1

                  tcp_new_ip_type PROC
;;;1961   struct tcp_pcb *
;;;1962   tcp_new_ip_type(u8_t type)
000000  2040              MOVS     r0,#0x40
;;;1963   {
;;;1964     struct tcp_pcb *pcb;
;;;1965     pcb = tcp_alloc(TCP_PRIO_NORMAL);
000002  f7ffbffe          B.W      tcp_alloc
;;;1966   #if LWIP_IPV4 && LWIP_IPV6
;;;1967     if (pcb != NULL) {
;;;1968       IP_SET_TYPE_VAL(pcb->local_ip, type);
;;;1969       IP_SET_TYPE_VAL(pcb->remote_ip, type);
;;;1970     }
;;;1971   #else
;;;1972     LWIP_UNUSED_ARG(type);
;;;1973   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1974     return pcb;
;;;1975   }
;;;1976   
                          ENDP


                          AREA ||i.tcp_new_port||, CODE, READONLY, ALIGN=2

                  tcp_new_port PROC
;;;1010   static u16_t
;;;1011   tcp_new_port(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1012   {
;;;1013     u8_t i;
;;;1014     u16_t n = 0;
000002  2400              MOVS     r4,#0
;;;1015     struct tcp_pcb *pcb;
;;;1016   
;;;1017   again:
;;;1018     tcp_port++;
;;;1019     if (tcp_port == TCP_LOCAL_PORT_RANGE_END) {
;;;1020       tcp_port = TCP_LOCAL_PORT_RANGE_START;
;;;1021     }
;;;1022     /* Check all PCB lists. */
;;;1023     for (i = 0; i < NUM_TCP_PCB_LISTS; i++) {
;;;1024       for (pcb = *tcp_pcb_lists[i]; pcb != NULL; pcb = pcb->next) {
000004  4e12              LDR      r6,|L32.80|
000006  4d13              LDR      r5,|L32.84|
000008  f64f77ff          MOV      r7,#0xffff            ;1019
                  |L32.12|
00000c  88a8              LDRH     r0,[r5,#4]            ;1018  ; tcp_port
00000e  1c40              ADDS     r0,r0,#1              ;1018
000010  b280              UXTH     r0,r0                 ;1018
000012  80a8              STRH     r0,[r5,#4]            ;1018
000014  42b8              CMP      r0,r7                 ;1019
000016  d102              BNE      |L32.30|
000018  f44f4040          MOV      r0,#0xc000            ;1020
00001c  80a8              STRH     r0,[r5,#4]            ;1020
                  |L32.30|
00001e  2100              MOVS     r1,#0                 ;1023
000020  88aa              LDRH     r2,[r5,#4]            ;1018
                  |L32.34|
000022  f8560021          LDR      r0,[r6,r1,LSL #2]
000026  6800              LDR      r0,[r0,#0]
000028  e00a              B        |L32.64|
                  |L32.42|
;;;1025         if (pcb->local_port == tcp_port) {
00002a  8ac3              LDRH     r3,[r0,#0x16]
00002c  4293              CMP      r3,r2
00002e  d106              BNE      |L32.62|
;;;1026           n++;
000030  1c64              ADDS     r4,r4,#1
000032  b2a4              UXTH     r4,r4
;;;1027           if (n > (TCP_LOCAL_PORT_RANGE_END - TCP_LOCAL_PORT_RANGE_START)) {
000034  f5b44f80          CMP      r4,#0x4000
000038  d3e8              BCC      |L32.12|
;;;1028             return 0;
00003a  2000              MOVS     r0,#0
;;;1029           }
;;;1030           goto again;
;;;1031         }
;;;1032       }
;;;1033     }
;;;1034     return tcp_port;
;;;1035   }
00003c  bdf0              POP      {r4-r7,pc}
                  |L32.62|
00003e  68c0              LDR      r0,[r0,#0xc]          ;1024
                  |L32.64|
000040  2800              CMP      r0,#0                 ;1024
000042  d1f2              BNE      |L32.42|
000044  1c49              ADDS     r1,r1,#1              ;1023
000046  b2c9              UXTB     r1,r1                 ;1023
000048  2904              CMP      r1,#4                 ;1023
00004a  d3ea              BCC      |L32.34|
00004c  88a8              LDRH     r0,[r5,#4]            ;1034  ; tcp_port
00004e  bdf0              POP      {r4-r7,pc}
;;;1036   
                          ENDP

                  |L32.80|
                          DCD      ||.constdata||+0x44
                  |L32.84|
                          DCD      ||.data||

                          AREA ||i.tcp_next_iss||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_next_iss PROC
;;;2214   u32_t
;;;2215   tcp_next_iss(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;2216   {
;;;2217   #ifdef LWIP_HOOK_TCP_ISN
;;;2218     LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
;;;2219     return LWIP_HOOK_TCP_ISN(&pcb->local_ip, pcb->local_port, &pcb->remote_ip, pcb->remote_port);
;;;2220   #else /* LWIP_HOOK_TCP_ISN */
;;;2221     static u32_t iss = 6510;
;;;2222   
;;;2223     LWIP_ASSERT("tcp_next_iss: invalid pcb", pcb != NULL);
000002  2800              CMP      r0,#0
000004  d106              BNE      |L33.20|
000006  a306              ADR      r3,|L33.32|
000008  f64002af          MOV      r2,#0x8af
00000c  a110              ADR      r1,|L33.80|
00000e  a017              ADR      r0,|L33.108|
000010  f7fffffe          BL       __2printf
                  |L33.20|
;;;2224     LWIP_UNUSED_ARG(pcb);
;;;2225   
;;;2226     iss += tcp_ticks;       /* XXX */
000014  491f              LDR      r1,|L33.148|
000016  e9d10202          LDRD     r0,r2,[r1,#8]
00001a  4410              ADD      r0,r0,r2
00001c  6088              STR      r0,[r1,#8]  ; iss
;;;2227     return iss;
;;;2228   #endif /* LWIP_HOOK_TCP_ISN */
;;;2229   }
00001e  bd10              POP      {r4,pc}
;;;2230   
                          ENDP

                  |L33.32|
000020  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000024  6964646c
000028  65776172
00002c  65735c54
000030  68697264
000034  5f506172
000038  74795c4c
00003c  7749505c
000040  7372635c
000044  636f7265
000048  5c746370
00004c  2e6300  
00004f  00                DCB      0
                  |L33.80|
000050  7463705f          DCB      "tcp_next_iss: invalid pcb",0
000054  6e657874
000058  5f697373
00005c  3a20696e
000060  76616c69
000064  64207063
000068  6200    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L33.108|
00006c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000070  7274696f
000074  6e202225
000078  73222066
00007c  61696c65
000080  64206174
000084  206c696e
000088  65202564
00008c  20696e20
000090  25730a00
                  |L33.148|
                          DCD      ||.data||

                          AREA ||i.tcp_pcb_purge||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_pcb_purge PROC
;;;2126   void
;;;2127   tcp_pcb_purge(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;2128   {
000002  4604              MOV      r4,r0
;;;2129     LWIP_ERROR("tcp_pcb_purge: invalid pcb", pcb != NULL, return);
000004  2c00              CMP      r4,#0
000006  d01f              BEQ      |L34.72|
;;;2130   
;;;2131     if (pcb->state != CLOSED &&
000008  7d20              LDRB     r0,[r4,#0x14]
00000a  2800              CMP      r0,#0
00000c  d01b              BEQ      |L34.70|
;;;2132         pcb->state != TIME_WAIT &&
00000e  280a              CMP      r0,#0xa
000010  d019              BEQ      |L34.70|
;;;2133         pcb->state != LISTEN) {
000012  2801              CMP      r0,#1
000014  d017              BEQ      |L34.70|
;;;2134   
;;;2135       LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));
;;;2136   
;;;2137       tcp_backlog_accepted(pcb);
;;;2138   
;;;2139       if (pcb->refused_data != NULL) {
000016  6fa0              LDR      r0,[r4,#0x78]
000018  2500              MOVS     r5,#0
00001a  b110              CBZ      r0,|L34.34|
;;;2140         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
;;;2141         pbuf_free(pcb->refused_data);
00001c  f7fffffe          BL       pbuf_free
;;;2142         pcb->refused_data = NULL;
000020  67a5              STR      r5,[r4,#0x78]
                  |L34.34|
;;;2143       }
;;;2144       if (pcb->unsent != NULL) {
;;;2145         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: not all data sent\n"));
;;;2146       }
;;;2147       if (pcb->unacked != NULL) {
;;;2148         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->unacked\n"));
;;;2149       }
;;;2150   #if TCP_QUEUE_OOSEQ
;;;2151       if (pcb->ooseq != NULL) {
000022  6f60              LDR      r0,[r4,#0x74]
000024  b110              CBZ      r0,|L34.44|
;;;2152         LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
;;;2153         tcp_free_ooseq(pcb);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       tcp_free_ooseq
                  |L34.44|
;;;2154       }
;;;2155   #endif /* TCP_QUEUE_OOSEQ */
;;;2156   
;;;2157       /* Stop the retransmission timer as it will expect data on unacked
;;;2158          queue if it fires */
;;;2159       pcb->rtime = -1;
00002c  f04f30ff          MOV      r0,#0xffffffff
000030  8620              STRH     r0,[r4,#0x30]
;;;2160   
;;;2161       tcp_segs_free(pcb->unsent);
000032  6ee0              LDR      r0,[r4,#0x6c]
000034  f7fffffe          BL       tcp_segs_free
;;;2162       tcp_segs_free(pcb->unacked);
000038  6f20              LDR      r0,[r4,#0x70]
00003a  f7fffffe          BL       tcp_segs_free
;;;2163       pcb->unacked = pcb->unsent = NULL;
00003e  66e5              STR      r5,[r4,#0x6c]
000040  6725              STR      r5,[r4,#0x70]
;;;2164   #if TCP_OVERSIZE
;;;2165       pcb->unsent_oversize = 0;
000042  f8a45068          STRH     r5,[r4,#0x68]
                  |L34.70|
;;;2166   #endif /* TCP_OVERSIZE */
;;;2167     }
;;;2168   }
000046  bd70              POP      {r4-r6,pc}
                  |L34.72|
000048  e8bd4070          POP      {r4-r6,lr}            ;2129
00004c  a303              ADR      r3,|L34.92|
00004e  f6400251          MOV      r2,#0x851             ;2129
000052  a10e              ADR      r1,|L34.140|
000054  a014              ADR      r0,|L34.168|
000056  f7ffbffe          B.W      __2printf
;;;2169   
                          ENDP

00005a  0000              DCW      0x0000
                  |L34.92|
00005c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000060  6964646c
000064  65776172
000068  65735c54
00006c  68697264
000070  5f506172
000074  74795c4c
000078  7749505c
00007c  7372635c
000080  636f7265
000084  5c746370
000088  2e6300  
00008b  00                DCB      0
                  |L34.140|
00008c  7463705f          DCB      "tcp_pcb_purge: invalid pcb",0
000090  7063625f
000094  70757267
000098  653a2069
00009c  6e76616c
0000a0  69642070
0000a4  636200  
0000a7  00                DCB      0
                  |L34.168|
0000a8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000ac  7274696f
0000b0  6e202225
0000b4  73222066
0000b8  61696c65
0000bc  64206174
0000c0  206c696e
0000c4  65202564
0000c8  20696e20
0000cc  25730a00

                          AREA ||i.tcp_pcb_remove||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_pcb_remove PROC
;;;2176   void
;;;2177   tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;2178   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;2179     LWIP_ASSERT("tcp_pcb_remove: invalid pcb", pcb != NULL);
000006  2c00              CMP      r4,#0
000008  d106              BNE      |L35.24|
00000a  a329              ADR      r3,|L35.176|
00000c  f6400283          MOV      r2,#0x883
000010  a133              ADR      r1,|L35.224|
000012  a03a              ADR      r0,|L35.252|
000014  f7fffffe          BL       __2printf
                  |L35.24|
;;;2180     LWIP_ASSERT("tcp_pcb_remove: invalid pcblist", pcblist != NULL);
000018  2d00              CMP      r5,#0
00001a  d106              BNE      |L35.42|
00001c  a324              ADR      r3,|L35.176|
00001e  f6400284          MOV      r2,#0x884
000022  a140              ADR      r1,|L35.292|
000024  a035              ADR      r0,|L35.252|
000026  f7fffffe          BL       __2printf
                  |L35.42|
;;;2181   
;;;2182     TCP_RMV(pcblist, pcb);
00002a  6828              LDR      r0,[r5,#0]
00002c  42a0              CMP      r0,r4
00002e  d109              BNE      |L35.68|
000030  68c0              LDR      r0,[r0,#0xc]
000032  6028              STR      r0,[r5,#0]
000034  e008              B        |L35.72|
                  |L35.54|
000036  68c1              LDR      r1,[r0,#0xc]
000038  42a1              CMP      r1,r4
00003a  d102              BNE      |L35.66|
00003c  68e1              LDR      r1,[r4,#0xc]
00003e  60c1              STR      r1,[r0,#0xc]
000040  e002              B        |L35.72|
                  |L35.66|
000042  4608              MOV      r0,r1
                  |L35.68|
000044  2800              CMP      r0,#0
000046  d1f6              BNE      |L35.54|
                  |L35.72|
000048  2500              MOVS     r5,#0
00004a  60e5              STR      r5,[r4,#0xc]
;;;2183   
;;;2184     tcp_pcb_purge(pcb);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       tcp_pcb_purge
;;;2185   
;;;2186     /* if there is an outstanding delayed ACKs, send it */
;;;2187     if ((pcb->state != TIME_WAIT) &&
000052  7d20              LDRB     r0,[r4,#0x14]
000054  280a              CMP      r0,#0xa
000056  d00a              BEQ      |L35.110|
;;;2188         (pcb->state != LISTEN) &&
000058  2801              CMP      r0,#1
00005a  d008              BEQ      |L35.110|
;;;2189         (pcb->flags & TF_ACK_DELAY)) {
00005c  8b60              LDRH     r0,[r4,#0x1a]
00005e  07c1              LSLS     r1,r0,#31
000060  d005              BEQ      |L35.110|
;;;2190       tcp_ack_now(pcb);
000062  f0400002          ORR      r0,r0,#2
000066  8360              STRH     r0,[r4,#0x1a]
;;;2191       tcp_output(pcb);
000068  4620              MOV      r0,r4
00006a  f7fffffe          BL       tcp_output
                  |L35.110|
;;;2192     }
;;;2193   
;;;2194     if (pcb->state != LISTEN) {
00006e  7d20              LDRB     r0,[r4,#0x14]
000070  2801              CMP      r0,#1
000072  d01a              BEQ      |L35.170|
;;;2195       LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
000074  6ee0              LDR      r0,[r4,#0x6c]
000076  b130              CBZ      r0,|L35.134|
000078  a30d              ADR      r3,|L35.176|
00007a  f6400293          MOV      r2,#0x893
00007e  a131              ADR      r1,|L35.324|
000080  a01e              ADR      r0,|L35.252|
000082  f7fffffe          BL       __2printf
                  |L35.134|
;;;2196       LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
000086  6f20              LDR      r0,[r4,#0x70]
000088  b130              CBZ      r0,|L35.152|
00008a  a309              ADR      r3,|L35.176|
00008c  f6400294          MOV      r2,#0x894
000090  a132              ADR      r1,|L35.348|
000092  a01a              ADR      r0,|L35.252|
000094  f7fffffe          BL       __2printf
                  |L35.152|
;;;2197   #if TCP_QUEUE_OOSEQ
;;;2198       LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
000098  6f60              LDR      r0,[r4,#0x74]
00009a  b130              CBZ      r0,|L35.170|
00009c  a304              ADR      r3,|L35.176|
00009e  f6400296          MOV      r2,#0x896
0000a2  a135              ADR      r1,|L35.376|
0000a4  a015              ADR      r0,|L35.252|
0000a6  f7fffffe          BL       __2printf
                  |L35.170|
;;;2199   #endif /* TCP_QUEUE_OOSEQ */
;;;2200     }
;;;2201   
;;;2202     pcb->state = CLOSED;
0000aa  7525              STRB     r5,[r4,#0x14]
;;;2203     /* reset the local port to prevent the pcb from being 'bound' */
;;;2204     pcb->local_port = 0;
0000ac  82e5              STRH     r5,[r4,#0x16]
;;;2205   
;;;2206     LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;2207   }
0000ae  bd70              POP      {r4-r6,pc}
;;;2208   
                          ENDP

                  |L35.176|
0000b0  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
0000b4  6964646c
0000b8  65776172
0000bc  65735c54
0000c0  68697264
0000c4  5f506172
0000c8  74795c4c
0000cc  7749505c
0000d0  7372635c
0000d4  636f7265
0000d8  5c746370
0000dc  2e6300  
0000df  00                DCB      0
                  |L35.224|
0000e0  7463705f          DCB      "tcp_pcb_remove: invalid pcb",0
0000e4  7063625f
0000e8  72656d6f
0000ec  76653a20
0000f0  696e7661
0000f4  6c696420
0000f8  70636200
                  |L35.252|
0000fc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000100  7274696f
000104  6e202225
000108  73222066
00010c  61696c65
000110  64206174
000114  206c696e
000118  65202564
00011c  20696e20
000120  25730a00
                  |L35.292|
000124  7463705f          DCB      "tcp_pcb_remove: invalid pcblist",0
000128  7063625f
00012c  72656d6f
000130  76653a20
000134  696e7661
000138  6c696420
00013c  7063626c
000140  69737400
                  |L35.324|
000144  756e7365          DCB      "unsent segments leaking",0
000148  6e742073
00014c  65676d65
000150  6e747320
000154  6c65616b
000158  696e6700
                  |L35.348|
00015c  756e6163          DCB      "unacked segments leaking",0
000160  6b656420
000164  7365676d
000168  656e7473
00016c  206c6561
000170  6b696e67
000174  00      
000175  00                DCB      0
000176  00                DCB      0
000177  00                DCB      0
                  |L35.376|
000178  6f6f7365          DCB      "ooseq segments leaking",0
00017c  71207365
000180  676d656e
000184  7473206c
000188  65616b69
00018c  6e6700  
00018f  00                DCB      0

                          AREA ||i.tcp_poll||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_poll PROC
;;;2104   void
;;;2105   tcp_poll(struct tcp_pcb *pcb, tcp_poll_fn poll, u8_t interval)
000000  b570              PUSH     {r4-r6,lr}
;;;2106   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;2107     LWIP_ASSERT_CORE_LOCKED();
;;;2108   
;;;2109     LWIP_ERROR("tcp_poll: invalid pcb", pcb != NULL, return);
000008  2c00              CMP      r4,#0
00000a  d003              BEQ      |L36.20|
;;;2110     LWIP_ASSERT("invalid socket state for poll", pcb->state != LISTEN);
00000c  7d20              LDRB     r0,[r4,#0x14]
00000e  2801              CMP      r0,#1
000010  d009              BEQ      |L36.38|
000012  e00f              B        |L36.52|
                  |L36.20|
000014  e8bd4070          POP      {r4-r6,lr}            ;2109
000018  a308              ADR      r3,|L36.60|
00001a  f640023d          MOV      r2,#0x83d             ;2109
00001e  a113              ADR      r1,|L36.108|
000020  a018              ADR      r0,|L36.132|
000022  f7ffbffe          B.W      __2printf
                  |L36.38|
000026  a305              ADR      r3,|L36.60|
000028  f640023e          MOV      r2,#0x83e
00002c  a11f              ADR      r1,|L36.172|
00002e  a015              ADR      r0,|L36.132|
000030  f7fffffe          BL       __2printf
                  |L36.52|
;;;2111   
;;;2112   #if LWIP_CALLBACK_API
;;;2113     pcb->poll = poll;
000034  f8c4508c          STR      r5,[r4,#0x8c]
;;;2114   #else /* LWIP_CALLBACK_API */
;;;2115     LWIP_UNUSED_ARG(poll);
;;;2116   #endif /* LWIP_CALLBACK_API */
;;;2117     pcb->pollinterval = interval;
000038  7766              STRB     r6,[r4,#0x1d]
;;;2118   }
00003a  bd70              POP      {r4-r6,pc}
;;;2119   
                          ENDP

                  |L36.60|
00003c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000040  6964646c
000044  65776172
000048  65735c54
00004c  68697264
000050  5f506172
000054  74795c4c
000058  7749505c
00005c  7372635c
000060  636f7265
000064  5c746370
000068  2e6300  
00006b  00                DCB      0
                  |L36.108|
00006c  7463705f          DCB      "tcp_poll: invalid pcb",0
000070  706f6c6c
000074  3a20696e
000078  76616c69
00007c  64207063
000080  6200    
000082  00                DCB      0
000083  00                DCB      0
                  |L36.132|
000084  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000088  7274696f
00008c  6e202225
000090  73222066
000094  61696c65
000098  64206174
00009c  206c696e
0000a0  65202564
0000a4  20696e20
0000a8  25730a00
                  |L36.172|
0000ac  696e7661          DCB      "invalid socket state for poll",0
0000b0  6c696420
0000b4  736f636b
0000b8  65742073
0000bc  74617465
0000c0  20666f72
0000c4  20706f6c
0000c8  6c00    
0000ca  00                DCB      0
0000cb  00                DCB      0

                          AREA ||i.tcp_process_refused_data||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_process_refused_data PROC
;;;1538   err_t
;;;1539   tcp_process_refused_data(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1540   {
000004  4604              MOV      r4,r0
;;;1541   #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;1542     struct pbuf *rest;
;;;1543   #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;1544   
;;;1545     LWIP_ERROR("tcp_process_refused_data: invalid pcb", pcb != NULL, return ERR_ARG);
000006  2c00              CMP      r4,#0
000008  d00d              BEQ      |L37.38|
;;;1546   
;;;1547   #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;1548     while (pcb->refused_data != NULL)
;;;1549   #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;1550     {
;;;1551       err_t err;
;;;1552       u8_t refused_flags = pcb->refused_data->flags;
00000a  6fa5              LDR      r5,[r4,#0x78]
00000c  7b6f              LDRB     r7,[r5,#0xd]
;;;1553       /* set pcb->refused_data to NULL in case the callback frees it and then
;;;1554          closes the pcb */
;;;1555       struct pbuf *refused_data = pcb->refused_data;
;;;1556   #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;1557       pbuf_split_64k(refused_data, &rest);
;;;1558       pcb->refused_data = rest;
;;;1559   #else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;1560       pcb->refused_data = NULL;
00000e  2000              MOVS     r0,#0
000010  67a0              STR      r0,[r4,#0x78]
;;;1561   #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;1562       /* Notify again application with data previously received. */
;;;1563       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
;;;1564       TCP_EVENT_RECV(pcb, refused_data, ERR_OK, err);
000012  f8d46084          LDR      r6,[r4,#0x84]
000016  2e00              CMP      r6,#0
000018  d010              BEQ      |L37.60|
00001a  2300              MOVS     r3,#0
00001c  462a              MOV      r2,r5
00001e  4621              MOV      r1,r4
000020  6920              LDR      r0,[r4,#0x10]
000022  47b0              BLX      r6
000024  e010              B        |L37.72|
                  |L37.38|
000026  a319              ADR      r3,|L37.140|
000028  f2406209          MOV      r2,#0x609             ;1545
00002c  a123              ADR      r1,|L37.188|
00002e  a02d              ADR      r0,|L37.228|
000030  f7fffffe          BL       __2printf
000034  f06f000f          MVN      r0,#0xf               ;1545
                  |L37.56|
;;;1565       if (err == ERR_OK) {
;;;1566         /* did refused_data include a FIN? */
;;;1567         if ((refused_flags & PBUF_FLAG_TCP_FIN)
;;;1568   #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;1569             && (rest == NULL)
;;;1570   #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;1571            ) {
;;;1572           /* correct rcv_wnd as the application won't call tcp_recved()
;;;1573              for the FIN's seqno */
;;;1574           if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
;;;1575             pcb->rcv_wnd++;
;;;1576           }
;;;1577           TCP_EVENT_CLOSED(pcb, err);
;;;1578           if (err == ERR_ABRT) {
;;;1579             return ERR_ABRT;
;;;1580           }
;;;1581         }
;;;1582       } else if (err == ERR_ABRT) {
;;;1583         /* if err == ERR_ABRT, 'pcb' is already deallocated */
;;;1584         /* Drop incoming packets because pcb is "full" (only if the incoming
;;;1585            segment contains data). */
;;;1586         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
;;;1587         return ERR_ABRT;
;;;1588       } else {
;;;1589         /* data is still refused, pbuf is still valid (go on for ACK-only packets) */
;;;1590   #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;1591         if (rest != NULL) {
;;;1592           pbuf_cat(refused_data, rest);
;;;1593         }
;;;1594   #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;1595         pcb->refused_data = refused_data;
;;;1596         return ERR_INPROGRESS;
;;;1597       }
;;;1598     }
;;;1599     return ERR_OK;
;;;1600   }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L37.60|
00003c  2300              MOVS     r3,#0                 ;1564
00003e  462a              MOV      r2,r5                 ;1564
000040  4621              MOV      r1,r4                 ;1564
000042  4618              MOV      r0,r3                 ;1564
000044  f7fffffe          BL       tcp_recv_null
                  |L37.72|
000048  f06f060c          MVN      r6,#0xc               ;1578
00004c  b128              CBZ      r0,|L37.90|
00004e  300d              ADDS     r0,r0,#0xd            ;1582
000050  d019              BEQ      |L37.134|
000052  67a5              STR      r5,[r4,#0x78]         ;1595
000054  f06f0004          MVN      r0,#4                 ;1596
000058  e7ee              B        |L37.56|
                  |L37.90|
00005a  06b9              LSLS     r1,r7,#26             ;1567
00005c  d50f              BPL      |L37.126|
00005e  8d21              LDRH     r1,[r4,#0x28]         ;1574
000060  f5b16f06          CMP      r1,#0x860             ;1574
000064  d001              BEQ      |L37.106|
000066  1c49              ADDS     r1,r1,#1              ;1575
000068  8521              STRH     r1,[r4,#0x28]         ;1575
                  |L37.106|
00006a  f8d45084          LDR      r5,[r4,#0x84]         ;1577
00006e  b125              CBZ      r5,|L37.122|
000070  2300              MOVS     r3,#0                 ;1577
000072  461a              MOV      r2,r3                 ;1577
000074  4621              MOV      r1,r4                 ;1577
000076  6920              LDR      r0,[r4,#0x10]         ;1577
000078  47a8              BLX      r5                    ;1577
                  |L37.122|
00007a  300d              ADDS     r0,r0,#0xd            ;1578
00007c  d001              BEQ      |L37.130|
                  |L37.126|
00007e  2000              MOVS     r0,#0                 ;1599
000080  e7da              B        |L37.56|
                  |L37.130|
000082  4630              MOV      r0,r6                 ;1579
000084  e7d8              B        |L37.56|
                  |L37.134|
000086  4630              MOV      r0,r6                 ;1587
000088  e7d6              B        |L37.56|
;;;1601   
                          ENDP

00008a  0000              DCW      0x0000
                  |L37.140|
00008c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000090  6964646c
000094  65776172
000098  65735c54
00009c  68697264
0000a0  5f506172
0000a4  74795c4c
0000a8  7749505c
0000ac  7372635c
0000b0  636f7265
0000b4  5c746370
0000b8  2e6300  
0000bb  00                DCB      0
                  |L37.188|
0000bc  7463705f          DCB      "tcp_process_refused_data: invalid pcb",0
0000c0  70726f63
0000c4  6573735f
0000c8  72656675
0000cc  7365645f
0000d0  64617461
0000d4  3a20696e
0000d8  76616c69
0000dc  64207063
0000e0  6200    
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L37.228|
0000e4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000e8  7274696f
0000ec  6e202225
0000f0  73222066
0000f4  61696c65
0000f8  64206174
0000fc  206c696e
000100  65202564
000104  20696e20
000108  25730a00

                          AREA ||i.tcp_recv||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_recv PROC
;;;2010   void
;;;2011   tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv)
000000  b570              PUSH     {r4-r6,lr}
;;;2012   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2013     LWIP_ASSERT_CORE_LOCKED();
;;;2014     if (pcb != NULL) {
000006  2c00              CMP      r4,#0
000008  d00b              BEQ      |L38.34|
;;;2015       LWIP_ASSERT("invalid socket state for recv callback", pcb->state != LISTEN);
00000a  7d20              LDRB     r0,[r4,#0x14]
00000c  2801              CMP      r0,#1
00000e  d106              BNE      |L38.30|
000010  a304              ADR      r3,|L38.36|
000012  f24072df          MOV      r2,#0x7df
000016  a10f              ADR      r1,|L38.84|
000018  a018              ADR      r0,|L38.124|
00001a  f7fffffe          BL       __2printf
                  |L38.30|
;;;2016       pcb->recv = recv;
00001e  f8c45084          STR      r5,[r4,#0x84]
                  |L38.34|
;;;2017     }
;;;2018   }
000022  bd70              POP      {r4-r6,pc}
;;;2019   
                          ENDP

                  |L38.36|
000024  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000028  6964646c
00002c  65776172
000030  65735c54
000034  68697264
000038  5f506172
00003c  74795c4c
000040  7749505c
000044  7372635c
000048  636f7265
00004c  5c746370
000050  2e6300  
000053  00                DCB      0
                  |L38.84|
000054  696e7661          DCB      "invalid socket state for recv callback",0
000058  6c696420
00005c  736f636b
000060  65742073
000064  74617465
000068  20666f72
00006c  20726563
000070  76206361
000074  6c6c6261
000078  636b00  
00007b  00                DCB      0
                  |L38.124|
00007c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000080  7274696f
000084  6e202225
000088  73222066
00008c  61696c65
000090  64206174
000094  206c696e
000098  65202564
00009c  20696e20
0000a0  25730a00

                          AREA ||i.tcp_recv_null||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_recv_null PROC
;;;1683   err_t
;;;1684   tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
000000  b510              PUSH     {r4,lr}
;;;1685   {
000002  4608              MOV      r0,r1
000004  4614              MOV      r4,r2
;;;1686     LWIP_UNUSED_ARG(arg);
;;;1687   
;;;1688     LWIP_ERROR("tcp_recv_null: invalid pcb", pcb != NULL, return ERR_ARG);
000006  2800              CMP      r0,#0
000008  d008              BEQ      |L39.28|
;;;1689   
;;;1690     if (p != NULL) {
00000a  2c00              CMP      r4,#0
00000c  d010              BEQ      |L39.48|
;;;1691       tcp_recved(pcb, p->tot_len);
00000e  8921              LDRH     r1,[r4,#8]
000010  f7fffffe          BL       tcp_recved
;;;1692       pbuf_free(p);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       pbuf_free
00001a  e00a              B        |L39.50|
                  |L39.28|
00001c  a308              ADR      r3,|L39.64|
00001e  f44f62d3          MOV      r2,#0x698             ;1688
000022  a113              ADR      r1,|L39.112|
000024  a019              ADR      r0,|L39.140|
000026  f7fffffe          BL       __2printf
00002a  f06f000f          MVN      r0,#0xf               ;1688
;;;1693     } else if (err == ERR_OK) {
;;;1694       return tcp_close(pcb);
;;;1695     }
;;;1696     return ERR_OK;
;;;1697   }
00002e  bd10              POP      {r4,pc}
                  |L39.48|
000030  b10b              CBZ      r3,|L39.54|
                  |L39.50|
000032  2000              MOVS     r0,#0                 ;1696
000034  bd10              POP      {r4,pc}
                  |L39.54|
000036  e8bd4010          POP      {r4,lr}               ;1694
00003a  f7ffbffe          B.W      tcp_close
;;;1698   #endif /* LWIP_CALLBACK_API */
                          ENDP

00003e  0000              DCW      0x0000
                  |L39.64|
000040  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000044  6964646c
000048  65776172
00004c  65735c54
000050  68697264
000054  5f506172
000058  74795c4c
00005c  7749505c
000060  7372635c
000064  636f7265
000068  5c746370
00006c  2e6300  
00006f  00                DCB      0
                  |L39.112|
000070  7463705f          DCB      "tcp_recv_null: invalid pcb",0
000074  72656376
000078  5f6e756c
00007c  6c3a2069
000080  6e76616c
000084  69642070
000088  636200  
00008b  00                DCB      0
                  |L39.140|
00008c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000090  7274696f
000094  6e202225
000098  73222066
00009c  61696c65
0000a0  64206174
0000a4  206c696e
0000a8  65202564
0000ac  20696e20
0000b0  25730a00

                          AREA ||i.tcp_recved||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_recved PROC
;;;967    void
;;;968    tcp_recved(struct tcp_pcb *pcb, u16_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;969    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;970      u32_t wnd_inflation;
;;;971      tcpwnd_size_t rcv_wnd;
;;;972    
;;;973      LWIP_ASSERT_CORE_LOCKED();
;;;974    
;;;975      LWIP_ERROR("tcp_recved: invalid pcb", pcb != NULL, return);
000006  2c00              CMP      r4,#0
000008  d003              BEQ      |L40.18|
;;;976    
;;;977      /* pcb->state LISTEN not allowed here */
;;;978      LWIP_ASSERT("don't call tcp_recved for listen-pcbs",
00000a  7d20              LDRB     r0,[r4,#0x14]
00000c  2801              CMP      r0,#1
00000e  d009              BEQ      |L40.36|
000010  e00f              B        |L40.50|
                  |L40.18|
000012  e8bd4070          POP      {r4-r6,lr}            ;975
000016  a315              ADR      r3,|L40.108|
000018  f24032cf          MOV      r2,#0x3cf             ;975
00001c  a11f              ADR      r1,|L40.156|
00001e  a025              ADR      r0,|L40.180|
000020  f7ffbffe          B.W      __2printf
                  |L40.36|
000024  a311              ADR      r3,|L40.108|
000026  f24032d2          MOV      r2,#0x3d2
00002a  a12c              ADR      r1,|L40.220|
00002c  a021              ADR      r0,|L40.180|
00002e  f7fffffe          BL       __2printf
                  |L40.50|
;;;979                  pcb->state != LISTEN);
;;;980    
;;;981      rcv_wnd = (tcpwnd_size_t)(pcb->rcv_wnd + len);
000032  8d22              LDRH     r2,[r4,#0x28]
000034  1950              ADDS     r0,r2,r5
000036  b280              UXTH     r0,r0
;;;982      if ((rcv_wnd > TCP_WND_MAX(pcb)) || (rcv_wnd < pcb->rcv_wnd)) {
000038  f44f6106          MOV      r1,#0x860
00003c  4288              CMP      r0,r1
00003e  d801              BHI      |L40.68|
000040  4282              CMP      r2,r0
000042  d901              BLS      |L40.72|
                  |L40.68|
;;;983        /* window got too big or tcpwnd_size_t overflow */
;;;984        LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: window got too big or tcpwnd_size_t overflow\n"));
;;;985        pcb->rcv_wnd = TCP_WND_MAX(pcb);
000044  8521              STRH     r1,[r4,#0x28]
000046  e000              B        |L40.74|
                  |L40.72|
;;;986      } else  {
;;;987        pcb->rcv_wnd = rcv_wnd;
000048  8520              STRH     r0,[r4,#0x28]
                  |L40.74|
;;;988      }
;;;989    
;;;990      wnd_inflation = tcp_update_rcv_ann_wnd(pcb);
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;991    
;;;992      /* If the change in the right edge of window is significant (default
;;;993       * watermark is TCP_WND/4), then send an explicit update now.
;;;994       * Otherwise wait for a packet to be sent in the normal course of
;;;995       * events (or more window to be available later) */
;;;996      if (wnd_inflation >= TCP_WND_UPDATE_THRESHOLD) {
000050  f5b07f06          CMP      r0,#0x218
000054  d308              BCC      |L40.104|
;;;997        tcp_ack_now(pcb);
000056  8b60              LDRH     r0,[r4,#0x1a]
000058  f0400002          ORR      r0,r0,#2
00005c  8360              STRH     r0,[r4,#0x1a]
;;;998        tcp_output(pcb);
00005e  4620              MOV      r0,r4
000060  e8bd4070          POP      {r4-r6,lr}
000064  f7ffbffe          B.W      tcp_output
                  |L40.104|
;;;999      }
;;;1000   
;;;1001     LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: received %"U16_F" bytes, wnd %"TCPWNDSIZE_F" (%"TCPWNDSIZE_F").\n",
;;;1002                             len, pcb->rcv_wnd, (u16_t)(TCP_WND_MAX(pcb) - pcb->rcv_wnd)));
;;;1003   }
000068  bd70              POP      {r4-r6,pc}
;;;1004   
                          ENDP

00006a  0000              DCW      0x0000
                  |L40.108|
00006c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000070  6964646c
000074  65776172
000078  65735c54
00007c  68697264
000080  5f506172
000084  74795c4c
000088  7749505c
00008c  7372635c
000090  636f7265
000094  5c746370
000098  2e6300  
00009b  00                DCB      0
                  |L40.156|
00009c  7463705f          DCB      "tcp_recved: invalid pcb",0
0000a0  72656376
0000a4  65643a20
0000a8  696e7661
0000ac  6c696420
0000b0  70636200
                  |L40.180|
0000b4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000b8  7274696f
0000bc  6e202225
0000c0  73222066
0000c4  61696c65
0000c8  64206174
0000cc  206c696e
0000d0  65202564
0000d4  20696e20
0000d8  25730a00
                  |L40.220|
0000dc  646f6e27          DCB      "don't call tcp_recved for listen-pcbs",0
0000e0  74206361
0000e4  6c6c2074
0000e8  63705f72
0000ec  65637665
0000f0  6420666f
0000f4  72206c69
0000f8  7374656e
0000fc  2d706362
000100  7300    
000102  00                DCB      0
000103  00                DCB      0

                          AREA ||i.tcp_remove_listener||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_remove_listener PROC
;;;250    static void
;;;251    tcp_remove_listener(struct tcp_pcb *list, struct tcp_pcb_listen *lpcb)
000000  b570              PUSH     {r4-r6,lr}
;;;252    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;253      struct tcp_pcb *pcb;
;;;254    
;;;255      LWIP_ASSERT("tcp_remove_listener: invalid listener", lpcb != NULL);
000006  2d00              CMP      r5,#0
000008  d105              BNE      |L41.22|
00000a  a308              ADR      r3,|L41.44|
00000c  22ff              MOVS     r2,#0xff
00000e  a113              ADR      r1,|L41.92|
000010  a01c              ADR      r0,|L41.132|
000012  f7fffffe          BL       __2printf
                  |L41.22|
;;;256    
;;;257      for (pcb = list; pcb != NULL; pcb = pcb->next) {
000016  2000              MOVS     r0,#0
000018  e004              B        |L41.36|
                  |L41.26|
;;;258        if (pcb->listener == lpcb) {
00001a  6fe1              LDR      r1,[r4,#0x7c]
00001c  42a9              CMP      r1,r5
00001e  d100              BNE      |L41.34|
;;;259          pcb->listener = NULL;
000020  67e0              STR      r0,[r4,#0x7c]
                  |L41.34|
000022  68e4              LDR      r4,[r4,#0xc]          ;257
                  |L41.36|
000024  2c00              CMP      r4,#0                 ;257
000026  d1f8              BNE      |L41.26|
;;;260        }
;;;261      }
;;;262    }
000028  bd70              POP      {r4-r6,pc}
;;;263    #endif
                          ENDP

00002a  0000              DCW      0x0000
                  |L41.44|
00002c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000030  6964646c
000034  65776172
000038  65735c54
00003c  68697264
000040  5f506172
000044  74795c4c
000048  7749505c
00004c  7372635c
000050  636f7265
000054  5c746370
000058  2e6300  
00005b  00                DCB      0
                  |L41.92|
00005c  7463705f          DCB      "tcp_remove_listener: invalid listener",0
000060  72656d6f
000064  76655f6c
000068  69737465
00006c  6e65723a
000070  20696e76
000074  616c6964
000078  206c6973
00007c  74656e65
000080  7200    
000082  00                DCB      0
000083  00                DCB      0
                  |L41.132|
000084  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000088  7274696f
00008c  6e202225
000090  73222066
000094  61696c65
000098  64206174
00009c  206c696e
0000a0  65202564
0000a4  20696e20
0000a8  25730a00

                          AREA ||i.tcp_seg_copy||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_seg_copy PROC
;;;1661   struct tcp_seg *
;;;1662   tcp_seg_copy(struct tcp_seg *seg)
000000  b570              PUSH     {r4-r6,lr}
;;;1663   {
000002  4604              MOV      r4,r0
;;;1664     struct tcp_seg *cseg;
;;;1665   
;;;1666     LWIP_ASSERT("tcp_seg_copy: invalid seg", seg != NULL);
000004  2c00              CMP      r4,#0
000006  d106              BNE      |L42.22|
000008  a30b              ADR      r3,|L42.56|
00000a  f2406282          MOV      r2,#0x682
00000e  a116              ADR      r1,|L42.104|
000010  a01c              ADR      r0,|L42.132|
000012  f7fffffe          BL       __2printf
                  |L42.22|
;;;1667   
;;;1668     cseg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG);
000016  2003              MOVS     r0,#3
000018  f7fffffe          BL       memp_malloc
00001c  4605              MOV      r5,r0
;;;1669     if (cseg == NULL) {
00001e  b14d              CBZ      r5,|L42.52|
;;;1670       return NULL;
;;;1671     }
;;;1672     SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg));
000020  1d20              ADDS     r0,r4,#4
000022  6822              LDR      r2,[r4,#0]
000024  c80b              LDM      r0,{r0,r1,r3}
000026  1d2c              ADDS     r4,r5,#4
000028  c40b              STM      r4!,{r0,r1,r3}
00002a  602a              STR      r2,[r5,#0]
;;;1673     pbuf_ref(cseg->p);
00002c  f7fffffe          BL       pbuf_ref
;;;1674     return cseg;
000030  4628              MOV      r0,r5
;;;1675   }
000032  bd70              POP      {r4-r6,pc}
                  |L42.52|
000034  2000              MOVS     r0,#0                 ;1670
000036  bd70              POP      {r4-r6,pc}
;;;1676   #endif /* TCP_QUEUE_OOSEQ */
                          ENDP

                  |L42.56|
000038  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
00003c  6964646c
000040  65776172
000044  65735c54
000048  68697264
00004c  5f506172
000050  74795c4c
000054  7749505c
000058  7372635c
00005c  636f7265
000060  5c746370
000064  2e6300  
000067  00                DCB      0
                  |L42.104|
000068  7463705f          DCB      "tcp_seg_copy: invalid seg",0
00006c  7365675f
000070  636f7079
000074  3a20696e
000078  76616c69
00007c  64207365
000080  6700    
000082  00                DCB      0
000083  00                DCB      0
                  |L42.132|
000084  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000088  7274696f
00008c  6e202225
000090  73222066
000094  61696c65
000098  64206174
00009c  206c696e
0000a0  65202564
0000a4  20696e20
0000a8  25730a00

                          AREA ||i.tcp_seg_free||, CODE, READONLY, ALIGN=1

                  tcp_seg_free PROC
;;;1622   void
;;;1623   tcp_seg_free(struct tcp_seg *seg)
000000  b510              PUSH     {r4,lr}
;;;1624   {
000002  4604              MOV      r4,r0
;;;1625     if (seg != NULL) {
000004  2c00              CMP      r4,#0
000006  d009              BEQ      |L43.28|
;;;1626       if (seg->p != NULL) {
000008  6860              LDR      r0,[r4,#4]
00000a  b108              CBZ      r0,|L43.16|
;;;1627         pbuf_free(seg->p);
00000c  f7fffffe          BL       pbuf_free
                  |L43.16|
;;;1628   #if TCP_DEBUG
;;;1629         seg->p = NULL;
;;;1630   #endif /* TCP_DEBUG */
;;;1631       }
;;;1632       memp_free(MEMP_TCP_SEG, seg);
000010  4621              MOV      r1,r4
000012  e8bd4010          POP      {r4,lr}
000016  2003              MOVS     r0,#3
000018  f7ffbffe          B.W      memp_free
                  |L43.28|
;;;1633     }
;;;1634   }
00001c  bd10              POP      {r4,pc}
;;;1635   
                          ENDP


                          AREA ||i.tcp_segs_free||, CODE, READONLY, ALIGN=1

                  tcp_segs_free PROC
;;;1607   void
;;;1608   tcp_segs_free(struct tcp_seg *seg)
000000  b510              PUSH     {r4,lr}
;;;1609   {
;;;1610     while (seg != NULL) {
;;;1611       struct tcp_seg *next = seg->next;
;;;1612       tcp_seg_free(seg);
;;;1613       seg = next;
;;;1614     }
000002  e003              B        |L44.12|
                  |L44.4|
000004  6804              LDR      r4,[r0,#0]            ;1611
000006  f7fffffe          BL       tcp_seg_free
00000a  4620              MOV      r0,r4                 ;1613
                  |L44.12|
00000c  2800              CMP      r0,#0                 ;1610
00000e  d1f9              BNE      |L44.4|
;;;1615   }
000010  bd10              POP      {r4,pc}
;;;1616   
                          ENDP


                          AREA ||i.tcp_sent||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_sent PROC
;;;2030   void
;;;2031   tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent)
000000  b570              PUSH     {r4-r6,lr}
;;;2032   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;2033     LWIP_ASSERT_CORE_LOCKED();
;;;2034     if (pcb != NULL) {
000006  2c00              CMP      r4,#0
000008  d00b              BEQ      |L45.34|
;;;2035       LWIP_ASSERT("invalid socket state for sent callback", pcb->state != LISTEN);
00000a  7d20              LDRB     r0,[r4,#0x14]
00000c  2801              CMP      r0,#1
00000e  d106              BNE      |L45.30|
000010  a304              ADR      r3,|L45.36|
000012  f24072f3          MOV      r2,#0x7f3
000016  a10f              ADR      r1,|L45.84|
000018  a018              ADR      r0,|L45.124|
00001a  f7fffffe          BL       __2printf
                  |L45.30|
;;;2036       pcb->sent = sent;
00001e  f8c45080          STR      r5,[r4,#0x80]
                  |L45.34|
;;;2037     }
;;;2038   }
000022  bd70              POP      {r4-r6,pc}
;;;2039   
                          ENDP

                  |L45.36|
000024  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000028  6964646c
00002c  65776172
000030  65735c54
000034  68697264
000038  5f506172
00003c  74795c4c
000040  7749505c
000044  7372635c
000048  636f7265
00004c  5c746370
000050  2e6300  
000053  00                DCB      0
                  |L45.84|
000054  696e7661          DCB      "invalid socket state for sent callback",0
000058  6c696420
00005c  736f636b
000060  65742073
000064  74617465
000068  20666f72
00006c  2073656e
000070  74206361
000074  6c6c6261
000078  636b00  
00007b  00                DCB      0
                  |L45.124|
00007c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000080  7274696f
000084  6e202225
000088  73222066
00008c  61696c65
000090  64206174
000094  206c696e
000098  65202564
00009c  20696e20
0000a0  25730a00

                          AREA ||i.tcp_setprio||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_setprio PROC
;;;1643   void
;;;1644   tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
000000  2800              CMP      r0,#0
;;;1645   {
000002  d001              BEQ      |L46.8|
;;;1646     LWIP_ASSERT_CORE_LOCKED();
;;;1647   
;;;1648     LWIP_ERROR("tcp_setprio: invalid pcb", pcb != NULL, return);
;;;1649   
;;;1650     pcb->prio = prio;
000004  7541              STRB     r1,[r0,#0x15]
;;;1651   }
000006  4770              BX       lr
                  |L46.8|
000008  a303              ADR      r3,|L46.24|
00000a  f44f62ce          MOV      r2,#0x670             ;1648
00000e  a10e              ADR      r1,|L46.72|
000010  a014              ADR      r0,|L46.100|
000012  f7ffbffe          B.W      __2printf
;;;1652   
                          ENDP

000016  0000              DCW      0x0000
                  |L46.24|
000018  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
00001c  6964646c
000020  65776172
000024  65735c54
000028  68697264
00002c  5f506172
000030  74795c4c
000034  7749505c
000038  7372635c
00003c  636f7265
000040  5c746370
000044  2e6300  
000047  00                DCB      0
                  |L46.72|
000048  7463705f          DCB      "tcp_setprio: invalid pcb",0
00004c  73657470
000050  72696f3a
000054  20696e76
000058  616c6964
00005c  20706362
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0
                  |L46.100|
000064  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000068  7274696f
00006c  6e202225
000070  73222066
000074  61696c65
000078  64206174
00007c  206c696e
000080  65202564
000084  20696e20
000088  25730a00

                          AREA ||i.tcp_shutdown||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_shutdown PROC
;;;514    err_t
;;;515    tcp_shutdown(struct tcp_pcb *pcb, int shut_rx, int shut_tx)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;516    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;517      LWIP_ASSERT_CORE_LOCKED();
;;;518    
;;;519      LWIP_ERROR("tcp_shutdown: invalid pcb", pcb != NULL, return ERR_ARG);
00000a  2c00              CMP      r4,#0
00000c  d012              BEQ      |L47.52|
;;;520    
;;;521      if (pcb->state == LISTEN) {
00000e  7d20              LDRB     r0,[r4,#0x14]
;;;522        return ERR_CONN;
000010  f06f070a          MVN      r7,#0xa
000014  2801              CMP      r0,#1                 ;521
000016  d018              BEQ      |L47.74|
;;;523      }
;;;524      if (shut_rx) {
000018  2d00              CMP      r5,#0
00001a  d01e              BEQ      |L47.90|
;;;525        /* shut down the receive side: set a flag not to receive any more data... */
;;;526        tcp_set_flags(pcb, TF_RXCLOSED);
00001c  8b60              LDRH     r0,[r4,#0x1a]
00001e  f0400010          ORR      r0,r0,#0x10
000022  8360              STRH     r0,[r4,#0x1a]
;;;527        if (shut_tx) {
000024  2e00              CMP      r6,#0
000026  d012              BEQ      |L47.78|
;;;528          /* shutting down the tx AND rx side is the same as closing for the raw API */
;;;529          return tcp_close_shutdown(pcb, 1);
000028  4620              MOV      r0,r4
00002a  e8bd41f0          POP      {r4-r8,lr}
00002e  2101              MOVS     r1,#1
000030  f7ffbffe          B.W      tcp_close_shutdown
                  |L47.52|
000034  a312              ADR      r3,|L47.128|
000036  f2402207          MOV      r2,#0x207             ;519
00003a  a11d              ADR      r1,|L47.176|
00003c  a023              ADR      r0,|L47.204|
00003e  f7fffffe          BL       __2printf
000042  f06f000f          MVN      r0,#0xf               ;519
                  |L47.70|
;;;530        }
;;;531        /* ... and free buffered data */
;;;532        if (pcb->refused_data != NULL) {
;;;533          pbuf_free(pcb->refused_data);
;;;534          pcb->refused_data = NULL;
;;;535        }
;;;536      }
;;;537      if (shut_tx) {
;;;538        /* This can't happen twice since if it succeeds, the pcb's state is changed.
;;;539           Only close in these states as the others directly deallocate the PCB */
;;;540        switch (pcb->state) {
;;;541          case SYN_RCVD:
;;;542          case ESTABLISHED:
;;;543          case CLOSE_WAIT:
;;;544            return tcp_close_shutdown(pcb, (u8_t)shut_rx);
;;;545          default:
;;;546            /* Not (yet?) connected, cannot shutdown the TX side as that would bring us
;;;547              into CLOSED state, where the PCB is deallocated. */
;;;548            return ERR_CONN;
;;;549        }
;;;550      }
;;;551      return ERR_OK;
;;;552    }
000046  e8bd81f0          POP      {r4-r8,pc}
                  |L47.74|
00004a  4638              MOV      r0,r7                 ;522
00004c  e7fb              B        |L47.70|
                  |L47.78|
00004e  6fa0              LDR      r0,[r4,#0x78]         ;532
000050  b118              CBZ      r0,|L47.90|
000052  f7fffffe          BL       pbuf_free
000056  2000              MOVS     r0,#0                 ;534
000058  67a0              STR      r0,[r4,#0x78]         ;534
                  |L47.90|
00005a  b176              CBZ      r6,|L47.122|
00005c  7d20              LDRB     r0,[r4,#0x14]         ;540
00005e  2803              CMP      r0,#3                 ;540
000060  d005              BEQ      |L47.110|
000062  2804              CMP      r0,#4                 ;540
000064  d003              BEQ      |L47.110|
000066  2807              CMP      r0,#7                 ;540
000068  d001              BEQ      |L47.110|
00006a  4638              MOV      r0,r7                 ;548
00006c  e7eb              B        |L47.70|
                  |L47.110|
00006e  b2e9              UXTB     r1,r5                 ;544
000070  4620              MOV      r0,r4                 ;544
000072  e8bd41f0          POP      {r4-r8,lr}            ;544
000076  f7ffbffe          B.W      tcp_close_shutdown
                  |L47.122|
00007a  2000              MOVS     r0,#0                 ;551
00007c  e7e3              B        |L47.70|
;;;553    
                          ENDP

00007e  0000              DCW      0x0000
                  |L47.128|
000080  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000084  6964646c
000088  65776172
00008c  65735c54
000090  68697264
000094  5f506172
000098  74795c4c
00009c  7749505c
0000a0  7372635c
0000a4  636f7265
0000a8  5c746370
0000ac  2e6300  
0000af  00                DCB      0
                  |L47.176|
0000b0  7463705f          DCB      "tcp_shutdown: invalid pcb",0
0000b4  73687574
0000b8  646f776e
0000bc  3a20696e
0000c0  76616c69
0000c4  64207063
0000c8  6200    
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L47.204|
0000cc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000d0  7274696f
0000d4  6e202225
0000d8  73222066
0000dc  61696c65
0000e0  64206174
0000e4  206c696e
0000e8  65202564
0000ec  20696e20
0000f0  25730a00

                          AREA ||i.tcp_slowtmr||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_slowtmr PROC
;;;1191   void
;;;1192   tcp_slowtmr(void)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1193   {
;;;1194     struct tcp_pcb *pcb, *prev;
;;;1195     tcpwnd_size_t eff_wnd;
;;;1196     u8_t pcb_remove;      /* flag if a PCB should be removed */
;;;1197     u8_t pcb_reset;       /* flag if a RST should be sent when removing */
;;;1198     err_t err;
;;;1199   
;;;1200     err = ERR_OK;
;;;1201   
;;;1202     ++tcp_ticks;
000004  4fd3              LDR      r7,|L48.852|
000006  68f8              LDR      r0,[r7,#0xc]  ; tcp_ticks
000008  1c40              ADDS     r0,r0,#1
00000a  60f8              STR      r0,[r7,#0xc]  ; tcp_ticks
;;;1203     ++tcp_timer_ctr;
00000c  78b8              LDRB     r0,[r7,#2]  ; tcp_timer_ctr
00000e  1c40              ADDS     r0,r0,#1
000010  70b8              STRB     r0,[r7,#2]
;;;1204   
;;;1205   tcp_slowtmr_start:
;;;1206     /* Steps through all of the active PCBs. */
;;;1207     prev = NULL;
;;;1208     pcb = tcp_active_pcbs;
;;;1209     if (pcb == NULL) {
;;;1210       LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
;;;1211     }
;;;1212     while (pcb != NULL) {
;;;1213       LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
;;;1214       LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
;;;1215       LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
;;;1216       LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
;;;1217       if (pcb->last_timer == tcp_timer_ctr) {
;;;1218         /* skip this pcb, we have already processed it */
;;;1219         prev = pcb;
;;;1220         pcb = pcb->next;
;;;1221         continue;
;;;1222       }
;;;1223       pcb->last_timer = tcp_timer_ctr;
;;;1224   
;;;1225       pcb_remove = 0;
;;;1226       pcb_reset = 0;
;;;1227   
;;;1228       if (pcb->state == SYN_SENT && pcb->nrtx >= TCP_SYNMAXRTX) {
;;;1229         ++pcb_remove;
;;;1230         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
;;;1231       } else if (pcb->nrtx >= TCP_MAXRTX) {
;;;1232         ++pcb_remove;
;;;1233         LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
;;;1234       } else {
;;;1235         if (pcb->persist_backoff > 0) {
;;;1236           LWIP_ASSERT("tcp_slowtimr: persist ticking with in-flight data", pcb->unacked == NULL);
;;;1237           LWIP_ASSERT("tcp_slowtimr: persist ticking with empty send buffer", pcb->unsent != NULL);
;;;1238           if (pcb->persist_probe >= TCP_MAXRTX) {
;;;1239             ++pcb_remove; /* max probes reached */
;;;1240           } else {
;;;1241             u8_t backoff_cnt = tcp_persist_backoff[pcb->persist_backoff - 1];
;;;1242             if (pcb->persist_cnt < backoff_cnt) {
;;;1243               pcb->persist_cnt++;
;;;1244             }
;;;1245             if (pcb->persist_cnt >= backoff_cnt) {
;;;1246               int next_slot = 1; /* increment timer to next slot */
;;;1247               /* If snd_wnd is zero, send 1 byte probes */
;;;1248               if (pcb->snd_wnd == 0) {
;;;1249                 if (tcp_zero_window_probe(pcb) != ERR_OK) {
;;;1250                   next_slot = 0; /* try probe again with current slot */
;;;1251                 }
;;;1252                 /* snd_wnd not fully closed, split unsent head and fill window */
;;;1253               } else {
;;;1254                 if (tcp_split_unsent_seg(pcb, (u16_t)pcb->snd_wnd) == ERR_OK) {
;;;1255                   if (tcp_output(pcb) == ERR_OK) {
;;;1256                     /* sending will cancel persist timer, else retry with current slot */
;;;1257                     next_slot = 0;
;;;1258                   }
;;;1259                 }
;;;1260               }
;;;1261               if (next_slot) {
;;;1262                 pcb->persist_cnt = 0;
;;;1263                 if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
;;;1264                   pcb->persist_backoff++;
;;;1265                 }
;;;1266               }
;;;1267             }
;;;1268           }
;;;1269         } else {
;;;1270           /* Increase the retransmission timer if it is running */
;;;1271           if ((pcb->rtime >= 0) && (pcb->rtime < 0x7FFF)) {
000012  f6477bff          MOV      r11,#0x7fff
000016  f04f0a00          MOV      r10,#0
                  |L48.26|
00001a  2600              MOVS     r6,#0                 ;1207
00001c  69bc              LDR      r4,[r7,#0x18]         ;1208  ; tcp_active_pcbs
00001e  e18a              B        |L48.822|
                  |L48.32|
000020  7d20              LDRB     r0,[r4,#0x14]         ;1214
000022  2800              CMP      r0,#0                 ;1214
000024  d106              BNE      |L48.52|
000026  a3cc              ADR      r3,|L48.856|
000028  f24042be          MOV      r2,#0x4be             ;1214
00002c  a1d6              ADR      r1,|L48.904|
00002e  a0e1              ADR      r0,|L48.948|
000030  f7fffffe          BL       __2printf
                  |L48.52|
000034  7d20              LDRB     r0,[r4,#0x14]         ;1215
000036  2801              CMP      r0,#1                 ;1215
000038  d106              BNE      |L48.72|
00003a  a3c7              ADR      r3,|L48.856|
00003c  f24042bf          MOV      r2,#0x4bf             ;1215
000040  a1e6              ADR      r1,|L48.988|
000042  a0dc              ADR      r0,|L48.948|
000044  f7fffffe          BL       __2printf
                  |L48.72|
000048  7d20              LDRB     r0,[r4,#0x14]         ;1216
00004a  280a              CMP      r0,#0xa               ;1216
00004c  d106              BNE      |L48.92|
00004e  a3c2              ADR      r3,|L48.856|
000050  f44f6298          MOV      r2,#0x4c0             ;1216
000054  a1ec              ADR      r1,|L48.1032|
000056  a0d7              ADR      r0,|L48.948|
000058  f7fffffe          BL       __2printf
                  |L48.92|
00005c  7fa1              LDRB     r1,[r4,#0x1e]         ;1217
00005e  78b8              LDRB     r0,[r7,#2]            ;1217  ; tcp_timer_ctr
000060  4281              CMP      r1,r0                 ;1217
000062  d102              BNE      |L48.106|
000064  4626              MOV      r6,r4                 ;1219
000066  68e4              LDR      r4,[r4,#0xc]          ;1220
000068  e165              B        |L48.822|
                  |L48.106|
00006a  77a0              STRB     r0,[r4,#0x1e]         ;1223
00006c  2500              MOVS     r5,#0                 ;1225
00006e  46a9              MOV      r9,r5                 ;1226
000070  7d20              LDRB     r0,[r4,#0x14]         ;1228
000072  2802              CMP      r0,#2                 ;1228
000074  d105              BNE      |L48.130|
000076  f8940042          LDRB     r0,[r4,#0x42]         ;1228
00007a  2806              CMP      r0,#6                 ;1228
00007c  d301              BCC      |L48.130|
00007e  2501              MOVS     r5,#1                 ;1229
000080  e09c              B        |L48.444|
                  |L48.130|
000082  f8940042          LDRB     r0,[r4,#0x42]         ;1231
000086  280c              CMP      r0,#0xc               ;1231
000088  d301              BCC      |L48.142|
00008a  2501              MOVS     r5,#1                 ;1232
00008c  e096              B        |L48.444|
                  |L48.142|
00008e  f8940099          LDRB     r0,[r4,#0x99]         ;1235
000092  2800              CMP      r0,#0                 ;1235
000094  d04c              BEQ      |L48.304|
000096  6f20              LDR      r0,[r4,#0x70]         ;1236
000098  2800              CMP      r0,#0                 ;1236
00009a  d006              BEQ      |L48.170|
00009c  a3ae              ADR      r3,|L48.856|
00009e  f24042d4          MOV      r2,#0x4d4             ;1236
0000a2  a1e5              ADR      r1,|L48.1080|
0000a4  a0c3              ADR      r0,|L48.948|
0000a6  f7fffffe          BL       __2printf
                  |L48.170|
0000aa  6ee0              LDR      r0,[r4,#0x6c]         ;1237
0000ac  2800              CMP      r0,#0                 ;1237
0000ae  d106              BNE      |L48.190|
0000b0  a3a9              ADR      r3,|L48.856|
0000b2  f24042d5          MOV      r2,#0x4d5             ;1237
0000b6  a1ed              ADR      r1,|L48.1132|
0000b8  a0be              ADR      r0,|L48.948|
0000ba  f7fffffe          BL       __2printf
                  |L48.190|
0000be  f894009a          LDRB     r0,[r4,#0x9a]         ;1238
0000c2  280c              CMP      r0,#0xc               ;1238
0000c4  d301              BCC      |L48.202|
0000c6  2501              MOVS     r5,#1                 ;1239
0000c8  e078              B        |L48.444|
                  |L48.202|
0000ca  f8941099          LDRB     r1,[r4,#0x99]         ;1241
0000ce  48f5              LDR      r0,|L48.1188|
0000d0  5c08              LDRB     r0,[r1,r0]            ;1241
0000d2  f8941098          LDRB     r1,[r4,#0x98]         ;1242
0000d6  4281              CMP      r1,r0                 ;1242
0000d8  d202              BCS      |L48.224|
0000da  1c49              ADDS     r1,r1,#1              ;1243
0000dc  f8841098          STRB     r1,[r4,#0x98]         ;1243
                  |L48.224|
0000e0  f8941098          LDRB     r1,[r4,#0x98]         ;1245
0000e4  4281              CMP      r1,r0                 ;1245
0000e6  d369              BCC      |L48.444|
0000e8  f04f0801          MOV      r8,#1                 ;1246
0000ec  f8b41060          LDRH     r1,[r4,#0x60]         ;1248
0000f0  b121              CBZ      r1,|L48.252|
0000f2  4620              MOV      r0,r4                 ;1254
0000f4  f7fffffe          BL       tcp_split_unsent_seg
0000f8  b138              CBZ      r0,|L48.266|
0000fa  e00c              B        |L48.278|
                  |L48.252|
0000fc  4620              MOV      r0,r4                 ;1249
0000fe  f7fffffe          BL       tcp_zero_window_probe
000102  b140              CBZ      r0,|L48.278|
000104  f04f0800          MOV      r8,#0                 ;1250
000108  e005              B        |L48.278|
                  |L48.266|
00010a  4620              MOV      r0,r4                 ;1255
00010c  f7fffffe          BL       tcp_output
000110  b908              CBNZ     r0,|L48.278|
000112  f04f0800          MOV      r8,#0                 ;1257
                  |L48.278|
000116  f1b80f00          CMP      r8,#0                 ;1261
00011a  d04f              BEQ      |L48.444|
00011c  f884a098          STRB     r10,[r4,#0x98]        ;1262
000120  f8940099          LDRB     r0,[r4,#0x99]         ;1263
000124  2807              CMP      r0,#7                 ;1263
000126  d249              BCS      |L48.444|
000128  1c40              ADDS     r0,r0,#1              ;1264
00012a  f8840099          STRB     r0,[r4,#0x99]         ;1264
00012e  e045              B        |L48.444|
                  |L48.304|
000130  f9b40030          LDRSH    r0,[r4,#0x30]
000134  4558              CMP      r0,r11
000136  d201              BCS      |L48.316|
;;;1272             ++pcb->rtime;
000138  1c40              ADDS     r0,r0,#1
00013a  8620              STRH     r0,[r4,#0x30]
                  |L48.316|
;;;1273           }
;;;1274   
;;;1275           if (pcb->rtime >= pcb->rto) {
00013c  f9b40030          LDRSH    r0,[r4,#0x30]
000140  f9b41040          LDRSH    r1,[r4,#0x40]
000144  4288              CMP      r0,r1
000146  db39              BLT      |L48.444|
;;;1276             /* Time for a retransmission. */
;;;1277             LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_slowtmr: rtime %"S16_F
;;;1278                                         " pcb->rto %"S16_F"\n",
;;;1279                                         pcb->rtime, pcb->rto));
;;;1280             /* If prepare phase fails but we have unsent data but no unacked data,
;;;1281                still execute the backoff calculations below, as this means we somehow
;;;1282                failed to send segment. */
;;;1283             if ((tcp_rexmit_rto_prepare(pcb) == ERR_OK) || ((pcb->unacked == NULL) && (pcb->unsent != NULL))) {
000148  4620              MOV      r0,r4
00014a  f7fffffe          BL       tcp_rexmit_rto_prepare
00014e  b118              CBZ      r0,|L48.344|
000150  6f20              LDR      r0,[r4,#0x70]
000152  bb98              CBNZ     r0,|L48.444|
000154  6ee0              LDR      r0,[r4,#0x6c]
000156  b388              CBZ      r0,|L48.444|
                  |L48.344|
;;;1284               /* Double retransmission time-out unless we are trying to
;;;1285                * connect to somebody (i.e., we are in SYN_SENT). */
;;;1286               if (pcb->state != SYN_SENT) {
000158  7d20              LDRB     r0,[r4,#0x14]
00015a  2802              CMP      r0,#2
00015c  d012              BEQ      |L48.388|
;;;1287                 u8_t backoff_idx = LWIP_MIN(pcb->nrtx, sizeof(tcp_backoff) - 1);
00015e  f8941042          LDRB     r1,[r4,#0x42]
000162  290c              CMP      r1,#0xc
000164  d300              BCC      |L48.360|
000166  210c              MOVS     r1,#0xc
                  |L48.360|
;;;1288                 int calc_rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[backoff_idx];
000168  f9b4003e          LDRSH    r0,[r4,#0x3e]
00016c  f9b4203c          LDRSH    r2,[r4,#0x3c]
000170  eb0000e2          ADD      r0,r0,r2,ASR #3
000174  4acc              LDR      r2,|L48.1192|
000176  5c51              LDRB     r1,[r2,r1]
000178  4088              LSLS     r0,r0,r1
;;;1289                 pcb->rto = (s16_t)LWIP_MIN(calc_rto, 0x7FFF);
00017a  4558              CMP      r0,r11
00017c  db00              BLT      |L48.384|
00017e  4658              MOV      r0,r11
                  |L48.384|
000180  f8a40040          STRH     r0,[r4,#0x40]
                  |L48.388|
;;;1290               }
;;;1291   
;;;1292               /* Reset the retransmission timer. */
;;;1293               pcb->rtime = 0;
000184  f8a4a030          STRH     r10,[r4,#0x30]
;;;1294   
;;;1295               /* Reduce congestion window and ssthresh. */
;;;1296               eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
000188  f8b40048          LDRH     r0,[r4,#0x48]
00018c  f8b41060          LDRH     r1,[r4,#0x60]
000190  4288              CMP      r0,r1
000192  d300              BCC      |L48.406|
000194  4608              MOV      r0,r1
                  |L48.406|
;;;1297               pcb->ssthresh = eff_wnd >> 1;
000196  0841              LSRS     r1,r0,#1
000198  f8a4104a          STRH     r1,[r4,#0x4a]
;;;1298               if (pcb->ssthresh < (tcpwnd_size_t)(pcb->mss << 1)) {
00019c  8e62              LDRH     r2,[r4,#0x32]
00019e  f64f70ff          MOV      r0,#0xffff
0001a2  ea000042          AND      r0,r0,r2,LSL #1
0001a6  4281              CMP      r1,r0
0001a8  d201              BCS      |L48.430|
;;;1299                 pcb->ssthresh = (tcpwnd_size_t)(pcb->mss << 1);
0001aa  f8a4004a          STRH     r0,[r4,#0x4a]
                  |L48.430|
;;;1300               }
;;;1301               pcb->cwnd = pcb->mss;
0001ae  f8a42048          STRH     r2,[r4,#0x48]
;;;1302               LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: cwnd %"TCPWNDSIZE_F
;;;1303                                            " ssthresh %"TCPWNDSIZE_F"\n",
;;;1304                                            pcb->cwnd, pcb->ssthresh));
;;;1305               pcb->bytes_acked = 0;
0001b2  f8a4a06a          STRH     r10,[r4,#0x6a]
;;;1306   
;;;1307               /* The following needs to be called AFTER cwnd is set to one
;;;1308                  mss - STJ */
;;;1309               tcp_rexmit_rto_commit(pcb);
0001b6  4620              MOV      r0,r4
0001b8  f7fffffe          BL       tcp_rexmit_rto_commit
                  |L48.444|
;;;1310             }
;;;1311           }
;;;1312         }
;;;1313       }
;;;1314       /* Check if this PCB has stayed too long in FIN-WAIT-2 */
;;;1315       if (pcb->state == FIN_WAIT_2) {
0001bc  7d20              LDRB     r0,[r4,#0x14]
0001be  2806              CMP      r0,#6
0001c0  d109              BNE      |L48.470|
;;;1316         /* If this PCB is in FIN_WAIT_2 because of SHUT_WR don't let it time out. */
;;;1317         if (pcb->flags & TF_RXCLOSED) {
0001c2  7ea1              LDRB     r1,[r4,#0x1a]
0001c4  06c9              LSLS     r1,r1,#27
0001c6  d506              BPL      |L48.470|
;;;1318           /* PCB was fully closed (either through close() or SHUT_RDWR):
;;;1319              normal FIN-WAIT timeout handling. */
;;;1320           if ((u32_t)(tcp_ticks - pcb->tmr) >
0001c8  6a21              LDR      r1,[r4,#0x20]
0001ca  68fa              LDR      r2,[r7,#0xc]  ; tcp_ticks
0001cc  1a51              SUBS     r1,r2,r1
0001ce  2928              CMP      r1,#0x28
0001d0  d901              BLS      |L48.470|
;;;1321               TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;1322             ++pcb_remove;
0001d2  1c6d              ADDS     r5,r5,#1
0001d4  b2ed              UXTB     r5,r5
                  |L48.470|
;;;1323             LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
;;;1324           }
;;;1325         }
;;;1326       }
;;;1327   
;;;1328       /* Check if KEEPALIVE should be sent */
;;;1329       if (ip_get_option(pcb, SOF_KEEPALIVE) &&
0001d6  7a61              LDRB     r1,[r4,#9]
0001d8  0709              LSLS     r1,r1,#28
0001da  d52c              BPL      |L48.566|
;;;1330           ((pcb->state == ESTABLISHED) ||
0001dc  2804              CMP      r0,#4
0001de  d001              BEQ      |L48.484|
;;;1331            (pcb->state == CLOSE_WAIT))) {
0001e0  2807              CMP      r0,#7
0001e2  d128              BNE      |L48.566|
                  |L48.484|
;;;1332         if ((u32_t)(tcp_ticks - pcb->tmr) >
0001e4  48b1              LDR      r0,|L48.1196|
0001e6  f8d41094          LDR      r1,[r4,#0x94]
0001ea  f44f73fa          MOV      r3,#0x1f4
0001ee  4408              ADD      r0,r0,r1
0001f0  fbb0f2f3          UDIV     r2,r0,r3
0001f4  6a20              LDR      r0,[r4,#0x20]
0001f6  f8d7c00c          LDR      r12,[r7,#0xc]  ; tcp_ticks
0001fa  ebac0000          SUB      r0,r12,r0
0001fe  4282              CMP      r2,r0
000200  d204              BCS      |L48.524|
;;;1333             (pcb->keep_idle + TCP_KEEP_DUR(pcb)) / TCP_SLOW_INTERVAL) {
;;;1334           LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to "));
;;;1335           ip_addr_debug_print_val(TCP_DEBUG, pcb->remote_ip);
;;;1336           LWIP_DEBUGF(TCP_DEBUG, ("\n"));
;;;1337   
;;;1338           ++pcb_remove;
000202  1c6d              ADDS     r5,r5,#1
000204  b2ed              UXTB     r5,r5
;;;1339           ++pcb_reset;
000206  f04f0901          MOV      r9,#1
00020a  e014              B        |L48.566|
                  |L48.524|
;;;1340         } else if ((u32_t)(tcp_ticks - pcb->tmr) >
00020c  f894209b          LDRB     r2,[r4,#0x9b]
000210  f2424c9f          MOV      r12,#0x249f
000214  fb02f20c          MUL      r2,r2,r12
000218  eb0101c2          ADD      r1,r1,r2,LSL #3
00021c  fbb1f1f3          UDIV     r1,r1,r3
000220  4281              CMP      r1,r0
000222  d208              BCS      |L48.566|
;;;1341                    (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEP_INTVL(pcb))
;;;1342                    / TCP_SLOW_INTERVAL) {
;;;1343           err = tcp_keepalive(pcb);
000224  4620              MOV      r0,r4
000226  f7fffffe          BL       tcp_keepalive
;;;1344           if (err == ERR_OK) {
00022a  b920              CBNZ     r0,|L48.566|
;;;1345             pcb->keep_cnt_sent++;
00022c  f894009b          LDRB     r0,[r4,#0x9b]
000230  1c40              ADDS     r0,r0,#1
000232  f884009b          STRB     r0,[r4,#0x9b]
                  |L48.566|
;;;1346           }
;;;1347         }
;;;1348       }
;;;1349   
;;;1350       /* If this PCB has queued out of sequence data, but has been
;;;1351          inactive for too long, will drop the data (it will eventually
;;;1352          be retransmitted). */
;;;1353   #if TCP_QUEUE_OOSEQ
;;;1354       if (pcb->ooseq != NULL &&
000236  6f60              LDR      r0,[r4,#0x74]
000238  b160              CBZ      r0,|L48.596|
;;;1355           (tcp_ticks - pcb->tmr >= (u32_t)pcb->rto * TCP_OOSEQ_TIMEOUT)) {
00023a  6a20              LDR      r0,[r4,#0x20]
00023c  68f9              LDR      r1,[r7,#0xc]  ; tcp_ticks
00023e  1a09              SUBS     r1,r1,r0
000240  f9b40040          LDRSH    r0,[r4,#0x40]
000244  eb000040          ADD      r0,r0,r0,LSL #1
000248  ebb10f40          CMP      r1,r0,LSL #1
00024c  d302              BCC      |L48.596|
;;;1356         LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
;;;1357         tcp_free_ooseq(pcb);
00024e  4620              MOV      r0,r4
000250  f7fffffe          BL       tcp_free_ooseq
                  |L48.596|
;;;1358       }
;;;1359   #endif /* TCP_QUEUE_OOSEQ */
;;;1360   
;;;1361       /* Check if this PCB has stayed too long in SYN-RCVD */
;;;1362       if (pcb->state == SYN_RCVD) {
000254  7d20              LDRB     r0,[r4,#0x14]
000256  2803              CMP      r0,#3
000258  d106              BNE      |L48.616|
;;;1363         if ((u32_t)(tcp_ticks - pcb->tmr) >
00025a  6a21              LDR      r1,[r4,#0x20]
00025c  68fa              LDR      r2,[r7,#0xc]  ; tcp_ticks
00025e  1a51              SUBS     r1,r2,r1
000260  2928              CMP      r1,#0x28
000262  d901              BLS      |L48.616|
;;;1364             TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
;;;1365           ++pcb_remove;
000264  1c6d              ADDS     r5,r5,#1
000266  b2ed              UXTB     r5,r5
                  |L48.616|
;;;1366           LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
;;;1367         }
;;;1368       }
;;;1369   
;;;1370       /* Check if this PCB has stayed too long in LAST-ACK */
;;;1371       if (pcb->state == LAST_ACK) {
000268  2809              CMP      r0,#9
00026a  d106              BNE      |L48.634|
;;;1372         if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
00026c  6a20              LDR      r0,[r4,#0x20]
00026e  68f9              LDR      r1,[r7,#0xc]  ; tcp_ticks
000270  1a08              SUBS     r0,r1,r0
000272  28f0              CMP      r0,#0xf0
000274  d901              BLS      |L48.634|
;;;1373           ++pcb_remove;
000276  1c6d              ADDS     r5,r5,#1
000278  b2ed              UXTB     r5,r5
                  |L48.634|
;;;1374           LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
;;;1375         }
;;;1376       }
;;;1377   
;;;1378       /* If the PCB should be removed, do it. */
;;;1379       if (pcb_remove) {
00027a  2d00              CMP      r5,#0
00027c  d03f              BEQ      |L48.766|
;;;1380         struct tcp_pcb *pcb2;
;;;1381   #if LWIP_CALLBACK_API
;;;1382         tcp_err_fn err_fn = pcb->errf;
00027e  f8d45090          LDR      r5,[r4,#0x90]
;;;1383   #endif /* LWIP_CALLBACK_API */
;;;1384         void *err_arg;
;;;1385         enum tcp_state last_state;
;;;1386         tcp_pcb_purge(pcb);
000282  4620              MOV      r0,r4
000284  f7fffffe          BL       tcp_pcb_purge
;;;1387         /* Remove PCB from tcp_active_pcbs list. */
;;;1388         if (prev != NULL) {
000288  b166              CBZ      r6,|L48.676|
;;;1389           LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
00028a  69b8              LDR      r0,[r7,#0x18]  ; tcp_active_pcbs
00028c  4284              CMP      r4,r0
00028e  d106              BNE      |L48.670|
000290  a331              ADR      r3,|L48.856|
000292  f240526d          MOV      r2,#0x56d
000296  a186              ADR      r1,|L48.1200|
000298  a046              ADR      r0,|L48.948|
00029a  f7fffffe          BL       __2printf
                  |L48.670|
;;;1390           prev->next = pcb->next;
00029e  68e0              LDR      r0,[r4,#0xc]
0002a0  60f0              STR      r0,[r6,#0xc]
0002a2  e00b              B        |L48.700|
                  |L48.676|
;;;1391         } else {
;;;1392           /* This PCB was the first. */
;;;1393           LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
0002a4  69b8              LDR      r0,[r7,#0x18]  ; tcp_active_pcbs
0002a6  42a0              CMP      r0,r4
0002a8  d006              BEQ      |L48.696|
0002aa  a32b              ADR      r3,|L48.856|
0002ac  f2405271          MOV      r2,#0x571
0002b0  a18a              ADR      r1,|L48.1244|
0002b2  a040              ADR      r0,|L48.948|
0002b4  f7fffffe          BL       __2printf
                  |L48.696|
;;;1394           tcp_active_pcbs = pcb->next;
0002b8  68e0              LDR      r0,[r4,#0xc]
0002ba  61b8              STR      r0,[r7,#0x18]  ; tcp_active_pcbs
                  |L48.700|
;;;1395         }
;;;1396   
;;;1397         if (pcb_reset) {
0002bc  f1b90f00          CMP      r9,#0
0002c0  d00b              BEQ      |L48.730|
;;;1398           tcp_rst(pcb, pcb->snd_nxt, pcb->rcv_nxt, &pcb->local_ip, &pcb->remote_ip,
0002c2  8ae0              LDRH     r0,[r4,#0x16]
0002c4  8b21              LDRH     r1,[r4,#0x18]
0002c6  1d22              ADDS     r2,r4,#4
0002c8  e9cd2000          STRD     r2,r0,[sp,#0]
0002cc  9102              STR      r1,[sp,#8]
0002ce  4623              MOV      r3,r4
0002d0  4620              MOV      r0,r4
0002d2  6a62              LDR      r2,[r4,#0x24]
0002d4  6d21              LDR      r1,[r4,#0x50]
0002d6  f7fffffe          BL       tcp_rst
                  |L48.730|
;;;1399                   pcb->local_port, pcb->remote_port);
;;;1400         }
;;;1401   
;;;1402         err_arg = pcb->callback_arg;
0002da  f8d48010          LDR      r8,[r4,#0x10]
;;;1403         last_state = pcb->state;
;;;1404         pcb2 = pcb;
;;;1405         pcb = pcb->next;
0002de  4620              MOV      r0,r4
0002e0  68e4              LDR      r4,[r4,#0xc]
;;;1406         tcp_free(pcb2);
0002e2  f7fffffe          BL       tcp_free
;;;1407   
;;;1408         tcp_active_pcbs_changed = 0;
0002e6  f887a000          STRB     r10,[r7,#0]
;;;1409         TCP_EVENT_ERR(last_state, err_fn, err_arg, ERR_ABRT);
0002ea  b11d              CBZ      r5,|L48.756|
0002ec  f06f010c          MVN      r1,#0xc
0002f0  4640              MOV      r0,r8
0002f2  47a8              BLX      r5
                  |L48.756|
;;;1410         if (tcp_active_pcbs_changed) {
0002f4  7838              LDRB     r0,[r7,#0]  ; tcp_active_pcbs_changed
0002f6  2800              CMP      r0,#0
                  |L48.760|
0002f8  f47fae8f          BNE      |L48.26|
0002fc  e01b              B        |L48.822|
                  |L48.766|
;;;1411           goto tcp_slowtmr_start;
;;;1412         }
;;;1413       } else {
;;;1414         /* get the 'next' element now and work with 'prev' below (in case of abort) */
;;;1415         prev = pcb;
0002fe  4626              MOV      r6,r4
;;;1416         pcb = pcb->next;
000300  68e4              LDR      r4,[r4,#0xc]
;;;1417   
;;;1418         /* We check if we should poll the connection. */
;;;1419         ++prev->polltmr;
000302  7f30              LDRB     r0,[r6,#0x1c]
000304  1c40              ADDS     r0,r0,#1
000306  b2c0              UXTB     r0,r0
000308  7730              STRB     r0,[r6,#0x1c]
;;;1420         if (prev->polltmr >= prev->pollinterval) {
00030a  7f71              LDRB     r1,[r6,#0x1d]
00030c  4288              CMP      r0,r1
00030e  d312              BCC      |L48.822|
;;;1421           prev->polltmr = 0;
000310  f886a01c          STRB     r10,[r6,#0x1c]
;;;1422           LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
;;;1423           tcp_active_pcbs_changed = 0;
000314  f887a000          STRB     r10,[r7,#0]
;;;1424           TCP_EVENT_POLL(prev, err);
000318  f8d6208c          LDR      r2,[r6,#0x8c]
00031c  b11a              CBZ      r2,|L48.806|
00031e  4631              MOV      r1,r6
000320  6930              LDR      r0,[r6,#0x10]
000322  4790              BLX      r2
000324  e000              B        |L48.808|
                  |L48.806|
000326  2000              MOVS     r0,#0
                  |L48.808|
;;;1425           if (tcp_active_pcbs_changed) {
000328  7839              LDRB     r1,[r7,#0]  ; tcp_active_pcbs_changed
00032a  2900              CMP      r1,#0
00032c  d1e4              BNE      |L48.760|
;;;1426             goto tcp_slowtmr_start;
;;;1427           }
;;;1428           /* if err == ERR_ABRT, 'prev' is already deallocated */
;;;1429           if (err == ERR_OK) {
00032e  b910              CBNZ     r0,|L48.822|
;;;1430             tcp_output(prev);
000330  4630              MOV      r0,r6
000332  f7fffffe          BL       tcp_output
                  |L48.822|
000336  2c00              CMP      r4,#0                 ;1212
000338  f47fae72          BNE      |L48.32|
;;;1431           }
;;;1432         }
;;;1433       }
;;;1434     }
;;;1435   
;;;1436   
;;;1437     /* Steps through all of the TIME-WAIT PCBs. */
;;;1438     prev = NULL;
00033c  2500              MOVS     r5,#0
;;;1439     pcb = tcp_tw_pcbs;
00033e  69fc              LDR      r4,[r7,#0x1c]  ; tcp_tw_pcbs
;;;1440     while (pcb != NULL) {
000340  e118              B        |L48.1396|
                  |L48.834|
;;;1441       LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
000342  7d20              LDRB     r0,[r4,#0x14]
000344  280a              CMP      r0,#0xa
000346  d003              BEQ      |L48.848|
000348  a303              ADR      r3,|L48.856|
00034a  f24052a1          MOV      r2,#0x5a1
00034e  e0db              B        |L48.1288|
                  |L48.848|
000350  e0df              B        |L48.1298|
000352  0000              DCW      0x0000
                  |L48.852|
                          DCD      ||.data||
                  |L48.856|
000358  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
00035c  6964646c
000360  65776172
000364  65735c54
000368  68697264
00036c  5f506172
000370  74795c4c
000374  7749505c
000378  7372635c
00037c  636f7265
000380  5c746370
000384  2e6300  
000387  00                DCB      0
                  |L48.904|
000388  7463705f          DCB      "tcp_slowtmr: active pcb->state != CLOSED\n",0
00038c  736c6f77
000390  746d723a
000394  20616374
000398  69766520
00039c  7063622d
0003a0  3e737461
0003a4  74652021
0003a8  3d20434c
0003ac  4f534544
0003b0  0a00    
0003b2  00                DCB      0
0003b3  00                DCB      0
                  |L48.948|
0003b4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0003b8  7274696f
0003bc  6e202225
0003c0  73222066
0003c4  61696c65
0003c8  64206174
0003cc  206c696e
0003d0  65202564
0003d4  20696e20
0003d8  25730a00
                  |L48.988|
0003dc  7463705f          DCB      "tcp_slowtmr: active pcb->state != LISTEN\n",0
0003e0  736c6f77
0003e4  746d723a
0003e8  20616374
0003ec  69766520
0003f0  7063622d
0003f4  3e737461
0003f8  74652021
0003fc  3d204c49
000400  5354454e
000404  0a00    
000406  00                DCB      0
000407  00                DCB      0
                  |L48.1032|
000408  7463705f          DCB      "tcp_slowtmr: active pcb->state != TIME-WAIT\n",0
00040c  736c6f77
000410  746d723a
000414  20616374
000418  69766520
00041c  7063622d
000420  3e737461
000424  74652021
000428  3d205449
00042c  4d452d57
000430  4149540a
000434  00      
000435  00                DCB      0
000436  00                DCB      0
000437  00                DCB      0
                  |L48.1080|
000438  7463705f          DCB      "tcp_slowtimr: persist ticking with in-flight data",0
00043c  736c6f77
000440  74696d72
000444  3a207065
000448  72736973
00044c  74207469
000450  636b696e
000454  67207769
000458  74682069
00045c  6e2d666c
000460  69676874
000464  20646174
000468  6100    
00046a  00                DCB      0
00046b  00                DCB      0
                  |L48.1132|
00046c  7463705f          DCB      "tcp_slowtimr: persist ticking with empty send buffer",0
000470  736c6f77
000474  74696d72
000478  3a207065
00047c  72736973
000480  74207469
000484  636b696e
000488  67207769
00048c  74682065
000490  6d707479
000494  2073656e
000498  64206275
00049c  66666572
0004a0  00      
0004a1  00                DCB      0
0004a2  00                DCB      0
0004a3  00                DCB      0
                  |L48.1188|
                          DCD      ||.constdata||-0x1
                  |L48.1192|
                          DCD      ||.constdata||+0x34
                  |L48.1196|
                          DCD      0x000a4cb8
                  |L48.1200|
0004b0  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_active_pcbs",0
0004b4  736c6f77
0004b8  746d723a
0004bc  206d6964
0004c0  646c6520
0004c4  74637020
0004c8  213d2074
0004cc  63705f61
0004d0  63746976
0004d4  655f7063
0004d8  627300  
0004db  00                DCB      0
                  |L48.1244|
0004dc  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_active_pcbs",0
0004e0  736c6f77
0004e4  746d723a
0004e8  20666972
0004ec  73742070
0004f0  6362203d
0004f4  3d207463
0004f8  705f6163
0004fc  74697665
000500  5f706362
000504  7300    
000506  00                DCB      0
000507  00                DCB      0
                  |L48.1288|
000508  a11d              ADR      r1,|L48.1408|
00050a  f2af1058          ADR      r0,|L48.948|
00050e  f7fffffe          BL       __2printf
                  |L48.1298|
;;;1442       pcb_remove = 0;
000512  2000              MOVS     r0,#0
;;;1443   
;;;1444       /* Check if this PCB has stayed long enough in TIME-WAIT */
;;;1445       if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
000514  6a21              LDR      r1,[r4,#0x20]
000516  68fa              LDR      r2,[r7,#0xc]  ; tcp_ticks
000518  1a51              SUBS     r1,r2,r1
00051a  29f0              CMP      r1,#0xf0
00051c  d900              BLS      |L48.1312|
;;;1446         ++pcb_remove;
00051e  2001              MOVS     r0,#1
                  |L48.1312|
;;;1447       }
;;;1448   
;;;1449       /* If the PCB should be removed, do it. */
;;;1450       if (pcb_remove) {
000520  2800              CMP      r0,#0
000522  d025              BEQ      |L48.1392|
;;;1451         struct tcp_pcb *pcb2;
;;;1452         tcp_pcb_purge(pcb);
000524  4620              MOV      r0,r4
000526  f7fffffe          BL       tcp_pcb_purge
;;;1453         /* Remove PCB from tcp_tw_pcbs list. */
;;;1454         if (prev != NULL) {
00052a  b175              CBZ      r5,|L48.1354|
;;;1455           LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
00052c  69f8              LDR      r0,[r7,#0x1c]  ; tcp_tw_pcbs
00052e  4284              CMP      r4,r0
000530  d108              BNE      |L48.1348|
000532  f2af13dc          ADR      r3,|L48.856|
000536  f24052af          MOV      r2,#0x5af
00053a  a11d              ADR      r1,|L48.1456|
00053c  f2af108c          ADR      r0,|L48.948|
000540  f7fffffe          BL       __2printf
                  |L48.1348|
;;;1456           prev->next = pcb->next;
000544  68e0              LDR      r0,[r4,#0xc]
000546  60e8              STR      r0,[r5,#0xc]
000548  e00d              B        |L48.1382|
                  |L48.1354|
;;;1457         } else {
;;;1458           /* This PCB was the first. */
;;;1459           LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
00054a  69f8              LDR      r0,[r7,#0x1c]  ; tcp_tw_pcbs
00054c  42a0              CMP      r0,r4
00054e  d008              BEQ      |L48.1378|
000550  f2af13fc          ADR      r3,|L48.856|
000554  f24052b3          MOV      r2,#0x5b3
000558  a11f              ADR      r1,|L48.1496|
00055a  f2af10a8          ADR      r0,|L48.948|
00055e  f7fffffe          BL       __2printf
                  |L48.1378|
;;;1460           tcp_tw_pcbs = pcb->next;
000562  68e0              LDR      r0,[r4,#0xc]
000564  61f8              STR      r0,[r7,#0x1c]  ; tcp_tw_pcbs
                  |L48.1382|
;;;1461         }
;;;1462         pcb2 = pcb;
;;;1463         pcb = pcb->next;
000566  4620              MOV      r0,r4
000568  68e4              LDR      r4,[r4,#0xc]
;;;1464         tcp_free(pcb2);
00056a  f7fffffe          BL       tcp_free
;;;1465       } else {
00056e  e001              B        |L48.1396|
                  |L48.1392|
;;;1466         prev = pcb;
000570  4625              MOV      r5,r4
;;;1467         pcb = pcb->next;
000572  68e4              LDR      r4,[r4,#0xc]
                  |L48.1396|
000574  2c00              CMP      r4,#0                 ;1440
000576  f47faee4          BNE      |L48.834|
;;;1468       }
;;;1469     }
;;;1470   }
00057a  e8bd8ffe          POP      {r1-r11,pc}
;;;1471   
                          ENDP

00057e  0000              DCW      0x0000
                  |L48.1408|
000580  7463705f          DCB      "tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT",0
000584  736c6f77
000588  746d723a
00058c  2054494d
000590  452d5741
000594  49542070
000598  63622d3e
00059c  73746174
0005a0  65203d3d
0005a4  2054494d
0005a8  452d5741
0005ac  495400  
0005af  00                DCB      0
                  |L48.1456|
0005b0  7463705f          DCB      "tcp_slowtmr: middle tcp != tcp_tw_pcbs",0
0005b4  736c6f77
0005b8  746d723a
0005bc  206d6964
0005c0  646c6520
0005c4  74637020
0005c8  213d2074
0005cc  63705f74
0005d0  775f7063
0005d4  627300  
0005d7  00                DCB      0
                  |L48.1496|
0005d8  7463705f          DCB      "tcp_slowtmr: first pcb == tcp_tw_pcbs",0
0005dc  736c6f77
0005e0  746d723a
0005e4  20666972
0005e8  73742070
0005ec  6362203d
0005f0  3d207463
0005f4  705f7477
0005f8  5f706362
0005fc  7300    
0005fe  00                DCB      0
0005ff  00                DCB      0

                          AREA ||i.tcp_tcp_get_tcp_addrinfo||, CODE, READONLY, ALIGN=1

                  tcp_tcp_get_tcp_addrinfo PROC
;;;2359   err_t
;;;2360   tcp_tcp_get_tcp_addrinfo(struct tcp_pcb *pcb, int local, ip_addr_t *addr, u16_t *port)
000000  2800              CMP      r0,#0
;;;2361   {
000002  d00f              BEQ      |L49.36|
;;;2362     if (pcb) {
;;;2363       if (local) {
000004  b131              CBZ      r1,|L49.20|
;;;2364         if (addr) {
000006  b10a              CBZ      r2,|L49.12|
;;;2365           *addr = pcb->local_ip;
000008  6801              LDR      r1,[r0,#0]
00000a  6011              STR      r1,[r2,#0]
                  |L49.12|
;;;2366         }
;;;2367         if (port) {
00000c  b143              CBZ      r3,|L49.32|
;;;2368           *port = pcb->local_port;
00000e  8ac0              LDRH     r0,[r0,#0x16]
000010  8018              STRH     r0,[r3,#0]
000012  e005              B        |L49.32|
                  |L49.20|
;;;2369         }
;;;2370       } else {
;;;2371         if (addr) {
000014  b10a              CBZ      r2,|L49.26|
;;;2372           *addr = pcb->remote_ip;
000016  6841              LDR      r1,[r0,#4]
000018  6011              STR      r1,[r2,#0]
                  |L49.26|
;;;2373         }
;;;2374         if (port) {
00001a  b10b              CBZ      r3,|L49.32|
;;;2375           *port = pcb->remote_port;
00001c  8b00              LDRH     r0,[r0,#0x18]
00001e  8018              STRH     r0,[r3,#0]
                  |L49.32|
;;;2376         }
;;;2377       }
;;;2378       return ERR_OK;
000020  2000              MOVS     r0,#0
;;;2379     }
;;;2380     return ERR_VAL;
;;;2381   }
000022  4770              BX       lr
                  |L49.36|
000024  f06f0005          MVN      r0,#5                 ;2380
000028  4770              BX       lr
;;;2382   
                          ENDP


                          AREA ||i.tcp_tmr||, CODE, READONLY, ALIGN=2

                  tcp_tmr PROC
;;;233    void
;;;234    tcp_tmr(void)
000000  b510              PUSH     {r4,lr}
;;;235    {
;;;236      /* Call tcp_fasttmr() every 250 ms */
;;;237      tcp_fasttmr();
000002  f7fffffe          BL       tcp_fasttmr
;;;238    
;;;239      if (++tcp_timer & 1) {
000006  4905              LDR      r1,|L50.28|
000008  7848              LDRB     r0,[r1,#1]  ; tcp_timer
00000a  1c40              ADDS     r0,r0,#1
00000c  7048              STRB     r0,[r1,#1]
00000e  07c0              LSLS     r0,r0,#31
000010  d003              BEQ      |L50.26|
;;;240        /* Call tcp_slowtmr() every 500 ms, i.e., every other timer
;;;241           tcp_tmr() is called. */
;;;242        tcp_slowtmr();
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      tcp_slowtmr
                  |L50.26|
;;;243      }
;;;244    }
00001a  bd10              POP      {r4,pc}
;;;245    
                          ENDP

                  |L50.28|
                          DCD      ||.data||

                          AREA ||i.tcp_txnow||, CODE, READONLY, ALIGN=2

                  tcp_txnow PROC
;;;1525   void
;;;1526   tcp_txnow(void)
000000  b510              PUSH     {r4,lr}
;;;1527   {
;;;1528     struct tcp_pcb *pcb;
;;;1529   
;;;1530     for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000002  4806              LDR      r0,|L51.28|
000004  6984              LDR      r4,[r0,#0x18]  ; tcp_active_pcbs
000006  e006              B        |L51.22|
                  |L51.8|
;;;1531       if (pcb->flags & TF_NAGLEMEMERR) {
000008  7ea0              LDRB     r0,[r4,#0x1a]
00000a  0600              LSLS     r0,r0,#24
00000c  d502              BPL      |L51.20|
;;;1532         tcp_output(pcb);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       tcp_output
                  |L51.20|
000014  68e4              LDR      r4,[r4,#0xc]          ;1530
                  |L51.22|
000016  2c00              CMP      r4,#0                 ;1530
000018  d1f6              BNE      |L51.8|
;;;1533       }
;;;1534     }
;;;1535   }
00001a  bd10              POP      {r4,pc}
;;;1536   
                          ENDP

                  |L51.28|
                          DCD      ||.data||

                          AREA ||i.tcp_update_rcv_ann_wnd||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_update_rcv_ann_wnd PROC
;;;929    u32_t
;;;930    tcp_update_rcv_ann_wnd(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;931    {
000002  4604              MOV      r4,r0
;;;932      u32_t new_right_edge;
;;;933    
;;;934      LWIP_ASSERT("tcp_update_rcv_ann_wnd: invalid pcb", pcb != NULL);
000004  2c00              CMP      r4,#0
000006  d106              BNE      |L52.22|
000008  a315              ADR      r3,|L52.96|
00000a  f24032a6          MOV      r2,#0x3a6
00000e  a120              ADR      r1,|L52.144|
000010  a028              ADR      r0,|L52.180|
000012  f7fffffe          BL       __2printf
                  |L52.22|
;;;935      new_right_edge = pcb->rcv_nxt + pcb->rcv_wnd;
000016  8d25              LDRH     r5,[r4,#0x28]
000018  6a62              LDR      r2,[r4,#0x24]
00001a  1951              ADDS     r1,r2,r5
;;;936    
;;;937      if (TCP_SEQ_GEQ(new_right_edge, pcb->rcv_ann_right_edge + LWIP_MIN((TCP_WND / 2), pcb->mss))) {
00001c  8e63              LDRH     r3,[r4,#0x32]
00001e  f44f6686          MOV      r6,#0x430
000022  6ae0              LDR      r0,[r4,#0x2c]
000024  42b3              CMP      r3,r6
000026  d900              BLS      |L52.42|
000028  4633              MOV      r3,r6
                  |L52.42|
00002a  4403              ADD      r3,r3,r0
00002c  1acb              SUBS     r3,r1,r3
00002e  d402              BMI      |L52.54|
;;;938        /* we can advertise more window */
;;;939        pcb->rcv_ann_wnd = pcb->rcv_wnd;
000030  8565              STRH     r5,[r4,#0x2a]
;;;940        return new_right_edge - pcb->rcv_ann_right_edge;
000032  1a08              SUBS     r0,r1,r0
;;;941      } else {
;;;942        if (TCP_SEQ_GT(pcb->rcv_nxt, pcb->rcv_ann_right_edge)) {
;;;943          /* Can happen due to other end sending out of advertised window,
;;;944           * but within actual available (but not yet advertised) window */
;;;945          pcb->rcv_ann_wnd = 0;
;;;946        } else {
;;;947          /* keep the right edge of window constant */
;;;948          u32_t new_rcv_ann_wnd = pcb->rcv_ann_right_edge - pcb->rcv_nxt;
;;;949    #if !LWIP_WND_SCALE
;;;950          LWIP_ASSERT("new_rcv_ann_wnd <= 0xffff", new_rcv_ann_wnd <= 0xffff);
;;;951    #endif
;;;952          pcb->rcv_ann_wnd = (tcpwnd_size_t)new_rcv_ann_wnd;
;;;953        }
;;;954        return 0;
;;;955      }
;;;956    }
000034  bd70              POP      {r4-r6,pc}
                  |L52.54|
000036  1a11              SUBS     r1,r2,r0              ;942
000038  2900              CMP      r1,#0                 ;942
00003a  dd02              BLE      |L52.66|
00003c  2000              MOVS     r0,#0                 ;945
00003e  8560              STRH     r0,[r4,#0x2a]         ;945
000040  e00b              B        |L52.90|
                  |L52.66|
000042  1a85              SUBS     r5,r0,r2              ;948
000044  f5b53f80          CMP      r5,#0x10000           ;950
000048  d306              BCC      |L52.88|
00004a  a305              ADR      r3,|L52.96|
00004c  f24032b6          MOV      r2,#0x3b6             ;950
000050  a122              ADR      r1,|L52.220|
000052  a018              ADR      r0,|L52.180|
000054  f7fffffe          BL       __2printf
                  |L52.88|
000058  8565              STRH     r5,[r4,#0x2a]         ;952
                  |L52.90|
00005a  2000              MOVS     r0,#0                 ;954
00005c  bd70              POP      {r4-r6,pc}
;;;957    
                          ENDP

00005e  0000              DCW      0x0000
                  |L52.96|
000060  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c",0
000064  6964646c
000068  65776172
00006c  65735c54
000070  68697264
000074  5f506172
000078  74795c4c
00007c  7749505c
000080  7372635c
000084  636f7265
000088  5c746370
00008c  2e6300  
00008f  00                DCB      0
                  |L52.144|
000090  7463705f          DCB      "tcp_update_rcv_ann_wnd: invalid pcb",0
000094  75706461
000098  74655f72
00009c  63765f61
0000a0  6e6e5f77
0000a4  6e643a20
0000a8  696e7661
0000ac  6c696420
0000b0  70636200
                  |L52.180|
0000b4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000b8  7274696f
0000bc  6e202225
0000c0  73222066
0000c4  61696c65
0000c8  64206174
0000cc  206c696e
0000d0  65202564
0000d4  20696e20
0000d8  25730a00
                  |L52.220|
0000dc  6e65775f          DCB      "new_rcv_ann_wnd <= 0xffff",0
0000e0  7263765f
0000e4  616e6e5f
0000e8  776e6420
0000ec  3c3d2030
0000f0  78666666
0000f4  6600    
0000f6  00                DCB      0
0000f7  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  tcp_persist_backoff
000000  03060c18          DCB      0x03,0x06,0x0c,0x18
000004  30607800          DCB      0x30,0x60,0x78,0x00
                  tcp_state_str
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      ||.conststring||+0x10
                          DCD      ||.conststring||+0x1c
                          DCD      ||.conststring||+0x28
                          DCD      ||.conststring||+0x34
                          DCD      ||.conststring||+0x40
                          DCD      ||.conststring||+0x4c
                          DCD      ||.conststring||+0x58
                          DCD      ||.conststring||+0x60
                          DCD      ||.conststring||+0x6c
                  tcp_backoff
000034  01020304          DCB      0x01,0x02,0x03,0x04
000038  05060707          DCB      0x05,0x06,0x07,0x07
00003c  07070707          DCB      0x07,0x07,0x07,0x07
000040  07000000          DCB      0x07,0x00,0x00,0x00
                  tcp_pcb_lists
                          DCD      tcp_listen_pcbs
                          DCD      tcp_bound_pcbs
                          DCD      tcp_active_pcbs
                          DCD      tcp_tw_pcbs

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  434c4f53          DCB      "CLOSED",0
000004  454400  
000007  00                DCB      0
000008  4c495354          DCB      "LISTEN",0
00000c  454e00  
00000f  00                DCB      0
000010  53594e5f          DCB      "SYN_SENT",0
000014  53454e54
000018  00      
000019  00                DCB      0
00001a  00                DCB      0
00001b  00                DCB      0
00001c  53594e5f          DCB      "SYN_RCVD",0
000020  52435644
000024  00      
000025  00                DCB      0
000026  00                DCB      0
000027  00                DCB      0
000028  45535441          DCB      "ESTABLISHED",0
00002c  424c4953
000030  48454400
000034  46494e5f          DCB      "FIN_WAIT_1",0
000038  57414954
00003c  5f3100  
00003f  00                DCB      0
000040  46494e5f          DCB      "FIN_WAIT_2",0
000044  57414954
000048  5f3200  
00004b  00                DCB      0
00004c  434c4f53          DCB      "CLOSE_WAIT",0
000050  455f5741
000054  495400  
000057  00                DCB      0
000058  434c4f53          DCB      "CLOSING",0
00005c  494e4700
000060  4c415354          DCB      "LAST_ACK",0
000064  5f41434b
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
00006c  54494d45          DCB      "TIME_WAIT",0
000070  5f574149
000074  5400    

                          AREA ||.data||, DATA, ALIGN=2

                  tcp_active_pcbs_changed
000000  00                DCB      0x00
                  tcp_timer
000001  00                DCB      0x00
                  tcp_timer_ctr
000002  0000              DCB      0x00,0x00
                  tcp_port
000004  c000              DCW      0xc000
000006  0000              DCB      0x00,0x00
                  iss
                          DCD      0x0000196e
                  tcp_ticks
                          DCD      0x00000000
                  tcp_bound_pcbs
                          DCD      0x00000000
                  tcp_listen_pcbs
                          DCD      0x00000000
                  tcp_active_pcbs
                          DCD      0x00000000
                  tcp_tw_pcbs
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_tcp_c_1dfa8a85____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_tcp_c_1dfa8a85____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_tcp_c_1dfa8a85____REVSH|
#line 478
|__asm___5_tcp_c_1dfa8a85____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_tcp_c_1dfa8a85____RRX|
#line 665
|__asm___5_tcp_c_1dfa8a85____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
