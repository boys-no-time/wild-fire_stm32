; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\stm32f1xx_hal_flash_ex.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f1xx_hal_flash_ex.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\system\arch -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Inc -I..\Middlewares\Third_Party\LwIP\src\include -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\stm32f1xx_hal_flash_ex.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_flash_ex.c]
                          THUMB

                          AREA ||i.FLASH_MassErase||, CODE, READONLY, ALIGN=2

                  FLASH_MassErase PROC
;;;594      */
;;;595    static void FLASH_MassErase(uint32_t Banks)
000000  4906              LDR      r1,|L1.28|
;;;596    {
;;;597      /* Check the parameters */
;;;598      assert_param(IS_FLASH_BANK(Banks));
;;;599    
;;;600      /* Clean the error context */
;;;601      pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
000002  2000              MOVS     r0,#0
000004  61c8              STR      r0,[r1,#0x1c]  ; pFlash
;;;602    
;;;603    #if defined(FLASH_BANK2_END)
;;;604      if(Banks == FLASH_BANK_BOTH)
;;;605      {
;;;606        /* bank1 & bank2 will be erased*/
;;;607        SET_BIT(FLASH->CR, FLASH_CR_MER);
;;;608        SET_BIT(FLASH->CR2, FLASH_CR2_MER);
;;;609        SET_BIT(FLASH->CR, FLASH_CR_STRT);
;;;610        SET_BIT(FLASH->CR2, FLASH_CR2_STRT);
;;;611      }
;;;612      else if(Banks == FLASH_BANK_2)
;;;613      {
;;;614        /*Only bank2 will be erased*/
;;;615        SET_BIT(FLASH->CR2, FLASH_CR2_MER);
;;;616        SET_BIT(FLASH->CR2, FLASH_CR2_STRT);
;;;617      }
;;;618      else
;;;619      {
;;;620    #endif /* FLASH_BANK2_END */
;;;621    #if !defined(FLASH_BANK2_END)
;;;622      /* Prevent unused argument(s) compilation warning */
;;;623      UNUSED(Banks);
;;;624    #endif /* FLASH_BANK2_END */  
;;;625        /* Only bank1 will be erased*/
;;;626        SET_BIT(FLASH->CR, FLASH_CR_MER);
000006  4806              LDR      r0,|L1.32|
000008  6901              LDR      r1,[r0,#0x10]
00000a  f0410104          ORR      r1,r1,#4
00000e  6101              STR      r1,[r0,#0x10]
;;;627        SET_BIT(FLASH->CR, FLASH_CR_STRT);
000010  6901              LDR      r1,[r0,#0x10]
000012  f0410140          ORR      r1,r1,#0x40
000016  6101              STR      r1,[r0,#0x10]
;;;628    #if defined(FLASH_BANK2_END)
;;;629      }
;;;630    #endif /* FLASH_BANK2_END */
;;;631    }
000018  4770              BX       lr
;;;632    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      pFlash
                  |L1.32|
                          DCD      0x40022000

                          AREA ||i.FLASH_OB_DisableWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_DisableWRP PROC
;;;766      */
;;;767    static HAL_StatusTypeDef FLASH_OB_DisableWRP(uint32_t WriteProtectPage)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;768    {
000004  4604              MOV      r4,r0
;;;769      HAL_StatusTypeDef status = HAL_OK;
;;;770      uint16_t WRP0_Data = 0xFFFF;
;;;771    #if defined(FLASH_WRP1_WRP1)
;;;772      uint16_t WRP1_Data = 0xFFFF;
;;;773    #endif /* FLASH_WRP1_WRP1 */
;;;774    #if defined(FLASH_WRP2_WRP2)
;;;775      uint16_t WRP2_Data = 0xFFFF;
;;;776    #endif /* FLASH_WRP2_WRP2 */
;;;777    #if defined(FLASH_WRP3_WRP3)
;;;778      uint16_t WRP3_Data = 0xFFFF;
;;;779    #endif /* FLASH_WRP3_WRP3 */
;;;780      
;;;781      /* Check the parameters */
;;;782      assert_param(IS_OB_WRP(WriteProtectPage));
;;;783    
;;;784      /* Get current write protected pages and the new pages to be unprotected ******/
;;;785      WriteProtectPage = (FLASH_OB_GetWRP() | WriteProtectPage);
000006  f7fffffe          BL       FLASH_OB_GetWRP
00000a  4320              ORRS     r0,r0,r4
;;;786    
;;;787    #if defined(OB_WRP_PAGES0TO15MASK)
;;;788      WRP0_Data = (uint16_t)(WriteProtectPage & OB_WRP_PAGES0TO15MASK);
00000c  b2c4              UXTB     r4,r0
;;;789    #elif defined(OB_WRP_PAGES0TO31MASK)
;;;790      WRP0_Data = (uint16_t)(WriteProtectPage & OB_WRP_PAGES0TO31MASK);
;;;791    #endif /* OB_WRP_PAGES0TO31MASK */
;;;792      
;;;793    #if defined(OB_WRP_PAGES16TO31MASK)
;;;794      WRP1_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES16TO31MASK) >> 8U);
00000e  f3c02507          UBFX     r5,r0,#8,#8
;;;795    #elif defined(OB_WRP_PAGES32TO63MASK)
;;;796      WRP1_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES32TO63MASK) >> 8U);
;;;797    #endif /* OB_WRP_PAGES32TO63MASK */
;;;798     
;;;799    #if defined(OB_WRP_PAGES64TO95MASK)
;;;800      WRP2_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES64TO95MASK) >> 16U);
;;;801    #endif /* OB_WRP_PAGES64TO95MASK */
;;;802    #if defined(OB_WRP_PAGES32TO47MASK)
;;;803      WRP2_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES32TO47MASK) >> 16U);
000012  f3c04607          UBFX     r6,r0,#16,#8
;;;804    #endif /* OB_WRP_PAGES32TO47MASK */
;;;805    
;;;806    #if defined(OB_WRP_PAGES96TO127MASK)
;;;807      WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES96TO127MASK) >> 24U); 
;;;808    #elif defined(OB_WRP_PAGES48TO255MASK)
;;;809      WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO255MASK) >> 24U); 
;;;810    #elif defined(OB_WRP_PAGES48TO511MASK)
;;;811      WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO511MASK) >> 24U); 
;;;812    #elif defined(OB_WRP_PAGES48TO127MASK)
;;;813      WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO127MASK) >> 24U); 
000016  0e07              LSRS     r7,r0,#24
;;;814    #endif /* OB_WRP_PAGES96TO127MASK */
;;;815    
;;;816        
;;;817      /* Wait for last operation to be completed */
;;;818      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000018  f24c3950          MOV      r9,#0xc350
00001c  4648              MOV      r0,r9
00001e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;819    
;;;820      if(status == HAL_OK)
000022  2800              CMP      r0,#0
000024  d13d              BNE      |L2.162|
;;;821      { 
;;;822        /* Clean the error context */
;;;823        pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
000026  4920              LDR      r1,|L2.168|
000028  61c8              STR      r0,[r1,#0x1c]  ; pFlash
;;;824    
;;;825        /* To be able to write again option byte, need to perform a option byte erase */
;;;826        status = HAL_FLASHEx_OBErase();
00002a  f7fffffe          BL       HAL_FLASHEx_OBErase
;;;827        if (status == HAL_OK)  
00002e  2800              CMP      r0,#0
000030  d137              BNE      |L2.162|
;;;828        {
;;;829          SET_BIT(FLASH->CR, FLASH_CR_OPTPG);
000032  f8df8078          LDR      r8,|L2.172|
000036  f8d81010          LDR      r1,[r8,#0x10]
00003a  f0410110          ORR      r1,r1,#0x10
00003e  f8c81010          STR      r1,[r8,#0x10]
;;;830    
;;;831    #if defined(FLASH_WRP0_WRP0)
;;;832          if(WRP0_Data != 0xFFU)
000042  2cff              CMP      r4,#0xff
000044  d006              BEQ      |L2.84|
;;;833          {
;;;834            OB->WRP0 |= WRP0_Data;
000046  481a              LDR      r0,|L2.176|
000048  8801              LDRH     r1,[r0,#0]
00004a  4321              ORRS     r1,r1,r4
00004c  8001              STRH     r1,[r0,#0]
;;;835            
;;;836            /* Wait for last operation to be completed */
;;;837            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
00004e  4648              MOV      r0,r9
000050  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L2.84|
;;;838          }
;;;839    #endif /* FLASH_WRP0_WRP0 */
;;;840    
;;;841    #if defined(FLASH_WRP1_WRP1)
;;;842          if((status == HAL_OK) && (WRP1_Data != 0xFFU))
000054  b948              CBNZ     r0,|L2.106|
000056  2dff              CMP      r5,#0xff
000058  d007              BEQ      |L2.106|
;;;843          {
;;;844            OB->WRP1 |= WRP1_Data;
00005a  4815              LDR      r0,|L2.176|
00005c  1c80              ADDS     r0,r0,#2
00005e  8801              LDRH     r1,[r0,#0]
000060  4329              ORRS     r1,r1,r5
000062  8001              STRH     r1,[r0,#0]
;;;845            
;;;846            /* Wait for last operation to be completed */
;;;847            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000064  4648              MOV      r0,r9
000066  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L2.106|
;;;848          }
;;;849    #endif /* FLASH_WRP1_WRP1 */
;;;850    
;;;851    #if defined(FLASH_WRP2_WRP2)
;;;852          if((status == HAL_OK) && (WRP2_Data != 0xFFU))
00006a  b948              CBNZ     r0,|L2.128|
00006c  2eff              CMP      r6,#0xff
00006e  d007              BEQ      |L2.128|
;;;853          {
;;;854            OB->WRP2 |= WRP2_Data;
000070  480f              LDR      r0,|L2.176|
000072  1d00              ADDS     r0,r0,#4
000074  8801              LDRH     r1,[r0,#0]
000076  4331              ORRS     r1,r1,r6
000078  8001              STRH     r1,[r0,#0]
;;;855            
;;;856            /* Wait for last operation to be completed */
;;;857            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
00007a  4648              MOV      r0,r9
00007c  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L2.128|
;;;858          }
;;;859    #endif /* FLASH_WRP2_WRP2 */
;;;860    
;;;861    #if defined(FLASH_WRP3_WRP3)
;;;862          if((status == HAL_OK) && (WRP3_Data != 0xFFU))
000080  b948              CBNZ     r0,|L2.150|
000082  2fff              CMP      r7,#0xff
000084  d007              BEQ      |L2.150|
;;;863          {
;;;864            OB->WRP3 |= WRP3_Data;
000086  480a              LDR      r0,|L2.176|
000088  1d80              ADDS     r0,r0,#6
00008a  8801              LDRH     r1,[r0,#0]
00008c  4339              ORRS     r1,r1,r7
00008e  8001              STRH     r1,[r0,#0]
;;;865            
;;;866            /* Wait for last operation to be completed */
;;;867            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000090  4648              MOV      r0,r9
000092  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L2.150|
;;;868          }
;;;869    #endif /* FLASH_WRP3_WRP3 */
;;;870    
;;;871          /* if the program operation is completed, disable the OPTPG Bit */
;;;872          CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
000096  f8d81010          LDR      r1,[r8,#0x10]
00009a  f0210110          BIC      r1,r1,#0x10
00009e  f8c81010          STR      r1,[r8,#0x10]
                  |L2.162|
;;;873        }
;;;874      }
;;;875      return status;
;;;876    }
0000a2  e8bd87f0          POP      {r4-r10,pc}
;;;877    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L2.168|
                          DCD      pFlash
                  |L2.172|
                          DCD      0x40022000
                  |L2.176|
                          DCD      0x1ffff808

                          AREA ||i.FLASH_OB_EnableWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_EnableWRP PROC
;;;643      */
;;;644    static HAL_StatusTypeDef FLASH_OB_EnableWRP(uint32_t WriteProtectPage)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;645    {
000004  4604              MOV      r4,r0
;;;646      HAL_StatusTypeDef status = HAL_OK;
;;;647      uint16_t WRP0_Data = 0xFFFF;
;;;648    #if defined(FLASH_WRP1_WRP1)
;;;649      uint16_t WRP1_Data = 0xFFFF;
;;;650    #endif /* FLASH_WRP1_WRP1 */
;;;651    #if defined(FLASH_WRP2_WRP2)
;;;652      uint16_t WRP2_Data = 0xFFFF;
;;;653    #endif /* FLASH_WRP2_WRP2 */
;;;654    #if defined(FLASH_WRP3_WRP3)
;;;655      uint16_t WRP3_Data = 0xFFFF;
;;;656    #endif /* FLASH_WRP3_WRP3 */
;;;657      
;;;658      /* Check the parameters */
;;;659      assert_param(IS_OB_WRP(WriteProtectPage));
;;;660        
;;;661      /* Get current write protected pages and the new pages to be protected ******/
;;;662      WriteProtectPage = (uint32_t)(~((~FLASH_OB_GetWRP()) | WriteProtectPage));
000006  f7fffffe          BL       FLASH_OB_GetWRP
00000a  43a0              BICS     r0,r0,r4
;;;663      
;;;664    #if defined(OB_WRP_PAGES0TO15MASK)
;;;665      WRP0_Data = (uint16_t)(WriteProtectPage & OB_WRP_PAGES0TO15MASK);
00000c  b2c4              UXTB     r4,r0
;;;666    #elif defined(OB_WRP_PAGES0TO31MASK)
;;;667      WRP0_Data = (uint16_t)(WriteProtectPage & OB_WRP_PAGES0TO31MASK);
;;;668    #endif /* OB_WRP_PAGES0TO31MASK */
;;;669      
;;;670    #if defined(OB_WRP_PAGES16TO31MASK)
;;;671      WRP1_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES16TO31MASK) >> 8U);
00000e  f3c02507          UBFX     r5,r0,#8,#8
;;;672    #elif defined(OB_WRP_PAGES32TO63MASK)
;;;673      WRP1_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES32TO63MASK) >> 8U);
;;;674    #endif /* OB_WRP_PAGES32TO63MASK */
;;;675     
;;;676    #if defined(OB_WRP_PAGES64TO95MASK)
;;;677      WRP2_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES64TO95MASK) >> 16U);
;;;678    #endif /* OB_WRP_PAGES64TO95MASK */
;;;679    #if defined(OB_WRP_PAGES32TO47MASK)
;;;680      WRP2_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES32TO47MASK) >> 16U);
000012  f3c04607          UBFX     r6,r0,#16,#8
;;;681    #endif /* OB_WRP_PAGES32TO47MASK */
;;;682    
;;;683    #if defined(OB_WRP_PAGES96TO127MASK)
;;;684      WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES96TO127MASK) >> 24U); 
;;;685    #elif defined(OB_WRP_PAGES48TO255MASK)
;;;686      WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO255MASK) >> 24U); 
;;;687    #elif defined(OB_WRP_PAGES48TO511MASK)
;;;688      WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO511MASK) >> 24U); 
;;;689    #elif defined(OB_WRP_PAGES48TO127MASK)
;;;690      WRP3_Data = (uint16_t)((WriteProtectPage & OB_WRP_PAGES48TO127MASK) >> 24U); 
000016  0e07              LSRS     r7,r0,#24
;;;691    #endif /* OB_WRP_PAGES96TO127MASK */
;;;692      
;;;693      /* Wait for last operation to be completed */
;;;694      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000018  f24c3950          MOV      r9,#0xc350
00001c  4648              MOV      r0,r9
00001e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;695    
;;;696      if(status == HAL_OK)
000022  2800              CMP      r0,#0
000024  d13d              BNE      |L3.162|
;;;697      { 
;;;698        /* Clean the error context */
;;;699        pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
000026  4920              LDR      r1,|L3.168|
000028  61c8              STR      r0,[r1,#0x1c]  ; pFlash
;;;700    
;;;701        /* To be able to write again option byte, need to perform a option byte erase */
;;;702        status = HAL_FLASHEx_OBErase();
00002a  f7fffffe          BL       HAL_FLASHEx_OBErase
;;;703        if (status == HAL_OK)  
00002e  2800              CMP      r0,#0
000030  d137              BNE      |L3.162|
;;;704        {
;;;705          /* Enable write protection */
;;;706          SET_BIT(FLASH->CR, FLASH_CR_OPTPG);
000032  f8df8078          LDR      r8,|L3.172|
000036  f8d81010          LDR      r1,[r8,#0x10]
00003a  f0410110          ORR      r1,r1,#0x10
00003e  f8c81010          STR      r1,[r8,#0x10]
;;;707    
;;;708    #if defined(FLASH_WRP0_WRP0)
;;;709          if(WRP0_Data != 0xFFU)
000042  2cff              CMP      r4,#0xff
000044  d006              BEQ      |L3.84|
;;;710          {
;;;711            OB->WRP0 &= WRP0_Data;
000046  481a              LDR      r0,|L3.176|
000048  8801              LDRH     r1,[r0,#0]
00004a  4021              ANDS     r1,r1,r4
00004c  8001              STRH     r1,[r0,#0]
;;;712            
;;;713            /* Wait for last operation to be completed */
;;;714            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
00004e  4648              MOV      r0,r9
000050  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L3.84|
;;;715          }
;;;716    #endif /* FLASH_WRP0_WRP0 */
;;;717    
;;;718    #if defined(FLASH_WRP1_WRP1)
;;;719          if((status == HAL_OK) && (WRP1_Data != 0xFFU))
000054  b948              CBNZ     r0,|L3.106|
000056  2dff              CMP      r5,#0xff
000058  d007              BEQ      |L3.106|
;;;720          {
;;;721            OB->WRP1 &= WRP1_Data;
00005a  4815              LDR      r0,|L3.176|
00005c  1c80              ADDS     r0,r0,#2
00005e  8801              LDRH     r1,[r0,#0]
000060  4029              ANDS     r1,r1,r5
000062  8001              STRH     r1,[r0,#0]
;;;722            
;;;723            /* Wait for last operation to be completed */
;;;724            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000064  4648              MOV      r0,r9
000066  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L3.106|
;;;725          }
;;;726    #endif /* FLASH_WRP1_WRP1 */
;;;727    
;;;728    #if defined(FLASH_WRP2_WRP2)
;;;729          if((status == HAL_OK) && (WRP2_Data != 0xFFU))
00006a  b948              CBNZ     r0,|L3.128|
00006c  2eff              CMP      r6,#0xff
00006e  d007              BEQ      |L3.128|
;;;730          {
;;;731            OB->WRP2 &= WRP2_Data;
000070  480f              LDR      r0,|L3.176|
000072  1d00              ADDS     r0,r0,#4
000074  8801              LDRH     r1,[r0,#0]
000076  4031              ANDS     r1,r1,r6
000078  8001              STRH     r1,[r0,#0]
;;;732            
;;;733            /* Wait for last operation to be completed */
;;;734            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
00007a  4648              MOV      r0,r9
00007c  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L3.128|
;;;735          }
;;;736    #endif /* FLASH_WRP2_WRP2 */
;;;737    
;;;738    #if defined(FLASH_WRP3_WRP3)
;;;739          if((status == HAL_OK) && (WRP3_Data != 0xFFU))
000080  b948              CBNZ     r0,|L3.150|
000082  2fff              CMP      r7,#0xff
000084  d007              BEQ      |L3.150|
;;;740          {
;;;741            OB->WRP3 &= WRP3_Data;
000086  480a              LDR      r0,|L3.176|
000088  1d80              ADDS     r0,r0,#6
00008a  8801              LDRH     r1,[r0,#0]
00008c  4039              ANDS     r1,r1,r7
00008e  8001              STRH     r1,[r0,#0]
;;;742            
;;;743            /* Wait for last operation to be completed */
;;;744            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000090  4648              MOV      r0,r9
000092  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L3.150|
;;;745          }
;;;746    #endif /* FLASH_WRP3_WRP3 */
;;;747    
;;;748          /* if the program operation is completed, disable the OPTPG Bit */
;;;749          CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
000096  f8d81010          LDR      r1,[r8,#0x10]
00009a  f0210110          BIC      r1,r1,#0x10
00009e  f8c81010          STR      r1,[r8,#0x10]
                  |L3.162|
;;;750        }
;;;751      }
;;;752      
;;;753      return status;
;;;754    }
0000a2  e8bd87f0          POP      {r4-r10,pc}
;;;755    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L3.168|
                          DCD      pFlash
                  |L3.172|
                          DCD      0x40022000
                  |L3.176|
                          DCD      0x1ffff808

                          AREA ||i.FLASH_OB_GetRDP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetRDP PROC
;;;1033     */
;;;1034   static uint32_t FLASH_OB_GetRDP(void)
000000  20a5              MOVS     r0,#0xa5
;;;1035   {
;;;1036     uint32_t readstatus = OB_RDP_LEVEL_0;
;;;1037     uint32_t tmp_reg = 0U;
;;;1038     
;;;1039     /* Read RDP level bits */
;;;1040     tmp_reg = READ_BIT(FLASH->OBR, FLASH_OBR_RDPRT);
000002  4904              LDR      r1,|L4.20|
000004  69c9              LDR      r1,[r1,#0x1c]
000006  f0010102          AND      r1,r1,#2
;;;1041   
;;;1042     if (tmp_reg == FLASH_OBR_RDPRT)
00000a  2902              CMP      r1,#2
00000c  d100              BNE      |L4.16|
;;;1043     {
;;;1044       readstatus = OB_RDP_LEVEL_1;
00000e  2000              MOVS     r0,#0
                  |L4.16|
;;;1045     }
;;;1046     else 
;;;1047     {
;;;1048       readstatus = OB_RDP_LEVEL_0;
;;;1049     }
;;;1050   
;;;1051     return readstatus;
;;;1052   }
000010  4770              BX       lr
;;;1053   
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_OB_GetUser||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetUser PROC
;;;1059     */
;;;1060   static uint8_t FLASH_OB_GetUser(void)
000000  4802              LDR      r0,|L5.12|
;;;1061   {
;;;1062     /* Return the User Option Byte */
;;;1063     return (uint8_t)((READ_REG(FLASH->OBR) & FLASH_OBR_USER) >> FLASH_POSITION_IWDGSW_BIT);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  f3c00082          UBFX     r0,r0,#2,#3
;;;1064   }
000008  4770              BX       lr
;;;1065   
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x40022000

                          AREA ||i.FLASH_OB_GetWRP||, CODE, READONLY, ALIGN=2

                  FLASH_OB_GetWRP PROC
;;;1020     */
;;;1021   static uint32_t FLASH_OB_GetWRP(void)
000000  4801              LDR      r0,|L6.8|
;;;1022   {
;;;1023     /* Return the FLASH write protection Register value */
;;;1024     return (uint32_t)(READ_REG(FLASH->WRPR));
000002  6a00              LDR      r0,[r0,#0x20]
;;;1025   }
000004  4770              BX       lr
;;;1026   
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_OB_ProgramData||, CODE, READONLY, ALIGN=2

                  FLASH_OB_ProgramData PROC
;;;987      */
;;;988    static HAL_StatusTypeDef FLASH_OB_ProgramData(uint32_t Address, uint8_t Data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;989    {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;990      HAL_StatusTypeDef status = HAL_ERROR;
;;;991      
;;;992      /* Check the parameters */
;;;993      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;994      
;;;995      /* Wait for last operation to be completed */
;;;996      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000008  f24c3750          MOV      r7,#0xc350
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;997      
;;;998      if(status == HAL_OK)
000012  2800              CMP      r0,#0
000014  d10e              BNE      |L7.52|
;;;999      {
;;;1000       /* Clean the error context */
;;;1001       pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
000016  4908              LDR      r1,|L7.56|
000018  61c8              STR      r0,[r1,#0x1c]  ; pFlash
;;;1002   
;;;1003       /* Enables the Option Bytes Programming operation */
;;;1004       SET_BIT(FLASH->CR, FLASH_CR_OPTPG); 
00001a  4c08              LDR      r4,|L7.60|
00001c  6920              LDR      r0,[r4,#0x10]
00001e  f0400010          ORR      r0,r0,#0x10
000022  6120              STR      r0,[r4,#0x10]
;;;1005       *(__IO uint16_t*)Address = Data;
000024  8035              STRH     r5,[r6,#0]
;;;1006       
;;;1007       /* Wait for last operation to be completed */
;;;1008       status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1009       
;;;1010       /* If the program operation is completed, disable the OPTPG Bit */
;;;1011       CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
00002c  6921              LDR      r1,[r4,#0x10]
00002e  f0210110          BIC      r1,r1,#0x10
000032  6121              STR      r1,[r4,#0x10]
                  |L7.52|
;;;1012     }
;;;1013     /* Return the Option Byte Data Program Status */
;;;1014     return status;
;;;1015   }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;1016   
                          ENDP

                  |L7.56|
                          DCD      pFlash
                  |L7.60|
                          DCD      0x40022000

                          AREA ||i.FLASH_OB_RDP_LevelConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_RDP_LevelConfig PROC
;;;885      */
;;;886    static HAL_StatusTypeDef FLASH_OB_RDP_LevelConfig(uint8_t ReadProtectLevel)
000000  b570              PUSH     {r4-r6,lr}
;;;887    {
000002  4605              MOV      r5,r0
;;;888      HAL_StatusTypeDef status = HAL_OK;
;;;889      
;;;890      /* Check the parameters */
;;;891      assert_param(IS_OB_RDP_LEVEL(ReadProtectLevel));
;;;892      
;;;893      /* Wait for last operation to be completed */
;;;894      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000004  f24c3650          MOV      r6,#0xc350
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;895      
;;;896      if(status == HAL_OK)
00000e  2800              CMP      r0,#0
000010  d120              BNE      |L8.84|
;;;897      { 
;;;898        /* Clean the error context */
;;;899        pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
000012  4911              LDR      r1,|L8.88|
000014  61c8              STR      r0,[r1,#0x1c]  ; pFlash
;;;900        
;;;901        /* If the previous operation is completed, proceed to erase the option bytes */
;;;902        SET_BIT(FLASH->CR, FLASH_CR_OPTER);
000016  4c11              LDR      r4,|L8.92|
000018  6920              LDR      r0,[r4,#0x10]
00001a  f0400020          ORR      r0,r0,#0x20
00001e  6120              STR      r0,[r4,#0x10]
;;;903        SET_BIT(FLASH->CR, FLASH_CR_STRT);
000020  6920              LDR      r0,[r4,#0x10]
000022  f0400040          ORR      r0,r0,#0x40
000026  6120              STR      r0,[r4,#0x10]
;;;904    
;;;905        /* Wait for last operation to be completed */
;;;906        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;907    
;;;908        /* If the erase operation is completed, disable the OPTER Bit */
;;;909        CLEAR_BIT(FLASH->CR, FLASH_CR_OPTER);
00002e  6921              LDR      r1,[r4,#0x10]
000030  f0210120          BIC      r1,r1,#0x20
000034  6121              STR      r1,[r4,#0x10]
;;;910    
;;;911        if(status == HAL_OK)
000036  2800              CMP      r0,#0
000038  d10c              BNE      |L8.84|
;;;912        {
;;;913          /* Enable the Option Bytes Programming operation */
;;;914          SET_BIT(FLASH->CR, FLASH_CR_OPTPG);
00003a  6920              LDR      r0,[r4,#0x10]
00003c  f0400010          ORR      r0,r0,#0x10
000040  6120              STR      r0,[r4,#0x10]
;;;915          
;;;916          WRITE_REG(OB->RDP, ReadProtectLevel);
000042  4807              LDR      r0,|L8.96|
000044  8005              STRH     r5,[r0,#0]
;;;917          
;;;918          /* Wait for last operation to be completed */
;;;919          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE); 
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       FLASH_WaitForLastOperation
;;;920          
;;;921          /* if the program operation is completed, disable the OPTPG Bit */
;;;922          CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
00004c  6921              LDR      r1,[r4,#0x10]
00004e  f0210110          BIC      r1,r1,#0x10
000052  6121              STR      r1,[r4,#0x10]
                  |L8.84|
;;;923        }
;;;924      }
;;;925      
;;;926      return status;
;;;927    }
000054  bd70              POP      {r4-r6,pc}
;;;928    
                          ENDP

000056  0000              DCW      0x0000
                  |L8.88|
                          DCD      pFlash
                  |L8.92|
                          DCD      0x40022000
                  |L8.96|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_OB_UserConfig||, CODE, READONLY, ALIGN=2

                  FLASH_OB_UserConfig PROC
;;;936      */
;;;937    static HAL_StatusTypeDef FLASH_OB_UserConfig(uint8_t UserConfig)
000000  b570              PUSH     {r4-r6,lr}
;;;938    {
000002  4605              MOV      r5,r0
;;;939      HAL_StatusTypeDef status = HAL_OK;
;;;940    
;;;941      /* Check the parameters */
;;;942      assert_param(IS_OB_IWDG_SOURCE((UserConfig&OB_IWDG_SW)));
;;;943      assert_param(IS_OB_STOP_SOURCE((UserConfig&OB_STOP_NO_RST)));
;;;944      assert_param(IS_OB_STDBY_SOURCE((UserConfig&OB_STDBY_NO_RST)));
;;;945    #if defined(FLASH_BANK2_END)
;;;946      assert_param(IS_OB_BOOT1((UserConfig&OB_BOOT1_SET)));
;;;947    #endif /* FLASH_BANK2_END */
;;;948    
;;;949      /* Wait for last operation to be completed */
;;;950      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000004  f24c3650          MOV      r6,#0xc350
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;951      
;;;952      if(status == HAL_OK)
00000e  2800              CMP      r0,#0
000010  d111              BNE      |L9.54|
;;;953      {     
;;;954        /* Clean the error context */
;;;955        pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
000012  4909              LDR      r1,|L9.56|
000014  61c8              STR      r0,[r1,#0x1c]  ; pFlash
;;;956    
;;;957        /* Enable the Option Bytes Programming operation */
;;;958        SET_BIT(FLASH->CR, FLASH_CR_OPTPG); 
000016  4c09              LDR      r4,|L9.60|
000018  6920              LDR      r0,[r4,#0x10]
00001a  f0400010          ORR      r0,r0,#0x10
00001e  6120              STR      r0,[r4,#0x10]
;;;959     
;;;960    #if defined(FLASH_BANK2_END)
;;;961        OB->USER = (UserConfig | 0xF0U);
;;;962    #else
;;;963        OB->USER = (UserConfig | 0x88U);
000020  4907              LDR      r1,|L9.64|
000022  f0450088          ORR      r0,r5,#0x88
000026  8008              STRH     r0,[r1,#0]
;;;964    #endif /* FLASH_BANK2_END */
;;;965    
;;;966        /* Wait for last operation to be completed */
;;;967        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;968    
;;;969        /* if the program operation is completed, disable the OPTPG Bit */
;;;970        CLEAR_BIT(FLASH->CR, FLASH_CR_OPTPG);
00002e  6921              LDR      r1,[r4,#0x10]
000030  f0210110          BIC      r1,r1,#0x10
000034  6121              STR      r1,[r4,#0x10]
                  |L9.54|
;;;971      }
;;;972      
;;;973      return status; 
;;;974    }
000036  bd70              POP      {r4-r6,pc}
;;;975    
                          ENDP

                  |L9.56|
                          DCD      pFlash
                  |L9.60|
                          DCD      0x40022000
                  |L9.64|
                          DCD      0x1ffff802

                          AREA ||i.FLASH_PageErase||, CODE, READONLY, ALIGN=2

                  FLASH_PageErase PROC
;;;1088     */
;;;1089   void FLASH_PageErase(uint32_t PageAddress)
000000  4a06              LDR      r2,|L10.28|
;;;1090   {
;;;1091     /* Clean the error context */
;;;1092     pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
000002  2100              MOVS     r1,#0
000004  61d1              STR      r1,[r2,#0x1c]  ; pFlash
;;;1093   
;;;1094   #if defined(FLASH_BANK2_END)
;;;1095     if(PageAddress > FLASH_BANK1_END)
;;;1096     { 
;;;1097       /* Proceed to erase the page */
;;;1098       SET_BIT(FLASH->CR2, FLASH_CR2_PER);
;;;1099       WRITE_REG(FLASH->AR2, PageAddress);
;;;1100       SET_BIT(FLASH->CR2, FLASH_CR2_STRT);
;;;1101     }
;;;1102     else
;;;1103     {
;;;1104   #endif /* FLASH_BANK2_END */
;;;1105       /* Proceed to erase the page */
;;;1106       SET_BIT(FLASH->CR, FLASH_CR_PER);
000006  4906              LDR      r1,|L10.32|
000008  690a              LDR      r2,[r1,#0x10]
00000a  f0420202          ORR      r2,r2,#2
00000e  610a              STR      r2,[r1,#0x10]
;;;1107       WRITE_REG(FLASH->AR, PageAddress);
000010  6148              STR      r0,[r1,#0x14]
;;;1108       SET_BIT(FLASH->CR, FLASH_CR_STRT);
000012  6908              LDR      r0,[r1,#0x10]
000014  f0400040          ORR      r0,r0,#0x40
000018  6108              STR      r0,[r1,#0x10]
;;;1109   #if defined(FLASH_BANK2_END)
;;;1110     }
;;;1111   #endif /* FLASH_BANK2_END */
;;;1112   }
00001a  4770              BX       lr
;;;1113   
                          ENDP

                  |L10.28|
                          DCD      pFlash
                  |L10.32|
                          DCD      0x40022000

                          AREA ||i.HAL_FLASHEx_Erase||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_Erase PROC
;;;158      */
;;;159    HAL_StatusTypeDef HAL_FLASHEx_Erase(FLASH_EraseInitTypeDef *pEraseInit, uint32_t *PageError)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;160    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;161      HAL_StatusTypeDef status = HAL_ERROR;
000008  f04f0a01          MOV      r10,#1
;;;162      uint32_t address = 0U;
;;;163    
;;;164      /* Process Locked */
;;;165      __HAL_LOCK(&pFlash);
00000c  f8df8090          LDR      r8,|L11.160|
000010  f8980018          LDRB     r0,[r8,#0x18]  ; pFlash
000014  2801              CMP      r0,#1
000016  d00d              BEQ      |L11.52|
000018  2001              MOVS     r0,#1
00001a  f8880018          STRB     r0,[r8,#0x18]
;;;166    
;;;167      /* Check the parameters */
;;;168      assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
;;;169    
;;;170      if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
00001e  6828              LDR      r0,[r5,#0]
;;;171      {
;;;172    #if defined(FLASH_BANK2_END)
;;;173        if (pEraseInit->Banks == FLASH_BANK_BOTH)
;;;174        {
;;;175          /* Mass Erase requested for Bank1 and Bank2 */
;;;176          /* Wait for last operation to be completed */
;;;177          if ((FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK) && \
;;;178              (FLASH_WaitForLastOperationBank2((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK))
;;;179          {
;;;180            /*Mass erase to be done*/
;;;181            FLASH_MassErase(FLASH_BANK_BOTH);
;;;182            
;;;183            /* Wait for last operation to be completed */
;;;184            if ((FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK) && \
;;;185                (FLASH_WaitForLastOperationBank2((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK))
;;;186            {
;;;187              status = HAL_OK;
;;;188            }
;;;189            
;;;190            /* If the erase operation is completed, disable the MER Bit */
;;;191            CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
;;;192            CLEAR_BIT(FLASH->CR2, FLASH_CR2_MER);
;;;193          }
;;;194        }
;;;195        else if (pEraseInit->Banks == FLASH_BANK_2)
;;;196        {
;;;197          /* Mass Erase requested for Bank2 */
;;;198          /* Wait for last operation to be completed */
;;;199          if (FLASH_WaitForLastOperationBank2((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
;;;200          {
;;;201            /*Mass erase to be done*/
;;;202            FLASH_MassErase(FLASH_BANK_2);
;;;203            
;;;204            /* Wait for last operation to be completed */
;;;205            status = FLASH_WaitForLastOperationBank2((uint32_t)FLASH_TIMEOUT_VALUE);
;;;206            
;;;207            /* If the erase operation is completed, disable the MER Bit */
;;;208            CLEAR_BIT(FLASH->CR2, FLASH_CR2_MER);
;;;209          }
;;;210        }
;;;211        else 
;;;212    #endif /* FLASH_BANK2_END */
;;;213        {
;;;214          /* Mass Erase requested for Bank1 */
;;;215          /* Wait for last operation to be completed */
;;;216          if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
;;;217          {
;;;218            /*Mass erase to be done*/
;;;219            FLASH_MassErase(FLASH_BANK_1);
;;;220            
;;;221            /* Wait for last operation to be completed */
;;;222            status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
;;;223            
;;;224            /* If the erase operation is completed, disable the MER Bit */
;;;225            CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
000020  4e20              LDR      r6,|L11.164|
000022  f24c3950          MOV      r9,#0xc350            ;216
000026  2802              CMP      r0,#2                 ;170
000028  d007              BEQ      |L11.58|
;;;226          }
;;;227        }
;;;228      }
;;;229      else
;;;230      {
;;;231        /* Page Erase is requested */
;;;232        /* Check the parameters */
;;;233        assert_param(IS_FLASH_PROGRAM_ADDRESS(pEraseInit->PageAddress));
;;;234        assert_param(IS_FLASH_NB_PAGES(pEraseInit->PageAddress, pEraseInit->NbPages));
;;;235        
;;;236    #if defined(FLASH_BANK2_END)
;;;237        /* Page Erase requested on address located on bank2 */
;;;238        if(pEraseInit->PageAddress > FLASH_BANK1_END)
;;;239        {   
;;;240          /* Wait for last operation to be completed */
;;;241          if (FLASH_WaitForLastOperationBank2((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
;;;242          {
;;;243            /*Initialization of PageError variable*/
;;;244            *PageError = 0xFFFFFFFFU;
;;;245            
;;;246            /* Erase by page by page to be done*/
;;;247            for(address = pEraseInit->PageAddress;
;;;248                address < (pEraseInit->PageAddress + (pEraseInit->NbPages)*FLASH_PAGE_SIZE);
;;;249                address += FLASH_PAGE_SIZE)
;;;250            {
;;;251              FLASH_PageErase(address);
;;;252              
;;;253              /* Wait for last operation to be completed */
;;;254              status = FLASH_WaitForLastOperationBank2((uint32_t)FLASH_TIMEOUT_VALUE);
;;;255              
;;;256              /* If the erase operation is completed, disable the PER Bit */
;;;257              CLEAR_BIT(FLASH->CR2, FLASH_CR2_PER);
;;;258              
;;;259              if (status != HAL_OK)
;;;260              {
;;;261                /* In case of error, stop erase procedure and return the faulty address */
;;;262                *PageError = address;
;;;263                break;
;;;264              }
;;;265            }
;;;266          }
;;;267        }
;;;268        else
;;;269    #endif /* FLASH_BANK2_END */
;;;270       {
;;;271          /* Page Erase requested on address located on bank1 */
;;;272          /* Wait for last operation to be completed */
;;;273          if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
00002a  4648              MOV      r0,r9
00002c  f7fffffe          BL       FLASH_WaitForLastOperation
000030  b198              CBZ      r0,|L11.90|
000032  e02f              B        |L11.148|
                  |L11.52|
000034  2002              MOVS     r0,#2                 ;165
                  |L11.54|
;;;274          {
;;;275            /*Initialization of PageError variable*/
;;;276            *PageError = 0xFFFFFFFFU;
;;;277            
;;;278            /* Erase page by page to be done*/
;;;279            for(address = pEraseInit->PageAddress;
;;;280                address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
;;;281                address += FLASH_PAGE_SIZE)
;;;282            {
;;;283              FLASH_PageErase(address);
;;;284              
;;;285              /* Wait for last operation to be completed */
;;;286              status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
;;;287              
;;;288              /* If the erase operation is completed, disable the PER Bit */
;;;289              CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
;;;290              
;;;291              if (status != HAL_OK)
;;;292              {
;;;293                /* In case of error, stop erase procedure and return the faulty address */
;;;294                *PageError = address;
;;;295                break;
;;;296              }
;;;297            }
;;;298          }
;;;299        }
;;;300      }
;;;301    
;;;302      /* Process Unlocked */
;;;303      __HAL_UNLOCK(&pFlash);
;;;304    
;;;305      return status;
;;;306    }
000036  e8bd87f0          POP      {r4-r10,pc}
                  |L11.58|
00003a  4648              MOV      r0,r9                 ;216
00003c  f7fffffe          BL       FLASH_WaitForLastOperation
000040  b9f8              CBNZ     r0,|L11.130|
000042  2001              MOVS     r0,#1                 ;219
000044  f7fffffe          BL       FLASH_MassErase
000048  4648              MOV      r0,r9                 ;222
00004a  f7fffffe          BL       FLASH_WaitForLastOperation
00004e  4682              MOV      r10,r0                ;222
000050  6930              LDR      r0,[r6,#0x10]         ;225
000052  f0200004          BIC      r0,r0,#4              ;225
000056  6130              STR      r0,[r6,#0x10]         ;225
000058  e01c              B        |L11.148|
                  |L11.90|
00005a  f04f30ff          MOV      r0,#0xffffffff        ;276
00005e  6038              STR      r0,[r7,#0]            ;276
000060  68ac              LDR      r4,[r5,#8]            ;279
000062  e011              B        |L11.136|
                  |L11.100|
000064  4620              MOV      r0,r4                 ;283
000066  f7fffffe          BL       FLASH_PageErase
00006a  4648              MOV      r0,r9                 ;286
00006c  f7fffffe          BL       FLASH_WaitForLastOperation
000070  4682              MOV      r10,r0                ;286
000072  6930              LDR      r0,[r6,#0x10]         ;289
000074  f0200002          BIC      r0,r0,#2              ;289
000078  6130              STR      r0,[r6,#0x10]         ;289
00007a  ea5f000a          MOVS     r0,r10                ;291
00007e  d001              BEQ      |L11.132|
000080  603c              STR      r4,[r7,#0]            ;294
                  |L11.130|
000082  e007              B        |L11.148|
                  |L11.132|
000084  f5046400          ADD      r4,r4,#0x800          ;281
                  |L11.136|
000088  e9d50102          LDRD     r0,r1,[r5,#8]         ;280
00008c  eb0020c1          ADD      r0,r0,r1,LSL #11      ;280
000090  42a0              CMP      r0,r4                 ;280
000092  d8e7              BHI      |L11.100|
                  |L11.148|
000094  2000              MOVS     r0,#0                 ;303
000096  f8880018          STRB     r0,[r8,#0x18]         ;303
00009a  4650              MOV      r0,r10                ;305
00009c  e7cb              B        |L11.54|
;;;307    
                          ENDP

00009e  0000              DCW      0x0000
                  |L11.160|
                          DCD      pFlash
                  |L11.164|
                          DCD      0x40022000

                          AREA ||i.HAL_FLASHEx_Erase_IT||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_Erase_IT PROC
;;;318      */
;;;319    HAL_StatusTypeDef HAL_FLASHEx_Erase_IT(FLASH_EraseInitTypeDef *pEraseInit)
000000  b570              PUSH     {r4-r6,lr}
;;;320    {
;;;321      HAL_StatusTypeDef status = HAL_OK;
000002  2400              MOVS     r4,#0
;;;322    
;;;323      /* Process Locked */
;;;324      __HAL_LOCK(&pFlash);
000004  4911              LDR      r1,|L12.76|
000006  7e0a              LDRB     r2,[r1,#0x18]  ; pFlash
000008  2a01              CMP      r2,#1
00000a  d005              BEQ      |L12.24|
00000c  2201              MOVS     r2,#1
00000e  760a              STRB     r2,[r1,#0x18]
;;;325    
;;;326      /* If procedure already ongoing, reject the next one */
;;;327      if (pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
000010  780b              LDRB     r3,[r1,#0]  ; pFlash
000012  b11b              CBZ      r3,|L12.28|
;;;328      {
;;;329        return HAL_ERROR;
000014  2001              MOVS     r0,#1
;;;330      }
;;;331      
;;;332      /* Check the parameters */
;;;333      assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
;;;334    
;;;335      /* Enable End of FLASH Operation and Error source interrupts */
;;;336      __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
;;;337    
;;;338    #if defined(FLASH_BANK2_END)
;;;339      /* Enable End of FLASH Operation and Error source interrupts */
;;;340      __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP_BANK2 | FLASH_IT_ERR_BANK2);
;;;341      
;;;342    #endif
;;;343      if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
;;;344      {
;;;345        /*Mass erase to be done*/
;;;346        pFlash.ProcedureOnGoing = FLASH_PROC_MASSERASE;
;;;347            FLASH_MassErase(pEraseInit->Banks);
;;;348      }
;;;349      else
;;;350      {
;;;351        /* Erase by page to be done*/
;;;352    
;;;353        /* Check the parameters */
;;;354        assert_param(IS_FLASH_PROGRAM_ADDRESS(pEraseInit->PageAddress));
;;;355        assert_param(IS_FLASH_NB_PAGES(pEraseInit->PageAddress, pEraseInit->NbPages));
;;;356    
;;;357        pFlash.ProcedureOnGoing = FLASH_PROC_PAGEERASE;
;;;358        pFlash.DataRemaining = pEraseInit->NbPages;
;;;359        pFlash.Address = pEraseInit->PageAddress;
;;;360    
;;;361        /*Erase 1st page and wait for IT*/
;;;362        FLASH_PageErase(pEraseInit->PageAddress);
;;;363      }
;;;364    
;;;365      return status;
;;;366    }
000016  bd70              POP      {r4-r6,pc}
                  |L12.24|
000018  2002              MOVS     r0,#2                 ;324
00001a  bd70              POP      {r4-r6,pc}
                  |L12.28|
00001c  4b0c              LDR      r3,|L12.80|
00001e  691d              LDR      r5,[r3,#0x10]         ;336
000020  f44555a0          ORR      r5,r5,#0x1400         ;336
000024  611d              STR      r5,[r3,#0x10]         ;336
000026  6803              LDR      r3,[r0,#0]            ;343
000028  2b02              CMP      r3,#2                 ;343
00002a  d009              BEQ      |L12.64|
00002c  700a              STRB     r2,[r1,#0]            ;357
00002e  68c2              LDR      r2,[r0,#0xc]          ;358
000030  604a              STR      r2,[r1,#4]            ;358  ; pFlash
000032  6882              LDR      r2,[r0,#8]            ;359
000034  608a              STR      r2,[r1,#8]            ;359  ; pFlash
000036  6880              LDR      r0,[r0,#8]            ;362
000038  f7fffffe          BL       FLASH_PageErase
                  |L12.60|
00003c  4620              MOV      r0,r4                 ;365
00003e  bd70              POP      {r4-r6,pc}
                  |L12.64|
000040  2202              MOVS     r2,#2                 ;346
000042  700a              STRB     r2,[r1,#0]            ;346
000044  6840              LDR      r0,[r0,#4]            ;347
000046  f7fffffe          BL       FLASH_MassErase
00004a  e7f7              B        |L12.60|
;;;367    
                          ENDP

                  |L12.76|
                          DCD      pFlash
                  |L12.80|
                          DCD      0x40022000

                          AREA ||i.HAL_FLASHEx_OBErase||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_OBErase PROC
;;;396    
;;;397    HAL_StatusTypeDef HAL_FLASHEx_OBErase(void)
000000  b570              PUSH     {r4-r6,lr}
;;;398    {
;;;399      uint8_t rdptmp = OB_RDP_LEVEL_0;
;;;400      HAL_StatusTypeDef status = HAL_ERROR;
;;;401    
;;;402      /* Get the actual read protection Option Byte value */
;;;403      rdptmp = FLASH_OB_GetRDP();
000002  f7fffffe          BL       FLASH_OB_GetRDP
000006  b2c5              UXTB     r5,r0
;;;404    
;;;405      /* Wait for last operation to be completed */
;;;406      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
000008  f24c3650          MOV      r6,#0xc350
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;407    
;;;408      if(status == HAL_OK)
000012  2800              CMP      r0,#0
000014  d118              BNE      |L13.72|
;;;409      {
;;;410        /* Clean the error context */
;;;411        pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
000016  490d              LDR      r1,|L13.76|
000018  61c8              STR      r0,[r1,#0x1c]  ; pFlash
;;;412    
;;;413        /* If the previous operation is completed, proceed to erase the option bytes */
;;;414        SET_BIT(FLASH->CR, FLASH_CR_OPTER);
00001a  4c0d              LDR      r4,|L13.80|
00001c  6920              LDR      r0,[r4,#0x10]
00001e  f0400020          ORR      r0,r0,#0x20
000022  6120              STR      r0,[r4,#0x10]
;;;415        SET_BIT(FLASH->CR, FLASH_CR_STRT);
000024  6920              LDR      r0,[r4,#0x10]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6120              STR      r0,[r4,#0x10]
;;;416    
;;;417        /* Wait for last operation to be completed */
;;;418        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;419    
;;;420        /* If the erase operation is completed, disable the OPTER Bit */
;;;421        CLEAR_BIT(FLASH->CR, FLASH_CR_OPTER);
000032  6921              LDR      r1,[r4,#0x10]
000034  f0210120          BIC      r1,r1,#0x20
000038  6121              STR      r1,[r4,#0x10]
;;;422    
;;;423        if(status == HAL_OK)
00003a  2800              CMP      r0,#0
00003c  d104              BNE      |L13.72|
;;;424        {
;;;425          /* Restore the last read protection Option Byte value */
;;;426          status = FLASH_OB_RDP_LevelConfig(rdptmp);
00003e  4628              MOV      r0,r5
000040  e8bd4070          POP      {r4-r6,lr}
000044  f7ffbffe          B.W      FLASH_OB_RDP_LevelConfig
                  |L13.72|
;;;427        }
;;;428      }
;;;429    
;;;430      /* Return the erase status */
;;;431      return status;
;;;432    }
000048  bd70              POP      {r4-r6,pc}
;;;433    
                          ENDP

00004a  0000              DCW      0x0000
                  |L13.76|
                          DCD      pFlash
                  |L13.80|
                          DCD      0x40022000

                          AREA ||i.HAL_FLASHEx_OBGetConfig||, CODE, READONLY, ALIGN=1

                  HAL_FLASHEx_OBGetConfig PROC
;;;526      */
;;;527    void HAL_FLASHEx_OBGetConfig(FLASH_OBProgramInitTypeDef *pOBInit)
000000  b510              PUSH     {r4,lr}
;;;528    {
000002  4604              MOV      r4,r0
;;;529      pOBInit->OptionType = OPTIONBYTE_WRP | OPTIONBYTE_RDP | OPTIONBYTE_USER;
000004  2007              MOVS     r0,#7
000006  6020              STR      r0,[r4,#0]
;;;530    
;;;531      /*Get WRP*/
;;;532      pOBInit->WRPPage = FLASH_OB_GetWRP();
000008  f7fffffe          BL       FLASH_OB_GetWRP
00000c  60a0              STR      r0,[r4,#8]
;;;533    
;;;534      /*Get RDP Level*/
;;;535      pOBInit->RDPLevel = FLASH_OB_GetRDP();
00000e  f7fffffe          BL       FLASH_OB_GetRDP
000012  7420              STRB     r0,[r4,#0x10]
;;;536    
;;;537      /*Get USER*/
;;;538      pOBInit->USERConfig = FLASH_OB_GetUser();
000014  f7fffffe          BL       FLASH_OB_GetUser
000018  7460              STRB     r0,[r4,#0x11]
;;;539    }
00001a  bd10              POP      {r4,pc}
;;;540    
                          ENDP


                          AREA ||i.HAL_FLASHEx_OBGetUserData||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_OBGetUserData PROC
;;;548      */
;;;549    uint32_t HAL_FLASHEx_OBGetUserData(uint32_t DATAAdress)
000000  4a05              LDR      r2,|L15.24|
;;;550    {
;;;551      uint32_t value = 0;
;;;552      
;;;553      if (DATAAdress == OB_DATA_ADDRESS_DATA0)
;;;554      {
;;;555        /* Get value programmed in OB USER Data0 */
;;;556        value = READ_BIT(FLASH->OBR, FLASH_OBR_DATA0) >> FLASH_POSITION_OB_USERDATA0_BIT;
000002  4906              LDR      r1,|L15.28|
000004  4290              CMP      r0,r2                 ;553
000006  d103              BNE      |L15.16|
000008  69c8              LDR      r0,[r1,#0x1c]
00000a  f3c02087          UBFX     r0,r0,#10,#8
;;;557      }
;;;558      else
;;;559      {
;;;560        /* Get value programmed in OB USER Data1 */
;;;561        value = READ_BIT(FLASH->OBR, FLASH_OBR_DATA1) >> FLASH_POSITION_OB_USERDATA1_BIT;
;;;562      }
;;;563      
;;;564      return value;
;;;565    }
00000e  4770              BX       lr
                  |L15.16|
000010  69c8              LDR      r0,[r1,#0x1c]         ;561
000012  f3c04087          UBFX     r0,r0,#18,#8          ;561
000016  4770              BX       lr
;;;566    
                          ENDP

                  |L15.24|
                          DCD      0x1ffff804
                  |L15.28|
                          DCD      0x40022000

                          AREA ||i.HAL_FLASHEx_OBProgram||, CODE, READONLY, ALIGN=2

                  HAL_FLASHEx_OBProgram PROC
;;;445      */
;;;446    HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
000000  b570              PUSH     {r4-r6,lr}
;;;447    {
000002  4604              MOV      r4,r0
;;;448      HAL_StatusTypeDef status = HAL_ERROR;
000004  2001              MOVS     r0,#1
;;;449    
;;;450      /* Process Locked */
;;;451      __HAL_LOCK(&pFlash);
000006  4d1c              LDR      r5,|L16.120|
000008  7e29              LDRB     r1,[r5,#0x18]  ; pFlash
00000a  2901              CMP      r1,#1
00000c  d00f              BEQ      |L16.46|
00000e  2101              MOVS     r1,#1
000010  7629              STRB     r1,[r5,#0x18]
;;;452    
;;;453      /* Check the parameters */
;;;454      assert_param(IS_OPTIONBYTE(pOBInit->OptionType));
;;;455    
;;;456      /* Write protection configuration */
;;;457      if((pOBInit->OptionType & OPTIONBYTE_WRP) == OPTIONBYTE_WRP)
000012  7821              LDRB     r1,[r4,#0]
000014  f04f0600          MOV      r6,#0
000018  07c9              LSLS     r1,r1,#31
00001a  d00e              BEQ      |L16.58|
;;;458      {
;;;459        assert_param(IS_WRPSTATE(pOBInit->WRPState));
;;;460        if (pOBInit->WRPState == OB_WRPSTATE_ENABLE)
00001c  6860              LDR      r0,[r4,#4]
00001e  2801              CMP      r0,#1
000020  d007              BEQ      |L16.50|
;;;461        {
;;;462          /* Enable of Write protection on the selected page */
;;;463          status = FLASH_OB_EnableWRP(pOBInit->WRPPage);
;;;464        }
;;;465        else
;;;466        {
;;;467          /* Disable of Write protection on the selected page */
;;;468          status = FLASH_OB_DisableWRP(pOBInit->WRPPage);
000022  68a0              LDR      r0,[r4,#8]
000024  f7fffffe          BL       FLASH_OB_DisableWRP
                  |L16.40|
;;;469        }
;;;470        if (status != HAL_OK)
000028  b138              CBZ      r0,|L16.58|
;;;471        {
;;;472          /* Process Unlocked */
;;;473          __HAL_UNLOCK(&pFlash);
00002a  762e              STRB     r6,[r5,#0x18]
;;;474          return status;
;;;475        }
;;;476      }
;;;477    
;;;478      /* Read protection configuration */
;;;479      if((pOBInit->OptionType & OPTIONBYTE_RDP) == OPTIONBYTE_RDP)
;;;480      {
;;;481        status = FLASH_OB_RDP_LevelConfig(pOBInit->RDPLevel);
;;;482        if (status != HAL_OK)
;;;483        {
;;;484          /* Process Unlocked */
;;;485          __HAL_UNLOCK(&pFlash);
;;;486          return status;
;;;487        }
;;;488      }
;;;489    
;;;490      /* USER configuration */
;;;491      if((pOBInit->OptionType & OPTIONBYTE_USER) == OPTIONBYTE_USER)
;;;492      {
;;;493        status = FLASH_OB_UserConfig(pOBInit->USERConfig);
;;;494        if (status != HAL_OK)
;;;495        {
;;;496          /* Process Unlocked */
;;;497          __HAL_UNLOCK(&pFlash);
;;;498          return status;
;;;499        }
;;;500      }
;;;501    
;;;502      /* DATA configuration*/
;;;503      if((pOBInit->OptionType & OPTIONBYTE_DATA) == OPTIONBYTE_DATA)
;;;504      {
;;;505        status = FLASH_OB_ProgramData(pOBInit->DATAAddress, pOBInit->DATAData);
;;;506        if (status != HAL_OK)
;;;507        {
;;;508          /* Process Unlocked */
;;;509          __HAL_UNLOCK(&pFlash);
;;;510          return status;
;;;511        }
;;;512      }
;;;513    
;;;514      /* Process Unlocked */
;;;515      __HAL_UNLOCK(&pFlash);
;;;516    
;;;517      return status;
;;;518    }
00002c  bd70              POP      {r4-r6,pc}
                  |L16.46|
00002e  2002              MOVS     r0,#2                 ;451
000030  bd70              POP      {r4-r6,pc}
                  |L16.50|
000032  68a0              LDR      r0,[r4,#8]            ;463
000034  f7fffffe          BL       FLASH_OB_EnableWRP
000038  e7f6              B        |L16.40|
                  |L16.58|
00003a  7821              LDRB     r1,[r4,#0]            ;479
00003c  0789              LSLS     r1,r1,#30             ;479
00003e  d505              BPL      |L16.76|
000040  7c20              LDRB     r0,[r4,#0x10]         ;481
000042  f7fffffe          BL       FLASH_OB_RDP_LevelConfig
000046  b108              CBZ      r0,|L16.76|
000048  762e              STRB     r6,[r5,#0x18]         ;485
00004a  bd70              POP      {r4-r6,pc}
                  |L16.76|
00004c  7821              LDRB     r1,[r4,#0]            ;491
00004e  0749              LSLS     r1,r1,#29             ;491
000050  d505              BPL      |L16.94|
000052  7c60              LDRB     r0,[r4,#0x11]         ;493
000054  f7fffffe          BL       FLASH_OB_UserConfig
000058  b108              CBZ      r0,|L16.94|
00005a  762e              STRB     r6,[r5,#0x18]         ;497
00005c  bd70              POP      {r4-r6,pc}
                  |L16.94|
00005e  7821              LDRB     r1,[r4,#0]            ;503
000060  0709              LSLS     r1,r1,#28             ;503
000062  d506              BPL      |L16.114|
000064  7e21              LDRB     r1,[r4,#0x18]         ;505
000066  6960              LDR      r0,[r4,#0x14]         ;505
000068  f7fffffe          BL       FLASH_OB_ProgramData
00006c  b108              CBZ      r0,|L16.114|
00006e  762e              STRB     r6,[r5,#0x18]         ;509
000070  bd70              POP      {r4-r6,pc}
                  |L16.114|
000072  762e              STRB     r6,[r5,#0x18]         ;515
000074  bd70              POP      {r4-r6,pc}
;;;519    
                          ENDP

000076  0000              DCW      0x0000
                  |L16.120|
                          DCD      pFlash

;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_flash_ex.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_stm32f1xx_hal_flash_ex_c_6648b60e____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___24_stm32f1xx_hal_flash_ex_c_6648b60e____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_stm32f1xx_hal_flash_ex_c_6648b60e____REVSH|
#line 478
|__asm___24_stm32f1xx_hal_flash_ex_c_6648b60e____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_stm32f1xx_hal_flash_ex_c_6648b60e____RRX|
#line 665
|__asm___24_stm32f1xx_hal_flash_ex_c_6648b60e____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
