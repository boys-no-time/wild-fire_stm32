; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\tcp_out.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\tcp_out.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\system\arch -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Inc -I..\Middlewares\Third_Party\LwIP\src\include -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\tcp_out.crf ..\Middlewares\Third_Party\LwIP\src\core\tcp_out.c]
                          THUMB

                          AREA ||i.tcp_create_segment||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_create_segment PROC
;;;172    static struct tcp_seg *
;;;173    tcp_create_segment(struct tcp_pcb *pcb, struct pbuf *p, u8_t flags, u32_t seqno, u8_t optflags)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;174    {
000004  f8dd8020          LDR      r8,[sp,#0x20]
000008  4607              MOV      r7,r0
00000a  460e              MOV      r6,r1
00000c  4691              MOV      r9,r2
00000e  469a              MOV      r10,r3
;;;175      struct tcp_seg *seg;
;;;176      u8_t optlen = LWIP_TCP_OPT_LENGTH(optflags);
000010  ea5f70c8          LSLS     r0,r8,#31
000014  d001              BEQ      |L1.26|
000016  2504              MOVS     r5,#4
000018  e000              B        |L1.28|
                  |L1.26|
00001a  2500              MOVS     r5,#0
                  |L1.28|
;;;177    
;;;178      if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
00001c  2003              MOVS     r0,#3
00001e  f7fffffe          BL       memp_malloc
000022  1e04              SUBS     r4,r0,#0
000024  d01d              BEQ      |L1.98|
;;;179        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no memory.\n"));
;;;180        pbuf_free(p);
;;;181        return NULL;
;;;182      }
;;;183      seg->flags = optflags;
000026  f884800a          STRB     r8,[r4,#0xa]
;;;184      seg->next = NULL;
00002a  f04f0800          MOV      r8,#0
00002e  f8c48000          STR      r8,[r4,#0]
;;;185      seg->p = p;
000032  6066              STR      r6,[r4,#4]
;;;186      LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
000034  8930              LDRH     r0,[r6,#8]
000036  42a8              CMP      r0,r5
000038  d205              BCS      |L1.70|
00003a  a31e              ADR      r3,|L1.180|
00003c  22ba              MOVS     r2,#0xba
00003e  a12a              ADR      r1,|L1.232|
000040  a02f              ADR      r0,|L1.256|
000042  f7fffffe          BL       __2printf
                  |L1.70|
;;;187      seg->len = p->tot_len - optlen;
000046  8930              LDRH     r0,[r6,#8]
000048  1b40              SUBS     r0,r0,r5
00004a  8120              STRH     r0,[r4,#8]
;;;188    #if TCP_OVERSIZE_DBGCHECK
;;;189      seg->oversize_left = 0;
;;;190    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;191    #if TCP_CHECKSUM_ON_COPY
;;;192      seg->chksum = 0;
;;;193      seg->chksum_swapped = 0;
;;;194      /* check optflags */
;;;195      LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
;;;196                  (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
;;;197    #endif /* TCP_CHECKSUM_ON_COPY */
;;;198    
;;;199      /* build TCP header */
;;;200      if (pbuf_header(p, TCP_HLEN)) {
00004c  2114              MOVS     r1,#0x14
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       pbuf_header
000054  b150              CBZ      r0,|L1.108|
;;;201        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
;;;202        TCP_STATS_INC(tcp.err);
;;;203        tcp_seg_free(seg);
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       tcp_seg_free
;;;204        return NULL;
00005c  2000              MOVS     r0,#0
                  |L1.94|
;;;205      }
;;;206      seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
;;;207      seg->tcphdr->src = lwip_htons(pcb->local_port);
;;;208      seg->tcphdr->dest = lwip_htons(pcb->remote_port);
;;;209      seg->tcphdr->seqno = lwip_htonl(seqno);
;;;210      /* ackno is set in tcp_output */
;;;211      TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), flags);
;;;212      /* wnd and chksum are set in tcp_output */
;;;213      seg->tcphdr->urgp = 0;
;;;214      return seg;
;;;215    }
00005e  e8bd87f0          POP      {r4-r10,pc}
                  |L1.98|
000062  4630              MOV      r0,r6                 ;180
000064  f7fffffe          BL       pbuf_free
000068  2000              MOVS     r0,#0                 ;181
00006a  e7f8              B        |L1.94|
                  |L1.108|
00006c  6860              LDR      r0,[r4,#4]            ;206
00006e  6840              LDR      r0,[r0,#4]            ;206
000070  60e0              STR      r0,[r4,#0xc]          ;206
000072  8af8              LDRH     r0,[r7,#0x16]         ;207
000074  f7fffffe          BL       lwip_htons
000078  68e1              LDR      r1,[r4,#0xc]          ;207
00007a  8008              STRH     r0,[r1,#0]            ;207
00007c  8b38              LDRH     r0,[r7,#0x18]         ;208
00007e  f7fffffe          BL       lwip_htons
000082  68e1              LDR      r1,[r4,#0xc]          ;208
000084  8048              STRH     r0,[r1,#2]            ;208
000086  4650              MOV      r0,r10                ;209
000088  f7fffffe          BL       lwip_htonl
00008c  68e1              LDR      r1,[r4,#0xc]          ;209
00008e  6048              STR      r0,[r1,#4]            ;209
000090  2005              MOVS     r0,#5                 ;211
000092  eb000095          ADD      r0,r0,r5,LSR #2       ;211
000096  f64f71ff          MOV      r1,#0xffff            ;211
00009a  ea013000          AND      r0,r1,r0,LSL #12      ;211
00009e  ea400009          ORR      r0,r0,r9              ;211
0000a2  f7fffffe          BL       lwip_htons
0000a6  68e1              LDR      r1,[r4,#0xc]          ;211
0000a8  8188              STRH     r0,[r1,#0xc]          ;211
0000aa  68e0              LDR      r0,[r4,#0xc]          ;213
0000ac  f8a08012          STRH     r8,[r0,#0x12]         ;213
0000b0  4620              MOV      r0,r4                 ;214
0000b2  e7d4              B        |L1.94|
;;;216    
                          ENDP

                  |L1.180|
0000b4  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
0000b8  6964646c
0000bc  65776172
0000c0  65735c54
0000c4  68697264
0000c8  5f506172
0000cc  74795c4c
0000d0  7749505c
0000d4  7372635c
0000d8  636f7265
0000dc  5c746370
0000e0  5f6f7574
0000e4  2e      
0000e5  6300              DCB      "c",0
0000e7  00                DCB      0
                  |L1.232|
0000e8  702d3e74          DCB      "p->tot_len >= optlen",0
0000ec  6f745f6c
0000f0  656e203e
0000f4  3d206f70
0000f8  746c656e
0000fc  00      
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L1.256|
000100  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000104  7274696f
000108  6e202225
00010c  73222066
000110  61696c65
000114  64206174
000118  206c696e
00011c  65202564
000120  20696e20
000124  25730a00

                          AREA ||i.tcp_enqueue_flags||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_enqueue_flags PROC
;;;784    err_t
;;;785    tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;786    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;787      struct pbuf *p;
;;;788      struct tcp_seg *seg;
;;;789      u8_t optflags = 0;
000008  2600              MOVS     r6,#0
;;;790      u8_t optlen = 0;
;;;791    
;;;792      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;793    
;;;794      LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
00000a  07a8              LSLS     r0,r5,#30
00000c  d106              BNE      |L2.28|
00000e  a346              ADR      r3,|L2.296|
000010  f240321a          MOV      r2,#0x31a
000014  4951              LDR      r1,|L2.348|
000016  a052              ADR      r0,|L2.352|
000018  f7fffffe          BL       __2printf
                  |L2.28|
;;;795                  (flags & (TCP_SYN | TCP_FIN)) != 0);
;;;796    
;;;797      /* check for configured max queuelen and possible overflow (FIN flag should always come through!) */
;;;798      if (((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) &&
00001c  f8b40062          LDRH     r0,[r4,#0x62]
;;;799          ((flags & TCP_FIN) == 0)) {
;;;800        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_enqueue_flags: too long queue %"U16_F" (max %"U16_F")\n",
;;;801                                           pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
;;;802        TCP_STATS_INC(tcp.memerr);
;;;803        pcb->flags |= TF_NAGLEMEMERR;
;;;804        return ERR_MEM;
000020  f04f38ff          MOV      r8,#0xffffffff
000024  2809              CMP      r0,#9                 ;798
000026  d301              BCC      |L2.44|
000028  07e8              LSLS     r0,r5,#31             ;799
00002a  d006              BEQ      |L2.58|
                  |L2.44|
;;;805      }
;;;806    
;;;807      if (flags & TCP_SYN) {
00002c  07a8              LSLS     r0,r5,#30
00002e  d500              BPL      |L2.50|
;;;808        optflags = TF_SEG_OPTS_MSS;
000030  2601              MOVS     r6,#1
                  |L2.50|
;;;809    #if LWIP_WND_SCALE
;;;810        if ((pcb->state != SYN_RCVD) || (pcb->flags & TF_WND_SCALE)) {
;;;811          /* In a <SYN,ACK> (sent in state SYN_RCVD), the window scale option may only
;;;812             be sent if we received a window scale option from the remote host. */
;;;813          optflags |= TF_SEG_OPTS_WND_SCALE;
;;;814        }
;;;815    #endif /* LWIP_WND_SCALE */
;;;816      }
;;;817    #if LWIP_TCP_TIMESTAMPS
;;;818      if ((pcb->flags & TF_TIMESTAMP)) {
;;;819        /* Make sure the timestamp option is only included in data segments if we
;;;820           agreed about it with the remote host. */
;;;821        optflags |= TF_SEG_OPTS_TS;
;;;822      }
;;;823    #endif /* LWIP_TCP_TIMESTAMPS */
;;;824      optlen = LWIP_TCP_OPT_LENGTH(optflags);
000032  07f0              LSLS     r0,r6,#31
000034  d008              BEQ      |L2.72|
000036  2704              MOVS     r7,#4
000038  e007              B        |L2.74|
                  |L2.58|
00003a  7ea0              LDRB     r0,[r4,#0x1a]         ;803
00003c  f0400080          ORR      r0,r0,#0x80           ;803
000040  76a0              STRB     r0,[r4,#0x1a]         ;803
000042  4640              MOV      r0,r8                 ;804
                  |L2.68|
;;;825    
;;;826      /* Allocate pbuf with room for TCP header + options */
;;;827      if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;828        pcb->flags |= TF_NAGLEMEMERR;
;;;829        TCP_STATS_INC(tcp.memerr);
;;;830        return ERR_MEM;
;;;831      }
;;;832      LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
;;;833                  (p->len >= optlen));
;;;834    
;;;835      /* Allocate memory for tcp_seg, and fill in fields. */
;;;836      if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
;;;837        pcb->flags |= TF_NAGLEMEMERR;
;;;838        TCP_STATS_INC(tcp.memerr);
;;;839        return ERR_MEM;
;;;840      }
;;;841      LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
;;;842      LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
;;;843    
;;;844      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE,
;;;845                  ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
;;;846                   lwip_ntohl(seg->tcphdr->seqno),
;;;847                   lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
;;;848                   (u16_t)flags));
;;;849    
;;;850      /* Now append seg to pcb->unsent queue */
;;;851      if (pcb->unsent == NULL) {
;;;852        pcb->unsent = seg;
;;;853      } else {
;;;854        struct tcp_seg *useg;
;;;855        for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
;;;856        useg->next = seg;
;;;857      }
;;;858    #if TCP_OVERSIZE
;;;859      /* The new unsent tail has no space */
;;;860      pcb->unsent_oversize = 0;
;;;861    #endif /* TCP_OVERSIZE */
;;;862    
;;;863      /* SYN and FIN bump the sequence number */
;;;864      if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
;;;865        pcb->snd_lbb++;
;;;866        /* optlen does not influence snd_buf */
;;;867      }
;;;868      if (flags & TCP_FIN) {
;;;869        pcb->flags |= TF_FIN;
;;;870      }
;;;871    
;;;872      /* update number of segments on the queues */
;;;873      pcb->snd_queuelen += pbuf_clen(seg->p);
;;;874      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
;;;875      if (pcb->snd_queuelen != 0) {
;;;876        LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
;;;877          pcb->unacked != NULL || pcb->unsent != NULL);
;;;878      }
;;;879    
;;;880      return ERR_OK;
;;;881    }
000044  e8bd83f8          POP      {r3-r9,pc}
                  |L2.72|
000048  2700              MOVS     r7,#0                 ;824
                  |L2.74|
00004a  2200              MOVS     r2,#0                 ;827
00004c  4639              MOV      r1,r7                 ;827
00004e  4610              MOV      r0,r2                 ;827
000050  f7fffffe          BL       pbuf_alloc
000054  f1b00900          SUBS     r9,r0,#0              ;827
000058  d02a              BEQ      |L2.176|
00005a  f8b9000a          LDRH     r0,[r9,#0xa]          ;832
00005e  42b8              CMP      r0,r7                 ;832
000060  d206              BCS      |L2.112|
000062  a331              ADR      r3,|L2.296|
000064  f44f7250          MOV      r2,#0x340             ;832
000068  a147              ADR      r1,|L2.392|
00006a  a03d              ADR      r0,|L2.352|
00006c  f7fffffe          BL       __2printf
                  |L2.112|
000070  9600              STR      r6,[sp,#0]            ;836
000072  462a              MOV      r2,r5                 ;836
000074  4649              MOV      r1,r9                 ;836
000076  4620              MOV      r0,r4                 ;836
000078  6da3              LDR      r3,[r4,#0x58]         ;836
00007a  f7fffffe          BL       tcp_create_segment
00007e  1e06              SUBS     r6,r0,#0              ;836
000080  d01c              BEQ      |L2.188|
000082  7b30              LDRB     r0,[r6,#0xc]          ;841
000084  0780              LSLS     r0,r0,#30             ;841
000086  d006              BEQ      |L2.150|
000088  a327              ADR      r3,|L2.296|
00008a  f2403249          MOV      r2,#0x349             ;841
00008e  a14d              ADR      r1,|L2.452|
000090  a033              ADR      r0,|L2.352|
000092  f7fffffe          BL       __2printf
                  |L2.150|
000096  8930              LDRH     r0,[r6,#8]            ;842
000098  2800              CMP      r0,#0                 ;842
00009a  d006              BEQ      |L2.170|
00009c  a322              ADR      r3,|L2.296|
00009e  f240324a          MOV      r2,#0x34a             ;842
0000a2  a14e              ADR      r1,|L2.476|
0000a4  a02e              ADR      r0,|L2.352|
0000a6  f7fffffe          BL       __2printf
                  |L2.170|
0000aa  6ea0              LDR      r0,[r4,#0x68]         ;851
0000ac  b160              CBZ      r0,|L2.200|
0000ae  e00e              B        |L2.206|
                  |L2.176|
0000b0  7ea0              LDRB     r0,[r4,#0x1a]         ;828
0000b2  f0400080          ORR      r0,r0,#0x80           ;828
0000b6  76a0              STRB     r0,[r4,#0x1a]         ;828
0000b8  4640              MOV      r0,r8                 ;830
0000ba  e7c3              B        |L2.68|
                  |L2.188|
0000bc  7ea0              LDRB     r0,[r4,#0x1a]         ;837
0000be  f0400080          ORR      r0,r0,#0x80           ;837
0000c2  76a0              STRB     r0,[r4,#0x1a]         ;837
0000c4  4640              MOV      r0,r8                 ;839
0000c6  e7bd              B        |L2.68|
                  |L2.200|
0000c8  66a6              STR      r6,[r4,#0x68]         ;852
0000ca  e004              B        |L2.214|
                  |L2.204|
0000cc  4608              MOV      r0,r1                 ;855
                  |L2.206|
0000ce  6801              LDR      r1,[r0,#0]            ;855
0000d0  2900              CMP      r1,#0                 ;855
0000d2  d1fb              BNE      |L2.204|
0000d4  6006              STR      r6,[r0,#0]            ;856
                  |L2.214|
0000d6  2000              MOVS     r0,#0                 ;860
0000d8  f8a40064          STRH     r0,[r4,#0x64]         ;860
0000dc  f0050002          AND      r0,r5,#2              ;864
0000e0  f0050101          AND      r1,r5,#1              ;864
0000e4  4308              ORRS     r0,r0,r1              ;864
0000e6  d002              BEQ      |L2.238|
0000e8  6da0              LDR      r0,[r4,#0x58]         ;865
0000ea  1c40              ADDS     r0,r0,#1              ;865
0000ec  65a0              STR      r0,[r4,#0x58]         ;865
                  |L2.238|
0000ee  07e8              LSLS     r0,r5,#31             ;868
0000f0  d003              BEQ      |L2.250|
0000f2  7ea0              LDRB     r0,[r4,#0x1a]         ;869
0000f4  f0400020          ORR      r0,r0,#0x20           ;869
0000f8  76a0              STRB     r0,[r4,#0x1a]         ;869
                  |L2.250|
0000fa  6870              LDR      r0,[r6,#4]            ;873
0000fc  f7fffffe          BL       pbuf_clen
000100  f8b41062          LDRH     r1,[r4,#0x62]         ;873
000104  4408              ADD      r0,r0,r1              ;873
000106  b280              UXTH     r0,r0                 ;873
000108  f8a40062          STRH     r0,[r4,#0x62]         ;873
00010c  b150              CBZ      r0,|L2.292|
00010e  6ee0              LDR      r0,[r4,#0x6c]         ;876
000110  b940              CBNZ     r0,|L2.292|
000112  6ea0              LDR      r0,[r4,#0x68]         ;876
000114  b930              CBNZ     r0,|L2.292|
000116  a304              ADR      r3,|L2.296|
000118  f44f725b          MOV      r2,#0x36c             ;876
00011c  a13a              ADR      r1,|L2.520|
00011e  a010              ADR      r0,|L2.352|
000120  f7fffffe          BL       __2printf
                  |L2.292|
000124  2000              MOVS     r0,#0                 ;880
000126  e78d              B        |L2.68|
;;;882    
                          ENDP

                  |L2.296|
000128  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
00012c  6964646c
000130  65776172
000134  65735c54
000138  68697264
00013c  5f506172
000140  74795c4c
000144  7749505c
000148  7372635c
00014c  636f7265
000150  5c746370
000154  5f6f7574
000158  2e      
000159  6300              DCB      "c",0
00015b  00                DCB      0
                  |L2.348|
                          DCD      ||.conststring||
                  |L2.352|
000160  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000164  7274696f
000168  6e202225
00016c  73222066
000170  61696c65
000174  64206174
000178  206c696e
00017c  65202564
000180  20696e20
000184  25730a00
                  |L2.392|
000188  7463705f          DCB      "tcp_enqueue_flags: check that first pbuf can hold optle"
00018c  656e7175
000190  6575655f
000194  666c6167
000198  733a2063
00019c  6865636b
0001a0  20746861
0001a4  74206669
0001a8  72737420
0001ac  70627566
0001b0  2063616e
0001b4  20686f6c
0001b8  64206f70
0001bc  746c65  
0001bf  6e00              DCB      "n",0
0001c1  00                DCB      0
0001c2  00                DCB      0
0001c3  00                DCB      0
                  |L2.452|
0001c4  7365672d          DCB      "seg->tcphdr not aligned",0
0001c8  3e746370
0001cc  68647220
0001d0  6e6f7420
0001d4  616c6967
0001d8  6e656400
                  |L2.476|
0001dc  7463705f          DCB      "tcp_enqueue_flags: invalid segment length",0
0001e0  656e7175
0001e4  6575655f
0001e8  666c6167
0001ec  733a2069
0001f0  6e76616c
0001f4  69642073
0001f8  65676d65
0001fc  6e74206c
000200  656e6774
000204  6800    
000206  00                DCB      0
000207  00                DCB      0
                  |L2.520|
000208  7463705f          DCB      "tcp_enqueue_flags: invalid queue length",0
00020c  656e7175
000210  6575655f
000214  666c6167
000218  733a2069
00021c  6e76616c
000220  69642071
000224  75657565
000228  206c656e
00022c  67746800

                          AREA ||i.tcp_keepalive||, CODE, READONLY, ALIGN=1

                  tcp_keepalive PROC
;;;1531   err_t
;;;1532   tcp_keepalive(struct tcp_pcb *pcb)
000000  b53e              PUSH     {r1-r5,lr}
;;;1533   {
000002  4604              MOV      r4,r0
;;;1534     err_t err;
;;;1535     struct pbuf *p;
;;;1536     struct netif *netif;
;;;1537   
;;;1538     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to "));
;;;1539     ip_addr_debug_print(TCP_DEBUG, &pcb->remote_ip);
;;;1540     LWIP_DEBUGF(TCP_DEBUG, ("\n"));
;;;1541   
;;;1542     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
;;;1543                             tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));
;;;1544   
;;;1545     p = tcp_output_alloc_header(pcb, 0, 0, lwip_htonl(pcb->snd_nxt - 1));
000004  6ce0              LDR      r0,[r4,#0x4c]
000006  1e40              SUBS     r0,r0,#1
000008  f7fffffe          BL       lwip_htonl
00000c  4603              MOV      r3,r0
00000e  2200              MOVS     r2,#0
000010  4611              MOV      r1,r2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       tcp_output_alloc_header
000018  4605              MOV      r5,r0
;;;1546     if (p == NULL) {
00001a  b1a5              CBZ      r5,|L3.70|
;;;1547       LWIP_DEBUGF(TCP_DEBUG,
;;;1548                   ("tcp_keepalive: could not allocate memory for pbuf\n"));
;;;1549       return ERR_MEM;
;;;1550     }
;;;1551     netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
00001c  1d20              ADDS     r0,r4,#4
00001e  f7fffffe          BL       ip4_route
;;;1552     if (netif == NULL) {
000022  b198              CBZ      r0,|L3.76|
;;;1553       err = ERR_RTE;
;;;1554     } else {
;;;1555   #if CHECKSUM_GEN_TCP
;;;1556       IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
;;;1557         struct tcp_hdr *tcphdr = (struct tcp_hdr *)p->payload;
;;;1558         tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
;;;1559           &pcb->local_ip, &pcb->remote_ip);
;;;1560       }
;;;1561   #endif /* CHECKSUM_GEN_TCP */
;;;1562       TCP_STATS_INC(tcp.xmit);
;;;1563   
;;;1564       /* Send output to IP */
;;;1565       NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
;;;1566       err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP, netif);
000024  2106              MOVS     r1,#6
000026  2200              MOVS     r2,#0
000028  e9cd2100          STRD     r2,r1,[sp,#0]
00002c  9002              STR      r0,[sp,#8]
00002e  7aa3              LDRB     r3,[r4,#0xa]
000030  1d22              ADDS     r2,r4,#4
000032  4621              MOV      r1,r4
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       ip4_output_if
00003a  4604              MOV      r4,r0
                  |L3.60|
;;;1567       NETIF_SET_HWADDRHINT(netif, NULL);
;;;1568     }
;;;1569     pbuf_free(p);
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       pbuf_free
;;;1570   
;;;1571     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
;;;1572                             pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
;;;1573     return err;
000042  4620              MOV      r0,r4
;;;1574   }
000044  bd3e              POP      {r1-r5,pc}
                  |L3.70|
000046  f04f30ff          MOV      r0,#0xffffffff        ;1549
00004a  bd3e              POP      {r1-r5,pc}
                  |L3.76|
00004c  f06f0403          MVN      r4,#3                 ;1553
000050  e7f4              B        |L3.60|
;;;1575   
                          ENDP


                          AREA ||i.tcp_output||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_output PROC
;;;992    err_t
;;;993    tcp_output(struct tcp_pcb *pcb)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;994    {
000004  4604              MOV      r4,r0
;;;995      struct tcp_seg *seg, *useg;
;;;996      u32_t wnd, snd_nxt;
;;;997      err_t err;
;;;998      struct netif *netif;
;;;999    #if TCP_CWND_DEBUG
;;;1000     s16_t i = 0;
;;;1001   #endif /* TCP_CWND_DEBUG */
;;;1002   
;;;1003     /* pcb->state LISTEN not allowed here */
;;;1004     LWIP_ASSERT("don't call tcp_output for listen-pcbs",
000006  7d20              LDRB     r0,[r4,#0x14]
000008  2801              CMP      r0,#1
00000a  d106              BNE      |L4.26|
00000c  a388              ADR      r3,|L4.560|
00000e  f44f727b          MOV      r2,#0x3ec
000012  a194              ADR      r1,|L4.612|
000014  a09d              ADR      r0,|L4.652|
000016  f7fffffe          BL       __2printf
                  |L4.26|
;;;1005       pcb->state != LISTEN);
;;;1006   
;;;1007     /* First, check if we are invoked by the TCP input processing
;;;1008        code. If so, we do not output anything. Instead, we rely on the
;;;1009        input processing code to call us when input processing is done
;;;1010        with. */
;;;1011     if (tcp_input_pcb == pcb) {
00001a  48a6              LDR      r0,|L4.692|
00001c  6800              LDR      r0,[r0,#0]  ; tcp_input_pcb
00001e  42a0              CMP      r0,r4
000020  d102              BNE      |L4.40|
;;;1012       return ERR_OK;
000022  2000              MOVS     r0,#0
                  |L4.36|
;;;1013     }
;;;1014   
;;;1015     wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
;;;1016   
;;;1017     seg = pcb->unsent;
;;;1018   
;;;1019     /* If the TF_ACK_NOW flag is set and no data will be sent (either
;;;1020      * because the ->unsent queue is empty or because the window does
;;;1021      * not allow it), construct an empty ACK segment and send it.
;;;1022      *
;;;1023      * If data is to be sent, we will just piggyback the ACK (see below).
;;;1024      */
;;;1025     if (pcb->flags & TF_ACK_NOW &&
;;;1026        (seg == NULL ||
;;;1027         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
;;;1028        return tcp_send_empty_ack(pcb);
;;;1029     }
;;;1030   
;;;1031     /* useg should point to last segment on unacked queue */
;;;1032     useg = pcb->unacked;
;;;1033     if (useg != NULL) {
;;;1034       for (; useg->next != NULL; useg = useg->next);
;;;1035     }
;;;1036   
;;;1037     netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
;;;1038     if (netif == NULL) {
;;;1039       return ERR_RTE;
;;;1040     }
;;;1041   
;;;1042     /* If we don't have a local IP address, we get one from netif */
;;;1043     if (ip_addr_isany(&pcb->local_ip)) {
;;;1044       const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, &pcb->remote_ip);
;;;1045       if (local_ip == NULL) {
;;;1046         return ERR_RTE;
;;;1047       }
;;;1048       ip_addr_copy(pcb->local_ip, *local_ip);
;;;1049     }
;;;1050   
;;;1051   #if TCP_OUTPUT_DEBUG
;;;1052     if (seg == NULL) {
;;;1053       LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
;;;1054                                      (void*)pcb->unsent));
;;;1055     }
;;;1056   #endif /* TCP_OUTPUT_DEBUG */
;;;1057   #if TCP_CWND_DEBUG
;;;1058     if (seg == NULL) {
;;;1059       LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"TCPWNDSIZE_F
;;;1060                                    ", cwnd %"TCPWNDSIZE_F", wnd %"U32_F
;;;1061                                    ", seg == NULL, ack %"U32_F"\n",
;;;1062                                    pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
;;;1063     } else {
;;;1064       LWIP_DEBUGF(TCP_CWND_DEBUG,
;;;1065                   ("tcp_output: snd_wnd %"TCPWNDSIZE_F", cwnd %"TCPWNDSIZE_F", wnd %"U32_F
;;;1066                    ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
;;;1067                    pcb->snd_wnd, pcb->cwnd, wnd,
;;;1068                    lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
;;;1069                    lwip_ntohl(seg->tcphdr->seqno), pcb->lastack));
;;;1070     }
;;;1071   #endif /* TCP_CWND_DEBUG */
;;;1072     /* Check if we need to start the persistent timer when the next unsent segment
;;;1073      * does not fit within the remaining send window and RTO timer is not running (we
;;;1074      * have no in-flight data). A traditional approach would fill the remaining window
;;;1075      * with part of the unsent segment (which will engage zero-window probing upon
;;;1076      * reception of the zero window update from the receiver). This ensures the
;;;1077      * subsequent window update is reliably received. With the goal of being lightweight,
;;;1078      * we avoid splitting the unsent segment and treat the window as already zero.
;;;1079      */
;;;1080     if (seg != NULL &&
;;;1081         lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd &&
;;;1082         wnd > 0 && wnd == pcb->snd_wnd && pcb->unacked == NULL) {
;;;1083       /* Start the persist timer */
;;;1084       if (pcb->persist_backoff == 0) {
;;;1085         pcb->persist_cnt = 0;
;;;1086         pcb->persist_backoff = 1;
;;;1087       }
;;;1088       goto output_done;
;;;1089     }
;;;1090     /* data available and window allows it to be sent? */
;;;1091     while (seg != NULL &&
;;;1092            lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
;;;1093       LWIP_ASSERT("RST not expected here!",
;;;1094                   (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
;;;1095       /* Stop sending if the nagle algorithm would prevent it
;;;1096        * Don't stop:
;;;1097        * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
;;;1098        * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
;;;1099        *   either seg->next != NULL or pcb->unacked == NULL;
;;;1100        *   RST is no sent using tcp_write/tcp_output.
;;;1101        */
;;;1102       if ((tcp_do_output_nagle(pcb) == 0) &&
;;;1103         ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
;;;1104         break;
;;;1105       }
;;;1106   #if TCP_CWND_DEBUG
;;;1107       LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"TCPWNDSIZE_F", cwnd %"TCPWNDSIZE_F", wnd %"U32_F", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"S16_F"\n",
;;;1108                               pcb->snd_wnd, pcb->cwnd, wnd,
;;;1109                               lwip_ntohl(seg->tcphdr->seqno) + seg->len -
;;;1110                               pcb->lastack,
;;;1111                               lwip_ntohl(seg->tcphdr->seqno), pcb->lastack, i));
;;;1112       ++i;
;;;1113   #endif /* TCP_CWND_DEBUG */
;;;1114   
;;;1115       if (pcb->state != SYN_SENT) {
;;;1116         TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
;;;1117       }
;;;1118   
;;;1119   #if TCP_OVERSIZE_DBGCHECK
;;;1120       seg->oversize_left = 0;
;;;1121   #endif /* TCP_OVERSIZE_DBGCHECK */
;;;1122       err = tcp_output_segment(seg, pcb, netif);
;;;1123       if (err != ERR_OK) {
;;;1124         /* segment could not be sent, for whatever reason */
;;;1125         pcb->flags |= TF_NAGLEMEMERR;
;;;1126         return err;
;;;1127       }
;;;1128       pcb->unsent = seg->next;
;;;1129       if (pcb->state != SYN_SENT) {
;;;1130         pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;1131       }
;;;1132       snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
;;;1133       if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
;;;1134         pcb->snd_nxt = snd_nxt;
;;;1135       }
;;;1136       /* put segment on unacknowledged list if length > 0 */
;;;1137       if (TCP_TCPLEN(seg) > 0) {
;;;1138         seg->next = NULL;
;;;1139         /* unacked list is empty? */
;;;1140         if (pcb->unacked == NULL) {
;;;1141           pcb->unacked = seg;
;;;1142           useg = seg;
;;;1143         /* unacked list is not empty? */
;;;1144         } else {
;;;1145           /* In the case of fast retransmit, the packet should not go to the tail
;;;1146            * of the unacked queue, but rather somewhere before it. We need to check for
;;;1147            * this case. -STJ Jul 27, 2004 */
;;;1148           if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
;;;1149             /* add segment to before tail of unacked list, keeping the list sorted */
;;;1150             struct tcp_seg **cur_seg = &(pcb->unacked);
;;;1151             while (*cur_seg &&
;;;1152               TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
;;;1153                 cur_seg = &((*cur_seg)->next );
;;;1154             }
;;;1155             seg->next = (*cur_seg);
;;;1156             (*cur_seg) = seg;
;;;1157           } else {
;;;1158             /* add segment to tail of unacked list */
;;;1159             useg->next = seg;
;;;1160             useg = useg->next;
;;;1161           }
;;;1162         }
;;;1163       /* do not queue empty segments on the unacked list */
;;;1164       } else {
;;;1165         tcp_seg_free(seg);
;;;1166       }
;;;1167       seg = pcb->unsent;
;;;1168     }
;;;1169   output_done:
;;;1170   #if TCP_OVERSIZE
;;;1171     if (pcb->unsent == NULL) {
;;;1172       /* last unsent has been removed, reset unsent_oversize */
;;;1173       pcb->unsent_oversize = 0;
;;;1174     }
;;;1175   #endif /* TCP_OVERSIZE */
;;;1176   
;;;1177     pcb->flags &= ~TF_NAGLEMEMERR;
;;;1178     return ERR_OK;
;;;1179   }
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.40|
000028  f8b4805c          LDRH     r8,[r4,#0x5c]         ;1015
00002c  f8b40048          LDRH     r0,[r4,#0x48]         ;1015
000030  4580              CMP      r8,r0                 ;1015
000032  d300              BCC      |L4.54|
000034  4680              MOV      r8,r0                 ;1015
                  |L4.54|
000036  6ea5              LDR      r5,[r4,#0x68]         ;1017
000038  7ea0              LDRB     r0,[r4,#0x1a]         ;1025
00003a  0780              LSLS     r0,r0,#30             ;1025
00003c  d50f              BPL      |L4.94|
00003e  b14d              CBZ      r5,|L4.84|
000040  68e8              LDR      r0,[r5,#0xc]          ;1027
000042  6840              LDR      r0,[r0,#4]            ;1027
000044  f7fffffe          BL       lwip_htonl
000048  6c61              LDR      r1,[r4,#0x44]         ;1027
00004a  1a40              SUBS     r0,r0,r1              ;1027
00004c  8929              LDRH     r1,[r5,#8]            ;1027
00004e  4408              ADD      r0,r0,r1              ;1027
000050  4540              CMP      r0,r8                 ;1027
000052  d904              BLS      |L4.94|
                  |L4.84|
000054  4620              MOV      r0,r4                 ;1028
000056  e8bd5ff0          POP      {r4-r12,lr}           ;1028
00005a  f7ffbffe          B.W      tcp_send_empty_ack
                  |L4.94|
00005e  6ee7              LDR      r7,[r4,#0x6c]         ;1032
000060  b90f              CBNZ     r7,|L4.102|
000062  e003              B        |L4.108|
                  |L4.100|
000064  4607              MOV      r7,r0                 ;1034
                  |L4.102|
000066  6838              LDR      r0,[r7,#0]            ;1034
000068  2800              CMP      r0,#0                 ;1034
00006a  d1fb              BNE      |L4.100|
                  |L4.108|
00006c  1d20              ADDS     r0,r4,#4              ;1037
00006e  f7fffffe          BL       ip4_route
000072  4681              MOV      r9,r0                 ;1037
000074  ea5f0009          MOVS     r0,r9                 ;1038
000078  f06f0103          MVN      r1,#3                 ;1039
00007c  d003              BEQ      |L4.134|
00007e  b124              CBZ      r4,|L4.138|
000080  6820              LDR      r0,[r4,#0]            ;1043
000082  b110              CBZ      r0,|L4.138|
000084  e006              B        |L4.148|
                  |L4.134|
000086  4608              MOV      r0,r1                 ;1039
000088  e7cc              B        |L4.36|
                  |L4.138|
00008a  f1090004          ADD      r0,r9,#4              ;1044
00008e  b1c8              CBZ      r0,|L4.196|
000090  6800              LDR      r0,[r0,#0]            ;1048
000092  6020              STR      r0,[r4,#0]            ;1048
                  |L4.148|
000094  f04f0a00          MOV      r10,#0                ;1080
000098  2d00              CMP      r5,#0                 ;1080
                  |L4.154|
00009a  d012              BEQ      |L4.194|
00009c  68e8              LDR      r0,[r5,#0xc]          ;1081
00009e  6840              LDR      r0,[r0,#4]            ;1081
0000a0  f7fffffe          BL       lwip_htonl
0000a4  6c61              LDR      r1,[r4,#0x44]         ;1081
0000a6  1a40              SUBS     r0,r0,r1              ;1081
0000a8  8929              LDRH     r1,[r5,#8]            ;1081
0000aa  4408              ADD      r0,r0,r1              ;1081
0000ac  4540              CMP      r0,r8                 ;1081
0000ae  d908              BLS      |L4.194|
0000b0  f1b80f00          CMP      r8,#0                 ;1082
0000b4  d0f1              BEQ      |L4.154|
0000b6  f8b4005c          LDRH     r0,[r4,#0x5c]         ;1082
0000ba  4540              CMP      r0,r8                 ;1082
0000bc  d101              BNE      |L4.194|
0000be  6ee0              LDR      r0,[r4,#0x6c]         ;1082
0000c0  b110              CBZ      r0,|L4.200|
                  |L4.194|
0000c2  e09f              B        |L4.516|
                  |L4.196|
0000c4  4608              MOV      r0,r1                 ;1046
0000c6  e7ad              B        |L4.36|
                  |L4.200|
0000c8  f8940095          LDRB     r0,[r4,#0x95]         ;1084
0000cc  2800              CMP      r0,#0                 ;1084
0000ce  d104              BNE      |L4.218|
0000d0  f884a094          STRB     r10,[r4,#0x94]        ;1085
0000d4  2001              MOVS     r0,#1                 ;1086
0000d6  f8840095          STRB     r0,[r4,#0x95]         ;1086
                  |L4.218|
0000da  e09f              B        |L4.540|
                  |L4.220|
0000dc  68e8              LDR      r0,[r5,#0xc]          ;1093
0000de  8980              LDRH     r0,[r0,#0xc]          ;1093
0000e0  f7fffffe          BL       lwip_htons
0000e4  0740              LSLS     r0,r0,#29             ;1093
0000e6  d506              BPL      |L4.246|
0000e8  a351              ADR      r3,|L4.560|
0000ea  f2404245          MOV      r2,#0x445             ;1093
0000ee  a172              ADR      r1,|L4.696|
0000f0  a066              ADR      r0,|L4.652|
0000f2  f7fffffe          BL       __2printf
                  |L4.246|
0000f6  6ee0              LDR      r0,[r4,#0x6c]         ;1102
0000f8  b1a8              CBZ      r0,|L4.294|
0000fa  7ea1              LDRB     r1,[r4,#0x1a]         ;1102
0000fc  f0110f44          TST      r1,#0x44              ;1102
000100  d111              BNE      |L4.294|
000102  6ea0              LDR      r0,[r4,#0x68]         ;1102
000104  b128              CBZ      r0,|L4.274|
000106  6802              LDR      r2,[r0,#0]            ;1102
000108  b96a              CBNZ     r2,|L4.294|
00010a  8900              LDRH     r0,[r0,#8]            ;1102
00010c  8e62              LDRH     r2,[r4,#0x32]         ;1102
00010e  4290              CMP      r0,r2                 ;1102
000110  d209              BCS      |L4.294|
                  |L4.274|
000112  f8b40060          LDRH     r0,[r4,#0x60]         ;1102
000116  b130              CBZ      r0,|L4.294|
000118  f8b40062          LDRH     r0,[r4,#0x62]         ;1102
00011c  2809              CMP      r0,#9                 ;1102
00011e  d202              BCS      |L4.294|
000120  f0110fa0          TST      r1,#0xa0              ;1103
000124  d07a              BEQ      |L4.540|
                  |L4.294|
000126  7d20              LDRB     r0,[r4,#0x14]         ;1115
000128  2802              CMP      r0,#2                 ;1115
00012a  d007              BEQ      |L4.316|
00012c  2010              MOVS     r0,#0x10              ;1116
00012e  f7fffffe          BL       lwip_htons
000132  4601              MOV      r1,r0                 ;1116
000134  68e8              LDR      r0,[r5,#0xc]          ;1116
000136  8982              LDRH     r2,[r0,#0xc]          ;1116
000138  4311              ORRS     r1,r1,r2              ;1116
00013a  8181              STRH     r1,[r0,#0xc]          ;1116
                  |L4.316|
00013c  464a              MOV      r2,r9                 ;1122
00013e  4621              MOV      r1,r4                 ;1122
000140  4628              MOV      r0,r5                 ;1122
000142  f7fffffe          BL       tcp_output_segment
000146  b120              CBZ      r0,|L4.338|
000148  7ea1              LDRB     r1,[r4,#0x1a]         ;1125
00014a  f0410180          ORR      r1,r1,#0x80           ;1125
00014e  76a1              STRB     r1,[r4,#0x1a]         ;1125
000150  e768              B        |L4.36|
                  |L4.338|
000152  6828              LDR      r0,[r5,#0]            ;1128
000154  66a0              STR      r0,[r4,#0x68]         ;1128
000156  7d20              LDRB     r0,[r4,#0x14]         ;1129
000158  2802              CMP      r0,#2                 ;1129
00015a  d003              BEQ      |L4.356|
00015c  7ea0              LDRB     r0,[r4,#0x1a]         ;1130
00015e  f0200003          BIC      r0,r0,#3              ;1130
000162  76a0              STRB     r0,[r4,#0x1a]         ;1130
                  |L4.356|
000164  68e8              LDR      r0,[r5,#0xc]          ;1132
000166  6840              LDR      r0,[r0,#4]            ;1132
000168  f7fffffe          BL       lwip_htonl
00016c  4606              MOV      r6,r0                 ;1132
00016e  68e8              LDR      r0,[r5,#0xc]          ;1132
000170  8980              LDRH     r0,[r0,#0xc]          ;1132
000172  f7fffffe          BL       lwip_htons
000176  0780              LSLS     r0,r0,#30             ;1132
000178  d001              BEQ      |L4.382|
00017a  2001              MOVS     r0,#1                 ;1132
00017c  e000              B        |L4.384|
                  |L4.382|
00017e  2000              MOVS     r0,#0                 ;1132
                  |L4.384|
000180  8929              LDRH     r1,[r5,#8]            ;1132
000182  4430              ADD      r0,r0,r6              ;1132
000184  4408              ADD      r0,r0,r1              ;1132
000186  6ce1              LDR      r1,[r4,#0x4c]         ;1133
000188  1a09              SUBS     r1,r1,r0              ;1133
00018a  d500              BPL      |L4.398|
00018c  64e0              STR      r0,[r4,#0x4c]         ;1134
                  |L4.398|
00018e  68e8              LDR      r0,[r5,#0xc]          ;1137
000190  8980              LDRH     r0,[r0,#0xc]          ;1137
000192  f7fffffe          BL       lwip_htons
000196  0780              LSLS     r0,r0,#30             ;1137
000198  d001              BEQ      |L4.414|
00019a  2001              MOVS     r0,#1                 ;1137
00019c  e000              B        |L4.416|
                  |L4.414|
00019e  2000              MOVS     r0,#0                 ;1137
                  |L4.416|
0001a0  8929              LDRH     r1,[r5,#8]            ;1137
0001a2  42c8              CMN      r0,r1                 ;1137
0001a4  d02a              BEQ      |L4.508|
0001a6  f8c5a000          STR      r10,[r5,#0]           ;1138
0001aa  6ee0              LDR      r0,[r4,#0x6c]         ;1140
0001ac  b168              CBZ      r0,|L4.458|
0001ae  68e8              LDR      r0,[r5,#0xc]          ;1148
0001b0  6840              LDR      r0,[r0,#4]            ;1148
0001b2  f7fffffe          BL       lwip_htonl
0001b6  4606              MOV      r6,r0                 ;1148
0001b8  68f8              LDR      r0,[r7,#0xc]          ;1148
0001ba  6840              LDR      r0,[r0,#4]            ;1148
0001bc  f7fffffe          BL       lwip_htonl
0001c0  1a30              SUBS     r0,r6,r0              ;1148
0001c2  d518              BPL      |L4.502|
0001c4  f104066c          ADD      r6,r4,#0x6c           ;1150
0001c8  e003              B        |L4.466|
                  |L4.458|
0001ca  66e5              STR      r5,[r4,#0x6c]         ;1141
0001cc  462f              MOV      r7,r5                 ;1142
0001ce  e018              B        |L4.514|
                  |L4.464|
0001d0  6836              LDR      r6,[r6,#0]            ;1153
                  |L4.466|
0001d2  6830              LDR      r0,[r6,#0]            ;1151
0001d4  b158              CBZ      r0,|L4.494|
0001d6  68c0              LDR      r0,[r0,#0xc]          ;1152
0001d8  6840              LDR      r0,[r0,#4]            ;1152
0001da  f7fffffe          BL       lwip_htonl
0001de  4683              MOV      r11,r0                ;1152
0001e0  68e8              LDR      r0,[r5,#0xc]          ;1152
0001e2  6840              LDR      r0,[r0,#4]            ;1152
0001e4  f7fffffe          BL       lwip_htonl
0001e8  ebbb0000          SUBS     r0,r11,r0             ;1152
0001ec  d4f0              BMI      |L4.464|
                  |L4.494|
0001ee  6830              LDR      r0,[r6,#0]            ;1155
0001f0  6028              STR      r0,[r5,#0]            ;1155
0001f2  6035              STR      r5,[r6,#0]            ;1156
0001f4  e005              B        |L4.514|
                  |L4.502|
0001f6  603d              STR      r5,[r7,#0]            ;1159
0001f8  462f              MOV      r7,r5                 ;1160
0001fa  e002              B        |L4.514|
                  |L4.508|
0001fc  4628              MOV      r0,r5                 ;1165
0001fe  f7fffffe          BL       tcp_seg_free
                  |L4.514|
000202  6ea5              LDR      r5,[r4,#0x68]         ;1167
                  |L4.516|
000204  b155              CBZ      r5,|L4.540|
000206  68e8              LDR      r0,[r5,#0xc]          ;1092
000208  6840              LDR      r0,[r0,#4]            ;1092
00020a  f7fffffe          BL       lwip_htonl
00020e  6c61              LDR      r1,[r4,#0x44]         ;1092
000210  1a40              SUBS     r0,r0,r1              ;1092
000212  8929              LDRH     r1,[r5,#8]            ;1092
000214  4408              ADD      r0,r0,r1              ;1092
000216  4540              CMP      r0,r8                 ;1092
000218  f67faf60          BLS      |L4.220|
                  |L4.540|
00021c  6ea0              LDR      r0,[r4,#0x68]         ;1171
00021e  b908              CBNZ     r0,|L4.548|
000220  f8a4a064          STRH     r10,[r4,#0x64]        ;1173
                  |L4.548|
000224  7ea0              LDRB     r0,[r4,#0x1a]         ;1177
000226  f0200080          BIC      r0,r0,#0x80           ;1177
00022a  76a0              STRB     r0,[r4,#0x1a]         ;1177
00022c  2000              MOVS     r0,#0                 ;1178
00022e  e6f9              B        |L4.36|
;;;1180   
                          ENDP

                  |L4.560|
000230  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000234  6964646c
000238  65776172
00023c  65735c54
000240  68697264
000244  5f506172
000248  74795c4c
00024c  7749505c
000250  7372635c
000254  636f7265
000258  5c746370
00025c  5f6f7574
000260  2e      
000261  6300              DCB      "c",0
000263  00                DCB      0
                  |L4.612|
000264  646f6e27          DCB      "don't call tcp_output for listen-pcbs",0
000268  74206361
00026c  6c6c2074
000270  63705f6f
000274  75747075
000278  7420666f
00027c  72206c69
000280  7374656e
000284  2d706362
000288  7300    
00028a  00                DCB      0
00028b  00                DCB      0
                  |L4.652|
00028c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000290  7274696f
000294  6e202225
000298  73222066
00029c  61696c65
0002a0  64206174
0002a4  206c696e
0002a8  65202564
0002ac  20696e20
0002b0  25730a00
                  |L4.692|
                          DCD      tcp_input_pcb
                  |L4.696|
0002b8  52535420          DCB      "RST not expected here!",0
0002bc  6e6f7420
0002c0  65787065
0002c4  63746564
0002c8  20686572
0002cc  652100  
0002cf  00                DCB      0

                          AREA ||i.tcp_output_alloc_header||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_output_alloc_header PROC
;;;107    static struct pbuf *
;;;108    tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;109                          u32_t seqno_be /* already in network byte order */)
;;;110    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4698              MOV      r8,r3
;;;111      struct tcp_hdr *tcphdr;
;;;112      struct pbuf *p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
00000a  18b8              ADDS     r0,r7,r2
00000c  3014              ADDS     r0,r0,#0x14
00000e  b281              UXTH     r1,r0
000010  2200              MOVS     r2,#0
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       pbuf_alloc
000018  4606              MOV      r6,r0
;;;113      if (p != NULL) {
00001a  0030              MOVS     r0,r6
00001c  d030              BEQ      |L5.128|
;;;114        LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
00001e  8971              LDRH     r1,[r6,#0xa]
000020  f1070014          ADD      r0,r7,#0x14
000024  4281              CMP      r1,r0
000026  d205              BCS      |L5.52|
000028  a317              ADR      r3,|L5.136|
00002a  2272              MOVS     r2,#0x72
00002c  a123              ADR      r1,|L5.188|
00002e  a02f              ADR      r0,|L5.236|
000030  f7fffffe          BL       __2printf
                  |L5.52|
;;;115                     (p->len >= TCP_HLEN + optlen));
;;;116        tcphdr = (struct tcp_hdr *)p->payload;
000034  6874              LDR      r4,[r6,#4]
;;;117        tcphdr->src = lwip_htons(pcb->local_port);
000036  8ae8              LDRH     r0,[r5,#0x16]
000038  f7fffffe          BL       lwip_htons
00003c  8020              STRH     r0,[r4,#0]
;;;118        tcphdr->dest = lwip_htons(pcb->remote_port);
00003e  8b28              LDRH     r0,[r5,#0x18]
000040  f7fffffe          BL       lwip_htons
000044  8060              STRH     r0,[r4,#2]
;;;119        tcphdr->seqno = seqno_be;
000046  f8c48004          STR      r8,[r4,#4]
;;;120        tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
00004a  6a68              LDR      r0,[r5,#0x24]
00004c  f7fffffe          BL       lwip_htonl
000050  60a0              STR      r0,[r4,#8]
;;;121        TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), TCP_ACK);
000052  2005              MOVS     r0,#5
000054  eb000097          ADD      r0,r0,r7,LSR #2
000058  f64f71ff          MOV      r1,#0xffff
00005c  ea013000          AND      r0,r1,r0,LSL #12
000060  f0400010          ORR      r0,r0,#0x10
000064  f7fffffe          BL       lwip_htons
000068  81a0              STRH     r0,[r4,#0xc]
;;;122        tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
00006a  8d68              LDRH     r0,[r5,#0x2a]
00006c  f7fffffe          BL       lwip_htons
000070  81e0              STRH     r0,[r4,#0xe]
;;;123        tcphdr->chksum = 0;
000072  2000              MOVS     r0,#0
000074  8220              STRH     r0,[r4,#0x10]
;;;124        tcphdr->urgp = 0;
000076  8260              STRH     r0,[r4,#0x12]
;;;125    
;;;126        /* If we're sending a packet, update the announced right window edge */
;;;127        pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
000078  8d69              LDRH     r1,[r5,#0x2a]
00007a  6a68              LDR      r0,[r5,#0x24]
00007c  4408              ADD      r0,r0,r1
00007e  62e8              STR      r0,[r5,#0x2c]
                  |L5.128|
;;;128      }
;;;129      return p;
000080  4630              MOV      r0,r6
;;;130    }
000082  e8bd81f0          POP      {r4-r8,pc}
;;;131    
                          ENDP

000086  0000              DCW      0x0000
                  |L5.136|
000088  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
00008c  6964646c
000090  65776172
000094  65735c54
000098  68697264
00009c  5f506172
0000a0  74795c4c
0000a4  7749505c
0000a8  7372635c
0000ac  636f7265
0000b0  5c746370
0000b4  5f6f7574
0000b8  2e      
0000b9  6300              DCB      "c",0
0000bb  00                DCB      0
                  |L5.188|
0000bc  63686563          DCB      "check that first pbuf can hold struct tcp_hdr",0
0000c0  6b207468
0000c4  61742066
0000c8  69727374
0000cc  20706275
0000d0  66206361
0000d4  6e20686f
0000d8  6c642073
0000dc  74727563
0000e0  74207463
0000e4  705f6864
0000e8  7200    
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L5.236|
0000ec  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000f0  7274696f
0000f4  6e202225
0000f8  73222066
0000fc  61696c65
000100  64206174
000104  206c696e
000108  65202564
00010c  20696e20
000110  25730a00

                          AREA ||i.tcp_output_segment||, CODE, READONLY, ALIGN=2

                  tcp_output_segment PROC
;;;1188   static err_t
;;;1189   tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif)
000000  b5fe              PUSH     {r1-r7,lr}
;;;1190   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4617              MOV      r7,r2
;;;1191     err_t err;
;;;1192     u16_t len;
;;;1193     u32_t *opts;
;;;1194   
;;;1195     if (seg->p->ref != 1) {
000008  6868              LDR      r0,[r5,#4]
00000a  89c0              LDRH     r0,[r0,#0xe]
00000c  2801              CMP      r0,#1
00000e  d001              BEQ      |L6.20|
;;;1196       /* This can happen if the pbuf of this segment is still referenced by the
;;;1197          netif driver due to deferred transmission. Since this function modifies
;;;1198          p->len, we must not continue in this case. */
;;;1199       return ERR_OK;
000010  2000              MOVS     r0,#0
;;;1200     }
;;;1201   
;;;1202     /* The TCP header has already been constructed, but the ackno and
;;;1203      wnd fields remain. */
;;;1204     seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
;;;1205   
;;;1206     /* advertise our receive window size in this TCP segment */
;;;1207   #if LWIP_WND_SCALE
;;;1208     if (seg->flags & TF_SEG_OPTS_WND_SCALE) {
;;;1209       /* The Window field in a SYN segment itself (the only type where we send
;;;1210          the window scale option) is never scaled. */
;;;1211       seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
;;;1212     } else
;;;1213   #endif /* LWIP_WND_SCALE */
;;;1214     {
;;;1215       seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
;;;1216     }
;;;1217   
;;;1218     pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
;;;1219   
;;;1220     /* Add any requested options.  NB MSS option is only set on SYN
;;;1221        packets, so ignore it here */
;;;1222     /* cast through void* to get rid of alignment warnings */
;;;1223     opts = (u32_t *)(void *)(seg->tcphdr + 1);
;;;1224     if (seg->flags & TF_SEG_OPTS_MSS) {
;;;1225       u16_t mss;
;;;1226   #if TCP_CALCULATE_EFF_SEND_MSS
;;;1227       mss = tcp_eff_send_mss(TCP_MSS, &pcb->local_ip, &pcb->remote_ip);
;;;1228   #else /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1229       mss = TCP_MSS;
;;;1230   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1231       *opts = TCP_BUILD_MSS_OPTION(mss);
;;;1232       opts += 1;
;;;1233     }
;;;1234   #if LWIP_TCP_TIMESTAMPS
;;;1235     pcb->ts_lastacksent = pcb->rcv_nxt;
;;;1236   
;;;1237     if (seg->flags & TF_SEG_OPTS_TS) {
;;;1238       tcp_build_timestamp_option(pcb, opts);
;;;1239       opts += 3;
;;;1240     }
;;;1241   #endif
;;;1242   #if LWIP_WND_SCALE
;;;1243     if (seg->flags & TF_SEG_OPTS_WND_SCALE) {
;;;1244       tcp_build_wnd_scale_option(opts);
;;;1245       opts += 1;
;;;1246     }
;;;1247   #endif
;;;1248   
;;;1249     /* Set retransmission timer running if it is not currently enabled
;;;1250        This must be set before checking the route. */
;;;1251     if (pcb->rtime < 0) {
;;;1252       pcb->rtime = 0;
;;;1253     }
;;;1254   
;;;1255     if (pcb->rttest == 0) {
;;;1256       pcb->rttest = tcp_ticks;
;;;1257       pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
;;;1258   
;;;1259       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
;;;1260     }
;;;1261     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
;;;1262             lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) +
;;;1263             seg->len));
;;;1264   
;;;1265     len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
;;;1266     if (len == 0) {
;;;1267       /** Exclude retransmitted segments from this count. */
;;;1268       MIB2_STATS_INC(mib2.tcpoutsegs);
;;;1269     }
;;;1270   
;;;1271     seg->p->len -= len;
;;;1272     seg->p->tot_len -= len;
;;;1273   
;;;1274     seg->p->payload = seg->tcphdr;
;;;1275   
;;;1276     seg->tcphdr->chksum = 0;
;;;1277   #if CHECKSUM_GEN_TCP
;;;1278     IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
;;;1279   #if TCP_CHECKSUM_ON_COPY
;;;1280       u32_t acc;
;;;1281   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1282       u16_t chksum_slow = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
;;;1283         seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
;;;1284   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1285       if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
;;;1286         LWIP_ASSERT("data included but not checksummed",
;;;1287           seg->p->tot_len == (TCPH_HDRLEN(seg->tcphdr) * 4));
;;;1288       }
;;;1289   
;;;1290       /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
;;;1291       acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
;;;1292         seg->p->tot_len, TCPH_HDRLEN(seg->tcphdr) * 4, &pcb->local_ip, &pcb->remote_ip);
;;;1293       /* add payload checksum */
;;;1294       if (seg->chksum_swapped) {
;;;1295         seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
;;;1296         seg->chksum_swapped = 0;
;;;1297       }
;;;1298       acc += (u16_t)~(seg->chksum);
;;;1299       seg->tcphdr->chksum = FOLD_U32T(acc);
;;;1300   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1301       if (chksum_slow != seg->tcphdr->chksum) {
;;;1302         TCP_CHECKSUM_ON_COPY_SANITY_CHECK_FAIL(
;;;1303                     ("tcp_output_segment: calculated checksum is %"X16_F" instead of %"X16_F"\n",
;;;1304                     seg->tcphdr->chksum, chksum_slow));
;;;1305         seg->tcphdr->chksum = chksum_slow;
;;;1306       }
;;;1307   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1308   #else /* TCP_CHECKSUM_ON_COPY */
;;;1309       seg->tcphdr->chksum = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
;;;1310         seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
;;;1311   #endif /* TCP_CHECKSUM_ON_COPY */
;;;1312     }
;;;1313   #endif /* CHECKSUM_GEN_TCP */
;;;1314     TCP_STATS_INC(tcp.xmit);
;;;1315   
;;;1316     NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
;;;1317     err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
;;;1318       pcb->tos, IP_PROTO_TCP, netif);
;;;1319     NETIF_SET_HWADDRHINT(netif, NULL);
;;;1320     return err;
;;;1321   }
000012  bdfe              POP      {r1-r7,pc}
                  |L6.20|
000014  6a60              LDR      r0,[r4,#0x24]         ;1204
000016  f7fffffe          BL       lwip_htonl
00001a  68e9              LDR      r1,[r5,#0xc]          ;1204
00001c  6088              STR      r0,[r1,#8]            ;1204
00001e  8d60              LDRH     r0,[r4,#0x2a]         ;1215
000020  f7fffffe          BL       lwip_htons
000024  68e9              LDR      r1,[r5,#0xc]          ;1215
000026  81c8              STRH     r0,[r1,#0xe]          ;1215
000028  8d61              LDRH     r1,[r4,#0x2a]         ;1218
00002a  6a60              LDR      r0,[r4,#0x24]         ;1218
00002c  4408              ADD      r0,r0,r1              ;1218
00002e  62e0              STR      r0,[r4,#0x2c]         ;1218
000030  68ee              LDR      r6,[r5,#0xc]          ;1223
000032  3614              ADDS     r6,r6,#0x14           ;1223
000034  7aa8              LDRB     r0,[r5,#0xa]          ;1224
000036  07c0              LSLS     r0,r0,#31             ;1224
000038  d009              BEQ      |L6.78|
00003a  1d21              ADDS     r1,r4,#4              ;1227
00003c  f44f7006          MOV      r0,#0x218             ;1227
000040  f7fffffe          BL       tcp_eff_send_mss_impl
000044  f0407001          ORR      r0,r0,#0x2040000      ;1231
000048  f7fffffe          BL       lwip_htonl
00004c  6030              STR      r0,[r6,#0]            ;1231
                  |L6.78|
00004e  f9b40030          LDRSH    r0,[r4,#0x30]         ;1251
000052  2600              MOVS     r6,#0                 ;1251
000054  2800              CMP      r0,#0                 ;1251
000056  da00              BGE      |L6.90|
000058  8626              STRH     r6,[r4,#0x30]         ;1252
                  |L6.90|
00005a  6b60              LDR      r0,[r4,#0x34]         ;1255
00005c  b938              CBNZ     r0,|L6.110|
00005e  4811              LDR      r0,|L6.164|
000060  6800              LDR      r0,[r0,#0]            ;1256  ; tcp_ticks
000062  6360              STR      r0,[r4,#0x34]         ;1256
000064  68e8              LDR      r0,[r5,#0xc]          ;1257
000066  6840              LDR      r0,[r0,#4]            ;1257
000068  f7fffffe          BL       lwip_htonl
00006c  63a0              STR      r0,[r4,#0x38]         ;1257
                  |L6.110|
00006e  6869              LDR      r1,[r5,#4]            ;1265
000070  89a8              LDRH     r0,[r5,#0xc]          ;1265
000072  888a              LDRH     r2,[r1,#4]            ;1265
000074  1a80              SUBS     r0,r0,r2              ;1265
000076  894a              LDRH     r2,[r1,#0xa]          ;1271
000078  1a12              SUBS     r2,r2,r0              ;1271
00007a  814a              STRH     r2,[r1,#0xa]          ;1271
00007c  6869              LDR      r1,[r5,#4]            ;1272
00007e  890a              LDRH     r2,[r1,#8]            ;1272
000080  1a10              SUBS     r0,r2,r0              ;1272
000082  8108              STRH     r0,[r1,#8]            ;1272
000084  6869              LDR      r1,[r5,#4]            ;1274
000086  68e8              LDR      r0,[r5,#0xc]          ;1274
000088  6048              STR      r0,[r1,#4]            ;1274
00008a  68e8              LDR      r0,[r5,#0xc]          ;1276
00008c  8206              STRH     r6,[r0,#0x10]         ;1276
00008e  7a60              LDRB     r0,[r4,#9]            ;1317
000090  2106              MOVS     r1,#6                 ;1317
000092  e88d0083          STM      sp,{r0,r1,r7}         ;1317
000096  7aa3              LDRB     r3,[r4,#0xa]          ;1317
000098  1d22              ADDS     r2,r4,#4              ;1317
00009a  4621              MOV      r1,r4                 ;1317
00009c  6868              LDR      r0,[r5,#4]            ;1317
00009e  f7fffffe          BL       ip4_output_if
0000a2  bdfe              POP      {r1-r7,pc}
;;;1322   
                          ENDP

                  |L6.164|
                          DCD      tcp_ticks

                          AREA ||i.tcp_pbuf_prealloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_pbuf_prealloc PROC
;;;232    static struct pbuf *
;;;233    tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;234                      u16_t *oversize, struct tcp_pcb *pcb, u8_t apiflags,
;;;235                      u8_t first_seg)
;;;236    {
000004  461e              MOV      r6,r3
000006  e9dd4706          LDRD     r4,r7,[sp,#0x18]
00000a  9b08              LDR      r3,[sp,#0x20]
00000c  460d              MOV      r5,r1
;;;237      struct pbuf *p;
;;;238      u16_t alloc = length;
;;;239    
;;;240    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;241      LWIP_UNUSED_ARG(max_length);
;;;242      LWIP_UNUSED_ARG(pcb);
;;;243      LWIP_UNUSED_ARG(apiflags);
;;;244      LWIP_UNUSED_ARG(first_seg);
;;;245      alloc = max_length;
;;;246    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;247      if (length < max_length) {
00000e  4629              MOV      r1,r5
000010  4295              CMP      r5,r2
000012  d211              BCS      |L7.56|
;;;248        /* Should we allocate an oversized pbuf, or just the minimum
;;;249         * length required? If tcp_write is going to be called again
;;;250         * before this segment is transmitted, we want the oversized
;;;251         * buffer. If the segment will be transmitted immediately, we can
;;;252         * save memory by allocating only length. We use a simple
;;;253         * heuristic based on the following information:
;;;254         *
;;;255         * Did the user set TCP_WRITE_FLAG_MORE?
;;;256         *
;;;257         * Will the Nagle algorithm defer transmission of this segment?
;;;258         */
;;;259        if ((apiflags & TCP_WRITE_FLAG_MORE) ||
000014  07bf              LSLS     r7,r7,#30
000016  d407              BMI      |L7.40|
;;;260            (!(pcb->flags & TF_NODELAY) &&
000018  7ea7              LDRB     r7,[r4,#0x1a]
00001a  067f              LSLS     r7,r7,#25
00001c  d40c              BMI      |L7.56|
;;;261             (!first_seg ||
00001e  b11b              CBZ      r3,|L7.40|
;;;262              pcb->unsent != NULL ||
000020  6ea3              LDR      r3,[r4,#0x68]
000022  b90b              CBNZ     r3,|L7.40|
;;;263              pcb->unacked != NULL))) {
000024  6ee3              LDR      r3,[r4,#0x6c]
000026  b13b              CBZ      r3,|L7.56|
                  |L7.40|
;;;264          alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
000028  f205211b          ADD      r1,r5,#0x21b
00002c  f0210103          BIC      r1,r1,#3
000030  4291              CMP      r1,r2
000032  d800              BHI      |L7.54|
000034  460a              MOV      r2,r1
                  |L7.54|
000036  b291              UXTH     r1,r2
                  |L7.56|
;;;265        }
;;;266      }
;;;267    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;268      p = pbuf_alloc(layer, alloc, PBUF_RAM);
000038  2200              MOVS     r2,#0
00003a  f7fffffe          BL       pbuf_alloc
00003e  4604              MOV      r4,r0
;;;269      if (p == NULL) {
000040  2c00              CMP      r4,#0
000042  d010              BEQ      |L7.102|
;;;270        return NULL;
;;;271      }
;;;272      LWIP_ASSERT("need unchained pbuf", p->next == NULL);
000044  6820              LDR      r0,[r4,#0]
000046  b130              CBZ      r0,|L7.86|
000048  a308              ADR      r3,|L7.108|
00004a  f44f7288          MOV      r2,#0x110
00004e  a114              ADR      r1,|L7.160|
000050  a018              ADR      r0,|L7.180|
000052  f7fffffe          BL       __2printf
                  |L7.86|
;;;273      *oversize = p->len - length;
000056  8960              LDRH     r0,[r4,#0xa]
000058  1b40              SUBS     r0,r0,r5
00005a  8030              STRH     r0,[r6,#0]
;;;274      /* trim p->len to the currently used size */
;;;275      p->len = p->tot_len = length;
00005c  8125              STRH     r5,[r4,#8]
00005e  8165              STRH     r5,[r4,#0xa]
;;;276      return p;
000060  4620              MOV      r0,r4
                  |L7.98|
;;;277    }
000062  e8bd81f0          POP      {r4-r8,pc}
                  |L7.102|
000066  2000              MOVS     r0,#0                 ;270
000068  e7fb              B        |L7.98|
;;;278    #else /* TCP_OVERSIZE */
                          ENDP

00006a  0000              DCW      0x0000
                  |L7.108|
00006c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000070  6964646c
000074  65776172
000078  65735c54
00007c  68697264
000080  5f506172
000084  74795c4c
000088  7749505c
00008c  7372635c
000090  636f7265
000094  5c746370
000098  5f6f7574
00009c  2e      
00009d  6300              DCB      "c",0
00009f  00                DCB      0
                  |L7.160|
0000a0  6e656564          DCB      "need unchained pbuf",0
0000a4  20756e63
0000a8  6861696e
0000ac  65642070
0000b0  62756600
                  |L7.180|
0000b4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000b8  7274696f
0000bc  6e202225
0000c0  73222066
0000c4  61696c65
0000c8  64206174
0000cc  206c696e
0000d0  65202564
0000d4  20696e20
0000d8  25730a00

                          AREA ||i.tcp_rexmit||, CODE, READONLY, ALIGN=1

                  tcp_rexmit PROC
;;;1441   void
;;;1442   tcp_rexmit(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1443   {
000004  4605              MOV      r5,r0
;;;1444     struct tcp_seg *seg;
;;;1445     struct tcp_seg **cur_seg;
;;;1446   
;;;1447     if (pcb->unacked == NULL) {
000006  6eee              LDR      r6,[r5,#0x6c]
000008  2e00              CMP      r6,#0
00000a  d022              BEQ      |L8.82|
;;;1448       return;
;;;1449     }
;;;1450   
;;;1451     /* Move the first unacked segment to the unsent queue */
;;;1452     /* Keep the unsent queue sorted. */
;;;1453     seg = pcb->unacked;
;;;1454     pcb->unacked = seg->next;
00000c  6830              LDR      r0,[r6,#0]
00000e  66e8              STR      r0,[r5,#0x6c]
;;;1455   
;;;1456     cur_seg = &(pcb->unsent);
000010  f1050468          ADD      r4,r5,#0x68
;;;1457     while (*cur_seg &&
000014  e000              B        |L8.24|
                  |L8.22|
;;;1458       TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
;;;1459         cur_seg = &((*cur_seg)->next );
000016  6824              LDR      r4,[r4,#0]
                  |L8.24|
000018  6820              LDR      r0,[r4,#0]            ;1457
00001a  b150              CBZ      r0,|L8.50|
00001c  68c0              LDR      r0,[r0,#0xc]          ;1458
00001e  6840              LDR      r0,[r0,#4]            ;1458
000020  f7fffffe          BL       lwip_htonl
000024  4607              MOV      r7,r0                 ;1458
000026  68f0              LDR      r0,[r6,#0xc]          ;1458
000028  6840              LDR      r0,[r0,#4]            ;1458
00002a  f7fffffe          BL       lwip_htonl
00002e  1a38              SUBS     r0,r7,r0              ;1458
000030  d4f1              BMI      |L8.22|
                  |L8.50|
;;;1460     }
;;;1461     seg->next = *cur_seg;
000032  6820              LDR      r0,[r4,#0]
000034  6030              STR      r0,[r6,#0]
;;;1462     *cur_seg = seg;
000036  6026              STR      r6,[r4,#0]
;;;1463   #if TCP_OVERSIZE
;;;1464     if (seg->next == NULL) {
000038  6830              LDR      r0,[r6,#0]
00003a  2100              MOVS     r1,#0
00003c  b908              CBNZ     r0,|L8.66|
;;;1465       /* the retransmitted segment is last in unsent, so reset unsent_oversize */
;;;1466       pcb->unsent_oversize = 0;
00003e  f8a51064          STRH     r1,[r5,#0x64]
                  |L8.66|
;;;1467     }
;;;1468   #endif /* TCP_OVERSIZE */
;;;1469   
;;;1470     if (pcb->nrtx < 0xFF) {
000042  f8950042          LDRB     r0,[r5,#0x42]
000046  28ff              CMP      r0,#0xff
000048  d202              BCS      |L8.80|
;;;1471       ++pcb->nrtx;
00004a  1c40              ADDS     r0,r0,#1
00004c  f8850042          STRB     r0,[r5,#0x42]
                  |L8.80|
;;;1472     }
;;;1473   
;;;1474     /* Don't take any rtt measurements after retransmitting. */
;;;1475     pcb->rttest = 0;
000050  6369              STR      r1,[r5,#0x34]
                  |L8.82|
;;;1476   
;;;1477     /* Do the actual retransmission. */
;;;1478     MIB2_STATS_INC(mib2.tcpretranssegs);
;;;1479     /* No need to call tcp_output: we are always called from tcp_input()
;;;1480        and thus tcp_output directly returns. */
;;;1481   }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;1482   
                          ENDP


                          AREA ||i.tcp_rexmit_fast||, CODE, READONLY, ALIGN=1

                  tcp_rexmit_fast PROC
;;;1489   void
;;;1490   tcp_rexmit_fast(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;1491   {
000002  4604              MOV      r4,r0
;;;1492     if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
000004  6ee0              LDR      r0,[r4,#0x6c]
000006  2800              CMP      r0,#0
000008  d025              BEQ      |L9.86|
00000a  7ea0              LDRB     r0,[r4,#0x1a]
00000c  0740              LSLS     r0,r0,#29
00000e  d422              BMI      |L9.86|
;;;1493       /* This is fast retransmit. Retransmit the first unacked segment. */
;;;1494       LWIP_DEBUGF(TCP_FR_DEBUG,
;;;1495                   ("tcp_receive: dupacks %"U16_F" (%"U32_F
;;;1496                    "), fast retransmit %"U32_F"\n",
;;;1497                    (u16_t)pcb->dupacks, pcb->lastack,
;;;1498                    lwip_ntohl(pcb->unacked->tcphdr->seqno)));
;;;1499       tcp_rexmit(pcb);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       tcp_rexmit
;;;1500   
;;;1501       /* Set ssthresh to half of the minimum of the current
;;;1502        * cwnd and the advertised window */
;;;1503       pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
000016  f8b40048          LDRH     r0,[r4,#0x48]
00001a  f8b4105c          LDRH     r1,[r4,#0x5c]
00001e  4288              CMP      r0,r1
000020  d300              BCC      |L9.36|
000022  4608              MOV      r0,r1
                  |L9.36|
000024  0841              LSRS     r1,r0,#1
000026  f8a4104a          STRH     r1,[r4,#0x4a]
;;;1504   
;;;1505       /* The minimum value for ssthresh should be 2 MSS */
;;;1506       if (pcb->ssthresh < (2U * pcb->mss)) {
00002a  8e60              LDRH     r0,[r4,#0x32]
00002c  ebb10f40          CMP      r1,r0,LSL #1
000030  d205              BCS      |L9.62|
;;;1507         LWIP_DEBUGF(TCP_FR_DEBUG,
;;;1508                     ("tcp_receive: The minimum value for ssthresh %"TCPWNDSIZE_F
;;;1509                      " should be min 2 mss %"U16_F"...\n",
;;;1510                      pcb->ssthresh, (u16_t)(2*pcb->mss)));
;;;1511         pcb->ssthresh = 2*pcb->mss;
000032  f64f71ff          MOV      r1,#0xffff
000036  ea010140          AND      r1,r1,r0,LSL #1
00003a  f8a4104a          STRH     r1,[r4,#0x4a]
                  |L9.62|
;;;1512       }
;;;1513   
;;;1514       pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
00003e  341a              ADDS     r4,r4,#0x1a
000040  eb000040          ADD      r0,r0,r0,LSL #1
000044  8e21              LDRH     r1,[r4,#0x30]
000046  4408              ADD      r0,r0,r1
000048  85e0              STRH     r0,[r4,#0x2e]
;;;1515       pcb->flags |= TF_INFR;
00004a  7820              LDRB     r0,[r4,#0]
00004c  f0400004          ORR      r0,r0,#4
000050  7020              STRB     r0,[r4,#0]
;;;1516   
;;;1517       /* Reset the retransmission timer to prevent immediate rto retransmissions */
;;;1518       pcb->rtime = 0;
000052  2000              MOVS     r0,#0
000054  82e0              STRH     r0,[r4,#0x16]
                  |L9.86|
;;;1519     }
;;;1520   }
000056  bd10              POP      {r4,pc}
;;;1521   
                          ENDP


                          AREA ||i.tcp_rexmit_rto||, CODE, READONLY, ALIGN=1

                  tcp_rexmit_rto PROC
;;;1398   void
;;;1399   tcp_rexmit_rto(struct tcp_pcb *pcb)
000000  6ec1              LDR      r1,[r0,#0x6c]
;;;1400   {
;;;1401     struct tcp_seg *seg;
;;;1402   
;;;1403     if (pcb->unacked == NULL) {
000002  2900              CMP      r1,#0
000004  d014              BEQ      |L10.48|
000006  e000              B        |L10.10|
                  |L10.8|
;;;1404       return;
;;;1405     }
;;;1406   
;;;1407     /* Move all unacked segments to the head of the unsent queue */
;;;1408     for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
000008  4611              MOV      r1,r2
                  |L10.10|
00000a  680a              LDR      r2,[r1,#0]
00000c  2a00              CMP      r2,#0
00000e  d1fb              BNE      |L10.8|
;;;1409     /* concatenate unsent queue after unacked queue */
;;;1410     seg->next = pcb->unsent;
000010  6e82              LDR      r2,[r0,#0x68]
000012  600a              STR      r2,[r1,#0]
;;;1411   #if TCP_OVERSIZE_DBGCHECK
;;;1412     /* if last unsent changed, we need to update unsent_oversize */
;;;1413     if (pcb->unsent == NULL) {
;;;1414       pcb->unsent_oversize = seg->oversize_left;
;;;1415     }
;;;1416   #endif /* TCP_OVERSIZE_DBGCHECK */
;;;1417     /* unsent queue is the concatenated queue (of unacked, unsent) */
;;;1418     pcb->unsent = pcb->unacked;
000014  6ec1              LDR      r1,[r0,#0x6c]
000016  6681              STR      r1,[r0,#0x68]
;;;1419     /* unacked queue is now empty */
;;;1420     pcb->unacked = NULL;
000018  2200              MOVS     r2,#0
00001a  66c2              STR      r2,[r0,#0x6c]
;;;1421   
;;;1422     /* increment number of retransmissions */
;;;1423     if (pcb->nrtx < 0xFF) {
00001c  f8901042          LDRB     r1,[r0,#0x42]
000020  29ff              CMP      r1,#0xff
000022  d202              BCS      |L10.42|
;;;1424       ++pcb->nrtx;
000024  1c49              ADDS     r1,r1,#1
000026  f8801042          STRB     r1,[r0,#0x42]
                  |L10.42|
;;;1425     }
;;;1426   
;;;1427     /* Don't take any RTT measurements after retransmitting. */
;;;1428     pcb->rttest = 0;
00002a  6342              STR      r2,[r0,#0x34]
;;;1429   
;;;1430     /* Do the actual retransmission */
;;;1431     tcp_output(pcb);
00002c  f7ffbffe          B.W      tcp_output
                  |L10.48|
;;;1432   }
000030  4770              BX       lr
;;;1433   
                          ENDP


                          AREA ||i.tcp_rst||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_rst PROC
;;;1343   void
;;;1344   tcp_rst(u32_t seqno, u32_t ackno,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1345     const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
;;;1346     u16_t local_port, u16_t remote_port)
;;;1347   {
000004  e9ddab0c          LDRD     r10,r11,[sp,#0x30]
000008  4681              MOV      r9,r0
00000a  4688              MOV      r8,r1
00000c  4617              MOV      r7,r2
00000e  461e              MOV      r6,r3
;;;1348     struct pbuf *p;
;;;1349     struct tcp_hdr *tcphdr;
;;;1350     struct netif *netif;
;;;1351     p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
000010  2200              MOVS     r2,#0
000012  2114              MOVS     r1,#0x14
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       pbuf_alloc
00001a  4605              MOV      r5,r0
;;;1352     if (p == NULL) {
00001c  0028              MOVS     r0,r5
00001e  d03b              BEQ      |L11.152|
;;;1353       LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
;;;1354       return;
;;;1355     }
;;;1356     LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
000020  8968              LDRH     r0,[r5,#0xa]
000022  2814              CMP      r0,#0x14
000024  d206              BCS      |L11.52|
000026  a31d              ADR      r3,|L11.156|
000028  f240524c          MOV      r2,#0x54c
00002c  a128              ADR      r1,|L11.208|
00002e  a034              ADR      r0,|L11.256|
000030  f7fffffe          BL       __2printf
                  |L11.52|
;;;1357                 (p->len >= sizeof(struct tcp_hdr)));
;;;1358   
;;;1359     tcphdr = (struct tcp_hdr *)p->payload;
000034  686c              LDR      r4,[r5,#4]
;;;1360     tcphdr->src = lwip_htons(local_port);
000036  4650              MOV      r0,r10
000038  f7fffffe          BL       lwip_htons
00003c  8020              STRH     r0,[r4,#0]
;;;1361     tcphdr->dest = lwip_htons(remote_port);
00003e  4658              MOV      r0,r11
000040  f7fffffe          BL       lwip_htons
000044  8060              STRH     r0,[r4,#2]
;;;1362     tcphdr->seqno = lwip_htonl(seqno);
000046  4648              MOV      r0,r9
000048  f7fffffe          BL       lwip_htonl
00004c  6060              STR      r0,[r4,#4]
;;;1363     tcphdr->ackno = lwip_htonl(ackno);
00004e  4640              MOV      r0,r8
000050  f7fffffe          BL       lwip_htonl
000054  60a0              STR      r0,[r4,#8]
;;;1364     TCPH_HDRLEN_FLAGS_SET(tcphdr, TCP_HLEN/4, TCP_RST | TCP_ACK);
000056  f2450014          MOV      r0,#0x5014
00005a  f7fffffe          BL       lwip_htons
00005e  81a0              STRH     r0,[r4,#0xc]
;;;1365   #if LWIP_WND_SCALE
;;;1366     tcphdr->wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
;;;1367   #else
;;;1368     tcphdr->wnd = PP_HTONS(TCP_WND);
000060  f2460008          MOV      r0,#0x6008
000064  81e0              STRH     r0,[r4,#0xe]
;;;1369   #endif
;;;1370     tcphdr->chksum = 0;
000066  f04f0800          MOV      r8,#0
00006a  f8a48010          STRH     r8,[r4,#0x10]
;;;1371     tcphdr->urgp = 0;
00006e  f8a48012          STRH     r8,[r4,#0x12]
;;;1372   
;;;1373     TCP_STATS_INC(tcp.xmit);
;;;1374     MIB2_STATS_INC(mib2.tcpoutrsts);
;;;1375   
;;;1376     netif = ip_route(local_ip, remote_ip);
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       ip4_route
;;;1377     if (netif != NULL) {
000078  b148              CBZ      r0,|L11.142|
;;;1378   #if CHECKSUM_GEN_TCP
;;;1379       IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
;;;1380         tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
;;;1381                                           local_ip, remote_ip);
;;;1382       }
;;;1383   #endif
;;;1384       /* Send output with hardcoded TTL/HL since we have no access to the pcb */
;;;1385       ip_output_if(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP, netif);
00007a  2106              MOVS     r1,#6
00007c  e9cd8100          STRD     r8,r1,[sp,#0]
000080  9002              STR      r0,[sp,#8]
000082  23ff              MOVS     r3,#0xff
000084  4632              MOV      r2,r6
000086  4639              MOV      r1,r7
000088  4628              MOV      r0,r5
00008a  f7fffffe          BL       ip4_output_if
                  |L11.142|
;;;1386     }
;;;1387     pbuf_free(p);
00008e  4628              MOV      r0,r5
000090  e8bd4ffe          POP      {r1-r11,lr}
000094  f7ffbffe          B.W      pbuf_free
                  |L11.152|
;;;1388     LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
;;;1389   }
000098  e8bd8ffe          POP      {r1-r11,pc}
;;;1390   
                          ENDP

                  |L11.156|
00009c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
0000a0  6964646c
0000a4  65776172
0000a8  65735c54
0000ac  68697264
0000b0  5f506172
0000b4  74795c4c
0000b8  7749505c
0000bc  7372635c
0000c0  636f7265
0000c4  5c746370
0000c8  5f6f7574
0000cc  2e      
0000cd  6300              DCB      "c",0
0000cf  00                DCB      0
                  |L11.208|
0000d0  63686563          DCB      "check that first pbuf can hold struct tcp_hdr",0
0000d4  6b207468
0000d8  61742066
0000dc  69727374
0000e0  20706275
0000e4  66206361
0000e8  6e20686f
0000ec  6c642073
0000f0  74727563
0000f4  74207463
0000f8  705f6864
0000fc  7200    
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L11.256|
000100  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000104  7274696f
000108  6e202225
00010c  73222066
000110  61696c65
000114  64206174
000118  206c696e
00011c  65202564
000120  20696e20
000124  25730a00

                          AREA ||i.tcp_send_empty_ack||, CODE, READONLY, ALIGN=1

                  tcp_send_empty_ack PROC
;;;917    err_t
;;;918    tcp_send_empty_ack(struct tcp_pcb *pcb)
000000  b5fe              PUSH     {r1-r7,lr}
;;;919    {
000002  4604              MOV      r4,r0
;;;920      err_t err;
;;;921      struct pbuf *p;
;;;922      u8_t optlen = 0;
000004  2500              MOVS     r5,#0
;;;923      struct netif *netif;
;;;924    #if LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP
;;;925      struct tcp_hdr *tcphdr;
;;;926    #endif /* LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP */
;;;927    
;;;928    #if LWIP_TCP_TIMESTAMPS
;;;929      if (pcb->flags & TF_TIMESTAMP) {
;;;930        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;931      }
;;;932    #endif
;;;933    
;;;934      p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
000006  6ce0              LDR      r0,[r4,#0x4c]
000008  f7fffffe          BL       lwip_htonl
00000c  4603              MOV      r3,r0
00000e  2200              MOVS     r2,#0
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       tcp_output_alloc_header
000018  4606              MOV      r6,r0
;;;935      if (p == NULL) {
00001a  b1c6              CBZ      r6,|L12.78|
;;;936        /* let tcp_fasttmr retry sending this ACK */
;;;937        pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
;;;938        LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
;;;939        return ERR_BUF;
;;;940      }
;;;941    #if LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP
;;;942      tcphdr = (struct tcp_hdr *)p->payload;
;;;943    #endif /* LWIP_TCP_TIMESTAMPS || CHECKSUM_GEN_TCP */
;;;944      LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
;;;945                  ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
;;;946    
;;;947      /* NB. MSS and window scale options are only sent on SYNs, so ignore them here */
;;;948    #if LWIP_TCP_TIMESTAMPS
;;;949      pcb->ts_lastacksent = pcb->rcv_nxt;
;;;950    
;;;951      if (pcb->flags & TF_TIMESTAMP) {
;;;952        tcp_build_timestamp_option(pcb, (u32_t *)(tcphdr + 1));
;;;953      }
;;;954    #endif
;;;955    
;;;956      netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
00001c  1d20              ADDS     r0,r4,#4
00001e  f7fffffe          BL       ip4_route
;;;957      if (netif == NULL) {
000022  b1d8              CBZ      r0,|L12.92|
;;;958        err = ERR_RTE;
;;;959      } else {
;;;960    #if CHECKSUM_GEN_TCP
;;;961        IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
;;;962          tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
;;;963            &pcb->local_ip, &pcb->remote_ip);
;;;964        }
;;;965    #endif
;;;966        NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
;;;967        err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip,
000024  7a61              LDRB     r1,[r4,#9]
000026  2206              MOVS     r2,#6
000028  e9cd1200          STRD     r1,r2,[sp,#0]
00002c  9002              STR      r0,[sp,#8]
00002e  7aa3              LDRB     r3,[r4,#0xa]
000030  1d22              ADDS     r2,r4,#4
000032  4621              MOV      r1,r4
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       ip4_output_if
00003a  4605              MOV      r5,r0
                  |L12.60|
;;;968          pcb->ttl, pcb->tos, IP_PROTO_TCP, netif);
;;;969        NETIF_SET_HWADDRHINT(netif, NULL);
;;;970      }
;;;971      pbuf_free(p);
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       pbuf_free
;;;972    
;;;973      if (err != ERR_OK) {
000042  b175              CBZ      r5,|L12.98|
;;;974        /* let tcp_fasttmr retry sending this ACK */
;;;975        pcb->flags |= (TF_ACK_DELAY | TF_ACK_NOW);
000044  7ea0              LDRB     r0,[r4,#0x1a]
000046  f0400003          ORR      r0,r0,#3
00004a  76a0              STRB     r0,[r4,#0x1a]
00004c  e00d              B        |L12.106|
                  |L12.78|
00004e  7ea0              LDRB     r0,[r4,#0x1a]         ;937
000050  f0400003          ORR      r0,r0,#3              ;937
000054  76a0              STRB     r0,[r4,#0x1a]         ;937
000056  f06f0001          MVN      r0,#1                 ;939
;;;976      } else {
;;;977        /* remove ACK flags from the PCB, as we sent an empty ACK now */
;;;978        pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
;;;979      }
;;;980    
;;;981      return err;
;;;982    }
00005a  bdfe              POP      {r1-r7,pc}
                  |L12.92|
00005c  f06f0503          MVN      r5,#3                 ;958
000060  e7ec              B        |L12.60|
                  |L12.98|
000062  7ea0              LDRB     r0,[r4,#0x1a]         ;978
000064  f0200003          BIC      r0,r0,#3              ;978
000068  76a0              STRB     r0,[r4,#0x1a]         ;978
                  |L12.106|
00006a  4628              MOV      r0,r5                 ;981
00006c  bdfe              POP      {r1-r7,pc}
;;;983    
                          ENDP


                          AREA ||i.tcp_send_fin||, CODE, READONLY, ALIGN=1

                  tcp_send_fin PROC
;;;138    err_t
;;;139    tcp_send_fin(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;140    {
000002  4605              MOV      r5,r0
;;;141      /* first, try to add the fin to the last unsent segment */
;;;142      if (pcb->unsent != NULL) {
000004  6eac              LDR      r4,[r5,#0x68]
000006  2c00              CMP      r4,#0
000008  d101              BNE      |L13.14|
00000a  e009              B        |L13.32|
                  |L13.12|
;;;143        struct tcp_seg *last_unsent;
;;;144        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
;;;145             last_unsent = last_unsent->next);
00000c  460c              MOV      r4,r1
                  |L13.14|
00000e  6821              LDR      r1,[r4,#0]            ;144
000010  2900              CMP      r1,#0                 ;144
000012  d1fb              BNE      |L13.12|
;;;146    
;;;147        if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
000014  68e0              LDR      r0,[r4,#0xc]
000016  8980              LDRH     r0,[r0,#0xc]
000018  f7fffffe          BL       lwip_htons
00001c  0740              LSLS     r0,r0,#29
00001e  d005              BEQ      |L13.44|
                  |L13.32|
;;;148          /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
;;;149          TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
;;;150          pcb->flags |= TF_FIN;
;;;151          return ERR_OK;
;;;152        }
;;;153      }
;;;154      /* no data, no length, flags, copy=1, no optdata */
;;;155      return tcp_enqueue_flags(pcb, TCP_FIN);
000020  4628              MOV      r0,r5
000022  e8bd4070          POP      {r4-r6,lr}
000026  2101              MOVS     r1,#1
000028  f7ffbffe          B.W      tcp_enqueue_flags
                  |L13.44|
00002c  2001              MOVS     r0,#1                 ;149
00002e  f7fffffe          BL       lwip_htons
000032  4601              MOV      r1,r0                 ;149
000034  68e0              LDR      r0,[r4,#0xc]          ;149
000036  8982              LDRH     r2,[r0,#0xc]          ;149
000038  4311              ORRS     r1,r1,r2              ;149
00003a  8181              STRH     r1,[r0,#0xc]          ;149
00003c  7ea8              LDRB     r0,[r5,#0x1a]         ;150
00003e  f0400020          ORR      r0,r0,#0x20           ;150
000042  76a8              STRB     r0,[r5,#0x1a]         ;150
000044  2000              MOVS     r0,#0                 ;151
;;;156    }
000046  bd70              POP      {r4-r6,pc}
;;;157    
                          ENDP


                          AREA ||i.tcp_write||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_write PROC
;;;367    err_t
;;;368    tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;369    {
000004  b08d              SUB      sp,sp,#0x34
000006  4605              MOV      r5,r0
000008  4690              MOV      r8,r2
;;;370      struct pbuf *concat_p = NULL;
00000a  2000              MOVS     r0,#0
00000c  900c              STR      r0,[sp,#0x30]
;;;371      struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
00000e  2400              MOVS     r4,#0
000010  2700              MOVS     r7,#0
000012  900b              STR      r0,[sp,#0x2c]
000014  4683              MOV      r11,r0
;;;372      u16_t pos = 0; /* position in 'arg' data */
000016  2600              MOVS     r6,#0
;;;373      u16_t queuelen;
;;;374      u8_t optlen = 0;
000018  900a              STR      r0,[sp,#0x28]
;;;375      u8_t optflags = 0;
00001a  9009              STR      r0,[sp,#0x24]
;;;376    #if TCP_OVERSIZE
;;;377      u16_t oversize = 0;
00001c  9008              STR      r0,[sp,#0x20]
;;;378      u16_t oversize_used = 0;
00001e  4682              MOV      r10,r0
;;;379    #if TCP_OVERSIZE_DBGCHECK
;;;380      u16_t oversize_add = 0;
;;;381    #endif /* TCP_OVERSIZE_DBGCHECK*/
;;;382    #endif /* TCP_OVERSIZE */
;;;383      u16_t extendlen = 0;
000020  9007              STR      r0,[sp,#0x1c]
;;;384    #if TCP_CHECKSUM_ON_COPY
;;;385      u16_t concat_chksum = 0;
;;;386      u8_t concat_chksum_swapped = 0;
;;;387      u16_t concat_chksummed = 0;
;;;388    #endif /* TCP_CHECKSUM_ON_COPY */
;;;389      err_t err;
;;;390      /* don't allocate segments bigger than half the maximum window we ever received */
;;;391      u16_t mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max/2));
000022  8e68              LDRH     r0,[r5,#0x32]
000024  f8b5105e          LDRH     r1,[r5,#0x5e]
000028  ebb00f51          CMP      r0,r1,LSR #1
00002c  d201              BCS      |L14.50|
00002e  4601              MOV      r1,r0
000030  e000              B        |L14.52|
                  |L14.50|
000032  0849              LSRS     r1,r1,#1
                  |L14.52|
;;;392      mss_local = mss_local ? mss_local : pcb->mss;
000034  b901              CBNZ     r1,|L14.56|
000036  4601              MOV      r1,r0
                  |L14.56|
000038  9106              STR      r1,[sp,#0x18]
;;;393    
;;;394    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;395      /* Always copy to try to create single pbufs for TX */
;;;396      apiflags |= TCP_WRITE_FLAG_COPY;
;;;397    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;398    
;;;399      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
;;;400        (void *)pcb, arg, len, (u16_t)apiflags));
;;;401      LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
00003a  980e              LDR      r0,[sp,#0x38]
00003c  b160              CBZ      r0,|L14.88|
;;;402                 arg != NULL, return ERR_ARG;);
;;;403    
;;;404      err = tcp_write_checks(pcb, len);
00003e  4641              MOV      r1,r8
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       tcp_write_checks
;;;405      if (err != ERR_OK) {
000046  2800              CMP      r0,#0
000048  d10f              BNE      |L14.106|
;;;406        return err;
;;;407      }
;;;408      queuelen = pcb->snd_queuelen;
00004a  f8b59062          LDRH     r9,[r5,#0x62]
;;;409    
;;;410    #if LWIP_TCP_TIMESTAMPS
;;;411      if ((pcb->flags & TF_TIMESTAMP)) {
;;;412        /* Make sure the timestamp option is only included in data segments if we
;;;413           agreed about it with the remote host. */
;;;414        optflags = TF_SEG_OPTS_TS;
;;;415        optlen = LWIP_TCP_OPT_LENGTH(TF_SEG_OPTS_TS);
;;;416        /* ensure that segments can hold at least one data byte... */
;;;417        mss_local = LWIP_MAX(mss_local, LWIP_TCP_OPT_LEN_TS + 1);
;;;418      }
;;;419    #endif /* LWIP_TCP_TIMESTAMPS */
;;;420    
;;;421    
;;;422      /*
;;;423       * TCP segmentation is done in three phases with increasing complexity:
;;;424       *
;;;425       * 1. Copy data directly into an oversized pbuf.
;;;426       * 2. Chain a new pbuf to the end of pcb->unsent.
;;;427       * 3. Create new segments.
;;;428       *
;;;429       * We may run out of memory at any point. In that case we must
;;;430       * return ERR_MEM and not change anything in pcb. Therefore, all
;;;431       * changes are recorded in local variables and committed at the end
;;;432       * of the function. Some pcb fields are maintained in local copies:
;;;433       *
;;;434       * queuelen = pcb->snd_queuelen
;;;435       * oversize = pcb->unsent_oversize
;;;436       *
;;;437       * These variables are set consistently by the phases:
;;;438       *
;;;439       * seg points to the last segment tampered with.
;;;440       *
;;;441       * pos records progress as data is segmented.
;;;442       */
;;;443    
;;;444      /* Find the tail of the unsent queue. */
;;;445      if (pcb->unsent != NULL) {
00004e  6ea8              LDR      r0,[r5,#0x68]
000050  2800              CMP      r0,#0
000052  d07d              BEQ      |L14.336|
;;;446        u16_t space;
;;;447        u16_t unsent_optlen;
;;;448    
;;;449        /* @todo: this could be sped up by keeping last_unsent in the pcb */
;;;450        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
000054  4604              MOV      r4,r0
000056  e00c              B        |L14.114|
                  |L14.88|
000058  a3cf              ADR      r3,|L14.920|
00005a  f2401291          MOV      r2,#0x191             ;401
00005e  a1db              ADR      r1,|L14.972|
000060  a0e7              ADR      r0,|L14.1024|
000062  f7fffffe          BL       __2printf
000066  f06f000f          MVN      r0,#0xf               ;401
                  |L14.106|
;;;451             last_unsent = last_unsent->next);
;;;452    
;;;453        /* Usable space at the end of the last unsent segment */
;;;454        unsent_optlen = LWIP_TCP_OPT_LENGTH(last_unsent->flags);
;;;455        LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
;;;456        space = mss_local - (last_unsent->len + unsent_optlen);
;;;457    
;;;458        /*
;;;459         * Phase 1: Copy data directly into an oversized pbuf.
;;;460         *
;;;461         * The number of bytes copied is recorded in the oversize_used
;;;462         * variable. The actual copying is done at the bottom of the
;;;463         * function.
;;;464         */
;;;465    #if TCP_OVERSIZE
;;;466    #if TCP_OVERSIZE_DBGCHECK
;;;467        /* check that pcb->unsent_oversize matches last_unsent->oversize_left */
;;;468        LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
;;;469                    pcb->unsent_oversize == last_unsent->oversize_left);
;;;470    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;471        oversize = pcb->unsent_oversize;
;;;472        if (oversize > 0) {
;;;473          LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
;;;474          seg = last_unsent;
;;;475          oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
;;;476          pos += oversize_used;
;;;477          oversize -= oversize_used;
;;;478          space -= oversize_used;
;;;479        }
;;;480        /* now we are either finished or oversize is zero */
;;;481        LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
;;;482    #endif /* TCP_OVERSIZE */
;;;483    
;;;484        /*
;;;485         * Phase 2: Chain a new pbuf to the end of pcb->unsent.
;;;486         *
;;;487         * As an exception when NOT copying the data, if the given data buffer
;;;488         * directly follows the last unsent data buffer in memory, extend the last
;;;489         * ROM pbuf reference to the buffer, thus saving a ROM pbuf allocation.
;;;490         *
;;;491         * We don't extend segments containing SYN/FIN flags or options
;;;492         * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
;;;493         * the end.
;;;494         */
;;;495        if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
;;;496          u16_t seglen = LWIP_MIN(space, len - pos);
;;;497          seg = last_unsent;
;;;498    
;;;499          /* Create a pbuf with a copy or reference to seglen bytes. We
;;;500           * can use PBUF_RAW here since the data appears in the middle of
;;;501           * a segment. A header will never be prepended. */
;;;502          if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;503            /* Data is copied */
;;;504            if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
;;;505              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;506                          ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
;;;507                           seglen));
;;;508              goto memerr;
;;;509            }
;;;510    #if TCP_OVERSIZE_DBGCHECK
;;;511            oversize_add = oversize;
;;;512    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;513            TCP_DATA_COPY2(concat_p->payload, (const u8_t*)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
;;;514    #if TCP_CHECKSUM_ON_COPY
;;;515            concat_chksummed += seglen;
;;;516    #endif /* TCP_CHECKSUM_ON_COPY */
;;;517            queuelen += pbuf_clen(concat_p);
;;;518          } else {
;;;519            /* Data is not copied */
;;;520            /* If the last unsent pbuf is of type PBUF_ROM, try to extend it. */
;;;521            struct pbuf *p;
;;;522            for (p = last_unsent->p; p->next != NULL; p = p->next);
;;;523            if (p->type == PBUF_ROM && (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
;;;524              LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
;;;525              extendlen = seglen;
;;;526            } else {
;;;527              if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
;;;528                LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;529                            ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;530                goto memerr;
;;;531              }
;;;532              /* reference the non-volatile payload data */
;;;533              ((struct pbuf_rom*)concat_p)->payload = (const u8_t*)arg + pos;
;;;534              queuelen += pbuf_clen(concat_p);
;;;535            }
;;;536    #if TCP_CHECKSUM_ON_COPY
;;;537            /* calculate the checksum of nocopy-data */
;;;538            tcp_seg_add_chksum(~inet_chksum((const u8_t*)arg + pos, seglen), seglen,
;;;539              &concat_chksum, &concat_chksum_swapped);
;;;540            concat_chksummed += seglen;
;;;541    #endif /* TCP_CHECKSUM_ON_COPY */
;;;542          }
;;;543    
;;;544          pos += seglen;
;;;545        }
;;;546      } else {
;;;547    #if TCP_OVERSIZE
;;;548        LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
;;;549                    pcb->unsent_oversize == 0);
;;;550    #endif /* TCP_OVERSIZE */
;;;551      }
;;;552    
;;;553      /*
;;;554       * Phase 3: Create new segments.
;;;555       *
;;;556       * The new segments are chained together in the local 'queue'
;;;557       * variable, ready to be appended to pcb->unsent.
;;;558       */
;;;559      while (pos < len) {
;;;560        struct pbuf *p;
;;;561        u16_t left = len - pos;
;;;562        u16_t max_len = mss_local - optlen;
;;;563        u16_t seglen = LWIP_MIN(left, max_len);
;;;564    #if TCP_CHECKSUM_ON_COPY
;;;565        u16_t chksum = 0;
;;;566        u8_t chksum_swapped = 0;
;;;567    #endif /* TCP_CHECKSUM_ON_COPY */
;;;568    
;;;569        if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;570          /* If copy is set, memory should be allocated and data copied
;;;571           * into pbuf */
;;;572          if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
;;;573            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
;;;574            goto memerr;
;;;575          }
;;;576          LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
;;;577                      (p->len >= seglen));
;;;578          TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t*)arg + pos, seglen, &chksum, &chksum_swapped);
;;;579        } else {
;;;580          /* Copy is not set: First allocate a pbuf for holding the data.
;;;581           * Since the referenced data is available at least until it is
;;;582           * sent out on the link (as it has to be ACKed by the remote
;;;583           * party) we can safely use PBUF_ROM instead of PBUF_REF here.
;;;584           */
;;;585          struct pbuf *p2;
;;;586    #if TCP_OVERSIZE
;;;587          LWIP_ASSERT("oversize == 0", oversize == 0);
;;;588    #endif /* TCP_OVERSIZE */
;;;589          if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
;;;590            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;591            goto memerr;
;;;592          }
;;;593    #if TCP_CHECKSUM_ON_COPY
;;;594          /* calculate the checksum of nocopy-data */
;;;595          chksum = ~inet_chksum((const u8_t*)arg + pos, seglen);
;;;596          if (seglen & 1) {
;;;597            chksum_swapped = 1;
;;;598            chksum = SWAP_BYTES_IN_WORD(chksum);
;;;599          }
;;;600    #endif /* TCP_CHECKSUM_ON_COPY */
;;;601          /* reference the non-volatile payload data */
;;;602          ((struct pbuf_rom*)p2)->payload = (const u8_t*)arg + pos;
;;;603    
;;;604          /* Second, allocate a pbuf for the headers. */
;;;605          if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;606            /* If allocation fails, we have to deallocate the data pbuf as
;;;607             * well. */
;;;608            pbuf_free(p2);
;;;609            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for header pbuf\n"));
;;;610            goto memerr;
;;;611          }
;;;612          /* Concatenate the headers and data pbufs together. */
;;;613          pbuf_cat(p/*header*/, p2/*data*/);
;;;614        }
;;;615    
;;;616        queuelen += pbuf_clen(p);
;;;617    
;;;618        /* Now that there are more segments queued, we check again if the
;;;619         * length of the queue exceeds the configured maximum or
;;;620         * overflows. */
;;;621        if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;622          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: queue too long %"U16_F" (%d)\n",
;;;623            queuelen, (int)TCP_SND_QUEUELEN));
;;;624          pbuf_free(p);
;;;625          goto memerr;
;;;626        }
;;;627    
;;;628        if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
;;;629          goto memerr;
;;;630        }
;;;631    #if TCP_OVERSIZE_DBGCHECK
;;;632        seg->oversize_left = oversize;
;;;633    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;634    #if TCP_CHECKSUM_ON_COPY
;;;635        seg->chksum = chksum;
;;;636        seg->chksum_swapped = chksum_swapped;
;;;637        seg->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;638    #endif /* TCP_CHECKSUM_ON_COPY */
;;;639    
;;;640        /* first segment of to-be-queued data? */
;;;641        if (queue == NULL) {
;;;642          queue = seg;
;;;643        } else {
;;;644          /* Attach the segment to the end of the queued segments */
;;;645          LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
;;;646          prev_seg->next = seg;
;;;647        }
;;;648        /* remember last segment of to-be-queued data for next iteration */
;;;649        prev_seg = seg;
;;;650    
;;;651        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
;;;652          lwip_ntohl(seg->tcphdr->seqno),
;;;653          lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));
;;;654    
;;;655        pos += seglen;
;;;656      }
;;;657    
;;;658      /*
;;;659       * All three segmentation phases were successful. We can commit the
;;;660       * transaction.
;;;661       */
;;;662    #if TCP_OVERSIZE_DBGCHECK
;;;663      if ((last_unsent != NULL) && (oversize_add != 0)) {
;;;664        last_unsent->oversize_left += oversize_add;
;;;665      }
;;;666    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;667    
;;;668      /*
;;;669       * Phase 1: If data has been added to the preallocated tail of
;;;670       * last_unsent, we update the length fields of the pbuf chain.
;;;671       */
;;;672    #if TCP_OVERSIZE
;;;673      if (oversize_used > 0) {
;;;674        struct pbuf *p;
;;;675        /* Bump tot_len of whole chain, len of tail */
;;;676        for (p = last_unsent->p; p; p = p->next) {
;;;677          p->tot_len += oversize_used;
;;;678          if (p->next == NULL) {
;;;679            TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
;;;680            p->len += oversize_used;
;;;681          }
;;;682        }
;;;683        last_unsent->len += oversize_used;
;;;684    #if TCP_OVERSIZE_DBGCHECK
;;;685        LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
;;;686                    last_unsent->oversize_left >= oversize_used);
;;;687        last_unsent->oversize_left -= oversize_used;
;;;688    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;689      }
;;;690      pcb->unsent_oversize = oversize;
;;;691    #endif /* TCP_OVERSIZE */
;;;692    
;;;693      /*
;;;694       * Phase 2: concat_p can be concatenated onto last_unsent->p, unless we
;;;695       * determined that the last ROM pbuf can be extended to include the new data.
;;;696       */
;;;697      if (concat_p != NULL) {
;;;698        LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
;;;699          (last_unsent != NULL));
;;;700        pbuf_cat(last_unsent->p, concat_p);
;;;701        last_unsent->len += concat_p->tot_len;
;;;702      } else if (extendlen > 0) {
;;;703        struct pbuf *p;
;;;704        LWIP_ASSERT("tcp_write: extension of reference requires reference",
;;;705          last_unsent != NULL && last_unsent->p != NULL);
;;;706        for (p = last_unsent->p; p->next != NULL; p = p->next) {
;;;707          p->tot_len += extendlen;
;;;708        }
;;;709        p->tot_len += extendlen;
;;;710        p->len += extendlen;
;;;711        last_unsent->len += extendlen;
;;;712      }
;;;713    
;;;714    #if TCP_CHECKSUM_ON_COPY
;;;715      if (concat_chksummed) {
;;;716        LWIP_ASSERT("tcp_write: concat checksum needs concatenated data",
;;;717            concat_p != NULL || extendlen > 0);
;;;718        /*if concat checksumm swapped - swap it back */
;;;719        if (concat_chksum_swapped) {
;;;720          concat_chksum = SWAP_BYTES_IN_WORD(concat_chksum);
;;;721        }
;;;722        tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
;;;723          &last_unsent->chksum_swapped);
;;;724        last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;725      }
;;;726    #endif /* TCP_CHECKSUM_ON_COPY */
;;;727    
;;;728      /*
;;;729       * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
;;;730       * is harmless
;;;731       */
;;;732      if (last_unsent == NULL) {
;;;733        pcb->unsent = queue;
;;;734      } else {
;;;735        last_unsent->next = queue;
;;;736      }
;;;737    
;;;738      /*
;;;739       * Finally update the pcb state.
;;;740       */
;;;741      pcb->snd_lbb += len;
;;;742      pcb->snd_buf -= len;
;;;743      pcb->snd_queuelen = queuelen;
;;;744    
;;;745      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
;;;746        pcb->snd_queuelen));
;;;747      if (pcb->snd_queuelen != 0) {
;;;748        LWIP_ASSERT("tcp_write: valid queue length",
;;;749                    pcb->unacked != NULL || pcb->unsent != NULL);
;;;750      }
;;;751    
;;;752      /* Set the PSH flag in the last segment that we enqueued. */
;;;753      if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
;;;754        TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
;;;755      }
;;;756    
;;;757      return ERR_OK;
;;;758    memerr:
;;;759      pcb->flags |= TF_NAGLEMEMERR;
;;;760      TCP_STATS_INC(tcp.memerr);
;;;761    
;;;762      if (concat_p != NULL) {
;;;763        pbuf_free(concat_p);
;;;764      }
;;;765      if (queue != NULL) {
;;;766        tcp_segs_free(queue);
;;;767      }
;;;768      if (pcb->snd_queuelen != 0) {
;;;769        LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
;;;770          pcb->unsent != NULL);
;;;771      }
;;;772      LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
;;;773      return ERR_MEM;
;;;774    }
00006a  b011              ADD      sp,sp,#0x44
00006c  e8bd8ff0          POP      {r4-r11,pc}
                  |L14.112|
000070  4604              MOV      r4,r0                 ;451
                  |L14.114|
000072  6820              LDR      r0,[r4,#0]            ;450
000074  2800              CMP      r0,#0                 ;450
000076  d1fb              BNE      |L14.112|
000078  7aa0              LDRB     r0,[r4,#0xa]          ;454
00007a  07c0              LSLS     r0,r0,#31             ;454
00007c  d001              BEQ      |L14.130|
00007e  2004              MOVS     r0,#4                 ;454
000080  e000              B        |L14.132|
                  |L14.130|
000082  2000              MOVS     r0,#0                 ;454
                  |L14.132|
000084  9004              STR      r0,[sp,#0x10]         ;454
000086  8921              LDRH     r1,[r4,#8]            ;455
000088  9804              LDR      r0,[sp,#0x10]         ;455
00008a  4401              ADD      r1,r1,r0              ;455
00008c  9806              LDR      r0,[sp,#0x18]         ;455
00008e  4281              CMP      r1,r0                 ;455
000090  d906              BLS      |L14.160|
000092  a3c1              ADR      r3,|L14.920|
000094  f24012c7          MOV      r2,#0x1c7             ;455
000098  a1e3              ADR      r1,|L14.1064|
00009a  a0d9              ADR      r0,|L14.1024|
00009c  f7fffffe          BL       __2printf
                  |L14.160|
0000a0  8921              LDRH     r1,[r4,#8]            ;456
0000a2  9804              LDR      r0,[sp,#0x10]         ;456
0000a4  4401              ADD      r1,r1,r0              ;456
0000a6  9806              LDR      r0,[sp,#0x18]         ;456
0000a8  1a40              SUBS     r0,r0,r1              ;456
0000aa  b280              UXTH     r0,r0                 ;456
0000ac  9005              STR      r0,[sp,#0x14]         ;456
0000ae  f8b50064          LDRH     r0,[r5,#0x64]         ;471
0000b2  9008              STR      r0,[sp,#0x20]         ;471
0000b4  2800              CMP      r0,#0                 ;472
0000b6  d027              BEQ      |L14.264|
0000b8  9905              LDR      r1,[sp,#0x14]         ;473
0000ba  4288              CMP      r0,r1                 ;473
0000bc  d906              BLS      |L14.204|
0000be  a3b6              ADR      r3,|L14.920|
0000c0  f24012d9          MOV      r2,#0x1d9             ;473
0000c4  a1de              ADR      r1,|L14.1088|
0000c6  a0ce              ADR      r0,|L14.1024|
0000c8  f7fffffe          BL       __2printf
                  |L14.204|
0000cc  4627              MOV      r7,r4                 ;474
0000ce  f8bd0020          LDRH     r0,[sp,#0x20]         ;475
0000d2  4540              CMP      r0,r8                 ;475
0000d4  d201              BCS      |L14.218|
0000d6  4601              MOV      r1,r0                 ;475
0000d8  e000              B        |L14.220|
                  |L14.218|
0000da  4641              MOV      r1,r8                 ;475
                  |L14.220|
0000dc  9a05              LDR      r2,[sp,#0x14]         ;475
0000de  4291              CMP      r1,r2                 ;475
0000e0  d902              BLS      |L14.232|
0000e2  f8dda014          LDR      r10,[sp,#0x14]        ;475
0000e6  e004              B        |L14.242|
                  |L14.232|
0000e8  4540              CMP      r0,r8                 ;475
0000ea  d201              BCS      |L14.240|
0000ec  4682              MOV      r10,r0                ;475
0000ee  e000              B        |L14.242|
                  |L14.240|
0000f0  46c2              MOV      r10,r8                ;475
                  |L14.242|
0000f2  eb06010a          ADD      r1,r6,r10             ;476
0000f6  b28e              UXTH     r6,r1                 ;476
0000f8  eba0000a          SUB      r0,r0,r10             ;477
0000fc  9008              STR      r0,[sp,#0x20]         ;477
0000fe  9805              LDR      r0,[sp,#0x14]         ;478
000100  eba0000a          SUB      r0,r0,r10             ;478
000104  b280              UXTH     r0,r0                 ;478
000106  9005              STR      r0,[sp,#0x14]         ;478
                  |L14.264|
000108  f8bd0020          LDRH     r0,[sp,#0x20]         ;481
00010c  b140              CBZ      r0,|L14.288|
00010e  4546              CMP      r6,r8                 ;481
000110  d006              BEQ      |L14.288|
000112  a3a1              ADR      r3,|L14.920|
000114  f24012e1          MOV      r2,#0x1e1             ;481
000118  a1d1              ADR      r1,|L14.1120|
00011a  a0b9              ADR      r0,|L14.1024|
00011c  f7fffffe          BL       __2printf
                  |L14.288|
000120  4546              CMP      r6,r8                 ;495
000122  d25e              BCS      |L14.482|
000124  9805              LDR      r0,[sp,#0x14]         ;495
000126  2800              CMP      r0,#0                 ;495
                  |L14.296|
000128  d05b              BEQ      |L14.482|
00012a  8920              LDRH     r0,[r4,#8]            ;495
00012c  2800              CMP      r0,#0                 ;495
00012e  d0fb              BEQ      |L14.296|
000130  9905              LDR      r1,[sp,#0x14]         ;496
000132  eba80006          SUB      r0,r8,r6              ;496
000136  4288              CMP      r0,r1                 ;496
000138  dd00              BLE      |L14.316|
00013a  9805              LDR      r0,[sp,#0x14]         ;496
                  |L14.316|
00013c  b280              UXTH     r0,r0                 ;496
00013e  9003              STR      r0,[sp,#0xc]          ;496
000140  4627              MOV      r7,r4                 ;497
000142  9810              LDR      r0,[sp,#0x40]         ;502
000144  07c0              LSLS     r0,r0,#31             ;502
000146  d01d              BEQ      |L14.388|
000148  2101              MOVS     r1,#1                 ;504
00014a  9810              LDR      r0,[sp,#0x40]         ;504
00014c  ab08              ADD      r3,sp,#0x20           ;504
00014e  e000              B        |L14.338|
                  |L14.336|
000150  e048              B        |L14.484|
                  |L14.338|
000152  e9cd5000          STRD     r5,r0,[sp,#0]         ;504
000156  9102              STR      r1,[sp,#8]            ;504
000158  2004              MOVS     r0,#4                 ;504
00015a  9a05              LDR      r2,[sp,#0x14]         ;504
00015c  9903              LDR      r1,[sp,#0xc]          ;504
00015e  f7fffffe          BL       tcp_pbuf_prealloc
000162  900c              STR      r0,[sp,#0x30]         ;504
000164  2800              CMP      r0,#0                 ;504
                  |L14.358|
000166  d074              BEQ      |L14.594|
000168  980e              LDR      r0,[sp,#0x38]         ;513
00016a  9a03              LDR      r2,[sp,#0xc]          ;513
00016c  1981              ADDS     r1,r0,r6              ;513
00016e  980c              LDR      r0,[sp,#0x30]         ;513
000170  6840              LDR      r0,[r0,#4]            ;513
000172  f7fffffe          BL       __aeabi_memcpy
000176  980c              LDR      r0,[sp,#0x30]         ;517
000178  f7fffffe          BL       pbuf_clen
00017c  4448              ADD      r0,r0,r9              ;517
00017e  fa1ff980          UXTH     r9,r0                 ;517
000182  e02b              B        |L14.476|
                  |L14.388|
000184  6860              LDR      r0,[r4,#4]            ;522
000186  e000              B        |L14.394|
                  |L14.392|
000188  4608              MOV      r0,r1                 ;522
                  |L14.394|
00018a  6801              LDR      r1,[r0,#0]            ;522
00018c  2900              CMP      r1,#0                 ;522
00018e  d1fb              BNE      |L14.392|
000190  7b01              LDRB     r1,[r0,#0xc]          ;523
000192  2901              CMP      r1,#1                 ;523
000194  d110              BNE      |L14.440|
000196  6841              LDR      r1,[r0,#4]            ;523
000198  8940              LDRH     r0,[r0,#0xa]          ;523
00019a  4401              ADD      r1,r1,r0              ;523
00019c  980e              LDR      r0,[sp,#0x38]         ;523
00019e  4281              CMP      r1,r0                 ;523
0001a0  d10a              BNE      |L14.440|
0001a2  b136              CBZ      r6,|L14.434|
0001a4  a37c              ADR      r3,|L14.920|
0001a6  f44f7203          MOV      r2,#0x20c             ;524
0001aa  a1b5              ADR      r1,|L14.1152|
0001ac  a094              ADR      r0,|L14.1024|
0001ae  f7fffffe          BL       __2printf
                  |L14.434|
0001b2  9803              LDR      r0,[sp,#0xc]          ;525
0001b4  9007              STR      r0,[sp,#0x1c]         ;525
0001b6  e011              B        |L14.476|
                  |L14.440|
0001b8  2201              MOVS     r2,#1                 ;527
0001ba  2004              MOVS     r0,#4                 ;527
0001bc  9903              LDR      r1,[sp,#0xc]          ;527
0001be  f7fffffe          BL       pbuf_alloc
0001c2  900c              STR      r0,[sp,#0x30]         ;527
0001c4  2800              CMP      r0,#0                 ;527
0001c6  d0ce              BEQ      |L14.358|
0001c8  980e              LDR      r0,[sp,#0x38]         ;533
0001ca  1981              ADDS     r1,r0,r6              ;533
0001cc  980c              LDR      r0,[sp,#0x30]         ;533
0001ce  6041              STR      r1,[r0,#4]            ;533
0001d0  980c              LDR      r0,[sp,#0x30]         ;534
0001d2  f7fffffe          BL       pbuf_clen
0001d6  4448              ADD      r0,r0,r9              ;534
0001d8  fa1ff980          UXTH     r9,r0                 ;534
                  |L14.476|
0001dc  9803              LDR      r0,[sp,#0xc]          ;544
0001de  4430              ADD      r0,r0,r6              ;544
0001e0  b286              UXTH     r6,r0                 ;544
                  |L14.482|
0001e2  e0ad              B        |L14.832|
                  |L14.484|
0001e4  f8b50064          LDRH     r0,[r5,#0x64]         ;548
0001e8  2800              CMP      r0,#0                 ;548
0001ea  d0fa              BEQ      |L14.482|
0001ec  a36a              ADR      r3,|L14.920|
0001ee  f44f7209          MOV      r2,#0x224             ;548
0001f2  a1ae              ADR      r1,|L14.1196|
0001f4  a082              ADR      r0,|L14.1024|
0001f6  f7fffffe          BL       __2printf
0001fa  e0a1              B        |L14.832|
                  |L14.508|
0001fc  eba80006          SUB      r0,r8,r6              ;561
000200  b280              UXTH     r0,r0                 ;561
000202  9a0a              LDR      r2,[sp,#0x28]         ;562
000204  9906              LDR      r1,[sp,#0x18]         ;562
000206  1a89              SUBS     r1,r1,r2              ;562
000208  b289              UXTH     r1,r1                 ;562
00020a  4288              CMP      r0,r1                 ;563
00020c  d300              BCC      |L14.528|
00020e  4608              MOV      r0,r1                 ;563
                  |L14.528|
000210  9004              STR      r0,[sp,#0x10]         ;563
000212  9810              LDR      r0,[sp,#0x40]         ;569
000214  07c0              LSLS     r0,r0,#31             ;569
000216  d02d              BEQ      |L14.628|
000218  f1bb0f00          CMP      r11,#0                ;572
00021c  d028              BEQ      |L14.624|
00021e  2000              MOVS     r0,#0                 ;572
                  |L14.544|
000220  9910              LDR      r1,[sp,#0x40]         ;572
000222  9002              STR      r0,[sp,#8]            ;572
000224  e9cd5100          STRD     r5,r1,[sp,#0]         ;572
000228  990a              LDR      r1,[sp,#0x28]         ;572
00022a  9804              LDR      r0,[sp,#0x10]         ;572
00022c  ab08              ADD      r3,sp,#0x20           ;572
00022e  4408              ADD      r0,r0,r1              ;572
000230  b281              UXTH     r1,r0                 ;572
000232  2000              MOVS     r0,#0                 ;572
000234  9a06              LDR      r2,[sp,#0x18]         ;572
000236  f7fffffe          BL       tcp_pbuf_prealloc
00023a  9005              STR      r0,[sp,#0x14]         ;572
00023c  2800              CMP      r0,#0                 ;572
00023e  d059              BEQ      |L14.756|
000240  9805              LDR      r0,[sp,#0x14]         ;576
000242  8941              LDRH     r1,[r0,#0xa]          ;576
000244  9804              LDR      r0,[sp,#0x10]         ;576
000246  4281              CMP      r1,r0                 ;576
000248  d208              BCS      |L14.604|
00024a  a353              ADR      r3,|L14.920|
00024c  f44f7210          MOV      r2,#0x240             ;576
000250  e000              B        |L14.596|
                  |L14.594|
000252  e04b              B        |L14.748|
                  |L14.596|
000254  a1a1              ADR      r1,|L14.1244|
000256  a06a              ADR      r0,|L14.1024|
000258  f7fffffe          BL       __2printf
                  |L14.604|
00025c  980e              LDR      r0,[sp,#0x38]         ;578
00025e  1981              ADDS     r1,r0,r6              ;578
000260  9805              LDR      r0,[sp,#0x14]         ;578
000262  6842              LDR      r2,[r0,#4]            ;578
000264  980a              LDR      r0,[sp,#0x28]         ;578
000266  4410              ADD      r0,r0,r2              ;578
000268  9a04              LDR      r2,[sp,#0x10]         ;578
00026a  f7fffffe          BL       __aeabi_memcpy
00026e  e020              B        |L14.690|
                  |L14.624|
000270  2001              MOVS     r0,#1                 ;572
000272  e7d5              B        |L14.544|
                  |L14.628|
000274  f8bd0020          LDRH     r0,[sp,#0x20]         ;587
000278  b130              CBZ      r0,|L14.648|
00027a  a347              ADR      r3,|L14.920|
00027c  f240224b          MOV      r2,#0x24b             ;587
000280  a1a6              ADR      r1,|L14.1308|
000282  a05f              ADR      r0,|L14.1024|
000284  f7fffffe          BL       __2printf
                  |L14.648|
000288  2201              MOVS     r2,#1                 ;589
00028a  2000              MOVS     r0,#0                 ;589
00028c  9904              LDR      r1,[sp,#0x10]         ;589
00028e  f7fffffe          BL       pbuf_alloc
000292  1e07              SUBS     r7,r0,#0              ;589
000294  d02e              BEQ      |L14.756|
000296  980e              LDR      r0,[sp,#0x38]         ;602
000298  4430              ADD      r0,r0,r6              ;602
00029a  6078              STR      r0,[r7,#4]            ;602
00029c  2200              MOVS     r2,#0                 ;605
00029e  4610              MOV      r0,r2                 ;605
0002a0  990a              LDR      r1,[sp,#0x28]         ;605
0002a2  f7fffffe          BL       pbuf_alloc
0002a6  9005              STR      r0,[sp,#0x14]         ;605
0002a8  b1e8              CBZ      r0,|L14.742|
0002aa  4639              MOV      r1,r7                 ;613
0002ac  9805              LDR      r0,[sp,#0x14]         ;613
0002ae  f7fffffe          BL       pbuf_cat
                  |L14.690|
0002b2  9805              LDR      r0,[sp,#0x14]         ;616
0002b4  f7fffffe          BL       pbuf_clen
0002b8  4448              ADD      r0,r0,r9              ;616
0002ba  fa1ff980          UXTH     r9,r0                 ;616
0002be  f1b90f09          CMP      r9,#9                 ;621
0002c2  d814              BHI      |L14.750|
0002c4  9809              LDR      r0,[sp,#0x24]         ;628
0002c6  9000              STR      r0,[sp,#0]            ;628
0002c8  6da8              LDR      r0,[r5,#0x58]         ;628
0002ca  2200              MOVS     r2,#0                 ;628
0002cc  1983              ADDS     r3,r0,r6              ;628
0002ce  4628              MOV      r0,r5                 ;628
0002d0  9905              LDR      r1,[sp,#0x14]         ;628
0002d2  f7fffffe          BL       tcp_create_segment
0002d6  1e07              SUBS     r7,r0,#0              ;628
0002d8  d00c              BEQ      |L14.756|
0002da  f1bb0f00          CMP      r11,#0                ;641
0002de  d020              BEQ      |L14.802|
0002e0  980b              LDR      r0,[sp,#0x2c]         ;645
0002e2  b300              CBZ      r0,|L14.806|
0002e4  e026              B        |L14.820|
                  |L14.742|
0002e6  4638              MOV      r0,r7                 ;608
0002e8  f7fffffe          BL       pbuf_free
                  |L14.748|
0002ec  e002              B        |L14.756|
                  |L14.750|
0002ee  9805              LDR      r0,[sp,#0x14]         ;624
0002f0  f7fffffe          BL       pbuf_free
                  |L14.756|
0002f4  7ea8              LDRB     r0,[r5,#0x1a]         ;759
0002f6  f0400080          ORR      r0,r0,#0x80           ;759
0002fa  76a8              STRB     r0,[r5,#0x1a]         ;759
0002fc  980c              LDR      r0,[sp,#0x30]         ;762
0002fe  b110              CBZ      r0,|L14.774|
000300  980c              LDR      r0,[sp,#0x30]         ;763
000302  f7fffffe          BL       pbuf_free
                  |L14.774|
000306  f1bb0f00          CMP      r11,#0                ;765
00030a  d002              BEQ      |L14.786|
00030c  4658              MOV      r0,r11                ;766
00030e  f7fffffe          BL       tcp_segs_free
                  |L14.786|
000312  f8b50062          LDRH     r0,[r5,#0x62]         ;768
000316  2800              CMP      r0,#0                 ;768
000318  d002              BEQ      |L14.800|
00031a  6ee8              LDR      r0,[r5,#0x6c]         ;769
00031c  2800              CMP      r0,#0                 ;769
00031e  d039              BEQ      |L14.916|
                  |L14.800|
000320  e17e              B        |L14.1568|
                  |L14.802|
000322  46bb              MOV      r11,r7                ;642
000324  e008              B        |L14.824|
                  |L14.806|
000326  a31c              ADR      r3,|L14.920|
000328  f2402285          MOV      r2,#0x285             ;645
00032c  a17f              ADR      r1,|L14.1324|
00032e  a034              ADR      r0,|L14.1024|
000330  f7fffffe          BL       __2printf
                  |L14.820|
000334  980b              LDR      r0,[sp,#0x2c]         ;646
000336  6007              STR      r7,[r0,#0]            ;646
                  |L14.824|
000338  970b              STR      r7,[sp,#0x2c]         ;649
00033a  9804              LDR      r0,[sp,#0x10]         ;655
00033c  4430              ADD      r0,r0,r6              ;655
00033e  b286              UXTH     r6,r0                 ;655
                  |L14.832|
000340  4546              CMP      r6,r8                 ;559
000342  f4ffaf5b          BCC      |L14.508|
000346  f1ba0f00          CMP      r10,#0                ;673
00034a  d016              BEQ      |L14.890|
00034c  6866              LDR      r6,[r4,#4]            ;676
00034e  e00f              B        |L14.880|
                  |L14.848|
000350  8930              LDRH     r0,[r6,#8]            ;677
000352  4450              ADD      r0,r0,r10             ;677
000354  8130              STRH     r0,[r6,#8]            ;677
000356  6830              LDR      r0,[r6,#0]            ;678
000358  b948              CBNZ     r0,|L14.878|
00035a  8971              LDRH     r1,[r6,#0xa]          ;679
00035c  6870              LDR      r0,[r6,#4]            ;679
00035e  4652              MOV      r2,r10                ;679
000360  4408              ADD      r0,r0,r1              ;679
000362  990e              LDR      r1,[sp,#0x38]         ;679
000364  f7fffffe          BL       __aeabi_memcpy
000368  8970              LDRH     r0,[r6,#0xa]          ;680
00036a  4450              ADD      r0,r0,r10             ;680
00036c  8170              STRH     r0,[r6,#0xa]          ;680
                  |L14.878|
00036e  6836              LDR      r6,[r6,#0]            ;676
                  |L14.880|
000370  2e00              CMP      r6,#0                 ;676
000372  d1ed              BNE      |L14.848|
000374  8920              LDRH     r0,[r4,#8]            ;683
000376  4450              ADD      r0,r0,r10             ;683
000378  8120              STRH     r0,[r4,#8]            ;683
                  |L14.890|
00037a  f8bd0020          LDRH     r0,[sp,#0x20]         ;690
00037e  f8a50064          STRH     r0,[r5,#0x64]         ;690
000382  980c              LDR      r0,[sp,#0x30]         ;697
000384  b120              CBZ      r0,|L14.912|
000386  b924              CBNZ     r4,|L14.914|
000388  a303              ADR      r3,|L14.920|
00038a  f24022ba          MOV      r2,#0x2ba             ;698
00038e  e0d7              B        |L14.1344|
                  |L14.912|
000390  e0e5              B        |L14.1374|
                  |L14.914|
000392  e0da              B        |L14.1354|
                  |L14.916|
000394  e139              B        |L14.1546|
000396  0000              DCW      0x0000
                  |L14.920|
000398  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
00039c  6964646c
0003a0  65776172
0003a4  65735c54
0003a8  68697264
0003ac  5f506172
0003b0  74795c4c
0003b4  7749505c
0003b8  7372635c
0003bc  636f7265
0003c0  5c746370
0003c4  5f6f7574
0003c8  2e      
0003c9  6300              DCB      "c",0
0003cb  00                DCB      0
                  |L14.972|
0003cc  7463705f          DCB      "tcp_write: arg == NULL (programmer violates API)",0
0003d0  77726974
0003d4  653a2061
0003d8  7267203d
0003dc  3d204e55
0003e0  4c4c2028
0003e4  70726f67
0003e8  72616d6d
0003ec  65722076
0003f0  696f6c61
0003f4  74657320
0003f8  41504929
0003fc  00      
0003fd  00                DCB      0
0003fe  00                DCB      0
0003ff  00                DCB      0
                  |L14.1024|
000400  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000404  7274696f
000408  6e202225
00040c  73222066
000410  61696c65
000414  64206174
000418  206c696e
00041c  65202564
000420  20696e20
000424  25730a00
                  |L14.1064|
000428  6d73735f          DCB      "mss_local is too small",0
00042c  6c6f6361
000430  6c206973
000434  20746f6f
000438  20736d61
00043c  6c6c00  
00043f  00                DCB      0
                  |L14.1088|
000440  696e636f          DCB      "inconsistent oversize vs. space",0
000444  6e736973
000448  74656e74
00044c  206f7665
000450  7273697a
000454  65207673
000458  2e207370
00045c  61636500
                  |L14.1120|
000460  696e636f          DCB      "inconsistent oversize vs. len",0
000464  6e736973
000468  74656e74
00046c  206f7665
000470  7273697a
000474  65207673
000478  2e206c65
00047c  6e00    
00047e  00                DCB      0
00047f  00                DCB      0
                  |L14.1152|
000480  7463705f          DCB      "tcp_write: ROM pbufs cannot be oversized",0
000484  77726974
000488  653a2052
00048c  4f4d2070
000490  62756673
000494  2063616e
000498  6e6f7420
00049c  6265206f
0004a0  76657273
0004a4  697a6564
0004a8  00      
0004a9  00                DCB      0
0004aa  00                DCB      0
0004ab  00                DCB      0
                  |L14.1196|
0004ac  756e7365          DCB      "unsent_oversize mismatch (pcb->unsent is NULL)",0
0004b0  6e745f6f
0004b4  76657273
0004b8  697a6520
0004bc  6d69736d
0004c0  61746368
0004c4  20287063
0004c8  622d3e75
0004cc  6e73656e
0004d0  74206973
0004d4  204e554c
0004d8  4c2900  
0004db  00                DCB      0
                  |L14.1244|
0004dc  7463705f          DCB      "tcp_write: check that first pbuf can hold the complete "
0004e0  77726974
0004e4  653a2063
0004e8  6865636b
0004ec  20746861
0004f0  74206669
0004f4  72737420
0004f8  70627566
0004fc  2063616e
000500  20686f6c
000504  64207468
000508  6520636f
00050c  6d706c65
000510  746520  
000513  7365676c          DCB      "seglen",0
000517  656e00  
00051a  00                DCB      0
00051b  00                DCB      0
                  |L14.1308|
00051c  6f766572          DCB      "oversize == 0",0
000520  73697a65
000524  203d3d20
000528  3000    
00052a  00                DCB      0
00052b  00                DCB      0
                  |L14.1324|
00052c  70726576          DCB      "prev_seg != NULL",0
000530  5f736567
000534  20213d20
000538  4e554c4c
00053c  00      
00053d  00                DCB      0
00053e  00                DCB      0
00053f  00                DCB      0
                  |L14.1344|
000540  a139              ADR      r1,|L14.1576|
000542  f2af1044          ADR      r0,|L14.1024|
000546  f7fffffe          BL       __2printf
                  |L14.1354|
00054a  6860              LDR      r0,[r4,#4]            ;700
00054c  990c              LDR      r1,[sp,#0x30]         ;700
00054e  f7fffffe          BL       pbuf_cat
000552  980c              LDR      r0,[sp,#0x30]         ;701
000554  8921              LDRH     r1,[r4,#8]            ;701
000556  8900              LDRH     r0,[r0,#8]            ;701
000558  4408              ADD      r0,r0,r1              ;701
00055a  8120              STRH     r0,[r4,#8]            ;701
00055c  e023              B        |L14.1446|
                  |L14.1374|
00055e  9807              LDR      r0,[sp,#0x1c]         ;702
000560  b308              CBZ      r0,|L14.1446|
000562  b10c              CBZ      r4,|L14.1384|
000564  6860              LDR      r0,[r4,#4]            ;704
000566  b940              CBNZ     r0,|L14.1402|
                  |L14.1384|
000568  f2af13d4          ADR      r3,|L14.920|
00056c  f44f7230          MOV      r2,#0x2c0             ;704
000570  a13b              ADR      r1,|L14.1632|
000572  f2af1074          ADR      r0,|L14.1024|
000576  f7fffffe          BL       __2printf
                  |L14.1402|
00057a  6860              LDR      r0,[r4,#4]            ;706
00057c  e004              B        |L14.1416|
                  |L14.1406|
00057e  8903              LDRH     r3,[r0,#8]            ;707
000580  9a07              LDR      r2,[sp,#0x1c]         ;707
000582  441a              ADD      r2,r2,r3              ;707
000584  8102              STRH     r2,[r0,#8]            ;707
000586  4608              MOV      r0,r1                 ;706
                  |L14.1416|
000588  6801              LDR      r1,[r0,#0]            ;706
00058a  2900              CMP      r1,#0                 ;706
00058c  d1f7              BNE      |L14.1406|
00058e  8902              LDRH     r2,[r0,#8]            ;709
000590  9907              LDR      r1,[sp,#0x1c]         ;709
000592  4411              ADD      r1,r1,r2              ;709
000594  8101              STRH     r1,[r0,#8]            ;709
000596  8942              LDRH     r2,[r0,#0xa]          ;710
000598  9907              LDR      r1,[sp,#0x1c]         ;710
00059a  4411              ADD      r1,r1,r2              ;710
00059c  8141              STRH     r1,[r0,#0xa]          ;710
00059e  8921              LDRH     r1,[r4,#8]            ;711
0005a0  9807              LDR      r0,[sp,#0x1c]         ;711
0005a2  4408              ADD      r0,r0,r1              ;711
0005a4  8120              STRH     r0,[r4,#8]            ;711
                  |L14.1446|
0005a6  b194              CBZ      r4,|L14.1486|
0005a8  f8c4b000          STR      r11,[r4,#0]           ;735
                  |L14.1452|
0005ac  6da8              LDR      r0,[r5,#0x58]         ;741
0005ae  4440              ADD      r0,r0,r8              ;741
0005b0  65a8              STR      r0,[r5,#0x58]         ;741
0005b2  f8b50060          LDRH     r0,[r5,#0x60]         ;742
0005b6  eba00008          SUB      r0,r0,r8              ;742
0005ba  f8a50060          STRH     r0,[r5,#0x60]         ;742
0005be  f8a59062          STRH     r9,[r5,#0x62]         ;743
0005c2  f1b90f00          CMP      r9,#0                 ;747
0005c6  d010              BEQ      |L14.1514|
0005c8  6ee8              LDR      r0,[r5,#0x6c]         ;748
0005ca  b118              CBZ      r0,|L14.1492|
0005cc  e00d              B        |L14.1514|
                  |L14.1486|
0005ce  f8c5b068          STR      r11,[r5,#0x68]        ;733
0005d2  e7eb              B        |L14.1452|
                  |L14.1492|
0005d4  6ea8              LDR      r0,[r5,#0x68]         ;748
0005d6  b940              CBNZ     r0,|L14.1514|
0005d8  f2af2344          ADR      r3,|L14.920|
0005dc  f44f723b          MOV      r2,#0x2ec             ;748
0005e0  a12d              ADR      r1,|L14.1688|
0005e2  f2af10e4          ADR      r0,|L14.1024|
0005e6  f7fffffe          BL       __2printf
                  |L14.1514|
0005ea  b167              CBZ      r7,|L14.1542|
0005ec  68f8              LDR      r0,[r7,#0xc]          ;753
0005ee  b150              CBZ      r0,|L14.1542|
0005f0  9810              LDR      r0,[sp,#0x40]         ;753
0005f2  0780              LSLS     r0,r0,#30             ;753
0005f4  d407              BMI      |L14.1542|
0005f6  2008              MOVS     r0,#8                 ;754
0005f8  f7fffffe          BL       lwip_htons
0005fc  4601              MOV      r1,r0                 ;754
0005fe  68f8              LDR      r0,[r7,#0xc]          ;754
000600  8982              LDRH     r2,[r0,#0xc]          ;754
000602  4311              ORRS     r1,r1,r2              ;754
000604  8181              STRH     r1,[r0,#0xc]          ;754
                  |L14.1542|
000606  2000              MOVS     r0,#0                 ;757
000608  e52f              B        |L14.106|
                  |L14.1546|
00060a  6ea8              LDR      r0,[r5,#0x68]         ;769
00060c  b940              CBNZ     r0,|L14.1568|
00060e  f2af2378          ADR      r3,|L14.920|
000612  f2403201          MOV      r2,#0x301             ;769
000616  a120              ADR      r1,|L14.1688|
000618  f2af201c          ADR      r0,|L14.1024|
00061c  f7fffffe          BL       __2printf
                  |L14.1568|
000620  f04f30ff          MOV      r0,#0xffffffff        ;773
000624  e521              B        |L14.106|
;;;775    
                          ENDP

000626  0000              DCW      0x0000
                  |L14.1576|
000628  7463705f          DCB      "tcp_write: cannot concatenate when pcb->unsent is empty"
00062c  77726974
000630  653a2063
000634  616e6e6f
000638  7420636f
00063c  6e636174
000640  656e6174
000644  65207768
000648  656e2070
00064c  63622d3e
000650  756e7365
000654  6e742069
000658  7320656d
00065c  707479  
00065f  00                DCB      0
                  |L14.1632|
000660  7463705f          DCB      "tcp_write: extension of reference requires reference",0
000664  77726974
000668  653a2065
00066c  7874656e
000670  73696f6e
000674  206f6620
000678  72656665
00067c  72656e63
000680  65207265
000684  71756972
000688  65732072
00068c  65666572
000690  656e6365
000694  00      
000695  00                DCB      0
000696  00                DCB      0
000697  00                DCB      0
                  |L14.1688|
000698  7463705f          DCB      "tcp_write: valid queue length",0
00069c  77726974
0006a0  653a2076
0006a4  616c6964
0006a8  20717565
0006ac  7565206c
0006b0  656e6774
0006b4  6800    
0006b6  00                DCB      0
0006b7  00                DCB      0

                          AREA ||i.tcp_write_checks||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_write_checks PROC
;;;306    static err_t
;;;307    tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
000000  b510              PUSH     {r4,lr}
;;;308    {
;;;309      /* connection is in invalid state for data transmission? */
;;;310      if ((pcb->state != ESTABLISHED) &&
000002  7d02              LDRB     r2,[r0,#0x14]
000004  2a04              CMP      r2,#4
000006  d008              BEQ      |L15.26|
;;;311          (pcb->state != CLOSE_WAIT) &&
000008  2a07              CMP      r2,#7
00000a  d006              BEQ      |L15.26|
;;;312          (pcb->state != SYN_SENT) &&
00000c  2a02              CMP      r2,#2
00000e  d004              BEQ      |L15.26|
;;;313          (pcb->state != SYN_RCVD)) {
000010  2a03              CMP      r2,#3
000012  d002              BEQ      |L15.26|
;;;314        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
;;;315        return ERR_CONN;
000014  f06f000a          MVN      r0,#0xa
;;;316      } else if (len == 0) {
;;;317        return ERR_OK;
;;;318      }
;;;319    
;;;320      /* fail on too much data */
;;;321      if (len > pcb->snd_buf) {
;;;322        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"TCPWNDSIZE_F")\n",
;;;323          len, pcb->snd_buf));
;;;324        pcb->flags |= TF_NAGLEMEMERR;
;;;325        return ERR_MEM;
;;;326      }
;;;327    
;;;328      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
;;;329    
;;;330      /* If total number of pbufs on the unsent/unacked queues exceeds the
;;;331       * configured maximum, return an error */
;;;332      /* check for configured max queuelen and possible overflow */
;;;333      if ((pcb->snd_queuelen >= TCP_SND_QUEUELEN) || (pcb->snd_queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
;;;334        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
;;;335          pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
;;;336        TCP_STATS_INC(tcp.memerr);
;;;337        pcb->flags |= TF_NAGLEMEMERR;
;;;338        return ERR_MEM;
;;;339      }
;;;340      if (pcb->snd_queuelen != 0) {
;;;341        LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
;;;342          pcb->unacked != NULL || pcb->unsent != NULL);
;;;343      } else {
;;;344        LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
;;;345          pcb->unacked == NULL && pcb->unsent == NULL);
;;;346      }
;;;347      return ERR_OK;
;;;348    }
000018  bd10              POP      {r4,pc}
                  |L15.26|
00001a  b159              CBZ      r1,|L15.52|
00001c  f8b02060          LDRH     r2,[r0,#0x60]         ;321
000020  f04f33ff          MOV      r3,#0xffffffff        ;325
000024  428a              CMP      r2,r1                 ;321
000026  d207              BCS      |L15.56|
000028  7e81              LDRB     r1,[r0,#0x1a]         ;324
00002a  f0410180          ORR      r1,r1,#0x80           ;324
00002e  7681              STRB     r1,[r0,#0x1a]         ;324
000030  4618              MOV      r0,r3                 ;325
000032  bd10              POP      {r4,pc}
                  |L15.52|
000034  2000              MOVS     r0,#0                 ;317
000036  bd10              POP      {r4,pc}
                  |L15.56|
000038  f8b01062          LDRH     r1,[r0,#0x62]         ;333
00003c  2909              CMP      r1,#9                 ;333
00003e  d204              BCS      |L15.74|
000040  2900              CMP      r1,#0                 ;340
000042  d013              BEQ      |L15.108|
000044  6ec1              LDR      r1,[r0,#0x6c]         ;341
000046  b131              CBZ      r1,|L15.86|
000048  e01b              B        |L15.130|
                  |L15.74|
00004a  7e81              LDRB     r1,[r0,#0x1a]         ;337
00004c  f0410180          ORR      r1,r1,#0x80           ;337
000050  7681              STRB     r1,[r0,#0x1a]         ;337
000052  4618              MOV      r0,r3                 ;338
000054  bd10              POP      {r4,pc}
                  |L15.86|
000056  6e80              LDR      r0,[r0,#0x68]         ;341
000058  2800              CMP      r0,#0                 ;341
00005a  d112              BNE      |L15.130|
00005c  a30a              ADR      r3,|L15.136|
00005e  f2401255          MOV      r2,#0x155             ;341
000062  a116              ADR      r1,|L15.188|
000064  a024              ADR      r0,|L15.248|
000066  f7fffffe          BL       __2printf
00006a  e00a              B        |L15.130|
                  |L15.108|
00006c  6ec1              LDR      r1,[r0,#0x6c]         ;344
00006e  b909              CBNZ     r1,|L15.116|
000070  6e80              LDR      r0,[r0,#0x68]         ;344
000072  b130              CBZ      r0,|L15.130|
                  |L15.116|
000074  a304              ADR      r3,|L15.136|
000076  f44f72ac          MOV      r2,#0x158             ;344
00007a  a129              ADR      r1,|L15.288|
00007c  a01e              ADR      r0,|L15.248|
00007e  f7fffffe          BL       __2printf
                  |L15.130|
000082  2000              MOVS     r0,#0                 ;347
000084  bd10              POP      {r4,pc}
;;;349    
                          ENDP

000086  0000              DCW      0x0000
                  |L15.136|
000088  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
00008c  6964646c
000090  65776172
000094  65735c54
000098  68697264
00009c  5f506172
0000a0  74795c4c
0000a4  7749505c
0000a8  7372635c
0000ac  636f7265
0000b0  5c746370
0000b4  5f6f7574
0000b8  2e      
0000b9  6300              DCB      "c",0
0000bb  00                DCB      0
                  |L15.188|
0000bc  7463705f          DCB      "tcp_write: pbufs on queue => at least one queue non-emp"
0000c0  77726974
0000c4  653a2070
0000c8  62756673
0000cc  206f6e20
0000d0  71756575
0000d4  65203d3e
0000d8  20617420
0000dc  6c656173
0000e0  74206f6e
0000e4  65207175
0000e8  65756520
0000ec  6e6f6e2d
0000f0  656d70  
0000f3  747900            DCB      "ty",0
0000f6  00                DCB      0
0000f7  00                DCB      0
                  |L15.248|
0000f8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000fc  7274696f
000100  6e202225
000104  73222066
000108  61696c65
00010c  64206174
000110  206c696e
000114  65202564
000118  20696e20
00011c  25730a00
                  |L15.288|
000120  7463705f          DCB      "tcp_write: no pbufs on queue => both queues empty",0
000124  77726974
000128  653a206e
00012c  6f207062
000130  75667320
000134  6f6e2071
000138  75657565
00013c  203d3e20
000140  626f7468
000144  20717565
000148  75657320
00014c  656d7074
000150  7900    
000152  00                DCB      0
000153  00                DCB      0

                          AREA ||i.tcp_zero_window_probe||, CODE, READONLY, ALIGN=1

                  tcp_zero_window_probe PROC
;;;1585   err_t
;;;1586   tcp_zero_window_probe(struct tcp_pcb *pcb)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;1587   {
000004  4605              MOV      r5,r0
;;;1588     err_t err;
;;;1589     struct pbuf *p;
;;;1590     struct tcp_hdr *tcphdr;
;;;1591     struct tcp_seg *seg;
;;;1592     u16_t len;
;;;1593     u8_t is_fin;
;;;1594     u32_t snd_nxt;
;;;1595     struct netif *netif;
;;;1596   
;;;1597     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: sending ZERO WINDOW probe to "));
;;;1598     ip_addr_debug_print(TCP_DEBUG, &pcb->remote_ip);
;;;1599     LWIP_DEBUGF(TCP_DEBUG, ("\n"));
;;;1600   
;;;1601     LWIP_DEBUGF(TCP_DEBUG,
;;;1602                 ("tcp_zero_window_probe: tcp_ticks %"U32_F
;;;1603                  "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
;;;1604                  tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));
;;;1605   
;;;1606     seg = pcb->unacked;
000006  6eec              LDR      r4,[r5,#0x6c]
;;;1607   
;;;1608     if (seg == NULL) {
000008  2c00              CMP      r4,#0
00000a  d100              BNE      |L16.14|
;;;1609       seg = pcb->unsent;
00000c  6eac              LDR      r4,[r5,#0x68]
                  |L16.14|
;;;1610     }
;;;1611     if (seg == NULL) {
00000e  b31c              CBZ      r4,|L16.88|
;;;1612       /* nothing to send, zero window probe not needed */
;;;1613       return ERR_OK;
;;;1614     }
;;;1615   
;;;1616     is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
000010  68e0              LDR      r0,[r4,#0xc]
000012  8980              LDRH     r0,[r0,#0xc]
000014  f7fffffe          BL       lwip_htons
000018  07c0              LSLS     r0,r0,#31
00001a  d001              BEQ      |L16.32|
00001c  8920              LDRH     r0,[r4,#8]
00001e  b1f0              CBZ      r0,|L16.94|
                  |L16.32|
000020  f04f0800          MOV      r8,#0
                  |L16.36|
;;;1617     /* we want to send one seqno: either FIN or data (no options) */
;;;1618     len = is_fin ? 0 : 1;
000024  f1b80f00          CMP      r8,#0
000028  d01c              BEQ      |L16.100|
00002a  2200              MOVS     r2,#0
                  |L16.44|
;;;1619   
;;;1620     p = tcp_output_alloc_header(pcb, 0, len, seg->tcphdr->seqno);
00002c  68e0              LDR      r0,[r4,#0xc]
00002e  2100              MOVS     r1,#0
000030  6843              LDR      r3,[r0,#4]
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       tcp_output_alloc_header
000038  4607              MOV      r7,r0
;;;1621     if (p == NULL) {
00003a  0038              MOVS     r0,r7
00003c  d014              BEQ      |L16.104|
;;;1622       LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
;;;1623       return ERR_MEM;
;;;1624     }
;;;1625     tcphdr = (struct tcp_hdr *)p->payload;
00003e  687e              LDR      r6,[r7,#4]
;;;1626   
;;;1627     if (is_fin) {
000040  f1b80f00          CMP      r8,#0
000044  d013              BEQ      |L16.110|
;;;1628       /* FIN segment, no data */
;;;1629       TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
000046  2011              MOVS     r0,#0x11
000048  f7fffffe          BL       lwip_htons
00004c  89b1              LDRH     r1,[r6,#0xc]
00004e  f421517c          BIC      r1,r1,#0x3f00
000052  4308              ORRS     r0,r0,r1
000054  81b0              STRH     r0,[r6,#0xc]
000056  e014              B        |L16.130|
                  |L16.88|
000058  2000              MOVS     r0,#0                 ;1613
                  |L16.90|
;;;1630     } else {
;;;1631       /* Data segment, copy in one byte from the head of the unacked queue */
;;;1632       char *d = ((char *)p->payload + TCP_HLEN);
;;;1633       /* Depending on whether the segment has already been sent (unacked) or not
;;;1634          (unsent), seg->p->payload points to the IP header or TCP header.
;;;1635          Ensure we copy the first TCP data byte: */
;;;1636       pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
;;;1637     }
;;;1638   
;;;1639     /* The byte may be acknowledged without the window being opened. */
;;;1640     snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
;;;1641     if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
;;;1642       pcb->snd_nxt = snd_nxt;
;;;1643     }
;;;1644   
;;;1645     netif = ip_route(&pcb->local_ip, &pcb->remote_ip);
;;;1646     if (netif == NULL) {
;;;1647       err = ERR_RTE;
;;;1648     } else {
;;;1649   #if CHECKSUM_GEN_TCP
;;;1650       IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
;;;1651         tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
;;;1652           &pcb->local_ip, &pcb->remote_ip);
;;;1653       }
;;;1654   #endif
;;;1655       TCP_STATS_INC(tcp.xmit);
;;;1656   
;;;1657       /* Send output to IP */
;;;1658       NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
;;;1659       err = ip_output_if(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
;;;1660         0, IP_PROTO_TCP, netif);
;;;1661       NETIF_SET_HWADDRHINT(netif, NULL);
;;;1662     }
;;;1663   
;;;1664     pbuf_free(p);
;;;1665   
;;;1666     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
;;;1667                             " ackno %"U32_F" err %d.\n",
;;;1668                             pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
;;;1669     return err;
;;;1670   }
00005a  e8bd83fe          POP      {r1-r9,pc}
                  |L16.94|
00005e  f04f0801          MOV      r8,#1                 ;1616
000062  e7df              B        |L16.36|
                  |L16.100|
000064  2201              MOVS     r2,#1                 ;1618
000066  e7e1              B        |L16.44|
                  |L16.104|
000068  f04f30ff          MOV      r0,#0xffffffff        ;1623
00006c  e7f5              B        |L16.90|
                  |L16.110|
00006e  f1060114          ADD      r1,r6,#0x14           ;1632
000072  6860              LDR      r0,[r4,#4]            ;1636
000074  8923              LDRH     r3,[r4,#8]            ;1636
000076  8902              LDRH     r2,[r0,#8]            ;1636
000078  1ad2              SUBS     r2,r2,r3              ;1636
00007a  b293              UXTH     r3,r2                 ;1636
00007c  2201              MOVS     r2,#1                 ;1636
00007e  f7fffffe          BL       pbuf_copy_partial
                  |L16.130|
000082  68e0              LDR      r0,[r4,#0xc]          ;1640
000084  6840              LDR      r0,[r0,#4]            ;1640
000086  f7fffffe          BL       lwip_htonl
00008a  1c40              ADDS     r0,r0,#1              ;1640
00008c  6ce9              LDR      r1,[r5,#0x4c]         ;1641
00008e  1a09              SUBS     r1,r1,r0              ;1641
000090  d500              BPL      |L16.148|
000092  64e8              STR      r0,[r5,#0x4c]         ;1642
                  |L16.148|
000094  1d28              ADDS     r0,r5,#4              ;1645
000096  f7fffffe          BL       ip4_route
00009a  b180              CBZ      r0,|L16.190|
00009c  2106              MOVS     r1,#6                 ;1659
00009e  2200              MOVS     r2,#0                 ;1659
0000a0  e9cd2100          STRD     r2,r1,[sp,#0]         ;1659
0000a4  9002              STR      r0,[sp,#8]            ;1659
0000a6  7aab              LDRB     r3,[r5,#0xa]          ;1659
0000a8  1d2a              ADDS     r2,r5,#4              ;1659
0000aa  4629              MOV      r1,r5                 ;1659
0000ac  4638              MOV      r0,r7                 ;1659
0000ae  f7fffffe          BL       ip4_output_if
0000b2  4604              MOV      r4,r0                 ;1659
                  |L16.180|
0000b4  4638              MOV      r0,r7                 ;1664
0000b6  f7fffffe          BL       pbuf_free
0000ba  4620              MOV      r0,r4                 ;1669
0000bc  e7cd              B        |L16.90|
                  |L16.190|
0000be  f06f0403          MVN      r4,#3                 ;1647
0000c2  e7f7              B        |L16.180|
;;;1671   #endif /* LWIP_TCP */
                          ENDP


                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  7463705f          DCB      "tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in fl"
000004  656e7175
000008  6575655f
00000c  666c6167
000010  733a206e
000014  65656420
000018  65697468
00001c  65722054
000020  43505f53
000024  594e206f
000028  72205443
00002c  505f4649
000030  4e20696e
000034  20666c  
000037  61677320          DCB      "ags (programmer violates API)",0
00003b  2870726f
00003f  6772616d
000043  6d657220
000047  76696f6c
00004b  61746573
00004f  20415049
000053  2900    

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_tcp_out_c_aa11f9a3____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_tcp_out_c_aa11f9a3____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_tcp_out_c_aa11f9a3____REVSH|
#line 478
|__asm___9_tcp_out_c_aa11f9a3____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_tcp_out_c_aa11f9a3____RRX|
#line 665
|__asm___9_tcp_out_c_aa11f9a3____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
