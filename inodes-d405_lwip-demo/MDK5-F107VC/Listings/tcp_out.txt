; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\tcp_out.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\tcp_out.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\tcp_out.crf ..\Middlewares\Third_Party\LwIP\src\core\tcp_out.c]
                          THUMB

                          AREA ||i.tcp_create_segment||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_create_segment PROC
;;;157    static struct tcp_seg *
;;;158    tcp_create_segment(const struct tcp_pcb *pcb, struct pbuf *p, u8_t hdrflags, u32_t seqno, u8_t optflags)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;159    {
000004  f8dd8020          LDR      r8,[sp,#0x20]
000008  4607              MOV      r7,r0
00000a  460d              MOV      r5,r1
00000c  4691              MOV      r9,r2
00000e  469a              MOV      r10,r3
;;;160      struct tcp_seg *seg;
;;;161      u8_t optlen;
;;;162    
;;;163      LWIP_ASSERT("tcp_create_segment: invalid pcb", pcb != NULL);
000010  2f00              CMP      r7,#0
000012  d105              BNE      |L1.32|
000014  a32f              ADR      r3,|L1.212|
000016  22a3              MOVS     r2,#0xa3
000018  a13b              ADR      r1,|L1.264|
00001a  a043              ADR      r0,|L1.296|
00001c  f7fffffe          BL       __2printf
                  |L1.32|
;;;164      LWIP_ASSERT("tcp_create_segment: invalid pbuf", p != NULL);
000020  2d00              CMP      r5,#0
000022  d105              BNE      |L1.48|
000024  a32b              ADR      r3,|L1.212|
000026  22a4              MOVS     r2,#0xa4
000028  a149              ADR      r1,|L1.336|
00002a  a03f              ADR      r0,|L1.296|
00002c  f7fffffe          BL       __2printf
                  |L1.48|
;;;165    
;;;166      optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
000030  ea5f70c8          LSLS     r0,r8,#31
000034  d001              BEQ      |L1.58|
000036  2604              MOVS     r6,#4
000038  e000              B        |L1.60|
                  |L1.58|
00003a  2600              MOVS     r6,#0
                  |L1.60|
;;;167    
;;;168      if ((seg = (struct tcp_seg *)memp_malloc(MEMP_TCP_SEG)) == NULL) {
00003c  2003              MOVS     r0,#3
00003e  f7fffffe          BL       memp_malloc
000042  1e04              SUBS     r4,r0,#0
000044  d01d              BEQ      |L1.130|
;;;169        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no memory.\n"));
;;;170        pbuf_free(p);
;;;171        return NULL;
;;;172      }
;;;173      seg->flags = optflags;
000046  f884800a          STRB     r8,[r4,#0xa]
;;;174      seg->next = NULL;
00004a  f04f0800          MOV      r8,#0
00004e  f8c48000          STR      r8,[r4,#0]
;;;175      seg->p = p;
000052  6065              STR      r5,[r4,#4]
;;;176      LWIP_ASSERT("p->tot_len >= optlen", p->tot_len >= optlen);
000054  8928              LDRH     r0,[r5,#8]
000056  42b0              CMP      r0,r6
000058  d205              BCS      |L1.102|
00005a  a31e              ADR      r3,|L1.212|
00005c  22b0              MOVS     r2,#0xb0
00005e  a145              ADR      r1,|L1.372|
000060  a031              ADR      r0,|L1.296|
000062  f7fffffe          BL       __2printf
                  |L1.102|
;;;177      seg->len = p->tot_len - optlen;
000066  8928              LDRH     r0,[r5,#8]
000068  1b80              SUBS     r0,r0,r6
00006a  8120              STRH     r0,[r4,#8]
;;;178    #if TCP_OVERSIZE_DBGCHECK
;;;179      seg->oversize_left = 0;
;;;180    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;181    #if TCP_CHECKSUM_ON_COPY
;;;182      seg->chksum = 0;
;;;183      seg->chksum_swapped = 0;
;;;184      /* check optflags */
;;;185      LWIP_ASSERT("invalid optflags passed: TF_SEG_DATA_CHECKSUMMED",
;;;186                  (optflags & TF_SEG_DATA_CHECKSUMMED) == 0);
;;;187    #endif /* TCP_CHECKSUM_ON_COPY */
;;;188    
;;;189      /* build TCP header */
;;;190      if (pbuf_add_header(p, TCP_HLEN)) {
00006c  2114              MOVS     r1,#0x14
00006e  4628              MOV      r0,r5
000070  f7fffffe          BL       pbuf_add_header
000074  b150              CBZ      r0,|L1.140|
;;;191        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_create_segment: no room for TCP header in pbuf.\n"));
;;;192        TCP_STATS_INC(tcp.err);
;;;193        tcp_seg_free(seg);
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       tcp_seg_free
;;;194        return NULL;
00007c  2000              MOVS     r0,#0
                  |L1.126|
;;;195      }
;;;196      seg->tcphdr = (struct tcp_hdr *)seg->p->payload;
;;;197      seg->tcphdr->src = lwip_htons(pcb->local_port);
;;;198      seg->tcphdr->dest = lwip_htons(pcb->remote_port);
;;;199      seg->tcphdr->seqno = lwip_htonl(seqno);
;;;200      /* ackno is set in tcp_output */
;;;201      TCPH_HDRLEN_FLAGS_SET(seg->tcphdr, (5 + optlen / 4), hdrflags);
;;;202      /* wnd and chksum are set in tcp_output */
;;;203      seg->tcphdr->urgp = 0;
;;;204      return seg;
;;;205    }
00007e  e8bd87f0          POP      {r4-r10,pc}
                  |L1.130|
000082  4628              MOV      r0,r5                 ;170
000084  f7fffffe          BL       pbuf_free
000088  2000              MOVS     r0,#0                 ;171
00008a  e7f8              B        |L1.126|
                  |L1.140|
00008c  6860              LDR      r0,[r4,#4]            ;196
00008e  6840              LDR      r0,[r0,#4]            ;196
000090  60e0              STR      r0,[r4,#0xc]          ;196
000092  8af8              LDRH     r0,[r7,#0x16]         ;197
000094  f7fffffe          BL       lwip_htons
000098  68e1              LDR      r1,[r4,#0xc]          ;197
00009a  8008              STRH     r0,[r1,#0]            ;197
00009c  8b38              LDRH     r0,[r7,#0x18]         ;198
00009e  f7fffffe          BL       lwip_htons
0000a2  68e1              LDR      r1,[r4,#0xc]          ;198
0000a4  8048              STRH     r0,[r1,#2]            ;198
0000a6  4650              MOV      r0,r10                ;199
0000a8  f7fffffe          BL       lwip_htonl
0000ac  68e1              LDR      r1,[r4,#0xc]          ;199
0000ae  6048              STR      r0,[r1,#4]            ;199
0000b0  2005              MOVS     r0,#5                 ;201
0000b2  eb000096          ADD      r0,r0,r6,LSR #2       ;201
0000b6  f64f71ff          MOV      r1,#0xffff            ;201
0000ba  ea013000          AND      r0,r1,r0,LSL #12      ;201
0000be  ea400009          ORR      r0,r0,r9              ;201
0000c2  f7fffffe          BL       lwip_htons
0000c6  68e1              LDR      r1,[r4,#0xc]          ;201
0000c8  8188              STRH     r0,[r1,#0xc]          ;201
0000ca  68e0              LDR      r0,[r4,#0xc]          ;203
0000cc  f8a08012          STRH     r8,[r0,#0x12]         ;203
0000d0  4620              MOV      r0,r4                 ;204
0000d2  e7d4              B        |L1.126|
;;;206    
                          ENDP

                  |L1.212|
0000d4  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
0000d8  6964646c
0000dc  65776172
0000e0  65735c54
0000e4  68697264
0000e8  5f506172
0000ec  74795c4c
0000f0  7749505c
0000f4  7372635c
0000f8  636f7265
0000fc  5c746370
000100  5f6f7574
000104  2e      
000105  6300              DCB      "c",0
000107  00                DCB      0
                  |L1.264|
000108  7463705f          DCB      "tcp_create_segment: invalid pcb",0
00010c  63726561
000110  74655f73
000114  65676d65
000118  6e743a20
00011c  696e7661
000120  6c696420
000124  70636200
                  |L1.296|
000128  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00012c  7274696f
000130  6e202225
000134  73222066
000138  61696c65
00013c  64206174
000140  206c696e
000144  65202564
000148  20696e20
00014c  25730a00
                  |L1.336|
000150  7463705f          DCB      "tcp_create_segment: invalid pbuf",0
000154  63726561
000158  74655f73
00015c  65676d65
000160  6e743a20
000164  696e7661
000168  6c696420
00016c  70627566
000170  00      
000171  00                DCB      0
000172  00                DCB      0
000173  00                DCB      0
                  |L1.372|
000174  702d3e74          DCB      "p->tot_len >= optlen",0
000178  6f745f6c
00017c  656e203e
000180  3d206f70
000184  746c656e
000188  00      
000189  00                DCB      0
00018a  00                DCB      0
00018b  00                DCB      0

                          AREA ||i.tcp_enqueue_flags||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_enqueue_flags PROC
;;;1031   err_t
;;;1032   tcp_enqueue_flags(struct tcp_pcb *pcb, u8_t flags)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1033   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1034     struct pbuf *p;
;;;1035     struct tcp_seg *seg;
;;;1036     u8_t optflags = 0;
000008  2500              MOVS     r5,#0
;;;1037     u8_t optlen = 0;
;;;1038   
;;;1039     LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));
;;;1040   
;;;1041     LWIP_ASSERT("tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in flags (programmer violates API)",
00000a  07b0              LSLS     r0,r6,#30
00000c  d106              BNE      |L2.28|
00000e  a345              ADR      r3,|L2.292|
000010  f2404211          MOV      r2,#0x411
000014  4950              LDR      r1,|L2.344|
000016  a051              ADR      r0,|L2.348|
000018  f7fffffe          BL       __2printf
                  |L2.28|
;;;1042                 (flags & (TCP_SYN | TCP_FIN)) != 0);
;;;1043     LWIP_ASSERT("tcp_enqueue_flags: invalid pcb", pcb != NULL);
00001c  2c00              CMP      r4,#0
00001e  d106              BNE      |L2.46|
000020  a340              ADR      r3,|L2.292|
000022  f2404213          MOV      r2,#0x413
000026  a157              ADR      r1,|L2.388|
000028  a04c              ADR      r0,|L2.348|
00002a  f7fffffe          BL       __2printf
                  |L2.46|
;;;1044   
;;;1045     /* No need to check pcb->snd_queuelen if only SYN or FIN are allowed! */
;;;1046   
;;;1047     /* Get options for this segment. This is a special case since this is the
;;;1048        only place where a SYN can be sent. */
;;;1049     if (flags & TCP_SYN) {
00002e  07b0              LSLS     r0,r6,#30
000030  d500              BPL      |L2.52|
;;;1050       optflags = TF_SEG_OPTS_MSS;
000032  2501              MOVS     r5,#1
                  |L2.52|
;;;1051   #if LWIP_WND_SCALE
;;;1052       if ((pcb->state != SYN_RCVD) || (pcb->flags & TF_WND_SCALE)) {
;;;1053         /* In a <SYN,ACK> (sent in state SYN_RCVD), the window scale option may only
;;;1054            be sent if we received a window scale option from the remote host. */
;;;1055         optflags |= TF_SEG_OPTS_WND_SCALE;
;;;1056       }
;;;1057   #endif /* LWIP_WND_SCALE */
;;;1058   #if LWIP_TCP_SACK_OUT
;;;1059       if ((pcb->state != SYN_RCVD) || (pcb->flags & TF_SACK)) {
;;;1060         /* In a <SYN,ACK> (sent in state SYN_RCVD), the SACK_PERM option may only
;;;1061            be sent if we received a SACK_PERM option from the remote host. */
;;;1062         optflags |= TF_SEG_OPTS_SACK_PERM;
;;;1063       }
;;;1064   #endif /* LWIP_TCP_SACK_OUT */
;;;1065     }
;;;1066   #if LWIP_TCP_TIMESTAMPS
;;;1067     if ((pcb->flags & TF_TIMESTAMP) || ((flags & TCP_SYN) && (pcb->state != SYN_RCVD))) {
;;;1068       /* Make sure the timestamp option is only included in data segments if we
;;;1069          agreed about it with the remote host (and in active open SYN segments). */
;;;1070       optflags |= TF_SEG_OPTS_TS;
;;;1071     }
;;;1072   #endif /* LWIP_TCP_TIMESTAMPS */
;;;1073     optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
000034  07e8              LSLS     r0,r5,#31
000036  d001              BEQ      |L2.60|
000038  2704              MOVS     r7,#4
00003a  e000              B        |L2.62|
                  |L2.60|
00003c  2700              MOVS     r7,#0
                  |L2.62|
;;;1074   
;;;1075     /* Allocate pbuf with room for TCP header + options */
;;;1076     if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
00003e  f44f7220          MOV      r2,#0x280
000042  4639              MOV      r1,r7
000044  2036              MOVS     r0,#0x36
000046  f7fffffe          BL       pbuf_alloc
00004a  f1b00900          SUBS     r9,r0,#0
;;;1077       tcp_set_flags(pcb, TF_NAGLEMEMERR);
;;;1078       TCP_STATS_INC(tcp.memerr);
;;;1079       return ERR_MEM;
00004e  f04f38ff          MOV      r8,#0xffffffff
000052  d02a              BEQ      |L2.170|
;;;1080     }
;;;1081     LWIP_ASSERT("tcp_enqueue_flags: check that first pbuf can hold optlen",
000054  f8b9000a          LDRH     r0,[r9,#0xa]
000058  42b8              CMP      r0,r7
00005a  d206              BCS      |L2.106|
00005c  a331              ADR      r3,|L2.292|
00005e  f2404239          MOV      r2,#0x439
000062  a150              ADR      r1,|L2.420|
000064  a03d              ADR      r0,|L2.348|
000066  f7fffffe          BL       __2printf
                  |L2.106|
;;;1082                 (p->len >= optlen));
;;;1083   
;;;1084     /* Allocate memory for tcp_seg, and fill in fields. */
;;;1085     if ((seg = tcp_create_segment(pcb, p, flags, pcb->snd_lbb, optflags)) == NULL) {
00006a  9500              STR      r5,[sp,#0]
00006c  4632              MOV      r2,r6
00006e  4649              MOV      r1,r9
000070  4620              MOV      r0,r4
000072  6de3              LDR      r3,[r4,#0x5c]
000074  f7fffffe          BL       tcp_create_segment
000078  1e05              SUBS     r5,r0,#0
00007a  d01d              BEQ      |L2.184|
;;;1086       tcp_set_flags(pcb, TF_NAGLEMEMERR);
;;;1087       TCP_STATS_INC(tcp.memerr);
;;;1088       return ERR_MEM;
;;;1089     }
;;;1090     LWIP_ASSERT("seg->tcphdr not aligned", ((mem_ptr_t)seg->tcphdr % LWIP_MIN(MEM_ALIGNMENT, 4)) == 0);
00007c  7b28              LDRB     r0,[r5,#0xc]
00007e  0780              LSLS     r0,r0,#30
000080  d006              BEQ      |L2.144|
000082  a328              ADR      r3,|L2.292|
000084  f2404242          MOV      r2,#0x442
000088  a155              ADR      r1,|L2.480|
00008a  a034              ADR      r0,|L2.348|
00008c  f7fffffe          BL       __2printf
                  |L2.144|
;;;1091     LWIP_ASSERT("tcp_enqueue_flags: invalid segment length", seg->len == 0);
000090  8928              LDRH     r0,[r5,#8]
000092  2800              CMP      r0,#0
000094  d006              BEQ      |L2.164|
000096  a323              ADR      r3,|L2.292|
000098  f2404243          MOV      r2,#0x443
00009c  a156              ADR      r1,|L2.504|
00009e  a02f              ADR      r0,|L2.348|
0000a0  f7fffffe          BL       __2printf
                  |L2.164|
;;;1092   
;;;1093     LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE,
;;;1094                 ("tcp_enqueue_flags: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
;;;1095                  lwip_ntohl(seg->tcphdr->seqno),
;;;1096                  lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
;;;1097                  (u16_t)flags));
;;;1098   
;;;1099     /* Now append seg to pcb->unsent queue */
;;;1100     if (pcb->unsent == NULL) {
0000a4  6ee0              LDR      r0,[r4,#0x6c]
0000a6  b168              CBZ      r0,|L2.196|
0000a8  e00f              B        |L2.202|
                  |L2.170|
0000aa  8b60              LDRH     r0,[r4,#0x1a]         ;1077
0000ac  f0400080          ORR      r0,r0,#0x80           ;1077
0000b0  8360              STRH     r0,[r4,#0x1a]         ;1077
0000b2  4640              MOV      r0,r8                 ;1079
                  |L2.180|
;;;1101       pcb->unsent = seg;
;;;1102     } else {
;;;1103       struct tcp_seg *useg;
;;;1104       for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
;;;1105       useg->next = seg;
;;;1106     }
;;;1107   #if TCP_OVERSIZE
;;;1108     /* The new unsent tail has no space */
;;;1109     pcb->unsent_oversize = 0;
;;;1110   #endif /* TCP_OVERSIZE */
;;;1111   
;;;1112     /* SYN and FIN bump the sequence number */
;;;1113     if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
;;;1114       pcb->snd_lbb++;
;;;1115       /* optlen does not influence snd_buf */
;;;1116     }
;;;1117     if (flags & TCP_FIN) {
;;;1118       tcp_set_flags(pcb, TF_FIN);
;;;1119     }
;;;1120   
;;;1121     /* update number of segments on the queues */
;;;1122     pcb->snd_queuelen += pbuf_clen(seg->p);
;;;1123     LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue_flags: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
;;;1124     if (pcb->snd_queuelen != 0) {
;;;1125       LWIP_ASSERT("tcp_enqueue_flags: invalid queue length",
;;;1126                   pcb->unacked != NULL || pcb->unsent != NULL);
;;;1127     }
;;;1128   
;;;1129     return ERR_OK;
;;;1130   }
0000b4  e8bd83f8          POP      {r3-r9,pc}
                  |L2.184|
0000b8  8b60              LDRH     r0,[r4,#0x1a]         ;1086
0000ba  f0400080          ORR      r0,r0,#0x80           ;1086
0000be  8360              STRH     r0,[r4,#0x1a]         ;1086
0000c0  4640              MOV      r0,r8                 ;1088
0000c2  e7f7              B        |L2.180|
                  |L2.196|
0000c4  66e5              STR      r5,[r4,#0x6c]         ;1101
0000c6  e004              B        |L2.210|
                  |L2.200|
0000c8  4608              MOV      r0,r1                 ;1104
                  |L2.202|
0000ca  6801              LDR      r1,[r0,#0]            ;1104
0000cc  2900              CMP      r1,#0                 ;1104
0000ce  d1fb              BNE      |L2.200|
0000d0  6005              STR      r5,[r0,#0]            ;1105
                  |L2.210|
0000d2  2000              MOVS     r0,#0                 ;1109
0000d4  f8a40068          STRH     r0,[r4,#0x68]         ;1109
0000d8  f0060002          AND      r0,r6,#2              ;1113
0000dc  f0060101          AND      r1,r6,#1              ;1113
0000e0  4308              ORRS     r0,r0,r1              ;1113
0000e2  d002              BEQ      |L2.234|
0000e4  6de0              LDR      r0,[r4,#0x5c]         ;1114
0000e6  1c40              ADDS     r0,r0,#1              ;1114
0000e8  65e0              STR      r0,[r4,#0x5c]         ;1114
                  |L2.234|
0000ea  07f0              LSLS     r0,r6,#31             ;1117
0000ec  d003              BEQ      |L2.246|
0000ee  8b60              LDRH     r0,[r4,#0x1a]         ;1118
0000f0  f0400020          ORR      r0,r0,#0x20           ;1118
0000f4  8360              STRH     r0,[r4,#0x1a]         ;1118
                  |L2.246|
0000f6  6868              LDR      r0,[r5,#4]            ;1122
0000f8  f7fffffe          BL       pbuf_clen
0000fc  f8b41066          LDRH     r1,[r4,#0x66]         ;1122
000100  4408              ADD      r0,r0,r1              ;1122
000102  b280              UXTH     r0,r0                 ;1122
000104  f8a40066          STRH     r0,[r4,#0x66]         ;1122
000108  b150              CBZ      r0,|L2.288|
00010a  6f20              LDR      r0,[r4,#0x70]         ;1125
00010c  b940              CBNZ     r0,|L2.288|
00010e  6ee0              LDR      r0,[r4,#0x6c]         ;1125
000110  b930              CBNZ     r0,|L2.288|
000112  a304              ADR      r3,|L2.292|
000114  f2404265          MOV      r2,#0x465             ;1125
000118  a142              ADR      r1,|L2.548|
00011a  a010              ADR      r0,|L2.348|
00011c  f7fffffe          BL       __2printf
                  |L2.288|
000120  2000              MOVS     r0,#0                 ;1129
000122  e7c7              B        |L2.180|
;;;1131   
                          ENDP

                  |L2.292|
000124  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000128  6964646c
00012c  65776172
000130  65735c54
000134  68697264
000138  5f506172
00013c  74795c4c
000140  7749505c
000144  7372635c
000148  636f7265
00014c  5c746370
000150  5f6f7574
000154  2e      
000155  6300              DCB      "c",0
000157  00                DCB      0
                  |L2.344|
                          DCD      ||.conststring||
                  |L2.348|
00015c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000160  7274696f
000164  6e202225
000168  73222066
00016c  61696c65
000170  64206174
000174  206c696e
000178  65202564
00017c  20696e20
000180  25730a00
                  |L2.388|
000184  7463705f          DCB      "tcp_enqueue_flags: invalid pcb",0
000188  656e7175
00018c  6575655f
000190  666c6167
000194  733a2069
000198  6e76616c
00019c  69642070
0001a0  636200  
0001a3  00                DCB      0
                  |L2.420|
0001a4  7463705f          DCB      "tcp_enqueue_flags: check that first pbuf can hold optle"
0001a8  656e7175
0001ac  6575655f
0001b0  666c6167
0001b4  733a2063
0001b8  6865636b
0001bc  20746861
0001c0  74206669
0001c4  72737420
0001c8  70627566
0001cc  2063616e
0001d0  20686f6c
0001d4  64206f70
0001d8  746c65  
0001db  6e00              DCB      "n",0
0001dd  00                DCB      0
0001de  00                DCB      0
0001df  00                DCB      0
                  |L2.480|
0001e0  7365672d          DCB      "seg->tcphdr not aligned",0
0001e4  3e746370
0001e8  68647220
0001ec  6e6f7420
0001f0  616c6967
0001f4  6e656400
                  |L2.504|
0001f8  7463705f          DCB      "tcp_enqueue_flags: invalid segment length",0
0001fc  656e7175
000200  6575655f
000204  666c6167
000208  733a2069
00020c  6e76616c
000210  69642073
000214  65676d65
000218  6e74206c
00021c  656e6774
000220  6800    
000222  00                DCB      0
000223  00                DCB      0
                  |L2.548|
000224  7463705f          DCB      "tcp_enqueue_flags: invalid queue length",0
000228  656e7175
00022c  6575655f
000230  666c6167
000234  733a2069
000238  6e76616c
00023c  69642071
000240  75657565
000244  206c656e
000248  67746800

                          AREA ||i.tcp_keepalive||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_keepalive PROC
;;;2077   err_t
;;;2078   tcp_keepalive(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;2079   {
000002  4604              MOV      r4,r0
;;;2080     err_t err;
;;;2081     struct pbuf *p;
;;;2082     u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
000004  2600              MOVS     r6,#0
;;;2083   
;;;2084     LWIP_ASSERT("tcp_keepalive: invalid pcb", pcb != NULL);
000006  2c00              CMP      r4,#0
000008  d106              BNE      |L3.24|
00000a  a312              ADR      r3,|L3.84|
00000c  f6400224          MOV      r2,#0x824
000010  a11d              ADR      r1,|L3.136|
000012  a024              ADR      r0,|L3.164|
000014  f7fffffe          BL       __2printf
                  |L3.24|
;;;2085   
;;;2086     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: sending KEEPALIVE probe to "));
;;;2087     ip_addr_debug_print_val(TCP_DEBUG, pcb->remote_ip);
;;;2088     LWIP_DEBUGF(TCP_DEBUG, ("\n"));
;;;2089   
;;;2090     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
;;;2091                             tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));
;;;2092   
;;;2093     p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt - 1));
000018  6d20              LDR      r0,[r4,#0x50]
00001a  1e40              SUBS     r0,r0,#1
00001c  f7fffffe          BL       lwip_htonl
000020  4603              MOV      r3,r0
000022  2200              MOVS     r2,#0
000024  4631              MOV      r1,r6
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       tcp_output_alloc_header
00002c  4605              MOV      r5,r0
;;;2094     if (p == NULL) {
00002e  b16d              CBZ      r5,|L3.76|
;;;2095       LWIP_DEBUGF(TCP_DEBUG,
;;;2096                   ("tcp_keepalive: could not allocate memory for pbuf\n"));
;;;2097       return ERR_MEM;
;;;2098     }
;;;2099     tcp_output_fill_options(pcb, p, 0, optlen);
000030  4633              MOV      r3,r6
000032  2200              MOVS     r2,#0
000034  4629              MOV      r1,r5
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       tcp_output_fill_options
;;;2100     err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
00003c  1d23              ADDS     r3,r4,#4
00003e  4622              MOV      r2,r4
000040  4629              MOV      r1,r5
000042  4620              MOV      r0,r4
000044  e8bd4070          POP      {r4-r6,lr}
000048  f7ffbffe          B.W      tcp_output_control_segment
                  |L3.76|
00004c  f04f30ff          MOV      r0,#0xffffffff        ;2097
;;;2101   
;;;2102     LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F" err %d.\n",
;;;2103                             pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
;;;2104     return err;
;;;2105   }
000050  bd70              POP      {r4-r6,pc}
;;;2106   
                          ENDP

000052  0000              DCW      0x0000
                  |L3.84|
000054  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000058  6964646c
00005c  65776172
000060  65735c54
000064  68697264
000068  5f506172
00006c  74795c4c
000070  7749505c
000074  7372635c
000078  636f7265
00007c  5c746370
000080  5f6f7574
000084  2e      
000085  6300              DCB      "c",0
000087  00                DCB      0
                  |L3.136|
000088  7463705f          DCB      "tcp_keepalive: invalid pcb",0
00008c  6b656570
000090  616c6976
000094  653a2069
000098  6e76616c
00009c  69642070
0000a0  636200  
0000a3  00                DCB      0
                  |L3.164|
0000a4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000a8  7274696f
0000ac  6e202225
0000b0  73222066
0000b4  61696c65
0000b8  64206174
0000bc  206c696e
0000c0  65202564
0000c4  20696e20
0000c8  25730a00

                          AREA ||i.tcp_output||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_output PROC
;;;1236   err_t
;;;1237   tcp_output(struct tcp_pcb *pcb)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1238   {
000004  4604              MOV      r4,r0
;;;1239     struct tcp_seg *seg, *useg;
;;;1240     u32_t wnd, snd_nxt;
;;;1241     err_t err;
;;;1242     struct netif *netif;
;;;1243   #if TCP_CWND_DEBUG
;;;1244     s16_t i = 0;
;;;1245   #endif /* TCP_CWND_DEBUG */
;;;1246   
;;;1247     LWIP_ASSERT_CORE_LOCKED();
;;;1248   
;;;1249     LWIP_ASSERT("tcp_output: invalid pcb", pcb != NULL);
000006  2c00              CMP      r4,#0
000008  d106              BNE      |L4.24|
00000a  a38d              ADR      r3,|L4.576|
00000c  f24042e1          MOV      r2,#0x4e1
000010  a198              ADR      r1,|L4.628|
000012  a09e              ADR      r0,|L4.652|
000014  f7fffffe          BL       __2printf
                  |L4.24|
;;;1250     /* pcb->state LISTEN not allowed here */
;;;1251     LWIP_ASSERT("don't call tcp_output for listen-pcbs",
000018  7d20              LDRB     r0,[r4,#0x14]
00001a  2801              CMP      r0,#1
00001c  d106              BNE      |L4.44|
00001e  a388              ADR      r3,|L4.576|
000020  f24042e3          MOV      r2,#0x4e3
000024  a1a3              ADR      r1,|L4.692|
000026  a099              ADR      r0,|L4.652|
000028  f7fffffe          BL       __2printf
                  |L4.44|
;;;1252                 pcb->state != LISTEN);
;;;1253   
;;;1254     /* First, check if we are invoked by the TCP input processing
;;;1255        code. If so, we do not output anything. Instead, we rely on the
;;;1256        input processing code to call us when input processing is done
;;;1257        with. */
;;;1258     if (tcp_input_pcb == pcb) {
00002c  48ab              LDR      r0,|L4.732|
00002e  6800              LDR      r0,[r0,#0]  ; tcp_input_pcb
000030  42a0              CMP      r0,r4
000032  d102              BNE      |L4.58|
;;;1259       return ERR_OK;
000034  2000              MOVS     r0,#0
                  |L4.54|
;;;1260     }
;;;1261   
;;;1262     wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
;;;1263   
;;;1264     seg = pcb->unsent;
;;;1265   
;;;1266     if (seg == NULL) {
;;;1267       LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: nothing to send (%p)\n",
;;;1268                                      (void *)pcb->unsent));
;;;1269       LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"TCPWNDSIZE_F
;;;1270                                    ", cwnd %"TCPWNDSIZE_F", wnd %"U32_F
;;;1271                                    ", seg == NULL, ack %"U32_F"\n",
;;;1272                                    pcb->snd_wnd, pcb->cwnd, wnd, pcb->lastack));
;;;1273   
;;;1274       /* If the TF_ACK_NOW flag is set and the ->unsent queue is empty, construct
;;;1275        * an empty ACK segment and send it. */
;;;1276       if (pcb->flags & TF_ACK_NOW) {
;;;1277         return tcp_send_empty_ack(pcb);
;;;1278       }
;;;1279       /* nothing to send: shortcut out of here */
;;;1280       goto output_done;
;;;1281     } else {
;;;1282       LWIP_DEBUGF(TCP_CWND_DEBUG,
;;;1283                   ("tcp_output: snd_wnd %"TCPWNDSIZE_F", cwnd %"TCPWNDSIZE_F", wnd %"U32_F
;;;1284                    ", effwnd %"U32_F", seq %"U32_F", ack %"U32_F"\n",
;;;1285                    pcb->snd_wnd, pcb->cwnd, wnd,
;;;1286                    lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
;;;1287                    lwip_ntohl(seg->tcphdr->seqno), pcb->lastack));
;;;1288     }
;;;1289   
;;;1290     netif = tcp_route(pcb, &pcb->local_ip, &pcb->remote_ip);
;;;1291     if (netif == NULL) {
;;;1292       return ERR_RTE;
;;;1293     }
;;;1294   
;;;1295     /* If we don't have a local IP address, we get one from netif */
;;;1296     if (ip_addr_isany(&pcb->local_ip)) {
;;;1297       const ip_addr_t *local_ip = ip_netif_get_local_ip(netif, &pcb->remote_ip);
;;;1298       if (local_ip == NULL) {
;;;1299         return ERR_RTE;
;;;1300       }
;;;1301       ip_addr_copy(pcb->local_ip, *local_ip);
;;;1302     }
;;;1303   
;;;1304     /* Handle the current segment not fitting within the window */
;;;1305     if (lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd) {
;;;1306       /* We need to start the persistent timer when the next unsent segment does not fit
;;;1307        * within the remaining (could be 0) send window and RTO timer is not running (we
;;;1308        * have no in-flight data). If window is still too small after persist timer fires,
;;;1309        * then we split the segment. We don't consider the congestion window since a cwnd
;;;1310        * smaller than 1 SMSS implies in-flight data
;;;1311        */
;;;1312       if (wnd == pcb->snd_wnd && pcb->unacked == NULL && pcb->persist_backoff == 0) {
;;;1313         pcb->persist_cnt = 0;
;;;1314         pcb->persist_backoff = 1;
;;;1315         pcb->persist_probe = 0;
;;;1316       }
;;;1317       /* We need an ACK, but can't send data now, so send an empty ACK */
;;;1318       if (pcb->flags & TF_ACK_NOW) {
;;;1319         return tcp_send_empty_ack(pcb);
;;;1320       }
;;;1321       goto output_done;
;;;1322     }
;;;1323     /* Stop persist timer, above conditions are not active */
;;;1324     pcb->persist_backoff = 0;
;;;1325   
;;;1326     /* useg should point to last segment on unacked queue */
;;;1327     useg = pcb->unacked;
;;;1328     if (useg != NULL) {
;;;1329       for (; useg->next != NULL; useg = useg->next);
;;;1330     }
;;;1331     /* data available and window allows it to be sent? */
;;;1332     while (seg != NULL &&
;;;1333            lwip_ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
;;;1334       LWIP_ASSERT("RST not expected here!",
;;;1335                   (TCPH_FLAGS(seg->tcphdr) & TCP_RST) == 0);
;;;1336       /* Stop sending if the nagle algorithm would prevent it
;;;1337        * Don't stop:
;;;1338        * - if tcp_write had a memory error before (prevent delayed ACK timeout) or
;;;1339        * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
;;;1340        *   either seg->next != NULL or pcb->unacked == NULL;
;;;1341        *   RST is no sent using tcp_write/tcp_output.
;;;1342        */
;;;1343       if ((tcp_do_output_nagle(pcb) == 0) &&
;;;1344           ((pcb->flags & (TF_NAGLEMEMERR | TF_FIN)) == 0)) {
;;;1345         break;
;;;1346       }
;;;1347   #if TCP_CWND_DEBUG
;;;1348       LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_output: snd_wnd %"TCPWNDSIZE_F", cwnd %"TCPWNDSIZE_F", wnd %"U32_F", effwnd %"U32_F", seq %"U32_F", ack %"U32_F", i %"S16_F"\n",
;;;1349                                    pcb->snd_wnd, pcb->cwnd, wnd,
;;;1350                                    lwip_ntohl(seg->tcphdr->seqno) + seg->len -
;;;1351                                    pcb->lastack,
;;;1352                                    lwip_ntohl(seg->tcphdr->seqno), pcb->lastack, i));
;;;1353       ++i;
;;;1354   #endif /* TCP_CWND_DEBUG */
;;;1355   
;;;1356       if (pcb->state != SYN_SENT) {
;;;1357         TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
;;;1358       }
;;;1359   
;;;1360       err = tcp_output_segment(seg, pcb, netif);
;;;1361       if (err != ERR_OK) {
;;;1362         /* segment could not be sent, for whatever reason */
;;;1363         tcp_set_flags(pcb, TF_NAGLEMEMERR);
;;;1364         return err;
;;;1365       }
;;;1366   #if TCP_OVERSIZE_DBGCHECK
;;;1367       seg->oversize_left = 0;
;;;1368   #endif /* TCP_OVERSIZE_DBGCHECK */
;;;1369       pcb->unsent = seg->next;
;;;1370       if (pcb->state != SYN_SENT) {
;;;1371         tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
;;;1372       }
;;;1373       snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
;;;1374       if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
;;;1375         pcb->snd_nxt = snd_nxt;
;;;1376       }
;;;1377       /* put segment on unacknowledged list if length > 0 */
;;;1378       if (TCP_TCPLEN(seg) > 0) {
;;;1379         seg->next = NULL;
;;;1380         /* unacked list is empty? */
;;;1381         if (pcb->unacked == NULL) {
;;;1382           pcb->unacked = seg;
;;;1383           useg = seg;
;;;1384           /* unacked list is not empty? */
;;;1385         } else {
;;;1386           /* In the case of fast retransmit, the packet should not go to the tail
;;;1387            * of the unacked queue, but rather somewhere before it. We need to check for
;;;1388            * this case. -STJ Jul 27, 2004 */
;;;1389           if (TCP_SEQ_LT(lwip_ntohl(seg->tcphdr->seqno), lwip_ntohl(useg->tcphdr->seqno))) {
;;;1390             /* add segment to before tail of unacked list, keeping the list sorted */
;;;1391             struct tcp_seg **cur_seg = &(pcb->unacked);
;;;1392             while (*cur_seg &&
;;;1393                    TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
;;;1394               cur_seg = &((*cur_seg)->next );
;;;1395             }
;;;1396             seg->next = (*cur_seg);
;;;1397             (*cur_seg) = seg;
;;;1398           } else {
;;;1399             /* add segment to tail of unacked list */
;;;1400             useg->next = seg;
;;;1401             useg = useg->next;
;;;1402           }
;;;1403         }
;;;1404         /* do not queue empty segments on the unacked list */
;;;1405       } else {
;;;1406         tcp_seg_free(seg);
;;;1407       }
;;;1408       seg = pcb->unsent;
;;;1409     }
;;;1410   #if TCP_OVERSIZE
;;;1411     if (pcb->unsent == NULL) {
;;;1412       /* last unsent has been removed, reset unsent_oversize */
;;;1413       pcb->unsent_oversize = 0;
;;;1414     }
;;;1415   #endif /* TCP_OVERSIZE */
;;;1416   
;;;1417   output_done:
;;;1418     tcp_clear_flags(pcb, TF_NAGLEMEMERR);
;;;1419     return ERR_OK;
;;;1420   }
000036  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.58|
00003a  f8b40060          LDRH     r0,[r4,#0x60]         ;1262
00003e  f8b48048          LDRH     r8,[r4,#0x48]         ;1262
000042  4540              CMP      r0,r8                 ;1262
000044  d200              BCS      |L4.72|
000046  4680              MOV      r8,r0                 ;1262
                  |L4.72|
000048  6ee5              LDR      r5,[r4,#0x6c]         ;1264
00004a  b175              CBZ      r5,|L4.106|
00004c  1d22              ADDS     r2,r4,#4              ;1290
00004e  4621              MOV      r1,r4                 ;1290
000050  4620              MOV      r0,r4                 ;1290
000052  f7fffffe          BL       tcp_route
000056  4681              MOV      r9,r0                 ;1290
000058  ea5f0009          MOVS     r0,r9                 ;1291
00005c  f06f0103          MVN      r1,#3                 ;1292
000060  d00b              BEQ      |L4.122|
000062  b164              CBZ      r4,|L4.126|
000064  6820              LDR      r0,[r4,#0]            ;1296
000066  b150              CBZ      r0,|L4.126|
000068  e00e              B        |L4.136|
                  |L4.106|
00006a  7ea0              LDRB     r0,[r4,#0x1a]         ;1276
00006c  0780              LSLS     r0,r0,#30             ;1276
                  |L4.110|
00006e  d577              BPL      |L4.352|
000070  4620              MOV      r0,r4                 ;1277
000072  e8bd5ff0          POP      {r4-r12,lr}           ;1277
000076  f7ffbffe          B.W      tcp_send_empty_ack
                  |L4.122|
00007a  4608              MOV      r0,r1                 ;1292
00007c  e7db              B        |L4.54|
                  |L4.126|
00007e  f1090004          ADD      r0,r9,#4              ;1297
000082  b1a0              CBZ      r0,|L4.174|
000084  6800              LDR      r0,[r0,#0]            ;1301
000086  6020              STR      r0,[r4,#0]            ;1301
                  |L4.136|
000088  68e8              LDR      r0,[r5,#0xc]          ;1305
00008a  6840              LDR      r0,[r0,#4]            ;1305
00008c  f7fffffe          BL       lwip_htonl
000090  6c61              LDR      r1,[r4,#0x44]         ;1305
000092  f04f0a00          MOV      r10,#0                ;1305
000096  1a40              SUBS     r0,r0,r1              ;1305
000098  8929              LDRH     r1,[r5,#8]            ;1305
00009a  4408              ADD      r0,r0,r1              ;1305
00009c  4540              CMP      r0,r8                 ;1305
00009e  d91a              BLS      |L4.214|
0000a0  f8b40060          LDRH     r0,[r4,#0x60]         ;1312
0000a4  4540              CMP      r0,r8                 ;1312
0000a6  d10e              BNE      |L4.198|
0000a8  6f20              LDR      r0,[r4,#0x70]         ;1312
0000aa  b110              CBZ      r0,|L4.178|
0000ac  e00b              B        |L4.198|
                  |L4.174|
0000ae  4608              MOV      r0,r1                 ;1299
0000b0  e7c1              B        |L4.54|
                  |L4.178|
0000b2  f8940099          LDRB     r0,[r4,#0x99]         ;1312
0000b6  b930              CBNZ     r0,|L4.198|
0000b8  f884a098          STRB     r10,[r4,#0x98]        ;1313
0000bc  2001              MOVS     r0,#1                 ;1314
0000be  f8840099          STRB     r0,[r4,#0x99]         ;1314
0000c2  f884a09a          STRB     r10,[r4,#0x9a]        ;1315
                  |L4.198|
0000c6  7ea0              LDRB     r0,[r4,#0x1a]         ;1318
0000c8  0780              LSLS     r0,r0,#30             ;1318
0000ca  d5d0              BPL      |L4.110|
0000cc  4620              MOV      r0,r4                 ;1319
0000ce  e8bd5ff0          POP      {r4-r12,lr}           ;1319
0000d2  f7ffbffe          B.W      tcp_send_empty_ack
                  |L4.214|
0000d6  f884a099          STRB     r10,[r4,#0x99]        ;1324
0000da  6f27              LDR      r7,[r4,#0x70]         ;1327
0000dc  b90f              CBNZ     r7,|L4.226|
0000de  e099              B        |L4.532|
                  |L4.224|
0000e0  4607              MOV      r7,r0                 ;1329
                  |L4.226|
0000e2  6838              LDR      r0,[r7,#0]            ;1329
0000e4  2800              CMP      r0,#0                 ;1329
0000e6  d1fb              BNE      |L4.224|
0000e8  e094              B        |L4.532|
                  |L4.234|
0000ea  68e8              LDR      r0,[r5,#0xc]          ;1334
0000ec  8980              LDRH     r0,[r0,#0xc]          ;1334
0000ee  f7fffffe          BL       lwip_htons
0000f2  0740              LSLS     r0,r0,#29             ;1334
0000f4  d506              BPL      |L4.260|
0000f6  a352              ADR      r3,|L4.576|
0000f8  f2405236          MOV      r2,#0x536             ;1334
0000fc  a178              ADR      r1,|L4.736|
0000fe  a063              ADR      r0,|L4.652|
000100  f7fffffe          BL       __2printf
                  |L4.260|
000104  6f20              LDR      r0,[r4,#0x70]         ;1343
000106  b1a8              CBZ      r0,|L4.308|
000108  8b61              LDRH     r1,[r4,#0x1a]         ;1343
00010a  f0110f44          TST      r1,#0x44              ;1343
00010e  d111              BNE      |L4.308|
000110  6ee0              LDR      r0,[r4,#0x6c]         ;1343
000112  b128              CBZ      r0,|L4.288|
000114  6802              LDR      r2,[r0,#0]            ;1343
000116  b96a              CBNZ     r2,|L4.308|
000118  8900              LDRH     r0,[r0,#8]            ;1343
00011a  8e62              LDRH     r2,[r4,#0x32]         ;1343
00011c  4290              CMP      r0,r2                 ;1343
00011e  d209              BCS      |L4.308|
                  |L4.288|
000120  f8b40064          LDRH     r0,[r4,#0x64]         ;1343
000124  b130              CBZ      r0,|L4.308|
000126  f8b40066          LDRH     r0,[r4,#0x66]         ;1343
00012a  2809              CMP      r0,#9                 ;1343
00012c  d202              BCS      |L4.308|
00012e  f0110fa0          TST      r1,#0xa0              ;1344
000132  d07b              BEQ      |L4.556|
                  |L4.308|
000134  7d20              LDRB     r0,[r4,#0x14]         ;1356
000136  2802              CMP      r0,#2                 ;1356
000138  d007              BEQ      |L4.330|
00013a  2010              MOVS     r0,#0x10              ;1357
00013c  f7fffffe          BL       lwip_htons
000140  4601              MOV      r1,r0                 ;1357
000142  68e8              LDR      r0,[r5,#0xc]          ;1357
000144  8982              LDRH     r2,[r0,#0xc]          ;1357
000146  4311              ORRS     r1,r1,r2              ;1357
000148  8181              STRH     r1,[r0,#0xc]          ;1357
                  |L4.330|
00014a  464a              MOV      r2,r9                 ;1360
00014c  4621              MOV      r1,r4                 ;1360
00014e  4628              MOV      r0,r5                 ;1360
000150  f7fffffe          BL       tcp_output_segment
000154  b128              CBZ      r0,|L4.354|
000156  8b61              LDRH     r1,[r4,#0x1a]         ;1363
000158  f0410180          ORR      r1,r1,#0x80           ;1363
00015c  8361              STRH     r1,[r4,#0x1a]         ;1363
00015e  e76a              B        |L4.54|
                  |L4.352|
000160  e068              B        |L4.564|
                  |L4.354|
000162  6828              LDR      r0,[r5,#0]            ;1369
000164  66e0              STR      r0,[r4,#0x6c]         ;1369
000166  7d20              LDRB     r0,[r4,#0x14]         ;1370
000168  2802              CMP      r0,#2                 ;1370
00016a  d003              BEQ      |L4.372|
00016c  8b60              LDRH     r0,[r4,#0x1a]         ;1371
00016e  f0200003          BIC      r0,r0,#3              ;1371
000172  8360              STRH     r0,[r4,#0x1a]         ;1371
                  |L4.372|
000174  68e8              LDR      r0,[r5,#0xc]          ;1373
000176  6840              LDR      r0,[r0,#4]            ;1373
000178  f7fffffe          BL       lwip_htonl
00017c  4606              MOV      r6,r0                 ;1373
00017e  68e8              LDR      r0,[r5,#0xc]          ;1373
000180  8980              LDRH     r0,[r0,#0xc]          ;1373
000182  f7fffffe          BL       lwip_htons
000186  0780              LSLS     r0,r0,#30             ;1373
000188  d001              BEQ      |L4.398|
00018a  2001              MOVS     r0,#1                 ;1373
00018c  e000              B        |L4.400|
                  |L4.398|
00018e  2000              MOVS     r0,#0                 ;1373
                  |L4.400|
000190  8929              LDRH     r1,[r5,#8]            ;1373
000192  4430              ADD      r0,r0,r6              ;1373
000194  4408              ADD      r0,r0,r1              ;1373
000196  6d21              LDR      r1,[r4,#0x50]         ;1374
000198  1a09              SUBS     r1,r1,r0              ;1374
00019a  d500              BPL      |L4.414|
00019c  6520              STR      r0,[r4,#0x50]         ;1375
                  |L4.414|
00019e  68e8              LDR      r0,[r5,#0xc]          ;1378
0001a0  8980              LDRH     r0,[r0,#0xc]          ;1378
0001a2  f7fffffe          BL       lwip_htons
0001a6  0780              LSLS     r0,r0,#30             ;1378
0001a8  d001              BEQ      |L4.430|
0001aa  2001              MOVS     r0,#1                 ;1378
0001ac  e000              B        |L4.432|
                  |L4.430|
0001ae  2000              MOVS     r0,#0                 ;1378
                  |L4.432|
0001b0  8929              LDRH     r1,[r5,#8]            ;1378
0001b2  42c8              CMN      r0,r1                 ;1378
0001b4  d02a              BEQ      |L4.524|
0001b6  f8c5a000          STR      r10,[r5,#0]           ;1379
0001ba  6f20              LDR      r0,[r4,#0x70]         ;1381
0001bc  b168              CBZ      r0,|L4.474|
0001be  68e8              LDR      r0,[r5,#0xc]          ;1389
0001c0  6840              LDR      r0,[r0,#4]            ;1389
0001c2  f7fffffe          BL       lwip_htonl
0001c6  4606              MOV      r6,r0                 ;1389
0001c8  68f8              LDR      r0,[r7,#0xc]          ;1389
0001ca  6840              LDR      r0,[r0,#4]            ;1389
0001cc  f7fffffe          BL       lwip_htonl
0001d0  1a30              SUBS     r0,r6,r0              ;1389
0001d2  d518              BPL      |L4.518|
0001d4  f1040670          ADD      r6,r4,#0x70           ;1391
0001d8  e003              B        |L4.482|
                  |L4.474|
0001da  6725              STR      r5,[r4,#0x70]         ;1382
0001dc  462f              MOV      r7,r5                 ;1383
0001de  e018              B        |L4.530|
                  |L4.480|
0001e0  6836              LDR      r6,[r6,#0]            ;1394
                  |L4.482|
0001e2  6830              LDR      r0,[r6,#0]            ;1392
0001e4  b158              CBZ      r0,|L4.510|
0001e6  68c0              LDR      r0,[r0,#0xc]          ;1393
0001e8  6840              LDR      r0,[r0,#4]            ;1393
0001ea  f7fffffe          BL       lwip_htonl
0001ee  4683              MOV      r11,r0                ;1393
0001f0  68e8              LDR      r0,[r5,#0xc]          ;1393
0001f2  6840              LDR      r0,[r0,#4]            ;1393
0001f4  f7fffffe          BL       lwip_htonl
0001f8  ebbb0000          SUBS     r0,r11,r0             ;1393
0001fc  d4f0              BMI      |L4.480|
                  |L4.510|
0001fe  6830              LDR      r0,[r6,#0]            ;1396
000200  6028              STR      r0,[r5,#0]            ;1396
000202  6035              STR      r5,[r6,#0]            ;1397
000204  e005              B        |L4.530|
                  |L4.518|
000206  603d              STR      r5,[r7,#0]            ;1400
000208  462f              MOV      r7,r5                 ;1401
00020a  e002              B        |L4.530|
                  |L4.524|
00020c  4628              MOV      r0,r5                 ;1406
00020e  f7fffffe          BL       tcp_seg_free
                  |L4.530|
000212  6ee5              LDR      r5,[r4,#0x6c]         ;1408
                  |L4.532|
000214  b155              CBZ      r5,|L4.556|
000216  68e8              LDR      r0,[r5,#0xc]          ;1333
000218  6840              LDR      r0,[r0,#4]            ;1333
00021a  f7fffffe          BL       lwip_htonl
00021e  6c61              LDR      r1,[r4,#0x44]         ;1333
000220  1a40              SUBS     r0,r0,r1              ;1333
000222  8929              LDRH     r1,[r5,#8]            ;1333
000224  4408              ADD      r0,r0,r1              ;1333
000226  4540              CMP      r0,r8                 ;1333
000228  f67faf5f          BLS      |L4.234|
                  |L4.556|
00022c  6ee0              LDR      r0,[r4,#0x6c]         ;1411
00022e  b908              CBNZ     r0,|L4.564|
000230  f8a4a068          STRH     r10,[r4,#0x68]        ;1413
                  |L4.564|
000234  8b60              LDRH     r0,[r4,#0x1a]         ;1418
000236  f0200080          BIC      r0,r0,#0x80           ;1418
00023a  8360              STRH     r0,[r4,#0x1a]         ;1418
00023c  2000              MOVS     r0,#0                 ;1419
00023e  e6fa              B        |L4.54|
;;;1421   
                          ENDP

                  |L4.576|
000240  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000244  6964646c
000248  65776172
00024c  65735c54
000250  68697264
000254  5f506172
000258  74795c4c
00025c  7749505c
000260  7372635c
000264  636f7265
000268  5c746370
00026c  5f6f7574
000270  2e      
000271  6300              DCB      "c",0
000273  00                DCB      0
                  |L4.628|
000274  7463705f          DCB      "tcp_output: invalid pcb",0
000278  6f757470
00027c  75743a20
000280  696e7661
000284  6c696420
000288  70636200
                  |L4.652|
00028c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000290  7274696f
000294  6e202225
000298  73222066
00029c  61696c65
0002a0  64206174
0002a4  206c696e
0002a8  65202564
0002ac  20696e20
0002b0  25730a00
                  |L4.692|
0002b4  646f6e27          DCB      "don't call tcp_output for listen-pcbs",0
0002b8  74206361
0002bc  6c6c2074
0002c0  63705f6f
0002c4  75747075
0002c8  7420666f
0002cc  72206c69
0002d0  7374656e
0002d4  2d706362
0002d8  7300    
0002da  00                DCB      0
0002db  00                DCB      0
                  |L4.732|
                          DCD      tcp_input_pcb
                  |L4.736|
0002e0  52535420          DCB      "RST not expected here!",0
0002e4  6e6f7420
0002e8  65787065
0002ec  63746564
0002f0  20686572
0002f4  652100  
0002f7  00                DCB      0

                          AREA ||i.tcp_output_alloc_header||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_output_alloc_header PROC
;;;1852   static struct pbuf *
;;;1853   tcp_output_alloc_header(struct tcp_pcb *pcb, u16_t optlen, u16_t datalen,
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;1854                           u32_t seqno_be /* already in network byte order */)
;;;1855   {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  4699              MOV      r9,r3
;;;1856     struct pbuf *p;
;;;1857   
;;;1858     LWIP_ASSERT("tcp_output_alloc_header: invalid pcb", pcb != NULL);
00000c  2c00              CMP      r4,#0
00000e  d106              BNE      |L5.30|
000010  a30e              ADR      r3,|L5.76|
000012  f2407242          MOV      r2,#0x742
000016  a11a              ADR      r1,|L5.128|
000018  a023              ADR      r0,|L5.168|
00001a  f7fffffe          BL       __2printf
                  |L5.30|
;;;1859   
;;;1860     p = tcp_output_alloc_header_common(pcb->rcv_nxt, optlen, datalen,
00001e  8d60              LDRH     r0,[r4,#0x2a]
000020  8b25              LDRH     r5,[r4,#0x18]
000022  8ae6              LDRH     r6,[r4,#0x16]
000024  2110              MOVS     r1,#0x10
000026  e9cd1002          STRD     r1,r0,[sp,#8]
00002a  e9cd6500          STRD     r6,r5,[sp,#0]
00002e  464b              MOV      r3,r9
000030  4642              MOV      r2,r8
000032  4639              MOV      r1,r7
000034  6a60              LDR      r0,[r4,#0x24]
000036  f7fffffe          BL       tcp_output_alloc_header_common
;;;1861       seqno_be, pcb->local_port, pcb->remote_port, TCP_ACK,
;;;1862       TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
;;;1863     if (p != NULL) {
00003a  2800              CMP      r0,#0
00003c  d003              BEQ      |L5.70|
;;;1864       /* If we're sending a packet, update the announced right window edge */
;;;1865       pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
00003e  8d62              LDRH     r2,[r4,#0x2a]
000040  6a61              LDR      r1,[r4,#0x24]
000042  4411              ADD      r1,r1,r2
000044  62e1              STR      r1,[r4,#0x2c]
                  |L5.70|
;;;1866     }
;;;1867     return p;
;;;1868   }
000046  b004              ADD      sp,sp,#0x10
000048  e8bd87f0          POP      {r4-r10,pc}
;;;1869   
                          ENDP

                  |L5.76|
00004c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000050  6964646c
000054  65776172
000058  65735c54
00005c  68697264
000060  5f506172
000064  74795c4c
000068  7749505c
00006c  7372635c
000070  636f7265
000074  5c746370
000078  5f6f7574
00007c  2e      
00007d  6300              DCB      "c",0
00007f  00                DCB      0
                  |L5.128|
000080  7463705f          DCB      "tcp_output_alloc_header: invalid pcb",0
000084  6f757470
000088  75745f61
00008c  6c6c6f63
000090  5f686561
000094  6465723a
000098  20696e76
00009c  616c6964
0000a0  20706362
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L5.168|
0000a8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000ac  7274696f
0000b0  6e202225
0000b4  73222066
0000b8  61696c65
0000bc  64206174
0000c0  206c696e
0000c4  65202564
0000c8  20696e20
0000cc  25730a00

                          AREA ||i.tcp_output_alloc_header_common||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_output_alloc_header_common PROC
;;;1817   static struct pbuf *
;;;1818   tcp_output_alloc_header_common(u32_t ackno, u16_t optlen, u16_t datalen,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1819                           u32_t seqno_be /* already in network byte order */,
;;;1820                           u16_t src_port, u16_t dst_port, u8_t flags, u16_t wnd)
;;;1821   {
000004  e9ddab0a          LDRD     r10,r11,[sp,#0x28]
000008  f8dd8030          LDR      r8,[sp,#0x30]
00000c  4681              MOV      r9,r0
00000e  460e              MOV      r6,r1
000010  461f              MOV      r7,r3
;;;1822     struct tcp_hdr *tcphdr;
;;;1823     struct pbuf *p;
;;;1824   
;;;1825     p = pbuf_alloc(PBUF_IP, TCP_HLEN + optlen + datalen, PBUF_RAM);
000012  18b0              ADDS     r0,r6,r2
000014  3014              ADDS     r0,r0,#0x14
000016  b281              UXTH     r1,r0
000018  f44f7220          MOV      r2,#0x280
00001c  2022              MOVS     r0,#0x22
00001e  f7fffffe          BL       pbuf_alloc
000022  4605              MOV      r5,r0
;;;1826     if (p != NULL) {
000024  0028              MOVS     r0,r5
000026  d02c              BEQ      |L6.130|
;;;1827       LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
000028  8969              LDRH     r1,[r5,#0xa]
00002a  f1060014          ADD      r0,r6,#0x14
00002e  4281              CMP      r1,r0
000030  d206              BCS      |L6.64|
000032  a315              ADR      r3,|L6.136|
000034  f2407223          MOV      r2,#0x723
000038  a120              ADR      r1,|L6.188|
00003a  a02c              ADR      r0,|L6.236|
00003c  f7fffffe          BL       __2printf
                  |L6.64|
;;;1828                   (p->len >= TCP_HLEN + optlen));
;;;1829       tcphdr = (struct tcp_hdr *)p->payload;
000040  686c              LDR      r4,[r5,#4]
;;;1830       tcphdr->src = lwip_htons(src_port);
000042  4650              MOV      r0,r10
000044  f7fffffe          BL       lwip_htons
000048  8020              STRH     r0,[r4,#0]
;;;1831       tcphdr->dest = lwip_htons(dst_port);
00004a  4658              MOV      r0,r11
00004c  f7fffffe          BL       lwip_htons
000050  8060              STRH     r0,[r4,#2]
;;;1832       tcphdr->seqno = seqno_be;
000052  6067              STR      r7,[r4,#4]
;;;1833       tcphdr->ackno = lwip_htonl(ackno);
000054  4648              MOV      r0,r9
000056  f7fffffe          BL       lwip_htonl
00005a  60a0              STR      r0,[r4,#8]
;;;1834       TCPH_HDRLEN_FLAGS_SET(tcphdr, (5 + optlen / 4), flags);
00005c  2005              MOVS     r0,#5
00005e  eb000096          ADD      r0,r0,r6,LSR #2
000062  f64f71ff          MOV      r1,#0xffff
000066  ea013000          AND      r0,r1,r0,LSL #12
00006a  ea400008          ORR      r0,r0,r8
00006e  f7fffffe          BL       lwip_htons
000072  81a0              STRH     r0,[r4,#0xc]
;;;1835       tcphdr->wnd = lwip_htons(wnd);
000074  980d              LDR      r0,[sp,#0x34]
000076  f7fffffe          BL       lwip_htons
00007a  81e0              STRH     r0,[r4,#0xe]
;;;1836       tcphdr->chksum = 0;
00007c  2000              MOVS     r0,#0
00007e  8220              STRH     r0,[r4,#0x10]
;;;1837       tcphdr->urgp = 0;
000080  8260              STRH     r0,[r4,#0x12]
                  |L6.130|
;;;1838     }
;;;1839     return p;
000082  4628              MOV      r0,r5
;;;1840   }
000084  e8bd9ff0          POP      {r4-r12,pc}
;;;1841   
                          ENDP

                  |L6.136|
000088  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
00008c  6964646c
000090  65776172
000094  65735c54
000098  68697264
00009c  5f506172
0000a0  74795c4c
0000a4  7749505c
0000a8  7372635c
0000ac  636f7265
0000b0  5c746370
0000b4  5f6f7574
0000b8  2e      
0000b9  6300              DCB      "c",0
0000bb  00                DCB      0
                  |L6.188|
0000bc  63686563          DCB      "check that first pbuf can hold struct tcp_hdr",0
0000c0  6b207468
0000c4  61742066
0000c8  69727374
0000cc  20706275
0000d0  66206361
0000d4  6e20686f
0000d8  6c642073
0000dc  74727563
0000e0  74207463
0000e4  705f6864
0000e8  7200    
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L6.236|
0000ec  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000f0  7274696f
0000f4  6e202225
0000f8  73222066
0000fc  61696c65
000100  64206174
000104  206c696e
000108  65202564
00010c  20696e20
000110  25730a00

                          AREA ||i.tcp_output_control_segment||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_output_control_segment PROC
;;;1920   static err_t
;;;1921   tcp_output_control_segment(const struct tcp_pcb *pcb, struct pbuf *p,
000000  b5fe              PUSH     {r1-r7,lr}
;;;1922                              const ip_addr_t *src, const ip_addr_t *dst)
;;;1923   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;1924     err_t err;
;;;1925     struct netif *netif;
;;;1926   
;;;1927     LWIP_ASSERT("tcp_output_control_segment: invalid pbuf", p != NULL);
00000a  2d00              CMP      r5,#0
00000c  d106              BNE      |L7.28|
00000e  a312              ADR      r3,|L7.88|
000010  f2407287          MOV      r2,#0x787
000014  a11d              ADR      r1,|L7.140|
000016  a028              ADR      r0,|L7.184|
000018  f7fffffe          BL       __2printf
                  |L7.28|
;;;1928   
;;;1929     netif = tcp_route(pcb, src, dst);
00001c  463a              MOV      r2,r7
00001e  4631              MOV      r1,r6
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       tcp_route
;;;1930     if (netif == NULL) {
000026  b118              CBZ      r0,|L7.48|
;;;1931       err = ERR_RTE;
;;;1932     } else {
;;;1933       u8_t ttl, tos;
;;;1934   #if CHECKSUM_GEN_TCP
;;;1935       IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
;;;1936         struct tcp_hdr *tcphdr = (struct tcp_hdr *)p->payload;
;;;1937         tcphdr->chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
;;;1938                                           src, dst);
;;;1939       }
;;;1940   #endif
;;;1941       if (pcb != NULL) {
000028  b12c              CBZ      r4,|L7.54|
;;;1942         NETIF_SET_HINTS(netif, LWIP_CONST_CAST(struct netif_hint*, &(pcb->netif_hints)));
;;;1943         ttl = pcb->ttl;
00002a  7ae3              LDRB     r3,[r4,#0xb]
;;;1944         tos = pcb->tos;
00002c  7aa1              LDRB     r1,[r4,#0xa]
00002e  e004              B        |L7.58|
                  |L7.48|
000030  f06f0403          MVN      r4,#3                 ;1931
000034  e00b              B        |L7.78|
                  |L7.54|
;;;1945       } else {
;;;1946         /* Send output with hardcoded TTL/HL since we have no access to the pcb */
;;;1947         ttl = TCP_TTL;
000036  23ff              MOVS     r3,#0xff
;;;1948         tos = 0;
000038  2100              MOVS     r1,#0
                  |L7.58|
;;;1949       }
;;;1950       TCP_STATS_INC(tcp.xmit);
;;;1951       err = ip_output_if(p, src, dst, ttl, tos, IP_PROTO_TCP, netif);
00003a  2206              MOVS     r2,#6
00003c  e9cd1200          STRD     r1,r2,[sp,#0]
000040  9002              STR      r0,[sp,#8]
000042  463a              MOV      r2,r7
000044  4631              MOV      r1,r6
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       ip4_output_if
00004c  4604              MOV      r4,r0
                  |L7.78|
;;;1952       NETIF_RESET_HINTS(netif);
;;;1953     }
;;;1954     pbuf_free(p);
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       pbuf_free
;;;1955     return err;
000054  4620              MOV      r0,r4
;;;1956   }
000056  bdfe              POP      {r1-r7,pc}
;;;1957   
                          ENDP

                  |L7.88|
000058  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
00005c  6964646c
000060  65776172
000064  65735c54
000068  68697264
00006c  5f506172
000070  74795c4c
000074  7749505c
000078  7372635c
00007c  636f7265
000080  5c746370
000084  5f6f7574
000088  2e      
000089  6300              DCB      "c",0
00008b  00                DCB      0
                  |L7.140|
00008c  7463705f          DCB      "tcp_output_control_segment: invalid pbuf",0
000090  6f757470
000094  75745f63
000098  6f6e7472
00009c  6f6c5f73
0000a0  65676d65
0000a4  6e743a20
0000a8  696e7661
0000ac  6c696420
0000b0  70627566
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L7.184|
0000b8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000bc  7274696f
0000c0  6e202225
0000c4  73222066
0000c8  61696c65
0000cc  64206174
0000d0  206c696e
0000d4  65202564
0000d8  20696e20
0000dc  25730a00

                          AREA ||i.tcp_output_fill_options||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_output_fill_options PROC
;;;1871   static void
;;;1872   tcp_output_fill_options(const struct tcp_pcb *pcb, struct pbuf *p, u8_t optflags, u8_t num_sacks)
000000  b570              PUSH     {r4-r6,lr}
;;;1873   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;1874     struct tcp_hdr *tcphdr;
;;;1875     u32_t *opts;
;;;1876     u16_t sacks_len = 0;
;;;1877   
;;;1878     LWIP_ASSERT("tcp_output_fill_options: invalid pbuf", p != NULL);
000006  2c00              CMP      r4,#0
000008  d106              BNE      |L8.24|
00000a  a30e              ADR      r3,|L8.68|
00000c  f2407256          MOV      r2,#0x756
000010  a119              ADR      r1,|L8.120|
000012  a023              ADR      r0,|L8.160|
000014  f7fffffe          BL       __2printf
                  |L8.24|
;;;1879   
;;;1880     tcphdr = (struct tcp_hdr *)p->payload;
000018  6860              LDR      r0,[r4,#4]
;;;1881     opts = (u32_t *)(void *)(tcphdr + 1);
00001a  f1000314          ADD      r3,r0,#0x14
;;;1882   
;;;1883     /* NB. MSS and window scale options are only sent on SYNs, so ignore them here */
;;;1884   
;;;1885   #if LWIP_TCP_TIMESTAMPS
;;;1886     if (optflags & TF_SEG_OPTS_TS) {
;;;1887       tcp_build_timestamp_option(pcb, opts);
;;;1888       opts += 3;
;;;1889     }
;;;1890   #endif
;;;1891   
;;;1892   #if LWIP_TCP_SACK_OUT
;;;1893     if (pcb && (num_sacks > 0)) {
;;;1894       tcp_build_sack_option(pcb, opts, num_sacks);
;;;1895       /* 1 word for SACKs header (including 2xNOP), and 2 words for each SACK */
;;;1896       sacks_len = 1 + num_sacks * 2;
;;;1897       opts += sacks_len;
;;;1898     }
;;;1899   #else
;;;1900     LWIP_UNUSED_ARG(num_sacks);
;;;1901   #endif
;;;1902   
;;;1903   #ifdef LWIP_HOOK_TCP_OUT_ADD_TCPOPTS
;;;1904     opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(p, tcphdr, pcb, opts);
;;;1905   #endif
;;;1906   
;;;1907     LWIP_UNUSED_ARG(pcb);
;;;1908     LWIP_UNUSED_ARG(sacks_len);
;;;1909     LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(tcphdr + 1)) + sacks_len * 4 + LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb));
00001e  07e9              LSLS     r1,r5,#31
000020  d001              BEQ      |L8.38|
000022  2104              MOVS     r1,#4
000024  e000              B        |L8.40|
                  |L8.38|
000026  2100              MOVS     r1,#0
                  |L8.40|
000028  4408              ADD      r0,r0,r1
00002a  3014              ADDS     r0,r0,#0x14
00002c  4298              CMP      r0,r3
00002e  d008              BEQ      |L8.66|
000030  e8bd4070          POP      {r4-r6,lr}
000034  a303              ADR      r3,|L8.68|
000036  f2407275          MOV      r2,#0x775
00003a  a123              ADR      r1,|L8.200|
00003c  a018              ADR      r0,|L8.160|
00003e  f7ffbffe          B.W      __2printf
                  |L8.66|
;;;1910     LWIP_UNUSED_ARG(optflags); /* for LWIP_NOASSERT */
;;;1911     LWIP_UNUSED_ARG(opts); /* for LWIP_NOASSERT */
;;;1912   }
000042  bd70              POP      {r4-r6,pc}
;;;1913   
                          ENDP

                  |L8.68|
000044  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000048  6964646c
00004c  65776172
000050  65735c54
000054  68697264
000058  5f506172
00005c  74795c4c
000060  7749505c
000064  7372635c
000068  636f7265
00006c  5c746370
000070  5f6f7574
000074  2e      
000075  6300              DCB      "c",0
000077  00                DCB      0
                  |L8.120|
000078  7463705f          DCB      "tcp_output_fill_options: invalid pbuf",0
00007c  6f757470
000080  75745f66
000084  696c6c5f
000088  6f707469
00008c  6f6e733a
000090  20696e76
000094  616c6964
000098  20706275
00009c  6600    
00009e  00                DCB      0
00009f  00                DCB      0
                  |L8.160|
0000a0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000a4  7274696f
0000a8  6e202225
0000ac  73222066
0000b0  61696c65
0000b4  64206174
0000b8  206c696e
0000bc  65202564
0000c0  20696e20
0000c4  25730a00
                  |L8.200|
0000c8  6f707469          DCB      "options not filled",0
0000cc  6f6e7320
0000d0  6e6f7420
0000d4  66696c6c
0000d8  656400  
0000db  00                DCB      0

                          AREA ||i.tcp_output_segment||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_output_segment PROC
;;;1454   static err_t
;;;1455   tcp_output_segment(struct tcp_seg *seg, struct tcp_pcb *pcb, struct netif *netif)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;1456   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
;;;1457     err_t err;
;;;1458     u16_t len;
;;;1459     u32_t *opts;
;;;1460   #if TCP_CHECKSUM_ON_COPY
;;;1461     int seg_chksum_was_swapped = 0;
;;;1462   #endif
;;;1463   
;;;1464     LWIP_ASSERT("tcp_output_segment: invalid seg", seg != NULL);
00000a  2d00              CMP      r5,#0
00000c  d106              BNE      |L9.28|
00000e  a33f              ADR      r3,|L9.268|
000010  f44f62b7          MOV      r2,#0x5b8
000014  a14a              ADR      r1,|L9.320|
000016  a052              ADR      r0,|L9.352|
000018  f7fffffe          BL       __2printf
                  |L9.28|
;;;1465     LWIP_ASSERT("tcp_output_segment: invalid pcb", pcb != NULL);
00001c  2c00              CMP      r4,#0
00001e  d106              BNE      |L9.46|
000020  a33a              ADR      r3,|L9.268|
000022  f24052b9          MOV      r2,#0x5b9
000026  a158              ADR      r1,|L9.392|
000028  a04d              ADR      r0,|L9.352|
00002a  f7fffffe          BL       __2printf
                  |L9.46|
;;;1466     LWIP_ASSERT("tcp_output_segment: invalid netif", netif != NULL);
00002e  2f00              CMP      r7,#0
000030  d106              BNE      |L9.64|
000032  a336              ADR      r3,|L9.268|
000034  f24052ba          MOV      r2,#0x5ba
000038  a15b              ADR      r1,|L9.424|
00003a  a049              ADR      r0,|L9.352|
00003c  f7fffffe          BL       __2printf
                  |L9.64|
;;;1467   
;;;1468     if (tcp_output_segment_busy(seg)) {
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       tcp_output_segment_busy
000046  b110              CBZ      r0,|L9.78|
;;;1469       /* This should not happen: rexmit functions should have checked this.
;;;1470          However, since this function modifies p->len, we must not continue in this case. */
;;;1471       LWIP_DEBUGF(TCP_RTO_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_output_segment: segment busy\n"));
;;;1472       return ERR_OK;
000048  2000              MOVS     r0,#0
                  |L9.74|
;;;1473     }
;;;1474   
;;;1475     /* The TCP header has already been constructed, but the ackno and
;;;1476      wnd fields remain. */
;;;1477     seg->tcphdr->ackno = lwip_htonl(pcb->rcv_nxt);
;;;1478   
;;;1479     /* advertise our receive window size in this TCP segment */
;;;1480   #if LWIP_WND_SCALE
;;;1481     if (seg->flags & TF_SEG_OPTS_WND_SCALE) {
;;;1482       /* The Window field in a SYN segment itself (the only type where we send
;;;1483          the window scale option) is never scaled. */
;;;1484       seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(pcb->rcv_ann_wnd));
;;;1485     } else
;;;1486   #endif /* LWIP_WND_SCALE */
;;;1487     {
;;;1488       seg->tcphdr->wnd = lwip_htons(TCPWND_MIN16(RCV_WND_SCALE(pcb, pcb->rcv_ann_wnd)));
;;;1489     }
;;;1490   
;;;1491     pcb->rcv_ann_right_edge = pcb->rcv_nxt + pcb->rcv_ann_wnd;
;;;1492   
;;;1493     /* Add any requested options.  NB MSS option is only set on SYN
;;;1494        packets, so ignore it here */
;;;1495     /* cast through void* to get rid of alignment warnings */
;;;1496     opts = (u32_t *)(void *)(seg->tcphdr + 1);
;;;1497     if (seg->flags & TF_SEG_OPTS_MSS) {
;;;1498       u16_t mss;
;;;1499   #if TCP_CALCULATE_EFF_SEND_MSS
;;;1500       mss = tcp_eff_send_mss_netif(TCP_MSS, netif, &pcb->remote_ip);
;;;1501   #else /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1502       mss = TCP_MSS;
;;;1503   #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;1504       *opts = TCP_BUILD_MSS_OPTION(mss);
;;;1505       opts += 1;
;;;1506     }
;;;1507   #if LWIP_TCP_TIMESTAMPS
;;;1508     pcb->ts_lastacksent = pcb->rcv_nxt;
;;;1509   
;;;1510     if (seg->flags & TF_SEG_OPTS_TS) {
;;;1511       tcp_build_timestamp_option(pcb, opts);
;;;1512       opts += 3;
;;;1513     }
;;;1514   #endif
;;;1515   #if LWIP_WND_SCALE
;;;1516     if (seg->flags & TF_SEG_OPTS_WND_SCALE) {
;;;1517       tcp_build_wnd_scale_option(opts);
;;;1518       opts += 1;
;;;1519     }
;;;1520   #endif
;;;1521   #if LWIP_TCP_SACK_OUT
;;;1522     if (seg->flags & TF_SEG_OPTS_SACK_PERM) {
;;;1523       /* Pad with two NOP options to make everything nicely aligned
;;;1524        * NOTE: When we send both timestamp and SACK_PERM options,
;;;1525        * we could use the first two NOPs before the timestamp to store SACK_PERM option,
;;;1526        * but that would complicate the code.
;;;1527        */
;;;1528       *(opts++) = PP_HTONL(0x01010402);
;;;1529     }
;;;1530   #endif
;;;1531   
;;;1532     /* Set retransmission timer running if it is not currently enabled
;;;1533        This must be set before checking the route. */
;;;1534     if (pcb->rtime < 0) {
;;;1535       pcb->rtime = 0;
;;;1536     }
;;;1537   
;;;1538     if (pcb->rttest == 0) {
;;;1539       pcb->rttest = tcp_ticks;
;;;1540       pcb->rtseq = lwip_ntohl(seg->tcphdr->seqno);
;;;1541   
;;;1542       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_output_segment: rtseq %"U32_F"\n", pcb->rtseq));
;;;1543     }
;;;1544     LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
;;;1545                                    lwip_htonl(seg->tcphdr->seqno), lwip_htonl(seg->tcphdr->seqno) +
;;;1546                                    seg->len));
;;;1547   
;;;1548     len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
;;;1549     if (len == 0) {
;;;1550       /** Exclude retransmitted segments from this count. */
;;;1551       MIB2_STATS_INC(mib2.tcpoutsegs);
;;;1552     }
;;;1553   
;;;1554     seg->p->len -= len;
;;;1555     seg->p->tot_len -= len;
;;;1556   
;;;1557     seg->p->payload = seg->tcphdr;
;;;1558   
;;;1559     seg->tcphdr->chksum = 0;
;;;1560   
;;;1561   #ifdef LWIP_HOOK_TCP_OUT_ADD_TCPOPTS
;;;1562     opts = LWIP_HOOK_TCP_OUT_ADD_TCPOPTS(seg->p, seg->tcphdr, pcb, opts);
;;;1563   #endif
;;;1564     LWIP_ASSERT("options not filled", (u8_t *)opts == ((u8_t *)(seg->tcphdr + 1)) + LWIP_TCP_OPT_LENGTH_SEGMENT(seg->flags, pcb));
;;;1565   
;;;1566   #if CHECKSUM_GEN_TCP
;;;1567     IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_TCP) {
;;;1568   #if TCP_CHECKSUM_ON_COPY
;;;1569       u32_t acc;
;;;1570   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1571       u16_t chksum_slow = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
;;;1572                                            seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
;;;1573   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1574       if ((seg->flags & TF_SEG_DATA_CHECKSUMMED) == 0) {
;;;1575         LWIP_ASSERT("data included but not checksummed",
;;;1576                     seg->p->tot_len == TCPH_HDRLEN_BYTES(seg->tcphdr));
;;;1577       }
;;;1578   
;;;1579       /* rebuild TCP header checksum (TCP header changes for retransmissions!) */
;;;1580       acc = ip_chksum_pseudo_partial(seg->p, IP_PROTO_TCP,
;;;1581                                      seg->p->tot_len, TCPH_HDRLEN_BYTES(seg->tcphdr), &pcb->local_ip, &pcb->remote_ip);
;;;1582       /* add payload checksum */
;;;1583       if (seg->chksum_swapped) {
;;;1584         seg_chksum_was_swapped = 1;
;;;1585         seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
;;;1586         seg->chksum_swapped = 0;
;;;1587       }
;;;1588       acc = (u16_t)~acc + seg->chksum;
;;;1589       seg->tcphdr->chksum = (u16_t)~FOLD_U32T(acc);
;;;1590   #if TCP_CHECKSUM_ON_COPY_SANITY_CHECK
;;;1591       if (chksum_slow != seg->tcphdr->chksum) {
;;;1592         TCP_CHECKSUM_ON_COPY_SANITY_CHECK_FAIL(
;;;1593           ("tcp_output_segment: calculated checksum is %"X16_F" instead of %"X16_F"\n",
;;;1594            seg->tcphdr->chksum, chksum_slow));
;;;1595         seg->tcphdr->chksum = chksum_slow;
;;;1596       }
;;;1597   #endif /* TCP_CHECKSUM_ON_COPY_SANITY_CHECK */
;;;1598   #else /* TCP_CHECKSUM_ON_COPY */
;;;1599       seg->tcphdr->chksum = ip_chksum_pseudo(seg->p, IP_PROTO_TCP,
;;;1600                                              seg->p->tot_len, &pcb->local_ip, &pcb->remote_ip);
;;;1601   #endif /* TCP_CHECKSUM_ON_COPY */
;;;1602     }
;;;1603   #endif /* CHECKSUM_GEN_TCP */
;;;1604     TCP_STATS_INC(tcp.xmit);
;;;1605   
;;;1606     NETIF_SET_HINTS(netif, &(pcb->netif_hints));
;;;1607     err = ip_output_if(seg->p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl,
;;;1608                        pcb->tos, IP_PROTO_TCP, netif);
;;;1609     NETIF_RESET_HINTS(netif);
;;;1610   
;;;1611   #if TCP_CHECKSUM_ON_COPY
;;;1612     if (seg_chksum_was_swapped) {
;;;1613       /* if data is added to this segment later, chksum needs to be swapped,
;;;1614          so restore this now */
;;;1615       seg->chksum = SWAP_BYTES_IN_WORD(seg->chksum);
;;;1616       seg->chksum_swapped = 1;
;;;1617     }
;;;1618   #endif
;;;1619   
;;;1620     return err;
;;;1621   }
00004a  e8bd83fe          POP      {r1-r9,pc}
                  |L9.78|
00004e  6a60              LDR      r0,[r4,#0x24]         ;1477
000050  f7fffffe          BL       lwip_htonl
000054  68e9              LDR      r1,[r5,#0xc]          ;1477
000056  6088              STR      r0,[r1,#8]            ;1477
000058  8d60              LDRH     r0,[r4,#0x2a]         ;1488
00005a  f7fffffe          BL       lwip_htons
00005e  68e9              LDR      r1,[r5,#0xc]          ;1488
000060  81c8              STRH     r0,[r1,#0xe]          ;1488
000062  8d61              LDRH     r1,[r4,#0x2a]         ;1491
000064  6a60              LDR      r0,[r4,#0x24]         ;1491
000066  4408              ADD      r0,r0,r1              ;1491
000068  62e0              STR      r0,[r4,#0x2c]         ;1491
00006a  68ee              LDR      r6,[r5,#0xc]          ;1496
00006c  3614              ADDS     r6,r6,#0x14           ;1496
00006e  7aa8              LDRB     r0,[r5,#0xa]          ;1497
000070  07c0              LSLS     r0,r0,#31             ;1497
000072  d00a              BEQ      |L9.138|
000074  1d22              ADDS     r2,r4,#4              ;1500
000076  4639              MOV      r1,r7                 ;1500
000078  f44f7006          MOV      r0,#0x218             ;1500
00007c  f7fffffe          BL       tcp_eff_send_mss_netif
000080  f0407001          ORR      r0,r0,#0x2040000      ;1504
000084  f7fffffe          BL       lwip_htonl
000088  c601              STM      r6!,{r0}              ;1504
                  |L9.138|
00008a  f9b40030          LDRSH    r0,[r4,#0x30]         ;1534
00008e  f04f0800          MOV      r8,#0                 ;1534
000092  2800              CMP      r0,#0                 ;1534
000094  da01              BGE      |L9.154|
000096  f8a48030          STRH     r8,[r4,#0x30]         ;1535
                  |L9.154|
00009a  6b60              LDR      r0,[r4,#0x34]         ;1538
00009c  b938              CBNZ     r0,|L9.174|
00009e  484b              LDR      r0,|L9.460|
0000a0  6800              LDR      r0,[r0,#0]            ;1539  ; tcp_ticks
0000a2  6360              STR      r0,[r4,#0x34]         ;1539
0000a4  68e8              LDR      r0,[r5,#0xc]          ;1540
0000a6  6840              LDR      r0,[r0,#4]            ;1540
0000a8  f7fffffe          BL       lwip_htonl
0000ac  63a0              STR      r0,[r4,#0x38]         ;1540
                  |L9.174|
0000ae  6869              LDR      r1,[r5,#4]            ;1548
0000b0  89a8              LDRH     r0,[r5,#0xc]          ;1548
0000b2  888a              LDRH     r2,[r1,#4]            ;1548
0000b4  1a80              SUBS     r0,r0,r2              ;1548
0000b6  894a              LDRH     r2,[r1,#0xa]          ;1554
0000b8  1a12              SUBS     r2,r2,r0              ;1554
0000ba  814a              STRH     r2,[r1,#0xa]          ;1554
0000bc  6869              LDR      r1,[r5,#4]            ;1555
0000be  890a              LDRH     r2,[r1,#8]            ;1555
0000c0  1a10              SUBS     r0,r2,r0              ;1555
0000c2  8108              STRH     r0,[r1,#8]            ;1555
0000c4  6869              LDR      r1,[r5,#4]            ;1557
0000c6  68e8              LDR      r0,[r5,#0xc]          ;1557
0000c8  6048              STR      r0,[r1,#4]            ;1557
0000ca  68e8              LDR      r0,[r5,#0xc]          ;1559
0000cc  f8a08010          STRH     r8,[r0,#0x10]         ;1559
0000d0  7aa8              LDRB     r0,[r5,#0xa]          ;1564
0000d2  68e9              LDR      r1,[r5,#0xc]          ;1564
0000d4  07c0              LSLS     r0,r0,#31             ;1564
0000d6  d001              BEQ      |L9.220|
0000d8  2004              MOVS     r0,#4                 ;1564
0000da  e000              B        |L9.222|
                  |L9.220|
0000dc  2000              MOVS     r0,#0                 ;1564
                  |L9.222|
0000de  3014              ADDS     r0,r0,#0x14           ;1564
0000e0  4408              ADD      r0,r0,r1              ;1564
0000e2  42b0              CMP      r0,r6                 ;1564
0000e4  d006              BEQ      |L9.244|
0000e6  a309              ADR      r3,|L9.268|
0000e8  f240621c          MOV      r2,#0x61c             ;1564
0000ec  a138              ADR      r1,|L9.464|
0000ee  a01c              ADR      r0,|L9.352|
0000f0  f7fffffe          BL       __2printf
                  |L9.244|
0000f4  7aa0              LDRB     r0,[r4,#0xa]          ;1607
0000f6  2106              MOVS     r1,#6                 ;1607
0000f8  e88d0083          STM      sp,{r0,r1,r7}         ;1607
0000fc  7ae3              LDRB     r3,[r4,#0xb]          ;1607
0000fe  1d22              ADDS     r2,r4,#4              ;1607
000100  4621              MOV      r1,r4                 ;1607
000102  6868              LDR      r0,[r5,#4]            ;1607
000104  f7fffffe          BL       ip4_output_if
000108  e79f              B        |L9.74|
;;;1622   
                          ENDP

00010a  0000              DCW      0x0000
                  |L9.268|
00010c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000110  6964646c
000114  65776172
000118  65735c54
00011c  68697264
000120  5f506172
000124  74795c4c
000128  7749505c
00012c  7372635c
000130  636f7265
000134  5c746370
000138  5f6f7574
00013c  2e      
00013d  6300              DCB      "c",0
00013f  00                DCB      0
                  |L9.320|
000140  7463705f          DCB      "tcp_output_segment: invalid seg",0
000144  6f757470
000148  75745f73
00014c  65676d65
000150  6e743a20
000154  696e7661
000158  6c696420
00015c  73656700
                  |L9.352|
000160  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000164  7274696f
000168  6e202225
00016c  73222066
000170  61696c65
000174  64206174
000178  206c696e
00017c  65202564
000180  20696e20
000184  25730a00
                  |L9.392|
000188  7463705f          DCB      "tcp_output_segment: invalid pcb",0
00018c  6f757470
000190  75745f73
000194  65676d65
000198  6e743a20
00019c  696e7661
0001a0  6c696420
0001a4  70636200
                  |L9.424|
0001a8  7463705f          DCB      "tcp_output_segment: invalid netif",0
0001ac  6f757470
0001b0  75745f73
0001b4  65676d65
0001b8  6e743a20
0001bc  696e7661
0001c0  6c696420
0001c4  6e657469
0001c8  6600    
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L9.460|
                          DCD      tcp_ticks
                  |L9.464|
0001d0  6f707469          DCB      "options not filled",0
0001d4  6f6e7320
0001d8  6e6f7420
0001dc  66696c6c
0001e0  656400  
0001e3  00                DCB      0

                          AREA ||i.tcp_output_segment_busy||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_output_segment_busy PROC
;;;1431   static int
;;;1432   tcp_output_segment_busy(const struct tcp_seg *seg)
000000  b510              PUSH     {r4,lr}
;;;1433   {
000002  4604              MOV      r4,r0
;;;1434     LWIP_ASSERT("tcp_output_segment_busy: invalid seg", seg != NULL);
000004  2c00              CMP      r4,#0
000006  d106              BNE      |L10.22|
000008  a307              ADR      r3,|L10.40|
00000a  f240529a          MOV      r2,#0x59a
00000e  a113              ADR      r1,|L10.92|
000010  a01c              ADR      r0,|L10.132|
000012  f7fffffe          BL       __2printf
                  |L10.22|
;;;1435   
;;;1436     /* We only need to check the first pbuf here:
;;;1437        If a pbuf is queued for transmission, a driver calls pbuf_ref(),
;;;1438        which only changes the ref count of the first pbuf */
;;;1439     if (seg->p->ref != 1) {
000016  6860              LDR      r0,[r4,#4]
000018  7b80              LDRB     r0,[r0,#0xe]
00001a  2801              CMP      r0,#1
00001c  d001              BEQ      |L10.34|
;;;1440       /* other reference found */
;;;1441       return 1;
00001e  2001              MOVS     r0,#1
;;;1442     }
;;;1443     /* no other references found */
;;;1444     return 0;
;;;1445   }
000020  bd10              POP      {r4,pc}
                  |L10.34|
000022  2000              MOVS     r0,#0                 ;1444
000024  bd10              POP      {r4,pc}
;;;1446   
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
000028  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
00002c  6964646c
000030  65776172
000034  65735c54
000038  68697264
00003c  5f506172
000040  74795c4c
000044  7749505c
000048  7372635c
00004c  636f7265
000050  5c746370
000054  5f6f7574
000058  2e      
000059  6300              DCB      "c",0
00005b  00                DCB      0
                  |L10.92|
00005c  7463705f          DCB      "tcp_output_segment_busy: invalid seg",0
000060  6f757470
000064  75745f73
000068  65676d65
00006c  6e745f62
000070  7573793a
000074  20696e76
000078  616c6964
00007c  20736567
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0
                  |L10.132|
000084  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000088  7274696f
00008c  6e202225
000090  73222066
000094  61696c65
000098  64206174
00009c  206c696e
0000a0  65202564
0000a4  20696e20
0000a8  25730a00

                          AREA ||i.tcp_pbuf_prealloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_pbuf_prealloc PROC
;;;224    static struct pbuf *
;;;225    tcp_pbuf_prealloc(pbuf_layer layer, u16_t length, u16_t max_length,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;226                      u16_t *oversize, const struct tcp_pcb *pcb, u8_t apiflags,
;;;227                      u8_t first_seg)
;;;228    {
000004  e9ddab0b          LDRD     r10,r11,[sp,#0x2c]
000008  9c0a              LDR      r4,[sp,#0x28]
00000a  4681              MOV      r9,r0
00000c  460d              MOV      r5,r1
00000e  4616              MOV      r6,r2
000010  4698              MOV      r8,r3
;;;229      struct pbuf *p;
;;;230      u16_t alloc = length;
000012  462f              MOV      r7,r5
;;;231    
;;;232      LWIP_ASSERT("tcp_pbuf_prealloc: invalid oversize", oversize != NULL);
000014  f1b80f00          CMP      r8,#0
000018  d105              BNE      |L11.38|
00001a  a320              ADR      r3,|L11.156|
00001c  22e8              MOVS     r2,#0xe8
00001e  a12c              ADR      r1,|L11.208|
000020  a034              ADR      r0,|L11.244|
000022  f7fffffe          BL       __2printf
                  |L11.38|
;;;233      LWIP_ASSERT("tcp_pbuf_prealloc: invalid pcb", pcb != NULL);
000026  2c00              CMP      r4,#0
000028  d105              BNE      |L11.54|
00002a  a31c              ADR      r3,|L11.156|
00002c  22e9              MOVS     r2,#0xe9
00002e  a13b              ADR      r1,|L11.284|
000030  a030              ADR      r0,|L11.244|
000032  f7fffffe          BL       __2printf
                  |L11.54|
;;;234    
;;;235    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;236      LWIP_UNUSED_ARG(max_length);
;;;237      LWIP_UNUSED_ARG(pcb);
;;;238      LWIP_UNUSED_ARG(apiflags);
;;;239      LWIP_UNUSED_ARG(first_seg);
;;;240      alloc = max_length;
;;;241    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;242      if (length < max_length) {
000036  42b5              CMP      r5,r6
000038  d214              BCS      |L11.100|
;;;243        /* Should we allocate an oversized pbuf, or just the minimum
;;;244         * length required? If tcp_write is going to be called again
;;;245         * before this segment is transmitted, we want the oversized
;;;246         * buffer. If the segment will be transmitted immediately, we can
;;;247         * save memory by allocating only length. We use a simple
;;;248         * heuristic based on the following information:
;;;249         *
;;;250         * Did the user set TCP_WRITE_FLAG_MORE?
;;;251         *
;;;252         * Will the Nagle algorithm defer transmission of this segment?
;;;253         */
;;;254        if ((apiflags & TCP_WRITE_FLAG_MORE) ||
00003a  ea5f708a          LSLS     r0,r10,#30
00003e  d409              BMI      |L11.84|
;;;255            (!(pcb->flags & TF_NODELAY) &&
000040  7ea0              LDRB     r0,[r4,#0x1a]
000042  0640              LSLS     r0,r0,#25
000044  d40e              BMI      |L11.100|
;;;256             (!first_seg ||
000046  f1bb0f00          CMP      r11,#0
00004a  d003              BEQ      |L11.84|
;;;257              pcb->unsent != NULL ||
00004c  6ee0              LDR      r0,[r4,#0x6c]
00004e  b908              CBNZ     r0,|L11.84|
;;;258              pcb->unacked != NULL))) {
000050  6f20              LDR      r0,[r4,#0x70]
000052  b138              CBZ      r0,|L11.100|
                  |L11.84|
;;;259          alloc = LWIP_MIN(max_length, LWIP_MEM_ALIGN_SIZE(TCP_OVERSIZE_CALC_LENGTH(length)));
000054  f205201b          ADD      r0,r5,#0x21b
000058  f0200103          BIC      r1,r0,#3
00005c  42b1              CMP      r1,r6
00005e  d800              BHI      |L11.98|
000060  460e              MOV      r6,r1
                  |L11.98|
000062  b2b7              UXTH     r7,r6
                  |L11.100|
;;;260        }
;;;261      }
;;;262    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;263      p = pbuf_alloc(layer, alloc, PBUF_RAM);
000064  f44f7220          MOV      r2,#0x280
000068  4639              MOV      r1,r7
00006a  4648              MOV      r0,r9
00006c  f7fffffe          BL       pbuf_alloc
000070  4604              MOV      r4,r0
;;;264      if (p == NULL) {
000072  b18c              CBZ      r4,|L11.152|
;;;265        return NULL;
;;;266      }
;;;267      LWIP_ASSERT("need unchained pbuf", p->next == NULL);
000074  6820              LDR      r0,[r4,#0]
000076  b130              CBZ      r0,|L11.134|
000078  a308              ADR      r3,|L11.156|
00007a  f240120b          MOV      r2,#0x10b
00007e  a12f              ADR      r1,|L11.316|
000080  a01c              ADR      r0,|L11.244|
000082  f7fffffe          BL       __2printf
                  |L11.134|
;;;268      *oversize = p->len - length;
000086  8960              LDRH     r0,[r4,#0xa]
000088  1b40              SUBS     r0,r0,r5
00008a  f8a80000          STRH     r0,[r8,#0]
;;;269      /* trim p->len to the currently used size */
;;;270      p->len = p->tot_len = length;
00008e  8125              STRH     r5,[r4,#8]
000090  8165              STRH     r5,[r4,#0xa]
;;;271      return p;
000092  4620              MOV      r0,r4
                  |L11.148|
;;;272    }
000094  e8bd9ff0          POP      {r4-r12,pc}
                  |L11.152|
000098  2000              MOVS     r0,#0                 ;265
00009a  e7fb              B        |L11.148|
;;;273    #else /* TCP_OVERSIZE */
                          ENDP

                  |L11.156|
00009c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
0000a0  6964646c
0000a4  65776172
0000a8  65735c54
0000ac  68697264
0000b0  5f506172
0000b4  74795c4c
0000b8  7749505c
0000bc  7372635c
0000c0  636f7265
0000c4  5c746370
0000c8  5f6f7574
0000cc  2e      
0000cd  6300              DCB      "c",0
0000cf  00                DCB      0
                  |L11.208|
0000d0  7463705f          DCB      "tcp_pbuf_prealloc: invalid oversize",0
0000d4  70627566
0000d8  5f707265
0000dc  616c6c6f
0000e0  633a2069
0000e4  6e76616c
0000e8  6964206f
0000ec  76657273
0000f0  697a6500
                  |L11.244|
0000f4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000f8  7274696f
0000fc  6e202225
000100  73222066
000104  61696c65
000108  64206174
00010c  206c696e
000110  65202564
000114  20696e20
000118  25730a00
                  |L11.284|
00011c  7463705f          DCB      "tcp_pbuf_prealloc: invalid pcb",0
000120  70627566
000124  5f707265
000128  616c6c6f
00012c  633a2069
000130  6e76616c
000134  69642070
000138  636200  
00013b  00                DCB      0
                  |L11.316|
00013c  6e656564          DCB      "need unchained pbuf",0
000140  20756e63
000144  6861696e
000148  65642070
00014c  62756600

                          AREA ||i.tcp_rexmit||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_rexmit PROC
;;;1723   err_t
;;;1724   tcp_rexmit(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1725   {
000004  4605              MOV      r5,r0
;;;1726     struct tcp_seg *seg;
;;;1727     struct tcp_seg **cur_seg;
;;;1728   
;;;1729     LWIP_ASSERT("tcp_rexmit: invalid pcb", pcb != NULL);
000006  2d00              CMP      r5,#0
000008  d106              BNE      |L12.24|
00000a  a31c              ADR      r3,|L12.124|
00000c  f24062c1          MOV      r2,#0x6c1
000010  a127              ADR      r1,|L12.176|
000012  a02d              ADR      r0,|L12.200|
000014  f7fffffe          BL       __2printf
                  |L12.24|
;;;1730   
;;;1731     if (pcb->unacked == NULL) {
000018  6f2e              LDR      r6,[r5,#0x70]
;;;1732       return ERR_VAL;
00001a  f06f0405          MVN      r4,#5
00001e  b136              CBZ      r6,|L12.46|
;;;1733     }
;;;1734   
;;;1735     seg = pcb->unacked;
;;;1736   
;;;1737     /* Give up if the segment is still referenced by the netif driver
;;;1738        due to deferred transmission. */
;;;1739     if (tcp_output_segment_busy(seg)) {
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       tcp_output_segment_busy
000026  b120              CBZ      r0,|L12.50|
;;;1740       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit busy\n"));
;;;1741       return ERR_VAL;
000028  4620              MOV      r0,r4
                  |L12.42|
;;;1742     }
;;;1743   
;;;1744     /* Move the first unacked segment to the unsent queue */
;;;1745     /* Keep the unsent queue sorted. */
;;;1746     pcb->unacked = seg->next;
;;;1747   
;;;1748     cur_seg = &(pcb->unsent);
;;;1749     while (*cur_seg &&
;;;1750            TCP_SEQ_LT(lwip_ntohl((*cur_seg)->tcphdr->seqno), lwip_ntohl(seg->tcphdr->seqno))) {
;;;1751       cur_seg = &((*cur_seg)->next );
;;;1752     }
;;;1753     seg->next = *cur_seg;
;;;1754     *cur_seg = seg;
;;;1755   #if TCP_OVERSIZE
;;;1756     if (seg->next == NULL) {
;;;1757       /* the retransmitted segment is last in unsent, so reset unsent_oversize */
;;;1758       pcb->unsent_oversize = 0;
;;;1759     }
;;;1760   #endif /* TCP_OVERSIZE */
;;;1761   
;;;1762     if (pcb->nrtx < 0xFF) {
;;;1763       ++pcb->nrtx;
;;;1764     }
;;;1765   
;;;1766     /* Don't take any rtt measurements after retransmitting. */
;;;1767     pcb->rttest = 0;
;;;1768   
;;;1769     /* Do the actual retransmission. */
;;;1770     MIB2_STATS_INC(mib2.tcpretranssegs);
;;;1771     /* No need to call tcp_output: we are always called from tcp_input()
;;;1772        and thus tcp_output directly returns. */
;;;1773     return ERR_OK;
;;;1774   }
00002a  e8bd81f0          POP      {r4-r8,pc}
                  |L12.46|
00002e  4620              MOV      r0,r4                 ;1732
000030  e7fb              B        |L12.42|
                  |L12.50|
000032  6830              LDR      r0,[r6,#0]            ;1746
000034  6728              STR      r0,[r5,#0x70]         ;1746
000036  f105046c          ADD      r4,r5,#0x6c           ;1748
00003a  e000              B        |L12.62|
                  |L12.60|
00003c  6824              LDR      r4,[r4,#0]            ;1751
                  |L12.62|
00003e  6820              LDR      r0,[r4,#0]            ;1749
000040  b150              CBZ      r0,|L12.88|
000042  68c0              LDR      r0,[r0,#0xc]          ;1750
000044  6840              LDR      r0,[r0,#4]            ;1750
000046  f7fffffe          BL       lwip_htonl
00004a  4607              MOV      r7,r0                 ;1750
00004c  68f0              LDR      r0,[r6,#0xc]          ;1750
00004e  6840              LDR      r0,[r0,#4]            ;1750
000050  f7fffffe          BL       lwip_htonl
000054  1a38              SUBS     r0,r7,r0              ;1750
000056  d4f1              BMI      |L12.60|
                  |L12.88|
000058  6820              LDR      r0,[r4,#0]            ;1753
00005a  6030              STR      r0,[r6,#0]            ;1753
00005c  6026              STR      r6,[r4,#0]            ;1754
00005e  6830              LDR      r0,[r6,#0]            ;1756
000060  2100              MOVS     r1,#0                 ;1756
000062  b908              CBNZ     r0,|L12.104|
000064  f8a51068          STRH     r1,[r5,#0x68]         ;1758
                  |L12.104|
000068  f8950042          LDRB     r0,[r5,#0x42]         ;1762
00006c  28ff              CMP      r0,#0xff              ;1762
00006e  d202              BCS      |L12.118|
000070  1c40              ADDS     r0,r0,#1              ;1763
000072  f8850042          STRB     r0,[r5,#0x42]         ;1763
                  |L12.118|
000076  6369              STR      r1,[r5,#0x34]         ;1767
000078  2000              MOVS     r0,#0                 ;1773
00007a  e7d6              B        |L12.42|
;;;1775   
                          ENDP

                  |L12.124|
00007c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000080  6964646c
000084  65776172
000088  65735c54
00008c  68697264
000090  5f506172
000094  74795c4c
000098  7749505c
00009c  7372635c
0000a0  636f7265
0000a4  5c746370
0000a8  5f6f7574
0000ac  2e      
0000ad  6300              DCB      "c",0
0000af  00                DCB      0
                  |L12.176|
0000b0  7463705f          DCB      "tcp_rexmit: invalid pcb",0
0000b4  7265786d
0000b8  69743a20
0000bc  696e7661
0000c0  6c696420
0000c4  70636200
                  |L12.200|
0000c8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000cc  7274696f
0000d0  6e202225
0000d4  73222066
0000d8  61696c65
0000dc  64206174
0000e0  206c696e
0000e4  65202564
0000e8  20696e20
0000ec  25730a00

                          AREA ||i.tcp_rexmit_fast||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_rexmit_fast PROC
;;;1782   void
;;;1783   tcp_rexmit_fast(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;1784   {
000002  4604              MOV      r4,r0
;;;1785     LWIP_ASSERT("tcp_rexmit_fast: invalid pcb", pcb != NULL);
000004  2c00              CMP      r4,#0
000006  d106              BNE      |L13.22|
000008  a319              ADR      r3,|L13.112|
00000a  f24062f9          MOV      r2,#0x6f9
00000e  a125              ADR      r1,|L13.164|
000010  a02c              ADR      r0,|L13.196|
000012  f7fffffe          BL       __2printf
                  |L13.22|
;;;1786   
;;;1787     if (pcb->unacked != NULL && !(pcb->flags & TF_INFR)) {
000016  6f20              LDR      r0,[r4,#0x70]
000018  2800              CMP      r0,#0
00001a  d027              BEQ      |L13.108|
00001c  7ea0              LDRB     r0,[r4,#0x1a]
00001e  0740              LSLS     r0,r0,#29
000020  d424              BMI      |L13.108|
;;;1788       /* This is fast retransmit. Retransmit the first unacked segment. */
;;;1789       LWIP_DEBUGF(TCP_FR_DEBUG,
;;;1790                   ("tcp_receive: dupacks %"U16_F" (%"U32_F
;;;1791                    "), fast retransmit %"U32_F"\n",
;;;1792                    (u16_t)pcb->dupacks, pcb->lastack,
;;;1793                    lwip_ntohl(pcb->unacked->tcphdr->seqno)));
;;;1794       if (tcp_rexmit(pcb) == ERR_OK) {
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       tcp_rexmit
000028  2800              CMP      r0,#0
00002a  d11f              BNE      |L13.108|
;;;1795         /* Set ssthresh to half of the minimum of the current
;;;1796          * cwnd and the advertised window */
;;;1797         pcb->ssthresh = LWIP_MIN(pcb->cwnd, pcb->snd_wnd) / 2;
00002c  f8b41048          LDRH     r1,[r4,#0x48]
000030  f8b40060          LDRH     r0,[r4,#0x60]
000034  4281              CMP      r1,r0
000036  d200              BCS      |L13.58|
000038  4608              MOV      r0,r1
                  |L13.58|
00003a  0841              LSRS     r1,r0,#1
00003c  f8a4104a          STRH     r1,[r4,#0x4a]
;;;1798   
;;;1799         /* The minimum value for ssthresh should be 2 MSS */
;;;1800         if (pcb->ssthresh < (2U * pcb->mss)) {
000040  8e60              LDRH     r0,[r4,#0x32]
000042  ebb10f40          CMP      r1,r0,LSL #1
000046  d205              BCS      |L13.84|
;;;1801           LWIP_DEBUGF(TCP_FR_DEBUG,
;;;1802                       ("tcp_receive: The minimum value for ssthresh %"TCPWNDSIZE_F
;;;1803                        " should be min 2 mss %"U16_F"...\n",
;;;1804                        pcb->ssthresh, (u16_t)(2 * pcb->mss)));
;;;1805           pcb->ssthresh = 2 * pcb->mss;
000048  f64f71ff          MOV      r1,#0xffff
00004c  ea010140          AND      r1,r1,r0,LSL #1
000050  f8a4104a          STRH     r1,[r4,#0x4a]
                  |L13.84|
;;;1806         }
;;;1807   
;;;1808         pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
000054  341a              ADDS     r4,r4,#0x1a
000056  eb000040          ADD      r0,r0,r0,LSL #1
00005a  8e21              LDRH     r1,[r4,#0x30]
00005c  4408              ADD      r0,r0,r1
00005e  85e0              STRH     r0,[r4,#0x2e]
;;;1809         tcp_set_flags(pcb, TF_INFR);
000060  8820              LDRH     r0,[r4,#0]
000062  f0400004          ORR      r0,r0,#4
000066  8020              STRH     r0,[r4,#0]
;;;1810   
;;;1811         /* Reset the retransmission timer to prevent immediate rto retransmissions */
;;;1812         pcb->rtime = 0;
000068  2000              MOVS     r0,#0
00006a  82e0              STRH     r0,[r4,#0x16]
                  |L13.108|
;;;1813       }
;;;1814     }
;;;1815   }
00006c  bd10              POP      {r4,pc}
;;;1816   
                          ENDP

00006e  0000              DCW      0x0000
                  |L13.112|
000070  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000074  6964646c
000078  65776172
00007c  65735c54
000080  68697264
000084  5f506172
000088  74795c4c
00008c  7749505c
000090  7372635c
000094  636f7265
000098  5c746370
00009c  5f6f7574
0000a0  2e      
0000a1  6300              DCB      "c",0
0000a3  00                DCB      0
                  |L13.164|
0000a4  7463705f          DCB      "tcp_rexmit_fast: invalid pcb",0
0000a8  7265786d
0000ac  69745f66
0000b0  6173743a
0000b4  20696e76
0000b8  616c6964
0000bc  20706362
0000c0  00      
0000c1  00                DCB      0
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L13.196|
0000c4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000c8  7274696f
0000cc  6e202225
0000d0  73222066
0000d4  61696c65
0000d8  64206174
0000dc  206c696e
0000e0  65202564
0000e4  20696e20
0000e8  25730a00

                          AREA ||i.tcp_rexmit_rto||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_rexmit_rto PROC
;;;1706   void
;;;1707   tcp_rexmit_rto(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;1708   {
000002  4604              MOV      r4,r0
;;;1709     LWIP_ASSERT("tcp_rexmit_rto: invalid pcb", pcb != NULL);
000004  2c00              CMP      r4,#0
000006  d106              BNE      |L14.22|
000008  a308              ADR      r3,|L14.44|
00000a  f24062ad          MOV      r2,#0x6ad
00000e  a114              ADR      r1,|L14.96|
000010  a01a              ADR      r0,|L14.124|
000012  f7fffffe          BL       __2printf
                  |L14.22|
;;;1710   
;;;1711     if (tcp_rexmit_rto_prepare(pcb) == ERR_OK) {
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       tcp_rexmit_rto_prepare
00001c  2800              CMP      r0,#0
00001e  d104              BNE      |L14.42|
;;;1712       tcp_rexmit_rto_commit(pcb);
000020  4620              MOV      r0,r4
000022  e8bd4010          POP      {r4,lr}
000026  f7ffbffe          B.W      tcp_rexmit_rto_commit
                  |L14.42|
;;;1713     }
;;;1714   }
00002a  bd10              POP      {r4,pc}
;;;1715   
                          ENDP

                  |L14.44|
00002c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000030  6964646c
000034  65776172
000038  65735c54
00003c  68697264
000040  5f506172
000044  74795c4c
000048  7749505c
00004c  7372635c
000050  636f7265
000054  5c746370
000058  5f6f7574
00005c  2e      
00005d  6300              DCB      "c",0
00005f  00                DCB      0
                  |L14.96|
000060  7463705f          DCB      "tcp_rexmit_rto: invalid pcb",0
000064  7265786d
000068  69745f72
00006c  746f3a20
000070  696e7661
000074  6c696420
000078  70636200
                  |L14.124|
00007c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000080  7274696f
000084  6e202225
000088  73222066
00008c  61696c65
000090  64206174
000094  206c696e
000098  65202564
00009c  20696e20
0000a0  25730a00

                          AREA ||i.tcp_rexmit_rto_commit||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_rexmit_rto_commit PROC
;;;1685   void
;;;1686   tcp_rexmit_rto_commit(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;1687   {
000002  4604              MOV      r4,r0
;;;1688     LWIP_ASSERT("tcp_rexmit_rto_commit: invalid pcb", pcb != NULL);
000004  2c00              CMP      r4,#0
000006  d106              BNE      |L15.22|
000008  a309              ADR      r3,|L15.48|
00000a  f44f62d3          MOV      r2,#0x698
00000e  a115              ADR      r1,|L15.100|
000010  a01d              ADR      r0,|L15.136|
000012  f7fffffe          BL       __2printf
                  |L15.22|
;;;1689   
;;;1690     /* increment number of retransmissions */
;;;1691     if (pcb->nrtx < 0xFF) {
000016  f8940042          LDRB     r0,[r4,#0x42]
00001a  28ff              CMP      r0,#0xff
00001c  d202              BCS      |L15.36|
;;;1692       ++pcb->nrtx;
00001e  1c40              ADDS     r0,r0,#1
000020  f8840042          STRB     r0,[r4,#0x42]
                  |L15.36|
;;;1693     }
;;;1694     /* Do the actual retransmission */
;;;1695     tcp_output(pcb);
000024  4620              MOV      r0,r4
000026  e8bd4010          POP      {r4,lr}
00002a  f7ffbffe          B.W      tcp_output
;;;1696   }
;;;1697   
                          ENDP

00002e  0000              DCW      0x0000
                  |L15.48|
000030  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000034  6964646c
000038  65776172
00003c  65735c54
000040  68697264
000044  5f506172
000048  74795c4c
00004c  7749505c
000050  7372635c
000054  636f7265
000058  5c746370
00005c  5f6f7574
000060  2e      
000061  6300              DCB      "c",0
000063  00                DCB      0
                  |L15.100|
000064  7463705f          DCB      "tcp_rexmit_rto_commit: invalid pcb",0
000068  7265786d
00006c  69745f72
000070  746f5f63
000074  6f6d6d69
000078  743a2069
00007c  6e76616c
000080  69642070
000084  636200  
000087  00                DCB      0
                  |L15.136|
000088  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00008c  7274696f
000090  6e202225
000094  73222066
000098  61696c65
00009c  64206174
0000a0  206c696e
0000a4  65202564
0000a8  20696e20
0000ac  25730a00

                          AREA ||i.tcp_rexmit_rto_prepare||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_rexmit_rto_prepare PROC
;;;1630   err_t
;;;1631   tcp_rexmit_rto_prepare(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1632   {
000004  4605              MOV      r5,r0
;;;1633     struct tcp_seg *seg;
;;;1634   
;;;1635     LWIP_ASSERT("tcp_rexmit_rto_prepare: invalid pcb", pcb != NULL);
000006  2d00              CMP      r5,#0
000008  d106              BNE      |L16.24|
00000a  a31e              ADR      r3,|L16.132|
00000c  f2406263          MOV      r2,#0x663
000010  a129              ADR      r1,|L16.184|
000012  a032              ADR      r0,|L16.220|
000014  f7fffffe          BL       __2printf
                  |L16.24|
;;;1636   
;;;1637     if (pcb->unacked == NULL) {
000018  6f2c              LDR      r4,[r5,#0x70]
;;;1638       return ERR_VAL;
00001a  f06f0605          MVN      r6,#5
00001e  b94c              CBNZ     r4,|L16.52|
000020  4630              MOV      r0,r6
                  |L16.34|
;;;1639     }
;;;1640   
;;;1641     /* Move all unacked segments to the head of the unsent queue.
;;;1642        However, give up if any of the unsent pbufs are still referenced by the
;;;1643        netif driver due to deferred transmission. No point loading the link further
;;;1644        if it is struggling to flush its buffered writes. */
;;;1645     for (seg = pcb->unacked; seg->next != NULL; seg = seg->next) {
;;;1646       if (tcp_output_segment_busy(seg)) {
;;;1647         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
;;;1648         return ERR_VAL;
;;;1649       }
;;;1650     }
;;;1651     if (tcp_output_segment_busy(seg)) {
;;;1652       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_rexmit_rto: segment busy\n"));
;;;1653       return ERR_VAL;
;;;1654     }
;;;1655     /* concatenate unsent queue after unacked queue */
;;;1656     seg->next = pcb->unsent;
;;;1657   #if TCP_OVERSIZE_DBGCHECK
;;;1658     /* if last unsent changed, we need to update unsent_oversize */
;;;1659     if (pcb->unsent == NULL) {
;;;1660       pcb->unsent_oversize = seg->oversize_left;
;;;1661     }
;;;1662   #endif /* TCP_OVERSIZE_DBGCHECK */
;;;1663     /* unsent queue is the concatenated queue (of unacked, unsent) */
;;;1664     pcb->unsent = pcb->unacked;
;;;1665     /* unacked queue is now empty */
;;;1666     pcb->unacked = NULL;
;;;1667   
;;;1668     /* Mark RTO in-progress */
;;;1669     tcp_set_flags(pcb, TF_RTO);
;;;1670     /* Record the next byte following retransmit */
;;;1671     pcb->rto_end = lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
;;;1672     /* Don't take any RTT measurements after retransmitting. */
;;;1673     pcb->rttest = 0;
;;;1674   
;;;1675     return ERR_OK;
;;;1676   }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L16.38|
000026  4620              MOV      r0,r4                 ;1646
000028  f7fffffe          BL       tcp_output_segment_busy
00002c  b108              CBZ      r0,|L16.50|
00002e  4630              MOV      r0,r6                 ;1648
000030  e7f7              B        |L16.34|
                  |L16.50|
000032  6824              LDR      r4,[r4,#0]            ;1645
                  |L16.52|
000034  6820              LDR      r0,[r4,#0]            ;1645
000036  2800              CMP      r0,#0                 ;1645
000038  d1f5              BNE      |L16.38|
00003a  4620              MOV      r0,r4                 ;1651
00003c  f7fffffe          BL       tcp_output_segment_busy
000040  b108              CBZ      r0,|L16.70|
000042  4630              MOV      r0,r6                 ;1653
000044  e7ed              B        |L16.34|
                  |L16.70|
000046  6ee8              LDR      r0,[r5,#0x6c]         ;1656
000048  6020              STR      r0,[r4,#0]            ;1656
00004a  6f28              LDR      r0,[r5,#0x70]         ;1664
00004c  66e8              STR      r0,[r5,#0x6c]         ;1664
00004e  2700              MOVS     r7,#0                 ;1666
000050  672f              STR      r7,[r5,#0x70]         ;1666
000052  8b68              LDRH     r0,[r5,#0x1a]         ;1669
000054  f4406000          ORR      r0,r0,#0x800          ;1669
000058  8368              STRH     r0,[r5,#0x1a]         ;1669
00005a  68e0              LDR      r0,[r4,#0xc]          ;1671
00005c  6840              LDR      r0,[r0,#4]            ;1671
00005e  f7fffffe          BL       lwip_htonl
000062  4606              MOV      r6,r0                 ;1671
000064  68e0              LDR      r0,[r4,#0xc]          ;1671
000066  8980              LDRH     r0,[r0,#0xc]          ;1671
000068  f7fffffe          BL       lwip_htons
00006c  0780              LSLS     r0,r0,#30             ;1671
00006e  d001              BEQ      |L16.116|
000070  2001              MOVS     r0,#1                 ;1671
000072  e000              B        |L16.118|
                  |L16.116|
000074  2000              MOVS     r0,#0                 ;1671
                  |L16.118|
000076  8921              LDRH     r1,[r4,#8]            ;1671
000078  4430              ADD      r0,r0,r6              ;1671
00007a  4408              ADD      r0,r0,r1              ;1671
00007c  64e8              STR      r0,[r5,#0x4c]         ;1671
00007e  636f              STR      r7,[r5,#0x34]         ;1673
000080  2000              MOVS     r0,#0                 ;1675
000082  e7ce              B        |L16.34|
;;;1677   
                          ENDP

                  |L16.132|
000084  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000088  6964646c
00008c  65776172
000090  65735c54
000094  68697264
000098  5f506172
00009c  74795c4c
0000a0  7749505c
0000a4  7372635c
0000a8  636f7265
0000ac  5c746370
0000b0  5f6f7574
0000b4  2e      
0000b5  6300              DCB      "c",0
0000b7  00                DCB      0
                  |L16.184|
0000b8  7463705f          DCB      "tcp_rexmit_rto_prepare: invalid pcb",0
0000bc  7265786d
0000c0  69745f72
0000c4  746f5f70
0000c8  72657061
0000cc  72653a20
0000d0  696e7661
0000d4  6c696420
0000d8  70636200
                  |L16.220|
0000dc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000e0  7274696f
0000e4  6e202225
0000e8  73222066
0000ec  61696c65
0000f0  64206174
0000f4  206c696e
0000f8  65202564
0000fc  20696e20
000100  25730a00

                          AREA ||i.tcp_route||, CODE, READONLY, ALIGN=1

                  tcp_route PROC
;;;131    static struct netif *
;;;132    tcp_route(const struct tcp_pcb *pcb, const ip_addr_t *src, const ip_addr_t *dst)
000000  2800              CMP      r0,#0
;;;133    {
000002  d003              BEQ      |L17.12|
;;;134      LWIP_UNUSED_ARG(src); /* in case IPv4-only and source-based routing is disabled */
;;;135    
;;;136      if ((pcb != NULL) && (pcb->netif_idx != NETIF_NO_INDEX)) {
000004  7a00              LDRB     r0,[r0,#8]
000006  b108              CBZ      r0,|L17.12|
;;;137        return netif_get_by_index(pcb->netif_idx);
000008  f7ffbffe          B.W      netif_get_by_index
                  |L17.12|
;;;138      } else {
;;;139        return ip_route(src, dst);
00000c  4610              MOV      r0,r2
00000e  f7ffbffe          B.W      ip4_route
;;;140      }
;;;141    }
;;;142    
                          ENDP


                          AREA ||i.tcp_rst||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_rst PROC
;;;1979   void
;;;1980   tcp_rst(const struct tcp_pcb *pcb, u32_t seqno, u32_t ackno,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1981           const ip_addr_t *local_ip, const ip_addr_t *remote_ip,
;;;1982           u16_t local_port, u16_t remote_port)
;;;1983   {
000004  b085              SUB      sp,sp,#0x14
000006  468b              MOV      r11,r1
000008  e9dd8913          LDRD     r8,r9,[sp,#0x4c]
00000c  9f12              LDR      r7,[sp,#0x48]
00000e  4692              MOV      r10,r2
000010  461d              MOV      r5,r3
;;;1984     struct pbuf *p;
;;;1985     u16_t wnd;
;;;1986     u8_t optlen;
;;;1987   
;;;1988     LWIP_ASSERT("tcp_rst: invalid local_ip", local_ip != NULL);
000012  2d00              CMP      r5,#0
000014  d106              BNE      |L18.36|
000016  a31b              ADR      r3,|L18.132|
000018  f24072c4          MOV      r2,#0x7c4
00001c  a126              ADR      r1,|L18.184|
00001e  a02d              ADR      r0,|L18.212|
000020  f7fffffe          BL       __2printf
                  |L18.36|
;;;1989     LWIP_ASSERT("tcp_rst: invalid remote_ip", remote_ip != NULL);
000024  2f00              CMP      r7,#0
000026  d106              BNE      |L18.54|
000028  a316              ADR      r3,|L18.132|
00002a  f24072c5          MOV      r2,#0x7c5
00002e  a133              ADR      r1,|L18.252|
000030  a028              ADR      r0,|L18.212|
000032  f7fffffe          BL       __2printf
                  |L18.54|
;;;1990   
;;;1991     optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
000036  2600              MOVS     r6,#0
;;;1992   
;;;1993   #if LWIP_WND_SCALE
;;;1994     wnd = PP_HTONS(((TCP_WND >> TCP_RCV_SCALE) & 0xFFFF));
;;;1995   #else
;;;1996     wnd = PP_HTONS(TCP_WND);
000038  f2460408          MOV      r4,#0x6008
;;;1997   #endif
;;;1998   
;;;1999     p = tcp_output_alloc_header_common(ackno, optlen, 0, lwip_htonl(seqno), local_port,
00003c  4658              MOV      r0,r11
00003e  f7fffffe          BL       lwip_htonl
000042  4603              MOV      r3,r0
000044  2014              MOVS     r0,#0x14
000046  e9cd0402          STRD     r0,r4,[sp,#8]
00004a  2200              MOVS     r2,#0
00004c  4631              MOV      r1,r6
00004e  e9cd8900          STRD     r8,r9,[sp,#0]
000052  4650              MOV      r0,r10
000054  f7fffffe          BL       tcp_output_alloc_header_common
000058  4604              MOV      r4,r0
;;;2000       remote_port, TCP_RST | TCP_ACK, wnd);
;;;2001     if (p == NULL) {
00005a  2c00              CMP      r4,#0
00005c  d00e              BEQ      |L18.124|
;;;2002       LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
;;;2003       return;
;;;2004     }
;;;2005     tcp_output_fill_options(pcb, p, 0, optlen);
00005e  4633              MOV      r3,r6
000060  2200              MOVS     r2,#0
000062  4621              MOV      r1,r4
000064  9805              LDR      r0,[sp,#0x14]
000066  f7fffffe          BL       tcp_output_fill_options
;;;2006   
;;;2007     MIB2_STATS_INC(mib2.tcpoutrsts);
;;;2008   
;;;2009     tcp_output_control_segment(pcb, p, local_ip, remote_ip);
00006a  9805              LDR      r0,[sp,#0x14]
00006c  b009              ADD      sp,sp,#0x24
00006e  463b              MOV      r3,r7
000070  462a              MOV      r2,r5
000072  4621              MOV      r1,r4
000074  e8bd4ff0          POP      {r4-r11,lr}
000078  f7ffbffe          B.W      tcp_output_control_segment
                  |L18.124|
;;;2010     LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
;;;2011   }
00007c  b009              ADD      sp,sp,#0x24
00007e  e8bd8ff0          POP      {r4-r11,pc}
;;;2012   
                          ENDP

000082  0000              DCW      0x0000
                  |L18.132|
000084  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000088  6964646c
00008c  65776172
000090  65735c54
000094  68697264
000098  5f506172
00009c  74795c4c
0000a0  7749505c
0000a4  7372635c
0000a8  636f7265
0000ac  5c746370
0000b0  5f6f7574
0000b4  2e      
0000b5  6300              DCB      "c",0
0000b7  00                DCB      0
                  |L18.184|
0000b8  7463705f          DCB      "tcp_rst: invalid local_ip",0
0000bc  7273743a
0000c0  20696e76
0000c4  616c6964
0000c8  206c6f63
0000cc  616c5f69
0000d0  7000    
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L18.212|
0000d4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000d8  7274696f
0000dc  6e202225
0000e0  73222066
0000e4  61696c65
0000e8  64206174
0000ec  206c696e
0000f0  65202564
0000f4  20696e20
0000f8  25730a00
                  |L18.252|
0000fc  7463705f          DCB      "tcp_rst: invalid remote_ip",0
000100  7273743a
000104  20696e76
000108  616c6964
00010c  2072656d
000110  6f74655f
000114  697000  
000117  00                DCB      0

                          AREA ||i.tcp_send_empty_ack||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_send_empty_ack PROC
;;;2018   err_t
;;;2019   tcp_send_empty_ack(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2020   {
000004  4604              MOV      r4,r0
;;;2021     err_t err;
;;;2022     struct pbuf *p;
;;;2023     u8_t optlen, optflags = 0;
000006  2600              MOVS     r6,#0
;;;2024     u8_t num_sacks = 0;
000008  2700              MOVS     r7,#0
;;;2025   
;;;2026     LWIP_ASSERT("tcp_send_empty_ack: invalid pcb", pcb != NULL);
00000a  2c00              CMP      r4,#0
00000c  d106              BNE      |L19.28|
00000e  a319              ADR      r3,|L19.116|
000010  f24072ea          MOV      r2,#0x7ea
000014  a124              ADR      r1,|L19.168|
000016  a02c              ADR      r0,|L19.200|
000018  f7fffffe          BL       __2printf
                  |L19.28|
;;;2027   
;;;2028   #if LWIP_TCP_TIMESTAMPS
;;;2029     if (pcb->flags & TF_TIMESTAMP) {
;;;2030       optflags = TF_SEG_OPTS_TS;
;;;2031     }
;;;2032   #endif
;;;2033     optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(optflags, pcb);
00001c  2500              MOVS     r5,#0
;;;2034   
;;;2035   #if LWIP_TCP_SACK_OUT
;;;2036     /* For now, SACKs are only sent with empty ACKs */
;;;2037     if ((num_sacks = tcp_get_num_sacks(pcb, optlen)) > 0) {
;;;2038       optlen += 4 + num_sacks * 8; /* 4 bytes for header (including 2*NOP), plus 8B for each SACK */
;;;2039     }
;;;2040   #endif
;;;2041   
;;;2042     p = tcp_output_alloc_header(pcb, optlen, 0, lwip_htonl(pcb->snd_nxt));
00001e  6d20              LDR      r0,[r4,#0x50]
000020  f7fffffe          BL       lwip_htonl
000024  4603              MOV      r3,r0
000026  2200              MOVS     r2,#0
000028  4629              MOV      r1,r5
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       tcp_output_alloc_header
000030  4605              MOV      r5,r0
000032  b195              CBZ      r5,|L19.90|
;;;2043     if (p == NULL) {
;;;2044       /* let tcp_fasttmr retry sending this ACK */
;;;2045       tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
;;;2046       LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
;;;2047       return ERR_BUF;
;;;2048     }
;;;2049     tcp_output_fill_options(pcb, p, optflags, num_sacks);
000034  463b              MOV      r3,r7
000036  4632              MOV      r2,r6
000038  4629              MOV      r1,r5
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       tcp_output_fill_options
;;;2050   
;;;2051   #if LWIP_TCP_TIMESTAMPS
;;;2052     pcb->ts_lastacksent = pcb->rcv_nxt;
;;;2053   #endif
;;;2054   
;;;2055     LWIP_DEBUGF(TCP_OUTPUT_DEBUG,
;;;2056                 ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
;;;2057     err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
000040  1d23              ADDS     r3,r4,#4
000042  4622              MOV      r2,r4
000044  4629              MOV      r1,r5
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       tcp_output_control_segment
;;;2058     if (err != ERR_OK) {
00004c  b160              CBZ      r0,|L19.104|
;;;2059       /* let tcp_fasttmr retry sending this ACK */
;;;2060       tcp_set_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
00004e  8b61              LDRH     r1,[r4,#0x1a]
000050  f0410103          ORR      r1,r1,#3
000054  8361              STRH     r1,[r4,#0x1a]
                  |L19.86|
;;;2061     } else {
;;;2062       /* remove ACK flags from the PCB, as we sent an empty ACK now */
;;;2063       tcp_clear_flags(pcb, TF_ACK_DELAY | TF_ACK_NOW);
;;;2064     }
;;;2065   
;;;2066     return err;
;;;2067   }
000056  e8bd81f0          POP      {r4-r8,pc}
                  |L19.90|
00005a  8b60              LDRH     r0,[r4,#0x1a]         ;2045
00005c  f0400003          ORR      r0,r0,#3              ;2045
000060  8360              STRH     r0,[r4,#0x1a]         ;2045
000062  f06f0001          MVN      r0,#1                 ;2047
000066  e7f6              B        |L19.86|
                  |L19.104|
000068  8b61              LDRH     r1,[r4,#0x1a]         ;2063
00006a  f0210103          BIC      r1,r1,#3              ;2063
00006e  8361              STRH     r1,[r4,#0x1a]         ;2063
000070  e7f1              B        |L19.86|
;;;2068   
                          ENDP

000072  0000              DCW      0x0000
                  |L19.116|
000074  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000078  6964646c
00007c  65776172
000080  65735c54
000084  68697264
000088  5f506172
00008c  74795c4c
000090  7749505c
000094  7372635c
000098  636f7265
00009c  5c746370
0000a0  5f6f7574
0000a4  2e      
0000a5  6300              DCB      "c",0
0000a7  00                DCB      0
                  |L19.168|
0000a8  7463705f          DCB      "tcp_send_empty_ack: invalid pcb",0
0000ac  73656e64
0000b0  5f656d70
0000b4  74795f61
0000b8  636b3a20
0000bc  696e7661
0000c0  6c696420
0000c4  70636200
                  |L19.200|
0000c8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000cc  7274696f
0000d0  6e202225
0000d4  73222066
0000d8  61696c65
0000dc  64206174
0000e0  206c696e
0000e4  65202564
0000e8  20696e20
0000ec  25730a00

                          AREA ||i.tcp_send_fin||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_send_fin PROC
;;;1000   err_t
;;;1001   tcp_send_fin(struct tcp_pcb *pcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1002   {
000002  4605              MOV      r5,r0
;;;1003     LWIP_ASSERT("tcp_send_fin: invalid pcb", pcb != NULL);
000004  2d00              CMP      r5,#0
000006  d106              BNE      |L20.22|
000008  a313              ADR      r3,|L20.88|
00000a  f24032eb          MOV      r2,#0x3eb
00000e  a11f              ADR      r1,|L20.140|
000010  a025              ADR      r0,|L20.168|
000012  f7fffffe          BL       __2printf
                  |L20.22|
;;;1004   
;;;1005     /* first, try to add the fin to the last unsent segment */
;;;1006     if (pcb->unsent != NULL) {
000016  6eec              LDR      r4,[r5,#0x6c]
000018  b90c              CBNZ     r4,|L20.30|
00001a  e009              B        |L20.48|
                  |L20.28|
;;;1007       struct tcp_seg *last_unsent;
;;;1008       for (last_unsent = pcb->unsent; last_unsent->next != NULL;
;;;1009            last_unsent = last_unsent->next);
00001c  460c              MOV      r4,r1
                  |L20.30|
00001e  6821              LDR      r1,[r4,#0]            ;1008
000020  2900              CMP      r1,#0                 ;1008
000022  d1fb              BNE      |L20.28|
;;;1010   
;;;1011       if ((TCPH_FLAGS(last_unsent->tcphdr) & (TCP_SYN | TCP_FIN | TCP_RST)) == 0) {
000024  68e0              LDR      r0,[r4,#0xc]
000026  8980              LDRH     r0,[r0,#0xc]
000028  f7fffffe          BL       lwip_htons
00002c  0740              LSLS     r0,r0,#29
00002e  d005              BEQ      |L20.60|
                  |L20.48|
;;;1012         /* no SYN/FIN/RST flag in the header, we can add the FIN flag */
;;;1013         TCPH_SET_FLAG(last_unsent->tcphdr, TCP_FIN);
;;;1014         tcp_set_flags(pcb, TF_FIN);
;;;1015         return ERR_OK;
;;;1016       }
;;;1017     }
;;;1018     /* no data, no length, flags, copy=1, no optdata */
;;;1019     return tcp_enqueue_flags(pcb, TCP_FIN);
000030  4628              MOV      r0,r5
000032  e8bd4070          POP      {r4-r6,lr}
000036  2101              MOVS     r1,#1
000038  f7ffbffe          B.W      tcp_enqueue_flags
                  |L20.60|
00003c  2001              MOVS     r0,#1                 ;1013
00003e  f7fffffe          BL       lwip_htons
000042  4601              MOV      r1,r0                 ;1013
000044  68e0              LDR      r0,[r4,#0xc]          ;1013
000046  8982              LDRH     r2,[r0,#0xc]          ;1013
000048  4311              ORRS     r1,r1,r2              ;1013
00004a  8181              STRH     r1,[r0,#0xc]          ;1013
00004c  8b68              LDRH     r0,[r5,#0x1a]         ;1014
00004e  f0400020          ORR      r0,r0,#0x20           ;1014
000052  8368              STRH     r0,[r5,#0x1a]         ;1014
000054  2000              MOVS     r0,#0                 ;1015
;;;1020   }
000056  bd70              POP      {r4-r6,pc}
;;;1021   
                          ENDP

                  |L20.88|
000058  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
00005c  6964646c
000060  65776172
000064  65735c54
000068  68697264
00006c  5f506172
000070  74795c4c
000074  7749505c
000078  7372635c
00007c  636f7265
000080  5c746370
000084  5f6f7574
000088  2e      
000089  6300              DCB      "c",0
00008b  00                DCB      0
                  |L20.140|
00008c  7463705f          DCB      "tcp_send_fin: invalid pcb",0
000090  73656e64
000094  5f66696e
000098  3a20696e
00009c  76616c69
0000a0  64207063
0000a4  6200    
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L20.168|
0000a8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000ac  7274696f
0000b0  6e202225
0000b4  73222066
0000b8  61696c65
0000bc  64206174
0000c0  206c696e
0000c4  65202564
0000c8  20696e20
0000cc  25730a00

                          AREA ||i.tcp_split_unsent_seg||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_split_unsent_seg PROC
;;;826    err_t
;;;827    tcp_split_unsent_seg(struct tcp_pcb *pcb, u16_t split)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;828    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;829      struct tcp_seg *seg = NULL, *useg = NULL;
;;;830      struct pbuf *p = NULL;
;;;831      u8_t optlen;
;;;832      u8_t optflags;
;;;833      u8_t split_flags;
;;;834      u8_t remainder_flags;
;;;835      u16_t remainder;
;;;836      u16_t offset;
;;;837    #if TCP_CHECKSUM_ON_COPY
;;;838      u16_t chksum = 0;
;;;839      u8_t chksum_swapped = 0;
;;;840      struct pbuf *q;
;;;841    #endif /* TCP_CHECKSUM_ON_COPY */
;;;842    
;;;843      LWIP_ASSERT("tcp_split_unsent_seg: invalid pcb", pcb != NULL);
000008  2d00              CMP      r5,#0
00000a  d106              BNE      |L21.26|
00000c  a359              ADR      r3,|L21.372|
00000e  f240324b          MOV      r2,#0x34b
000012  a165              ADR      r1,|L21.424|
000014  a06d              ADR      r0,|L21.460|
000016  f7fffffe          BL       __2printf
                  |L21.26|
;;;844    
;;;845      useg = pcb->unsent;
00001a  6eec              LDR      r4,[r5,#0x6c]
;;;846      if (useg == NULL) {
00001c  b134              CBZ      r4,|L21.44|
;;;847        return ERR_MEM;
;;;848      }
;;;849    
;;;850      if (split == 0) {
00001e  b147              CBZ      r7,|L21.50|
;;;851        LWIP_ASSERT("Can't split segment into length 0", 0);
;;;852        return ERR_VAL;
;;;853      }
;;;854    
;;;855      if (useg->len <= split) {
000020  8920              LDRH     r0,[r4,#8]
000022  42b8              CMP      r0,r7
000024  d80f              BHI      |L21.70|
;;;856        return ERR_OK;
000026  2000              MOVS     r0,#0
                  |L21.40|
;;;857      }
;;;858    
;;;859      LWIP_ASSERT("split <= mss", split <= pcb->mss);
;;;860      LWIP_ASSERT("useg->len > 0", useg->len > 0);
;;;861    
;;;862      /* We should check that we don't exceed TCP_SND_QUEUELEN but we need
;;;863       * to split this packet so we may actually exceed the max value by
;;;864       * one!
;;;865       */
;;;866      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: split_unsent_seg: %u\n", (unsigned int)pcb->snd_queuelen));
;;;867    
;;;868      optflags = useg->flags;
;;;869    #if TCP_CHECKSUM_ON_COPY
;;;870      /* Remove since checksum is not stored until after tcp_create_segment() */
;;;871      optflags &= ~TF_SEG_DATA_CHECKSUMMED;
;;;872    #endif /* TCP_CHECKSUM_ON_COPY */
;;;873      optlen = LWIP_TCP_OPT_LENGTH(optflags);
;;;874      remainder = useg->len - split;
;;;875    
;;;876      /* Create new pbuf for the remainder of the split */
;;;877      p = pbuf_alloc(PBUF_TRANSPORT, remainder + optlen, PBUF_RAM);
;;;878      if (p == NULL) {
;;;879        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;880                    ("tcp_split_unsent_seg: could not allocate memory for pbuf remainder %u\n", remainder));
;;;881        goto memerr;
;;;882      }
;;;883    
;;;884      /* Offset into the original pbuf is past TCP/IP headers, options, and split amount */
;;;885      offset = useg->p->tot_len - useg->len + split;
;;;886      /* Copy remainder into new pbuf, headers and options will not be filled out */
;;;887      if (pbuf_copy_partial(useg->p, (u8_t *)p->payload + optlen, remainder, offset ) != remainder) {
;;;888        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;889                    ("tcp_split_unsent_seg: could not copy pbuf remainder %u\n", remainder));
;;;890        goto memerr;
;;;891      }
;;;892    #if TCP_CHECKSUM_ON_COPY
;;;893      /* calculate the checksum on remainder data */
;;;894      tcp_seg_add_chksum(~inet_chksum((const u8_t *)p->payload + optlen, remainder), remainder,
;;;895                         &chksum, &chksum_swapped);
;;;896    #endif /* TCP_CHECKSUM_ON_COPY */
;;;897    
;;;898      /* Options are created when calling tcp_output() */
;;;899    
;;;900      /* Migrate flags from original segment */
;;;901      split_flags = TCPH_FLAGS(useg->tcphdr);
;;;902      remainder_flags = 0; /* ACK added in tcp_output() */
;;;903    
;;;904      if (split_flags & TCP_PSH) {
;;;905        split_flags &= ~TCP_PSH;
;;;906        remainder_flags |= TCP_PSH;
;;;907      }
;;;908      if (split_flags & TCP_FIN) {
;;;909        split_flags &= ~TCP_FIN;
;;;910        remainder_flags |= TCP_FIN;
;;;911      }
;;;912      /* SYN should be left on split, RST should not be present with data */
;;;913    
;;;914      seg = tcp_create_segment(pcb, p, remainder_flags, lwip_ntohl(useg->tcphdr->seqno) + split, optflags);
;;;915      if (seg == NULL) {
;;;916        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;917                    ("tcp_split_unsent_seg: could not create new TCP segment\n"));
;;;918        goto memerr;
;;;919      }
;;;920    
;;;921    #if TCP_CHECKSUM_ON_COPY
;;;922      seg->chksum = chksum;
;;;923      seg->chksum_swapped = chksum_swapped;
;;;924      seg->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;925    #endif /* TCP_CHECKSUM_ON_COPY */
;;;926    
;;;927      /* Remove this segment from the queue since trimming it may free pbufs */
;;;928      pcb->snd_queuelen -= pbuf_clen(useg->p);
;;;929    
;;;930      /* Trim the original pbuf into our split size.  At this point our remainder segment must be setup
;;;931      successfully because we are modifying the original segment */
;;;932      pbuf_realloc(useg->p, useg->p->tot_len - remainder);
;;;933      useg->len -= remainder;
;;;934      TCPH_SET_FLAG(useg->tcphdr, split_flags);
;;;935    #if TCP_OVERSIZE_DBGCHECK
;;;936      /* By trimming, realloc may have actually shrunk the pbuf, so clear oversize_left */
;;;937      useg->oversize_left = 0;
;;;938    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;939    
;;;940      /* Add back to the queue with new trimmed pbuf */
;;;941      pcb->snd_queuelen += pbuf_clen(useg->p);
;;;942    
;;;943    #if TCP_CHECKSUM_ON_COPY
;;;944      /* The checksum on the split segment is now incorrect. We need to re-run it over the split */
;;;945      useg->chksum = 0;
;;;946      useg->chksum_swapped = 0;
;;;947      q = useg->p;
;;;948      offset = q->tot_len - useg->len; /* Offset due to exposed headers */
;;;949    
;;;950      /* Advance to the pbuf where the offset ends */
;;;951      while (q != NULL && offset > q->len) {
;;;952        offset -= q->len;
;;;953        q = q->next;
;;;954      }
;;;955      LWIP_ASSERT("Found start of payload pbuf", q != NULL);
;;;956      /* Checksum the first payload pbuf accounting for offset, then other pbufs are all payload */
;;;957      for (; q != NULL; offset = 0, q = q->next) {
;;;958        tcp_seg_add_chksum(~inet_chksum((const u8_t *)q->payload + offset, q->len - offset), q->len - offset,
;;;959                           &useg->chksum, &useg->chksum_swapped);
;;;960      }
;;;961    #endif /* TCP_CHECKSUM_ON_COPY */
;;;962    
;;;963      /* Update number of segments on the queues. Note that length now may
;;;964       * exceed TCP_SND_QUEUELEN! We don't have to touch pcb->snd_buf
;;;965       * because the total amount of data is constant when packet is split */
;;;966      pcb->snd_queuelen += pbuf_clen(seg->p);
;;;967    
;;;968      /* Finally insert remainder into queue after split (which stays head) */
;;;969      seg->next = useg->next;
;;;970      useg->next = seg;
;;;971    
;;;972    #if TCP_OVERSIZE
;;;973      /* If remainder is last segment on the unsent, ensure we clear the oversize amount
;;;974       * because the remainder is always sized to the exact remaining amount */
;;;975      if (seg->next == NULL) {
;;;976        pcb->unsent_oversize = 0;
;;;977      }
;;;978    #endif /* TCP_OVERSIZE */
;;;979    
;;;980      return ERR_OK;
;;;981    memerr:
;;;982      TCP_STATS_INC(tcp.memerr);
;;;983    
;;;984      LWIP_ASSERT("seg == NULL", seg == NULL);
;;;985      if (p != NULL) {
;;;986        pbuf_free(p);
;;;987      }
;;;988    
;;;989      return ERR_MEM;
;;;990    }
000028  e8bd8ff8          POP      {r3-r11,pc}
                  |L21.44|
00002c  f04f30ff          MOV      r0,#0xffffffff        ;847
000030  e7fa              B        |L21.40|
                  |L21.50|
000032  a350              ADR      r3,|L21.372|
000034  f2403253          MOV      r2,#0x353             ;851
000038  a16e              ADR      r1,|L21.500|
00003a  a064              ADR      r0,|L21.460|
00003c  f7fffffe          BL       __2printf
000040  f06f0005          MVN      r0,#5                 ;852
000044  e7f0              B        |L21.40|
                  |L21.70|
000046  8e68              LDRH     r0,[r5,#0x32]         ;859
000048  42b8              CMP      r0,r7                 ;859
00004a  d206              BCS      |L21.90|
00004c  a349              ADR      r3,|L21.372|
00004e  f240325b          MOV      r2,#0x35b             ;859
000052  a171              ADR      r1,|L21.536|
000054  a05d              ADR      r0,|L21.460|
000056  f7fffffe          BL       __2printf
                  |L21.90|
00005a  8920              LDRH     r0,[r4,#8]            ;860
00005c  b930              CBNZ     r0,|L21.108|
00005e  a345              ADR      r3,|L21.372|
000060  f44f7257          MOV      r2,#0x35c             ;860
000064  a170              ADR      r1,|L21.552|
000066  a059              ADR      r0,|L21.460|
000068  f7fffffe          BL       __2printf
                  |L21.108|
00006c  f894b00a          LDRB     r11,[r4,#0xa]         ;868
000070  ea5f70cb          LSLS     r0,r11,#31            ;873
000074  d001              BEQ      |L21.122|
000076  2604              MOVS     r6,#4                 ;873
000078  e000              B        |L21.124|
                  |L21.122|
00007a  2600              MOVS     r6,#0                 ;873
                  |L21.124|
00007c  8920              LDRH     r0,[r4,#8]            ;874
00007e  1bc0              SUBS     r0,r0,r7              ;874
000080  fa1ff880          UXTH     r8,r0                 ;874
000084  eb080006          ADD      r0,r8,r6              ;877
000088  b281              UXTH     r1,r0                 ;877
00008a  f44f7220          MOV      r2,#0x280             ;877
00008e  2036              MOVS     r0,#0x36              ;877
000090  f7fffffe          BL       pbuf_alloc
000094  4682              MOV      r10,r0                ;877
000096  ea5f000a          MOVS     r0,r10                ;878
00009a  d061              BEQ      |L21.352|
00009c  6860              LDR      r0,[r4,#4]            ;885
00009e  8922              LDRH     r2,[r4,#8]            ;885
0000a0  8901              LDRH     r1,[r0,#8]            ;885
0000a2  1a89              SUBS     r1,r1,r2              ;885
0000a4  4439              ADD      r1,r1,r7              ;885
0000a6  b28b              UXTH     r3,r1                 ;885
0000a8  f8da1004          LDR      r1,[r10,#4]           ;887
0000ac  4642              MOV      r2,r8                 ;887
0000ae  4431              ADD      r1,r1,r6              ;887
0000b0  f7fffffe          BL       pbuf_copy_partial
0000b4  4540              CMP      r0,r8                 ;887
0000b6  d153              BNE      |L21.352|
0000b8  68e0              LDR      r0,[r4,#0xc]          ;901
0000ba  8980              LDRH     r0,[r0,#0xc]          ;901
0000bc  f7fffffe          BL       lwip_htons
0000c0  f000063f          AND      r6,r0,#0x3f           ;901
0000c4  f04f0900          MOV      r9,#0                 ;902
0000c8  0730              LSLS     r0,r6,#28             ;904
0000ca  d503              BPL      |L21.212|
0000cc  f0260608          BIC      r6,r6,#8              ;905
0000d0  f04f0908          MOV      r9,#8                 ;906
                  |L21.212|
0000d4  07f0              LSLS     r0,r6,#31             ;908
0000d6  d003              BEQ      |L21.224|
0000d8  f0260601          BIC      r6,r6,#1              ;909
0000dc  f0490901          ORR      r9,r9,#1              ;910
                  |L21.224|
0000e0  68e0              LDR      r0,[r4,#0xc]          ;914
0000e2  6840              LDR      r0,[r0,#4]            ;914
0000e4  f7fffffe          BL       lwip_htonl
0000e8  19c3              ADDS     r3,r0,r7              ;914
0000ea  464a              MOV      r2,r9                 ;914
0000ec  4651              MOV      r1,r10                ;914
0000ee  4628              MOV      r0,r5                 ;914
0000f0  f8cdb000          STR      r11,[sp,#0]           ;914
0000f4  f7fffffe          BL       tcp_create_segment
0000f8  4607              MOV      r7,r0                 ;914
0000fa  0038              MOVS     r0,r7                 ;915
0000fc  d030              BEQ      |L21.352|
0000fe  6860              LDR      r0,[r4,#4]            ;928
000100  f7fffffe          BL       pbuf_clen
000104  f8351f66          LDRH     r1,[r5,#0x66]!        ;928
000108  1a08              SUBS     r0,r1,r0              ;928
00010a  8028              STRH     r0,[r5,#0]            ;928
00010c  6860              LDR      r0,[r4,#4]            ;932
00010e  8901              LDRH     r1,[r0,#8]            ;932
000110  eba10108          SUB      r1,r1,r8              ;932
000114  b289              UXTH     r1,r1                 ;932
000116  f7fffffe          BL       pbuf_realloc
00011a  8920              LDRH     r0,[r4,#8]            ;933
00011c  eba00008          SUB      r0,r0,r8              ;933
000120  8120              STRH     r0,[r4,#8]            ;933
000122  4630              MOV      r0,r6                 ;934
000124  f7fffffe          BL       lwip_htons
000128  4601              MOV      r1,r0                 ;934
00012a  68e0              LDR      r0,[r4,#0xc]          ;934
00012c  8982              LDRH     r2,[r0,#0xc]          ;934
00012e  4311              ORRS     r1,r1,r2              ;934
000130  8181              STRH     r1,[r0,#0xc]          ;934
000132  6860              LDR      r0,[r4,#4]            ;941
000134  f7fffffe          BL       pbuf_clen
000138  8829              LDRH     r1,[r5,#0]            ;941
00013a  4408              ADD      r0,r0,r1              ;941
00013c  8028              STRH     r0,[r5,#0]            ;941
00013e  6878              LDR      r0,[r7,#4]            ;966
000140  f7fffffe          BL       pbuf_clen
000144  8829              LDRH     r1,[r5,#0]            ;966
000146  4408              ADD      r0,r0,r1              ;966
000148  f8250966          STRH     r0,[r5],#-0x66        ;966
00014c  6820              LDR      r0,[r4,#0]            ;969
00014e  6038              STR      r0,[r7,#0]            ;969
000150  6027              STR      r7,[r4,#0]            ;970
000152  6838              LDR      r0,[r7,#0]            ;975
000154  b910              CBNZ     r0,|L21.348|
000156  2000              MOVS     r0,#0                 ;976
000158  f8a50068          STRH     r0,[r5,#0x68]         ;976
                  |L21.348|
00015c  2000              MOVS     r0,#0                 ;980
00015e  e763              B        |L21.40|
                  |L21.352|
000160  f1ba0f00          CMP      r10,#0                ;985
000164  d002              BEQ      |L21.364|
000166  4650              MOV      r0,r10                ;986
000168  f7fffffe          BL       pbuf_free
                  |L21.364|
00016c  f04f30ff          MOV      r0,#0xffffffff        ;989
000170  e75a              B        |L21.40|
;;;991    
                          ENDP

000172  0000              DCW      0x0000
                  |L21.372|
000174  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
000178  6964646c
00017c  65776172
000180  65735c54
000184  68697264
000188  5f506172
00018c  74795c4c
000190  7749505c
000194  7372635c
000198  636f7265
00019c  5c746370
0001a0  5f6f7574
0001a4  2e      
0001a5  6300              DCB      "c",0
0001a7  00                DCB      0
                  |L21.424|
0001a8  7463705f          DCB      "tcp_split_unsent_seg: invalid pcb",0
0001ac  73706c69
0001b0  745f756e
0001b4  73656e74
0001b8  5f736567
0001bc  3a20696e
0001c0  76616c69
0001c4  64207063
0001c8  6200    
0001ca  00                DCB      0
0001cb  00                DCB      0
                  |L21.460|
0001cc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001d0  7274696f
0001d4  6e202225
0001d8  73222066
0001dc  61696c65
0001e0  64206174
0001e4  206c696e
0001e8  65202564
0001ec  20696e20
0001f0  25730a00
                  |L21.500|
0001f4  43616e27          DCB      "Can't split segment into length 0",0
0001f8  74207370
0001fc  6c697420
000200  7365676d
000204  656e7420
000208  696e746f
00020c  206c656e
000210  67746820
000214  3000    
000216  00                DCB      0
000217  00                DCB      0
                  |L21.536|
000218  73706c69          DCB      "split <= mss",0
00021c  74203c3d
000220  206d7373
000224  00      
000225  00                DCB      0
000226  00                DCB      0
000227  00                DCB      0
                  |L21.552|
000228  75736567          DCB      "useg->len > 0",0
00022c  2d3e6c65
000230  6e203e20
000234  3000    
000236  00                DCB      0
000237  00                DCB      0

                          AREA ||i.tcp_write||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_write PROC
;;;389    err_t
;;;390    tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;391    {
000004  b08d              SUB      sp,sp,#0x34
000006  4605              MOV      r5,r0
000008  4690              MOV      r8,r2
;;;392      struct pbuf *concat_p = NULL;
00000a  2000              MOVS     r0,#0
00000c  900c              STR      r0,[sp,#0x30]
;;;393      struct tcp_seg *last_unsent = NULL, *seg = NULL, *prev_seg = NULL, *queue = NULL;
00000e  2400              MOVS     r4,#0
000010  2700              MOVS     r7,#0
000012  900b              STR      r0,[sp,#0x2c]
000014  4683              MOV      r11,r0
;;;394      u16_t pos = 0; /* position in 'arg' data */
000016  2600              MOVS     r6,#0
;;;395      u16_t queuelen;
;;;396      u8_t optlen;
;;;397      u8_t optflags = 0;
000018  9009              STR      r0,[sp,#0x24]
;;;398    #if TCP_OVERSIZE
;;;399      u16_t oversize = 0;
00001a  9008              STR      r0,[sp,#0x20]
;;;400      u16_t oversize_used = 0;
00001c  4682              MOV      r10,r0
;;;401    #if TCP_OVERSIZE_DBGCHECK
;;;402      u16_t oversize_add = 0;
;;;403    #endif /* TCP_OVERSIZE_DBGCHECK*/
;;;404    #endif /* TCP_OVERSIZE */
;;;405      u16_t extendlen = 0;
00001e  9007              STR      r0,[sp,#0x1c]
;;;406    #if TCP_CHECKSUM_ON_COPY
;;;407      u16_t concat_chksum = 0;
;;;408      u8_t concat_chksum_swapped = 0;
;;;409      u16_t concat_chksummed = 0;
;;;410    #endif /* TCP_CHECKSUM_ON_COPY */
;;;411      err_t err;
;;;412      u16_t mss_local;
;;;413    
;;;414      LWIP_ERROR("tcp_write: invalid pcb", pcb != NULL, return ERR_ARG);
000020  f06f090f          MVN      r9,#0xf
000024  2d00              CMP      r5,#0
000026  d007              BEQ      |L22.56|
;;;415    
;;;416      /* don't allocate segments bigger than half the maximum window we ever received */
;;;417      mss_local = LWIP_MIN(pcb->mss, TCPWND_MIN16(pcb->snd_wnd_max / 2));
000028  8e68              LDRH     r0,[r5,#0x32]
00002a  f8b51062          LDRH     r1,[r5,#0x62]
00002e  ebb00f51          CMP      r0,r1,LSR #1
000032  d20c              BCS      |L22.78|
000034  4601              MOV      r1,r0
000036  e00b              B        |L22.80|
                  |L22.56|
000038  a3ec              ADR      r3,|L22.1004|
00003a  f44f72cf          MOV      r2,#0x19e             ;414
00003e  a1f8              ADR      r1,|L22.1056|
000040  a0fd              ADR      r0,|L22.1080|
000042  f7fffffe          BL       __2printf
000046  4648              MOV      r0,r9                 ;414
                  |L22.72|
;;;418      mss_local = mss_local ? mss_local : pcb->mss;
;;;419    
;;;420      LWIP_ASSERT_CORE_LOCKED();
;;;421    
;;;422    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;423      /* Always copy to try to create single pbufs for TX */
;;;424      apiflags |= TCP_WRITE_FLAG_COPY;
;;;425    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;426    
;;;427      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n",
;;;428                                     (void *)pcb, arg, len, (u16_t)apiflags));
;;;429      LWIP_ERROR("tcp_write: arg == NULL (programmer violates API)",
;;;430                 arg != NULL, return ERR_ARG;);
;;;431    
;;;432      err = tcp_write_checks(pcb, len);
;;;433      if (err != ERR_OK) {
;;;434        return err;
;;;435      }
;;;436      queuelen = pcb->snd_queuelen;
;;;437    
;;;438    #if LWIP_TCP_TIMESTAMPS
;;;439      if ((pcb->flags & TF_TIMESTAMP)) {
;;;440        /* Make sure the timestamp option is only included in data segments if we
;;;441           agreed about it with the remote host. */
;;;442        optflags = TF_SEG_OPTS_TS;
;;;443        optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(TF_SEG_OPTS_TS, pcb);
;;;444        /* ensure that segments can hold at least one data byte... */
;;;445        mss_local = LWIP_MAX(mss_local, LWIP_TCP_OPT_LEN_TS + 1);
;;;446      } else
;;;447    #endif /* LWIP_TCP_TIMESTAMPS */
;;;448      {
;;;449        optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
;;;450      }
;;;451    
;;;452    
;;;453      /*
;;;454       * TCP segmentation is done in three phases with increasing complexity:
;;;455       *
;;;456       * 1. Copy data directly into an oversized pbuf.
;;;457       * 2. Chain a new pbuf to the end of pcb->unsent.
;;;458       * 3. Create new segments.
;;;459       *
;;;460       * We may run out of memory at any point. In that case we must
;;;461       * return ERR_MEM and not change anything in pcb. Therefore, all
;;;462       * changes are recorded in local variables and committed at the end
;;;463       * of the function. Some pcb fields are maintained in local copies:
;;;464       *
;;;465       * queuelen = pcb->snd_queuelen
;;;466       * oversize = pcb->unsent_oversize
;;;467       *
;;;468       * These variables are set consistently by the phases:
;;;469       *
;;;470       * seg points to the last segment tampered with.
;;;471       *
;;;472       * pos records progress as data is segmented.
;;;473       */
;;;474    
;;;475      /* Find the tail of the unsent queue. */
;;;476      if (pcb->unsent != NULL) {
;;;477        u16_t space;
;;;478        u16_t unsent_optlen;
;;;479    
;;;480        /* @todo: this could be sped up by keeping last_unsent in the pcb */
;;;481        for (last_unsent = pcb->unsent; last_unsent->next != NULL;
;;;482             last_unsent = last_unsent->next);
;;;483    
;;;484        /* Usable space at the end of the last unsent segment */
;;;485        unsent_optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(last_unsent->flags, pcb);
;;;486        LWIP_ASSERT("mss_local is too small", mss_local >= last_unsent->len + unsent_optlen);
;;;487        space = mss_local - (last_unsent->len + unsent_optlen);
;;;488    
;;;489        /*
;;;490         * Phase 1: Copy data directly into an oversized pbuf.
;;;491         *
;;;492         * The number of bytes copied is recorded in the oversize_used
;;;493         * variable. The actual copying is done at the bottom of the
;;;494         * function.
;;;495         */
;;;496    #if TCP_OVERSIZE
;;;497    #if TCP_OVERSIZE_DBGCHECK
;;;498        /* check that pcb->unsent_oversize matches last_unsent->oversize_left */
;;;499        LWIP_ASSERT("unsent_oversize mismatch (pcb vs. last_unsent)",
;;;500                    pcb->unsent_oversize == last_unsent->oversize_left);
;;;501    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;502        oversize = pcb->unsent_oversize;
;;;503        if (oversize > 0) {
;;;504          LWIP_ASSERT("inconsistent oversize vs. space", oversize <= space);
;;;505          seg = last_unsent;
;;;506          oversize_used = LWIP_MIN(space, LWIP_MIN(oversize, len));
;;;507          pos += oversize_used;
;;;508          oversize -= oversize_used;
;;;509          space -= oversize_used;
;;;510        }
;;;511        /* now we are either finished or oversize is zero */
;;;512        LWIP_ASSERT("inconsistent oversize vs. len", (oversize == 0) || (pos == len));
;;;513    #endif /* TCP_OVERSIZE */
;;;514    
;;;515    #if !LWIP_NETIF_TX_SINGLE_PBUF
;;;516        /*
;;;517         * Phase 2: Chain a new pbuf to the end of pcb->unsent.
;;;518         *
;;;519         * As an exception when NOT copying the data, if the given data buffer
;;;520         * directly follows the last unsent data buffer in memory, extend the last
;;;521         * ROM pbuf reference to the buffer, thus saving a ROM pbuf allocation.
;;;522         *
;;;523         * We don't extend segments containing SYN/FIN flags or options
;;;524         * (len==0). The new pbuf is kept in concat_p and pbuf_cat'ed at
;;;525         * the end.
;;;526         *
;;;527         * This phase is skipped for LWIP_NETIF_TX_SINGLE_PBUF as we could only execute
;;;528         * it after rexmit puts a segment from unacked to unsent and at this point,
;;;529         * oversize info is lost.
;;;530         */
;;;531        if ((pos < len) && (space > 0) && (last_unsent->len > 0)) {
;;;532          u16_t seglen = LWIP_MIN(space, len - pos);
;;;533          seg = last_unsent;
;;;534    
;;;535          /* Create a pbuf with a copy or reference to seglen bytes. We
;;;536           * can use PBUF_RAW here since the data appears in the middle of
;;;537           * a segment. A header will never be prepended. */
;;;538          if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;539            /* Data is copied */
;;;540            if ((concat_p = tcp_pbuf_prealloc(PBUF_RAW, seglen, space, &oversize, pcb, apiflags, 1)) == NULL) {
;;;541              LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;542                          ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n",
;;;543                           seglen));
;;;544              goto memerr;
;;;545            }
;;;546    #if TCP_OVERSIZE_DBGCHECK
;;;547            oversize_add = oversize;
;;;548    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;549            TCP_DATA_COPY2(concat_p->payload, (const u8_t *)arg + pos, seglen, &concat_chksum, &concat_chksum_swapped);
;;;550    #if TCP_CHECKSUM_ON_COPY
;;;551            concat_chksummed += seglen;
;;;552    #endif /* TCP_CHECKSUM_ON_COPY */
;;;553            queuelen += pbuf_clen(concat_p);
;;;554          } else {
;;;555            /* Data is not copied */
;;;556            /* If the last unsent pbuf is of type PBUF_ROM, try to extend it. */
;;;557            struct pbuf *p;
;;;558            for (p = last_unsent->p; p->next != NULL; p = p->next);
;;;559            if (((p->type_internal & (PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS | PBUF_TYPE_FLAG_DATA_VOLATILE)) == 0) &&
;;;560                (const u8_t *)p->payload + p->len == (const u8_t *)arg) {
;;;561              LWIP_ASSERT("tcp_write: ROM pbufs cannot be oversized", pos == 0);
;;;562              extendlen = seglen;
;;;563            } else {
;;;564              if ((concat_p = pbuf_alloc(PBUF_RAW, seglen, PBUF_ROM)) == NULL) {
;;;565                LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;566                            ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;567                goto memerr;
;;;568              }
;;;569              /* reference the non-volatile payload data */
;;;570              ((struct pbuf_rom *)concat_p)->payload = (const u8_t *)arg + pos;
;;;571              queuelen += pbuf_clen(concat_p);
;;;572            }
;;;573    #if TCP_CHECKSUM_ON_COPY
;;;574            /* calculate the checksum of nocopy-data */
;;;575            tcp_seg_add_chksum(~inet_chksum((const u8_t *)arg + pos, seglen), seglen,
;;;576                               &concat_chksum, &concat_chksum_swapped);
;;;577            concat_chksummed += seglen;
;;;578    #endif /* TCP_CHECKSUM_ON_COPY */
;;;579          }
;;;580    
;;;581          pos += seglen;
;;;582        }
;;;583    #endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
;;;584      } else {
;;;585    #if TCP_OVERSIZE
;;;586        LWIP_ASSERT("unsent_oversize mismatch (pcb->unsent is NULL)",
;;;587                    pcb->unsent_oversize == 0);
;;;588    #endif /* TCP_OVERSIZE */
;;;589      }
;;;590    
;;;591      /*
;;;592       * Phase 3: Create new segments.
;;;593       *
;;;594       * The new segments are chained together in the local 'queue'
;;;595       * variable, ready to be appended to pcb->unsent.
;;;596       */
;;;597      while (pos < len) {
;;;598        struct pbuf *p;
;;;599        u16_t left = len - pos;
;;;600        u16_t max_len = mss_local - optlen;
;;;601        u16_t seglen = LWIP_MIN(left, max_len);
;;;602    #if TCP_CHECKSUM_ON_COPY
;;;603        u16_t chksum = 0;
;;;604        u8_t chksum_swapped = 0;
;;;605    #endif /* TCP_CHECKSUM_ON_COPY */
;;;606    
;;;607        if (apiflags & TCP_WRITE_FLAG_COPY) {
;;;608          /* If copy is set, memory should be allocated and data copied
;;;609           * into pbuf */
;;;610          if ((p = tcp_pbuf_prealloc(PBUF_TRANSPORT, seglen + optlen, mss_local, &oversize, pcb, apiflags, queue == NULL)) == NULL) {
;;;611            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
;;;612            goto memerr;
;;;613          }
;;;614          LWIP_ASSERT("tcp_write: check that first pbuf can hold the complete seglen",
;;;615                      (p->len >= seglen));
;;;616          TCP_DATA_COPY2((char *)p->payload + optlen, (const u8_t *)arg + pos, seglen, &chksum, &chksum_swapped);
;;;617        } else {
;;;618          /* Copy is not set: First allocate a pbuf for holding the data.
;;;619           * Since the referenced data is available at least until it is
;;;620           * sent out on the link (as it has to be ACKed by the remote
;;;621           * party) we can safely use PBUF_ROM instead of PBUF_REF here.
;;;622           */
;;;623          struct pbuf *p2;
;;;624    #if TCP_OVERSIZE
;;;625          LWIP_ASSERT("oversize == 0", oversize == 0);
;;;626    #endif /* TCP_OVERSIZE */
;;;627          if ((p2 = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
;;;628            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for zero-copy pbuf\n"));
;;;629            goto memerr;
;;;630          }
;;;631    #if TCP_CHECKSUM_ON_COPY
;;;632          /* calculate the checksum of nocopy-data */
;;;633          chksum = ~inet_chksum((const u8_t *)arg + pos, seglen);
;;;634          if (seglen & 1) {
;;;635            chksum_swapped = 1;
;;;636            chksum = SWAP_BYTES_IN_WORD(chksum);
;;;637          }
;;;638    #endif /* TCP_CHECKSUM_ON_COPY */
;;;639          /* reference the non-volatile payload data */
;;;640          ((struct pbuf_rom *)p2)->payload = (const u8_t *)arg + pos;
;;;641    
;;;642          /* Second, allocate a pbuf for the headers. */
;;;643          if ((p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
;;;644            /* If allocation fails, we have to deallocate the data pbuf as
;;;645             * well. */
;;;646            pbuf_free(p2);
;;;647            LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: could not allocate memory for header pbuf\n"));
;;;648            goto memerr;
;;;649          }
;;;650          /* Concatenate the headers and data pbufs together. */
;;;651          pbuf_cat(p/*header*/, p2/*data*/);
;;;652        }
;;;653    
;;;654        queuelen += pbuf_clen(p);
;;;655    
;;;656        /* Now that there are more segments queued, we check again if the
;;;657         * length of the queue exceeds the configured maximum or
;;;658         * overflows. */
;;;659        if (queuelen > LWIP_MIN(TCP_SND_QUEUELEN, TCP_SNDQUEUELEN_OVERFLOW)) {
;;;660          LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("tcp_write: queue too long %"U16_F" (%d)\n",
;;;661                      queuelen, (int)TCP_SND_QUEUELEN));
;;;662          pbuf_free(p);
;;;663          goto memerr;
;;;664        }
;;;665    
;;;666        if ((seg = tcp_create_segment(pcb, p, 0, pcb->snd_lbb + pos, optflags)) == NULL) {
;;;667          goto memerr;
;;;668        }
;;;669    #if TCP_OVERSIZE_DBGCHECK
;;;670        seg->oversize_left = oversize;
;;;671    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;672    #if TCP_CHECKSUM_ON_COPY
;;;673        seg->chksum = chksum;
;;;674        seg->chksum_swapped = chksum_swapped;
;;;675        seg->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;676    #endif /* TCP_CHECKSUM_ON_COPY */
;;;677    
;;;678        /* first segment of to-be-queued data? */
;;;679        if (queue == NULL) {
;;;680          queue = seg;
;;;681        } else {
;;;682          /* Attach the segment to the end of the queued segments */
;;;683          LWIP_ASSERT("prev_seg != NULL", prev_seg != NULL);
;;;684          prev_seg->next = seg;
;;;685        }
;;;686        /* remember last segment of to-be-queued data for next iteration */
;;;687        prev_seg = seg;
;;;688    
;;;689        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_write: queueing %"U32_F":%"U32_F"\n",
;;;690                    lwip_ntohl(seg->tcphdr->seqno),
;;;691                    lwip_ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg)));
;;;692    
;;;693        pos += seglen;
;;;694      }
;;;695    
;;;696      /*
;;;697       * All three segmentation phases were successful. We can commit the
;;;698       * transaction.
;;;699       */
;;;700    #if TCP_OVERSIZE_DBGCHECK
;;;701      if ((last_unsent != NULL) && (oversize_add != 0)) {
;;;702        last_unsent->oversize_left += oversize_add;
;;;703      }
;;;704    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;705    
;;;706      /*
;;;707       * Phase 1: If data has been added to the preallocated tail of
;;;708       * last_unsent, we update the length fields of the pbuf chain.
;;;709       */
;;;710    #if TCP_OVERSIZE
;;;711      if (oversize_used > 0) {
;;;712        struct pbuf *p;
;;;713        /* Bump tot_len of whole chain, len of tail */
;;;714        for (p = last_unsent->p; p; p = p->next) {
;;;715          p->tot_len += oversize_used;
;;;716          if (p->next == NULL) {
;;;717            TCP_DATA_COPY((char *)p->payload + p->len, arg, oversize_used, last_unsent);
;;;718            p->len += oversize_used;
;;;719          }
;;;720        }
;;;721        last_unsent->len += oversize_used;
;;;722    #if TCP_OVERSIZE_DBGCHECK
;;;723        LWIP_ASSERT("last_unsent->oversize_left >= oversize_used",
;;;724                    last_unsent->oversize_left >= oversize_used);
;;;725        last_unsent->oversize_left -= oversize_used;
;;;726    #endif /* TCP_OVERSIZE_DBGCHECK */
;;;727      }
;;;728      pcb->unsent_oversize = oversize;
;;;729    #endif /* TCP_OVERSIZE */
;;;730    
;;;731      /*
;;;732       * Phase 2: concat_p can be concatenated onto last_unsent->p, unless we
;;;733       * determined that the last ROM pbuf can be extended to include the new data.
;;;734       */
;;;735      if (concat_p != NULL) {
;;;736        LWIP_ASSERT("tcp_write: cannot concatenate when pcb->unsent is empty",
;;;737                    (last_unsent != NULL));
;;;738        pbuf_cat(last_unsent->p, concat_p);
;;;739        last_unsent->len += concat_p->tot_len;
;;;740      } else if (extendlen > 0) {
;;;741        struct pbuf *p;
;;;742        LWIP_ASSERT("tcp_write: extension of reference requires reference",
;;;743                    last_unsent != NULL && last_unsent->p != NULL);
;;;744        for (p = last_unsent->p; p->next != NULL; p = p->next) {
;;;745          p->tot_len += extendlen;
;;;746        }
;;;747        p->tot_len += extendlen;
;;;748        p->len += extendlen;
;;;749        last_unsent->len += extendlen;
;;;750      }
;;;751    
;;;752    #if TCP_CHECKSUM_ON_COPY
;;;753      if (concat_chksummed) {
;;;754        LWIP_ASSERT("tcp_write: concat checksum needs concatenated data",
;;;755                    concat_p != NULL || extendlen > 0);
;;;756        /*if concat checksumm swapped - swap it back */
;;;757        if (concat_chksum_swapped) {
;;;758          concat_chksum = SWAP_BYTES_IN_WORD(concat_chksum);
;;;759        }
;;;760        tcp_seg_add_chksum(concat_chksum, concat_chksummed, &last_unsent->chksum,
;;;761                           &last_unsent->chksum_swapped);
;;;762        last_unsent->flags |= TF_SEG_DATA_CHECKSUMMED;
;;;763      }
;;;764    #endif /* TCP_CHECKSUM_ON_COPY */
;;;765    
;;;766      /*
;;;767       * Phase 3: Append queue to pcb->unsent. Queue may be NULL, but that
;;;768       * is harmless
;;;769       */
;;;770      if (last_unsent == NULL) {
;;;771        pcb->unsent = queue;
;;;772      } else {
;;;773        last_unsent->next = queue;
;;;774      }
;;;775    
;;;776      /*
;;;777       * Finally update the pcb state.
;;;778       */
;;;779      pcb->snd_lbb += len;
;;;780      pcb->snd_buf -= len;
;;;781      pcb->snd_queuelen = queuelen;
;;;782    
;;;783      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: %"S16_F" (after enqueued)\n",
;;;784                                   pcb->snd_queuelen));
;;;785      if (pcb->snd_queuelen != 0) {
;;;786        LWIP_ASSERT("tcp_write: valid queue length",
;;;787                    pcb->unacked != NULL || pcb->unsent != NULL);
;;;788      }
;;;789    
;;;790      /* Set the PSH flag in the last segment that we enqueued. */
;;;791      if (seg != NULL && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE) == 0)) {
;;;792        TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
;;;793      }
;;;794    
;;;795      return ERR_OK;
;;;796    memerr:
;;;797      tcp_set_flags(pcb, TF_NAGLEMEMERR);
;;;798      TCP_STATS_INC(tcp.memerr);
;;;799    
;;;800      if (concat_p != NULL) {
;;;801        pbuf_free(concat_p);
;;;802      }
;;;803      if (queue != NULL) {
;;;804        tcp_segs_free(queue);
;;;805      }
;;;806      if (pcb->snd_queuelen != 0) {
;;;807        LWIP_ASSERT("tcp_write: valid queue length", pcb->unacked != NULL ||
;;;808                    pcb->unsent != NULL);
;;;809      }
;;;810      LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_write: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
;;;811      return ERR_MEM;
;;;812    }
000048  b011              ADD      sp,sp,#0x44
00004a  e8bd8ff0          POP      {r4-r11,pc}
                  |L22.78|
00004e  0849              LSRS     r1,r1,#1              ;417
                  |L22.80|
000050  b901              CBNZ     r1,|L22.84|
000052  4601              MOV      r1,r0                 ;418
                  |L22.84|
000054  9106              STR      r1,[sp,#0x18]         ;418
000056  980e              LDR      r0,[sp,#0x38]         ;429
000058  b168              CBZ      r0,|L22.118|
00005a  4641              MOV      r1,r8                 ;432
00005c  4628              MOV      r0,r5                 ;432
00005e  f7fffffe          BL       tcp_write_checks
000062  2800              CMP      r0,#0                 ;433
000064  d1f0              BNE      |L22.72|
000066  f8b59066          LDRH     r9,[r5,#0x66]         ;436
00006a  900a              STR      r0,[sp,#0x28]         ;449
00006c  6ee8              LDR      r0,[r5,#0x6c]         ;476
00006e  2800              CMP      r0,#0                 ;476
000070  d07e              BEQ      |L22.368|
000072  4604              MOV      r4,r0                 ;481
000074  e009              B        |L22.138|
                  |L22.118|
000076  a3dd              ADR      r3,|L22.1004|
000078  f24012ad          MOV      r2,#0x1ad             ;429
00007c  a1f8              ADR      r1,|L22.1120|
00007e  a0ee              ADR      r0,|L22.1080|
000080  f7fffffe          BL       __2printf
000084  4648              MOV      r0,r9                 ;429
000086  e7df              B        |L22.72|
                  |L22.136|
000088  4604              MOV      r4,r0                 ;482
                  |L22.138|
00008a  6820              LDR      r0,[r4,#0]            ;481
00008c  2800              CMP      r0,#0                 ;481
00008e  d1fb              BNE      |L22.136|
000090  7aa0              LDRB     r0,[r4,#0xa]          ;485
000092  07c0              LSLS     r0,r0,#31             ;485
000094  d001              BEQ      |L22.154|
000096  2004              MOVS     r0,#4                 ;485
000098  e000              B        |L22.156|
                  |L22.154|
00009a  2000              MOVS     r0,#0                 ;485
                  |L22.156|
00009c  9004              STR      r0,[sp,#0x10]         ;485
00009e  8921              LDRH     r1,[r4,#8]            ;486
0000a0  9804              LDR      r0,[sp,#0x10]         ;486
0000a2  4401              ADD      r1,r1,r0              ;486
0000a4  9806              LDR      r0,[sp,#0x18]         ;486
0000a6  4281              CMP      r1,r0                 ;486
0000a8  d906              BLS      |L22.184|
0000aa  a3d0              ADR      r3,|L22.1004|
0000ac  f44f72f3          MOV      r2,#0x1e6             ;486
0000b0  a1f8              ADR      r1,|L22.1172|
0000b2  a0e1              ADR      r0,|L22.1080|
0000b4  f7fffffe          BL       __2printf
                  |L22.184|
0000b8  8921              LDRH     r1,[r4,#8]            ;487
0000ba  9804              LDR      r0,[sp,#0x10]         ;487
0000bc  4401              ADD      r1,r1,r0              ;487
0000be  9806              LDR      r0,[sp,#0x18]         ;487
0000c0  1a40              SUBS     r0,r0,r1              ;487
0000c2  b280              UXTH     r0,r0                 ;487
0000c4  9005              STR      r0,[sp,#0x14]         ;487
0000c6  f8b50068          LDRH     r0,[r5,#0x68]         ;502
0000ca  9008              STR      r0,[sp,#0x20]         ;502
0000cc  2800              CMP      r0,#0                 ;503
0000ce  d027              BEQ      |L22.288|
0000d0  9905              LDR      r1,[sp,#0x14]         ;504
0000d2  4288              CMP      r0,r1                 ;504
0000d4  d906              BLS      |L22.228|
0000d6  a3c5              ADR      r3,|L22.1004|
0000d8  f44f72fc          MOV      r2,#0x1f8             ;504
0000dc  a1f3              ADR      r1,|L22.1196|
0000de  a0d6              ADR      r0,|L22.1080|
0000e0  f7fffffe          BL       __2printf
                  |L22.228|
0000e4  4627              MOV      r7,r4                 ;505
0000e6  f8bd0020          LDRH     r0,[sp,#0x20]         ;506
0000ea  4540              CMP      r0,r8                 ;506
0000ec  d201              BCS      |L22.242|
0000ee  4601              MOV      r1,r0                 ;506
0000f0  e000              B        |L22.244|
                  |L22.242|
0000f2  4641              MOV      r1,r8                 ;506
                  |L22.244|
0000f4  9a05              LDR      r2,[sp,#0x14]         ;506
0000f6  4291              CMP      r1,r2                 ;506
0000f8  d902              BLS      |L22.256|
0000fa  f8dda014          LDR      r10,[sp,#0x14]        ;506
0000fe  e004              B        |L22.266|
                  |L22.256|
000100  4540              CMP      r0,r8                 ;506
000102  d201              BCS      |L22.264|
000104  4682              MOV      r10,r0                ;506
000106  e000              B        |L22.266|
                  |L22.264|
000108  46c2              MOV      r10,r8                ;506
                  |L22.266|
00010a  eb06010a          ADD      r1,r6,r10             ;507
00010e  b28e              UXTH     r6,r1                 ;507
000110  eba0000a          SUB      r0,r0,r10             ;508
000114  9008              STR      r0,[sp,#0x20]         ;508
000116  9805              LDR      r0,[sp,#0x14]         ;509
000118  eba0000a          SUB      r0,r0,r10             ;509
00011c  b280              UXTH     r0,r0                 ;509
00011e  9005              STR      r0,[sp,#0x14]         ;509
                  |L22.288|
000120  f8bd0020          LDRH     r0,[sp,#0x20]         ;512
000124  b140              CBZ      r0,|L22.312|
000126  4546              CMP      r6,r8                 ;512
000128  d006              BEQ      |L22.312|
00012a  a3b0              ADR      r3,|L22.1004|
00012c  f44f7200          MOV      r2,#0x200             ;512
000130  a1e6              ADR      r1,|L22.1228|
000132  a0c1              ADR      r0,|L22.1080|
000134  f7fffffe          BL       __2printf
                  |L22.312|
000138  4546              CMP      r6,r8                 ;531
00013a  d25e              BCS      |L22.506|
00013c  9805              LDR      r0,[sp,#0x14]         ;531
00013e  2800              CMP      r0,#0                 ;531
                  |L22.320|
000140  d05b              BEQ      |L22.506|
000142  8920              LDRH     r0,[r4,#8]            ;531
000144  2800              CMP      r0,#0                 ;531
000146  d0fb              BEQ      |L22.320|
000148  9905              LDR      r1,[sp,#0x14]         ;532
00014a  eba80006          SUB      r0,r8,r6              ;532
00014e  4288              CMP      r0,r1                 ;532
000150  dd00              BLE      |L22.340|
000152  9805              LDR      r0,[sp,#0x14]         ;532
                  |L22.340|
000154  b280              UXTH     r0,r0                 ;532
000156  9003              STR      r0,[sp,#0xc]          ;532
000158  4627              MOV      r7,r4                 ;533
00015a  9810              LDR      r0,[sp,#0x40]         ;538
00015c  07c0              LSLS     r0,r0,#31             ;538
00015e  d01d              BEQ      |L22.412|
000160  9810              LDR      r0,[sp,#0x40]         ;540
000162  2101              MOVS     r1,#1                 ;540
000164  e9cd5000          STRD     r5,r0,[sp,#0]         ;540
000168  ab08              ADD      r3,sp,#0x20           ;540
00016a  9102              STR      r1,[sp,#8]            ;540
00016c  2000              MOVS     r0,#0                 ;540
00016e  e000              B        |L22.370|
                  |L22.368|
000170  e044              B        |L22.508|
                  |L22.370|
000172  9a05              LDR      r2,[sp,#0x14]         ;540
000174  9903              LDR      r1,[sp,#0xc]          ;540
000176  f7fffffe          BL       tcp_pbuf_prealloc
00017a  900c              STR      r0,[sp,#0x30]         ;540
00017c  2800              CMP      r0,#0                 ;540
                  |L22.382|
00017e  d074              BEQ      |L22.618|
000180  980e              LDR      r0,[sp,#0x38]         ;549
000182  9a03              LDR      r2,[sp,#0xc]          ;549
000184  1981              ADDS     r1,r0,r6              ;549
000186  980c              LDR      r0,[sp,#0x30]         ;549
000188  6840              LDR      r0,[r0,#4]            ;549
00018a  f7fffffe          BL       __aeabi_memcpy
00018e  980c              LDR      r0,[sp,#0x30]         ;553
000190  f7fffffe          BL       pbuf_clen
000194  4448              ADD      r0,r0,r9              ;553
000196  fa1ff980          UXTH     r9,r0                 ;553
00019a  e02b              B        |L22.500|
                  |L22.412|
00019c  6860              LDR      r0,[r4,#4]            ;558
00019e  e000              B        |L22.418|
                  |L22.416|
0001a0  4608              MOV      r0,r1                 ;558
                  |L22.418|
0001a2  6801              LDR      r1,[r0,#0]            ;558
0001a4  2900              CMP      r1,#0                 ;558
0001a6  d1fb              BNE      |L22.416|
0001a8  7b01              LDRB     r1,[r0,#0xc]          ;559
0001aa  0989              LSRS     r1,r1,#6              ;559
0001ac  d110              BNE      |L22.464|
0001ae  6841              LDR      r1,[r0,#4]            ;560
0001b0  8940              LDRH     r0,[r0,#0xa]          ;560
0001b2  4401              ADD      r1,r1,r0              ;560
0001b4  980e              LDR      r0,[sp,#0x38]         ;560
0001b6  4281              CMP      r1,r0                 ;560
0001b8  d10a              BNE      |L22.464|
0001ba  b136              CBZ      r6,|L22.458|
0001bc  a38b              ADR      r3,|L22.1004|
0001be  f2402231          MOV      r2,#0x231             ;561
0001c2  a1ca              ADR      r1,|L22.1260|
0001c4  a09c              ADR      r0,|L22.1080|
0001c6  f7fffffe          BL       __2printf
                  |L22.458|
0001ca  9803              LDR      r0,[sp,#0xc]          ;562
0001cc  9007              STR      r0,[sp,#0x1c]         ;562
0001ce  e011              B        |L22.500|
                  |L22.464|
0001d0  2201              MOVS     r2,#1                 ;564
0001d2  2000              MOVS     r0,#0                 ;564
0001d4  9903              LDR      r1,[sp,#0xc]          ;564
0001d6  f7fffffe          BL       pbuf_alloc
0001da  900c              STR      r0,[sp,#0x30]         ;564
0001dc  2800              CMP      r0,#0                 ;564
                  |L22.478|
0001de  d0ce              BEQ      |L22.382|
0001e0  980e              LDR      r0,[sp,#0x38]         ;570
0001e2  1981              ADDS     r1,r0,r6              ;570
0001e4  980c              LDR      r0,[sp,#0x30]         ;570
0001e6  6041              STR      r1,[r0,#4]            ;570
0001e8  980c              LDR      r0,[sp,#0x30]         ;571
0001ea  f7fffffe          BL       pbuf_clen
0001ee  4448              ADD      r0,r0,r9              ;571
0001f0  fa1ff980          UXTH     r9,r0                 ;571
                  |L22.500|
0001f4  9803              LDR      r0,[sp,#0xc]          ;581
0001f6  4430              ADD      r0,r0,r6              ;581
0001f8  b286              UXTH     r6,r0                 ;581
                  |L22.506|
0001fa  e098              B        |L22.814|
                  |L22.508|
0001fc  f8b50068          LDRH     r0,[r5,#0x68]         ;586
000200  2800              CMP      r0,#0                 ;586
000202  d0fa              BEQ      |L22.506|
000204  a379              ADR      r3,|L22.1004|
000206  f240224a          MOV      r2,#0x24a             ;586
00020a  a1c3              ADR      r1,|L22.1304|
00020c  a08a              ADR      r0,|L22.1080|
00020e  f7fffffe          BL       __2printf
000212  e08c              B        |L22.814|
                  |L22.532|
000214  eba80006          SUB      r0,r8,r6              ;599
000218  b280              UXTH     r0,r0                 ;599
00021a  9a0a              LDR      r2,[sp,#0x28]         ;600
00021c  9906              LDR      r1,[sp,#0x18]         ;600
00021e  1a89              SUBS     r1,r1,r2              ;600
000220  b289              UXTH     r1,r1                 ;600
000222  4288              CMP      r0,r1                 ;601
000224  d300              BCC      |L22.552|
000226  4608              MOV      r0,r1                 ;601
                  |L22.552|
000228  9004              STR      r0,[sp,#0x10]         ;601
00022a  9810              LDR      r0,[sp,#0x40]         ;607
00022c  07c0              LSLS     r0,r0,#31             ;607
00022e  d02d              BEQ      |L22.652|
000230  f1bb0f00          CMP      r11,#0                ;610
000234  d028              BEQ      |L22.648|
000236  2000              MOVS     r0,#0                 ;610
                  |L22.568|
000238  9910              LDR      r1,[sp,#0x40]         ;610
00023a  9002              STR      r0,[sp,#8]            ;610
00023c  e9cd5100          STRD     r5,r1,[sp,#0]         ;610
000240  990a              LDR      r1,[sp,#0x28]         ;610
000242  9804              LDR      r0,[sp,#0x10]         ;610
000244  ab08              ADD      r3,sp,#0x20           ;610
000246  4408              ADD      r0,r0,r1              ;610
000248  b281              UXTH     r1,r0                 ;610
00024a  2036              MOVS     r0,#0x36              ;610
00024c  9a06              LDR      r2,[sp,#0x18]         ;610
00024e  f7fffffe          BL       tcp_pbuf_prealloc
000252  9005              STR      r0,[sp,#0x14]         ;610
000254  2800              CMP      r0,#0                 ;610
000256  d092              BEQ      |L22.382|
000258  9805              LDR      r0,[sp,#0x14]         ;614
00025a  8941              LDRH     r1,[r0,#0xa]          ;614
00025c  9804              LDR      r0,[sp,#0x10]         ;614
00025e  4281              CMP      r1,r0                 ;614
000260  d208              BCS      |L22.628|
000262  a362              ADR      r3,|L22.1004|
000264  f2402266          MOV      r2,#0x266             ;614
000268  e000              B        |L22.620|
                  |L22.618|
00026a  e203              B        |L22.1652|
                  |L22.620|
00026c  a1b6              ADR      r1,|L22.1352|
00026e  a072              ADR      r0,|L22.1080|
000270  f7fffffe          BL       __2printf
                  |L22.628|
000274  980e              LDR      r0,[sp,#0x38]         ;616
000276  1981              ADDS     r1,r0,r6              ;616
000278  9805              LDR      r0,[sp,#0x14]         ;616
00027a  6842              LDR      r2,[r0,#4]            ;616
00027c  980a              LDR      r0,[sp,#0x28]         ;616
00027e  4410              ADD      r0,r0,r2              ;616
000280  9a04              LDR      r2,[sp,#0x10]         ;616
000282  f7fffffe          BL       __aeabi_memcpy
000286  e021              B        |L22.716|
                  |L22.648|
000288  2001              MOVS     r0,#1                 ;610
00028a  e7d5              B        |L22.568|
                  |L22.652|
00028c  f8bd0020          LDRH     r0,[sp,#0x20]         ;625
000290  b130              CBZ      r0,|L22.672|
000292  a356              ADR      r3,|L22.1004|
000294  f2402271          MOV      r2,#0x271             ;625
000298  a1bb              ADR      r1,|L22.1416|
00029a  a067              ADR      r0,|L22.1080|
00029c  f7fffffe          BL       __2printf
                  |L22.672|
0002a0  2201              MOVS     r2,#1                 ;627
0002a2  2036              MOVS     r0,#0x36              ;627
0002a4  9904              LDR      r1,[sp,#0x10]         ;627
0002a6  f7fffffe          BL       pbuf_alloc
0002aa  1e07              SUBS     r7,r0,#0              ;627
0002ac  d097              BEQ      |L22.478|
0002ae  980e              LDR      r0,[sp,#0x38]         ;640
0002b0  4430              ADD      r0,r0,r6              ;640
0002b2  6078              STR      r0,[r7,#4]            ;640
0002b4  f44f7220          MOV      r2,#0x280             ;643
0002b8  2036              MOVS     r0,#0x36              ;643
0002ba  990a              LDR      r1,[sp,#0x28]         ;643
0002bc  f7fffffe          BL       pbuf_alloc
0002c0  9005              STR      r0,[sp,#0x14]         ;643
0002c2  b180              CBZ      r0,|L22.742|
0002c4  4639              MOV      r1,r7                 ;651
0002c6  9805              LDR      r0,[sp,#0x14]         ;651
0002c8  f7fffffe          BL       pbuf_cat
                  |L22.716|
0002cc  9805              LDR      r0,[sp,#0x14]         ;654
0002ce  f7fffffe          BL       pbuf_clen
0002d2  4448              ADD      r0,r0,r9              ;654
0002d4  fa1ff980          UXTH     r9,r0                 ;654
0002d8  f1b90f09          CMP      r9,#9                 ;659
0002dc  d907              BLS      |L22.750|
0002de  9805              LDR      r0,[sp,#0x14]         ;662
0002e0  f7fffffe          BL       pbuf_free
                  |L22.740|
0002e4  e1c6              B        |L22.1652|
                  |L22.742|
0002e6  4638              MOV      r0,r7                 ;646
0002e8  f7fffffe          BL       pbuf_free
0002ec  e1c2              B        |L22.1652|
                  |L22.750|
0002ee  9809              LDR      r0,[sp,#0x24]         ;666
0002f0  9000              STR      r0,[sp,#0]            ;666
0002f2  6de8              LDR      r0,[r5,#0x5c]         ;666
0002f4  2200              MOVS     r2,#0                 ;666
0002f6  1983              ADDS     r3,r0,r6              ;666
0002f8  4628              MOV      r0,r5                 ;666
0002fa  9905              LDR      r1,[sp,#0x14]         ;666
0002fc  f7fffffe          BL       tcp_create_segment
000300  1e07              SUBS     r7,r0,#0              ;666
000302  d0ef              BEQ      |L22.740|
000304  f1bb0f00          CMP      r11,#0                ;679
000308  d002              BEQ      |L22.784|
00030a  980b              LDR      r0,[sp,#0x2c]         ;683
00030c  b110              CBZ      r0,|L22.788|
00030e  e008              B        |L22.802|
                  |L22.784|
000310  46bb              MOV      r11,r7                ;680
000312  e008              B        |L22.806|
                  |L22.788|
000314  a335              ADR      r3,|L22.1004|
000316  f24022ab          MOV      r2,#0x2ab             ;683
00031a  a19f              ADR      r1,|L22.1432|
00031c  a046              ADR      r0,|L22.1080|
00031e  f7fffffe          BL       __2printf
                  |L22.802|
000322  980b              LDR      r0,[sp,#0x2c]         ;684
000324  6007              STR      r7,[r0,#0]            ;684
                  |L22.806|
000326  970b              STR      r7,[sp,#0x2c]         ;687
000328  9804              LDR      r0,[sp,#0x10]         ;693
00032a  4430              ADD      r0,r0,r6              ;693
00032c  b286              UXTH     r6,r0                 ;693
                  |L22.814|
00032e  4546              CMP      r6,r8                 ;597
000330  f4ffaf70          BCC      |L22.532|
000334  f1ba0f00          CMP      r10,#0                ;711
000338  d016              BEQ      |L22.872|
00033a  6866              LDR      r6,[r4,#4]            ;714
00033c  e00f              B        |L22.862|
                  |L22.830|
00033e  8930              LDRH     r0,[r6,#8]            ;715
000340  4450              ADD      r0,r0,r10             ;715
000342  8130              STRH     r0,[r6,#8]            ;715
000344  6830              LDR      r0,[r6,#0]            ;716
000346  b948              CBNZ     r0,|L22.860|
000348  8971              LDRH     r1,[r6,#0xa]          ;717
00034a  6870              LDR      r0,[r6,#4]            ;717
00034c  4652              MOV      r2,r10                ;717
00034e  4408              ADD      r0,r0,r1              ;717
000350  990e              LDR      r1,[sp,#0x38]         ;717
000352  f7fffffe          BL       __aeabi_memcpy
000356  8970              LDRH     r0,[r6,#0xa]          ;718
000358  4450              ADD      r0,r0,r10             ;718
00035a  8170              STRH     r0,[r6,#0xa]          ;718
                  |L22.860|
00035c  6836              LDR      r6,[r6,#0]            ;714
                  |L22.862|
00035e  2e00              CMP      r6,#0                 ;714
000360  d1ed              BNE      |L22.830|
000362  8920              LDRH     r0,[r4,#8]            ;721
000364  4450              ADD      r0,r0,r10             ;721
000366  8120              STRH     r0,[r4,#8]            ;721
                  |L22.872|
000368  f8bd0020          LDRH     r0,[sp,#0x20]         ;728
00036c  f8a50068          STRH     r0,[r5,#0x68]         ;728
000370  980c              LDR      r0,[sp,#0x30]         ;735
000372  b188              CBZ      r0,|L22.920|
000374  b934              CBNZ     r4,|L22.900|
000376  a31d              ADR      r3,|L22.1004|
000378  f44f7238          MOV      r2,#0x2e0             ;736
00037c  a18b              ADR      r1,|L22.1452|
00037e  a02e              ADR      r0,|L22.1080|
000380  f7fffffe          BL       __2printf
                  |L22.900|
000384  6860              LDR      r0,[r4,#4]            ;738
000386  990c              LDR      r1,[sp,#0x30]         ;738
000388  f7fffffe          BL       pbuf_cat
00038c  980c              LDR      r0,[sp,#0x30]         ;739
00038e  8921              LDRH     r1,[r4,#8]            ;739
000390  8900              LDRH     r0,[r0,#8]            ;739
000392  4408              ADD      r0,r0,r1              ;739
000394  8120              STRH     r0,[r4,#8]            ;739
000396  e021              B        |L22.988|
                  |L22.920|
000398  9807              LDR      r0,[sp,#0x1c]         ;740
00039a  b1f8              CBZ      r0,|L22.988|
00039c  b10c              CBZ      r4,|L22.930|
00039e  6860              LDR      r0,[r4,#4]            ;742
0003a0  b930              CBNZ     r0,|L22.944|
                  |L22.930|
0003a2  a312              ADR      r3,|L22.1004|
0003a4  f24022e6          MOV      r2,#0x2e6             ;742
0003a8  a18e              ADR      r1,|L22.1508|
0003aa  a023              ADR      r0,|L22.1080|
0003ac  f7fffffe          BL       __2printf
                  |L22.944|
0003b0  6860              LDR      r0,[r4,#4]            ;744
0003b2  e004              B        |L22.958|
                  |L22.948|
0003b4  8903              LDRH     r3,[r0,#8]            ;745
0003b6  9a07              LDR      r2,[sp,#0x1c]         ;745
0003b8  441a              ADD      r2,r2,r3              ;745
0003ba  8102              STRH     r2,[r0,#8]            ;745
0003bc  4608              MOV      r0,r1                 ;744
                  |L22.958|
0003be  6801              LDR      r1,[r0,#0]            ;744
0003c0  2900              CMP      r1,#0                 ;744
0003c2  d1f7              BNE      |L22.948|
0003c4  8902              LDRH     r2,[r0,#8]            ;747
0003c6  9907              LDR      r1,[sp,#0x1c]         ;747
0003c8  4411              ADD      r1,r1,r2              ;747
0003ca  8101              STRH     r1,[r0,#8]            ;747
0003cc  8942              LDRH     r2,[r0,#0xa]          ;748
0003ce  9907              LDR      r1,[sp,#0x1c]         ;748
0003d0  4411              ADD      r1,r1,r2              ;748
0003d2  8141              STRH     r1,[r0,#0xa]          ;748
0003d4  8921              LDRH     r1,[r4,#8]            ;749
0003d6  9807              LDR      r0,[sp,#0x1c]         ;749
0003d8  4408              ADD      r0,r0,r1              ;749
0003da  8120              STRH     r0,[r4,#8]            ;749
                  |L22.988|
0003dc  b12c              CBZ      r4,|L22.1002|
0003de  f8c4b000          STR      r11,[r4,#0]           ;773
                  |L22.994|
0003e2  6de8              LDR      r0,[r5,#0x5c]         ;779
0003e4  4440              ADD      r0,r0,r8              ;779
0003e6  65e8              STR      r0,[r5,#0x5c]         ;779
0003e8  e118              B        |L22.1564|
                  |L22.1002|
0003ea  e125              B        |L22.1592|
                  |L22.1004|
0003ec  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
0003f0  6964646c
0003f4  65776172
0003f8  65735c54
0003fc  68697264
000400  5f506172
000404  74795c4c
000408  7749505c
00040c  7372635c
000410  636f7265
000414  5c746370
000418  5f6f7574
00041c  2e      
00041d  6300              DCB      "c",0
00041f  00                DCB      0
                  |L22.1056|
000420  7463705f          DCB      "tcp_write: invalid pcb",0
000424  77726974
000428  653a2069
00042c  6e76616c
000430  69642070
000434  636200  
000437  00                DCB      0
                  |L22.1080|
000438  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00043c  7274696f
000440  6e202225
000444  73222066
000448  61696c65
00044c  64206174
000450  206c696e
000454  65202564
000458  20696e20
00045c  25730a00
                  |L22.1120|
000460  7463705f          DCB      "tcp_write: arg == NULL (programmer violates API)",0
000464  77726974
000468  653a2061
00046c  7267203d
000470  3d204e55
000474  4c4c2028
000478  70726f67
00047c  72616d6d
000480  65722076
000484  696f6c61
000488  74657320
00048c  41504929
000490  00      
000491  00                DCB      0
000492  00                DCB      0
000493  00                DCB      0
                  |L22.1172|
000494  6d73735f          DCB      "mss_local is too small",0
000498  6c6f6361
00049c  6c206973
0004a0  20746f6f
0004a4  20736d61
0004a8  6c6c00  
0004ab  00                DCB      0
                  |L22.1196|
0004ac  696e636f          DCB      "inconsistent oversize vs. space",0
0004b0  6e736973
0004b4  74656e74
0004b8  206f7665
0004bc  7273697a
0004c0  65207673
0004c4  2e207370
0004c8  61636500
                  |L22.1228|
0004cc  696e636f          DCB      "inconsistent oversize vs. len",0
0004d0  6e736973
0004d4  74656e74
0004d8  206f7665
0004dc  7273697a
0004e0  65207673
0004e4  2e206c65
0004e8  6e00    
0004ea  00                DCB      0
0004eb  00                DCB      0
                  |L22.1260|
0004ec  7463705f          DCB      "tcp_write: ROM pbufs cannot be oversized",0
0004f0  77726974
0004f4  653a2052
0004f8  4f4d2070
0004fc  62756673
000500  2063616e
000504  6e6f7420
000508  6265206f
00050c  76657273
000510  697a6564
000514  00      
000515  00                DCB      0
000516  00                DCB      0
000517  00                DCB      0
                  |L22.1304|
000518  756e7365          DCB      "unsent_oversize mismatch (pcb->unsent is NULL)",0
00051c  6e745f6f
000520  76657273
000524  697a6520
000528  6d69736d
00052c  61746368
000530  20287063
000534  622d3e75
000538  6e73656e
00053c  74206973
000540  204e554c
000544  4c2900  
000547  00                DCB      0
                  |L22.1352|
000548  7463705f          DCB      "tcp_write: check that first pbuf can hold the complete "
00054c  77726974
000550  653a2063
000554  6865636b
000558  20746861
00055c  74206669
000560  72737420
000564  70627566
000568  2063616e
00056c  20686f6c
000570  64207468
000574  6520636f
000578  6d706c65
00057c  746520  
00057f  7365676c          DCB      "seglen",0
000583  656e00  
000586  00                DCB      0
000587  00                DCB      0
                  |L22.1416|
000588  6f766572          DCB      "oversize == 0",0
00058c  73697a65
000590  203d3d20
000594  3000    
000596  00                DCB      0
000597  00                DCB      0
                  |L22.1432|
000598  70726576          DCB      "prev_seg != NULL",0
00059c  5f736567
0005a0  20213d20
0005a4  4e554c4c
0005a8  00      
0005a9  00                DCB      0
0005aa  00                DCB      0
0005ab  00                DCB      0
                  |L22.1452|
0005ac  7463705f          DCB      "tcp_write: cannot concatenate when pcb->unsent is empty"
0005b0  77726974
0005b4  653a2063
0005b8  616e6e6f
0005bc  7420636f
0005c0  6e636174
0005c4  656e6174
0005c8  65207768
0005cc  656e2070
0005d0  63622d3e
0005d4  756e7365
0005d8  6e742069
0005dc  7320656d
0005e0  707479  
0005e3  00                DCB      0
                  |L22.1508|
0005e4  7463705f          DCB      "tcp_write: extension of reference requires reference",0
0005e8  77726974
0005ec  653a2065
0005f0  7874656e
0005f4  73696f6e
0005f8  206f6620
0005fc  72656665
000600  72656e63
000604  65207265
000608  71756972
00060c  65732072
000610  65666572
000614  656e6365
000618  00      
000619  00                DCB      0
00061a  00                DCB      0
00061b  00                DCB      0
                  |L22.1564|
00061c  f8b50064          LDRH     r0,[r5,#0x64]         ;780
000620  eba00008          SUB      r0,r0,r8              ;780
000624  f8a50064          STRH     r0,[r5,#0x64]         ;780
000628  f8a59066          STRH     r9,[r5,#0x66]         ;781
00062c  f1b90f00          CMP      r9,#0                 ;785
000630  d010              BEQ      |L22.1620|
000632  6f28              LDR      r0,[r5,#0x70]         ;786
000634  b118              CBZ      r0,|L22.1598|
000636  e00d              B        |L22.1620|
                  |L22.1592|
000638  f8c5b06c          STR      r11,[r5,#0x6c]        ;771
00063c  e6d1              B        |L22.994|
                  |L22.1598|
00063e  6ee8              LDR      r0,[r5,#0x6c]         ;786
000640  b940              CBNZ     r0,|L22.1620|
000642  f2af2358          ADR      r3,|L22.1004|
000646  f2403212          MOV      r2,#0x312             ;786
00064a  a11b              ADR      r1,|L22.1720|
00064c  f2af2018          ADR      r0,|L22.1080|
000650  f7fffffe          BL       __2printf
                  |L22.1620|
000654  b167              CBZ      r7,|L22.1648|
000656  68f8              LDR      r0,[r7,#0xc]          ;791
000658  b150              CBZ      r0,|L22.1648|
00065a  9810              LDR      r0,[sp,#0x40]         ;791
00065c  0780              LSLS     r0,r0,#30             ;791
00065e  d407              BMI      |L22.1648|
000660  2008              MOVS     r0,#8                 ;792
000662  f7fffffe          BL       lwip_htons
000666  4601              MOV      r1,r0                 ;792
000668  68f8              LDR      r0,[r7,#0xc]          ;792
00066a  8982              LDRH     r2,[r0,#0xc]          ;792
00066c  4311              ORRS     r1,r1,r2              ;792
00066e  8181              STRH     r1,[r0,#0xc]          ;792
                  |L22.1648|
000670  2000              MOVS     r0,#0                 ;795
000672  e4e9              B        |L22.72|
                  |L22.1652|
000674  8b68              LDRH     r0,[r5,#0x1a]         ;797
000676  f0400080          ORR      r0,r0,#0x80           ;797
00067a  8368              STRH     r0,[r5,#0x1a]         ;797
00067c  980c              LDR      r0,[sp,#0x30]         ;800
00067e  b110              CBZ      r0,|L22.1670|
000680  980c              LDR      r0,[sp,#0x30]         ;801
000682  f7fffffe          BL       pbuf_free
                  |L22.1670|
000686  f1bb0f00          CMP      r11,#0                ;803
00068a  d002              BEQ      |L22.1682|
00068c  4658              MOV      r0,r11                ;804
00068e  f7fffffe          BL       tcp_segs_free
                  |L22.1682|
000692  f8b50066          LDRH     r0,[r5,#0x66]         ;806
000696  b160              CBZ      r0,|L22.1714|
000698  6f28              LDR      r0,[r5,#0x70]         ;807
00069a  b950              CBNZ     r0,|L22.1714|
00069c  6ee8              LDR      r0,[r5,#0x6c]         ;807
00069e  b940              CBNZ     r0,|L22.1714|
0006a0  f2af23b8          ADR      r3,|L22.1004|
0006a4  f2403227          MOV      r2,#0x327             ;807
0006a8  a103              ADR      r1,|L22.1720|
0006aa  f2af2074          ADR      r0,|L22.1080|
0006ae  f7fffffe          BL       __2printf
                  |L22.1714|
0006b2  f04f30ff          MOV      r0,#0xffffffff        ;811
0006b6  e4c7              B        |L22.72|
;;;813    
                          ENDP

                  |L22.1720|
0006b8  7463705f          DCB      "tcp_write: valid queue length",0
0006bc  77726974
0006c0  653a2076
0006c4  616c6964
0006c8  20717565
0006cc  7565206c
0006d0  656e6774
0006d4  6800    
0006d6  00                DCB      0
0006d7  00                DCB      0

                          AREA ||i.tcp_write_checks||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_write_checks PROC
;;;304    static err_t
;;;305    tcp_write_checks(struct tcp_pcb *pcb, u16_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;306    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;307      LWIP_ASSERT("tcp_write_checks: invalid pcb", pcb != NULL);
000006  2c00              CMP      r4,#0
000008  d106              BNE      |L23.24|
00000a  a324              ADR      r3,|L23.156|
00000c  f2401233          MOV      r2,#0x133
000010  a12f              ADR      r1,|L23.208|
000012  a037              ADR      r0,|L23.240|
000014  f7fffffe          BL       __2printf
                  |L23.24|
;;;308    
;;;309      /* connection is in invalid state for data transmission? */
;;;310      if ((pcb->state != ESTABLISHED) &&
000018  7d20              LDRB     r0,[r4,#0x14]
00001a  2804              CMP      r0,#4
00001c  d008              BEQ      |L23.48|
;;;311          (pcb->state != CLOSE_WAIT) &&
00001e  2807              CMP      r0,#7
000020  d006              BEQ      |L23.48|
;;;312          (pcb->state != SYN_SENT) &&
000022  2802              CMP      r0,#2
000024  d004              BEQ      |L23.48|
;;;313          (pcb->state != SYN_RCVD)) {
000026  2803              CMP      r0,#3
000028  d002              BEQ      |L23.48|
;;;314        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | LWIP_DBG_LEVEL_SEVERE, ("tcp_write() called in invalid state\n"));
;;;315        return ERR_CONN;
00002a  f06f000a          MVN      r0,#0xa
;;;316      } else if (len == 0) {
;;;317        return ERR_OK;
;;;318      }
;;;319    
;;;320      /* fail on too much data */
;;;321      if (len > pcb->snd_buf) {
;;;322        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too much data (len=%"U16_F" > snd_buf=%"TCPWNDSIZE_F")\n",
;;;323                    len, pcb->snd_buf));
;;;324        tcp_set_flags(pcb, TF_NAGLEMEMERR);
;;;325        return ERR_MEM;
;;;326      }
;;;327    
;;;328      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_write: queuelen: %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
;;;329    
;;;330      /* If total number of pbufs on the unsent/unacked queues exceeds the
;;;331       * configured maximum, return an error */
;;;332      /* check for configured max queuelen and possible overflow */
;;;333      if (pcb->snd_queuelen >= LWIP_MIN(TCP_SND_QUEUELEN, (TCP_SNDQUEUELEN_OVERFLOW + 1))) {
;;;334        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("tcp_write: too long queue %"U16_F" (max %"U16_F")\n",
;;;335                    pcb->snd_queuelen, (u16_t)TCP_SND_QUEUELEN));
;;;336        TCP_STATS_INC(tcp.memerr);
;;;337        tcp_set_flags(pcb, TF_NAGLEMEMERR);
;;;338        return ERR_MEM;
;;;339      }
;;;340      if (pcb->snd_queuelen != 0) {
;;;341        LWIP_ASSERT("tcp_write: pbufs on queue => at least one queue non-empty",
;;;342                    pcb->unacked != NULL || pcb->unsent != NULL);
;;;343      } else {
;;;344        LWIP_ASSERT("tcp_write: no pbufs on queue => both queues empty",
;;;345                    pcb->unacked == NULL && pcb->unsent == NULL);
;;;346      }
;;;347      return ERR_OK;
;;;348    }
00002e  bd70              POP      {r4-r6,pc}
                  |L23.48|
000030  b15d              CBZ      r5,|L23.74|
000032  f8b40064          LDRH     r0,[r4,#0x64]         ;321
000036  f04f31ff          MOV      r1,#0xffffffff        ;325
00003a  42a8              CMP      r0,r5                 ;321
00003c  d207              BCS      |L23.78|
00003e  8b60              LDRH     r0,[r4,#0x1a]         ;324
000040  f0400080          ORR      r0,r0,#0x80           ;324
000044  8360              STRH     r0,[r4,#0x1a]         ;324
000046  4608              MOV      r0,r1                 ;325
000048  bd70              POP      {r4-r6,pc}
                  |L23.74|
00004a  2000              MOVS     r0,#0                 ;317
00004c  bd70              POP      {r4-r6,pc}
                  |L23.78|
00004e  f8b40066          LDRH     r0,[r4,#0x66]         ;333
000052  2809              CMP      r0,#9                 ;333
000054  d305              BCC      |L23.98|
000056  8b60              LDRH     r0,[r4,#0x1a]         ;337
000058  f0400080          ORR      r0,r0,#0x80           ;337
00005c  8360              STRH     r0,[r4,#0x1a]         ;337
00005e  4608              MOV      r0,r1                 ;338
000060  bd70              POP      {r4-r6,pc}
                  |L23.98|
000062  2800              CMP      r0,#0                 ;340
000064  d00d              BEQ      |L23.130|
000066  6f20              LDR      r0,[r4,#0x70]         ;341
000068  2800              CMP      r0,#0                 ;341
00006a  d115              BNE      |L23.152|
00006c  6ee0              LDR      r0,[r4,#0x6c]         ;341
00006e  2800              CMP      r0,#0                 ;341
000070  d112              BNE      |L23.152|
000072  a30a              ADR      r3,|L23.156|
000074  f2401255          MOV      r2,#0x155             ;341
000078  a127              ADR      r1,|L23.280|
00007a  a01d              ADR      r0,|L23.240|
00007c  f7fffffe          BL       __2printf
000080  e00a              B        |L23.152|
                  |L23.130|
000082  6f20              LDR      r0,[r4,#0x70]         ;344
000084  b908              CBNZ     r0,|L23.138|
000086  6ee0              LDR      r0,[r4,#0x6c]         ;344
000088  b130              CBZ      r0,|L23.152|
                  |L23.138|
00008a  a304              ADR      r3,|L23.156|
00008c  f44f72ac          MOV      r2,#0x158             ;344
000090  a130              ADR      r1,|L23.340|
000092  a017              ADR      r0,|L23.240|
000094  f7fffffe          BL       __2printf
                  |L23.152|
000098  2000              MOVS     r0,#0                 ;347
00009a  bd70              POP      {r4-r6,pc}
;;;349    
                          ENDP

                  |L23.156|
00009c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
0000a0  6964646c
0000a4  65776172
0000a8  65735c54
0000ac  68697264
0000b0  5f506172
0000b4  74795c4c
0000b8  7749505c
0000bc  7372635c
0000c0  636f7265
0000c4  5c746370
0000c8  5f6f7574
0000cc  2e      
0000cd  6300              DCB      "c",0
0000cf  00                DCB      0
                  |L23.208|
0000d0  7463705f          DCB      "tcp_write_checks: invalid pcb",0
0000d4  77726974
0000d8  655f6368
0000dc  65636b73
0000e0  3a20696e
0000e4  76616c69
0000e8  64207063
0000ec  6200    
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L23.240|
0000f0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000f4  7274696f
0000f8  6e202225
0000fc  73222066
000100  61696c65
000104  64206174
000108  206c696e
00010c  65202564
000110  20696e20
000114  25730a00
                  |L23.280|
000118  7463705f          DCB      "tcp_write: pbufs on queue => at least one queue non-emp"
00011c  77726974
000120  653a2070
000124  62756673
000128  206f6e20
00012c  71756575
000130  65203d3e
000134  20617420
000138  6c656173
00013c  74206f6e
000140  65207175
000144  65756520
000148  6e6f6e2d
00014c  656d70  
00014f  747900            DCB      "ty",0
000152  00                DCB      0
000153  00                DCB      0
                  |L23.340|
000154  7463705f          DCB      "tcp_write: no pbufs on queue => both queues empty",0
000158  77726974
00015c  653a206e
000160  6f207062
000164  75667320
000168  6f6e2071
00016c  75657565
000170  203d3e20
000174  626f7468
000178  20717565
00017c  75657320
000180  656d7074
000184  7900    
000186  00                DCB      0
000187  00                DCB      0

                          AREA ||i.tcp_zero_window_probe||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_zero_window_probe PROC
;;;2115   err_t
;;;2116   tcp_zero_window_probe(struct tcp_pcb *pcb)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2117   {
000004  4605              MOV      r5,r0
;;;2118     err_t err;
;;;2119     struct pbuf *p;
;;;2120     struct tcp_hdr *tcphdr;
;;;2121     struct tcp_seg *seg;
;;;2122     u16_t len;
;;;2123     u8_t is_fin;
;;;2124     u32_t snd_nxt;
;;;2125     u8_t optlen = LWIP_TCP_OPT_LENGTH_SEGMENT(0, pcb);
000006  f04f0900          MOV      r9,#0
;;;2126   
;;;2127     LWIP_ASSERT("tcp_zero_window_probe: invalid pcb", pcb != NULL);
00000a  2d00              CMP      r5,#0
00000c  d106              BNE      |L24.28|
00000e  a330              ADR      r3,|L24.208|
000010  f640024f          MOV      r2,#0x84f
000014  a13b              ADR      r1,|L24.260|
000016  a044              ADR      r0,|L24.296|
000018  f7fffffe          BL       __2printf
                  |L24.28|
;;;2128   
;;;2129     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: sending ZERO WINDOW probe to "));
;;;2130     ip_addr_debug_print_val(TCP_DEBUG, pcb->remote_ip);
;;;2131     LWIP_DEBUGF(TCP_DEBUG, ("\n"));
;;;2132   
;;;2133     LWIP_DEBUGF(TCP_DEBUG,
;;;2134                 ("tcp_zero_window_probe: tcp_ticks %"U32_F
;;;2135                  "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n",
;;;2136                  tcp_ticks, pcb->tmr, (u16_t)pcb->keep_cnt_sent));
;;;2137   
;;;2138     /* Only consider unsent, persist timer should be off when there is data in-flight */
;;;2139     seg = pcb->unsent;
00001c  6eec              LDR      r4,[r5,#0x6c]
;;;2140     if (seg == NULL) {
00001e  b354              CBZ      r4,|L24.118|
;;;2141       /* Not expected, persist timer should be off when the send buffer is empty */
;;;2142       return ERR_OK;
;;;2143     }
;;;2144   
;;;2145     /* increment probe count. NOTE: we record probe even if it fails
;;;2146        to actually transmit due to an error. This ensures memory exhaustion/
;;;2147        routing problem doesn't leave a zero-window pcb as an indefinite zombie.
;;;2148        RTO mechanism has similar behavior, see pcb->nrtx */
;;;2149     if (pcb->persist_probe < 0xFF) {
000020  f895009a          LDRB     r0,[r5,#0x9a]
000024  28ff              CMP      r0,#0xff
000026  d202              BCS      |L24.46|
;;;2150       ++pcb->persist_probe;
000028  1c40              ADDS     r0,r0,#1
00002a  f885009a          STRB     r0,[r5,#0x9a]
                  |L24.46|
;;;2151     }
;;;2152   
;;;2153     is_fin = ((TCPH_FLAGS(seg->tcphdr) & TCP_FIN) != 0) && (seg->len == 0);
00002e  68e0              LDR      r0,[r4,#0xc]
000030  8980              LDRH     r0,[r0,#0xc]
000032  f7fffffe          BL       lwip_htons
000036  07c0              LSLS     r0,r0,#31
000038  d001              BEQ      |L24.62|
00003a  8920              LDRH     r0,[r4,#8]
00003c  b1f0              CBZ      r0,|L24.124|
                  |L24.62|
00003e  f04f0800          MOV      r8,#0
                  |L24.66|
;;;2154     /* we want to send one seqno: either FIN or data (no options) */
;;;2155     len = is_fin ? 0 : 1;
000042  f1b80f00          CMP      r8,#0
000046  d01c              BEQ      |L24.130|
000048  2200              MOVS     r2,#0
                  |L24.74|
;;;2156   
;;;2157     p = tcp_output_alloc_header(pcb, optlen, len, seg->tcphdr->seqno);
00004a  68e0              LDR      r0,[r4,#0xc]
00004c  4649              MOV      r1,r9
00004e  6843              LDR      r3,[r0,#4]
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       tcp_output_alloc_header
000056  4607              MOV      r7,r0
;;;2158     if (p == NULL) {
000058  0038              MOVS     r0,r7
00005a  d014              BEQ      |L24.134|
;;;2159       LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
;;;2160       return ERR_MEM;
;;;2161     }
;;;2162     tcphdr = (struct tcp_hdr *)p->payload;
00005c  687e              LDR      r6,[r7,#4]
;;;2163   
;;;2164     if (is_fin) {
00005e  f1b80f00          CMP      r8,#0
000062  d013              BEQ      |L24.140|
;;;2165       /* FIN segment, no data */
;;;2166       TCPH_FLAGS_SET(tcphdr, TCP_ACK | TCP_FIN);
000064  2011              MOVS     r0,#0x11
000066  f7fffffe          BL       lwip_htons
00006a  89b1              LDRH     r1,[r6,#0xc]
00006c  f421517c          BIC      r1,r1,#0x3f00
000070  4308              ORRS     r0,r0,r1
000072  81b0              STRH     r0,[r6,#0xc]
000074  e014              B        |L24.160|
                  |L24.118|
000076  2000              MOVS     r0,#0                 ;2142
                  |L24.120|
;;;2167     } else {
;;;2168       /* Data segment, copy in one byte from the head of the unacked queue */
;;;2169       char *d = ((char *)p->payload + TCP_HLEN);
;;;2170       /* Depending on whether the segment has already been sent (unacked) or not
;;;2171          (unsent), seg->p->payload points to the IP header or TCP header.
;;;2172          Ensure we copy the first TCP data byte: */
;;;2173       pbuf_copy_partial(seg->p, d, 1, seg->p->tot_len - seg->len);
;;;2174     }
;;;2175   
;;;2176     /* The byte may be acknowledged without the window being opened. */
;;;2177     snd_nxt = lwip_ntohl(seg->tcphdr->seqno) + 1;
;;;2178     if (TCP_SEQ_LT(pcb->snd_nxt, snd_nxt)) {
;;;2179       pcb->snd_nxt = snd_nxt;
;;;2180     }
;;;2181     tcp_output_fill_options(pcb, p, 0, optlen);
;;;2182   
;;;2183     err = tcp_output_control_segment(pcb, p, &pcb->local_ip, &pcb->remote_ip);
;;;2184   
;;;2185     LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
;;;2186                             " ackno %"U32_F" err %d.\n",
;;;2187                             pcb->snd_nxt - 1, pcb->rcv_nxt, (int)err));
;;;2188     return err;
;;;2189   }
000078  e8bd87f0          POP      {r4-r10,pc}
                  |L24.124|
00007c  f04f0801          MOV      r8,#1                 ;2153
000080  e7df              B        |L24.66|
                  |L24.130|
000082  2201              MOVS     r2,#1                 ;2155
000084  e7e1              B        |L24.74|
                  |L24.134|
000086  f04f30ff          MOV      r0,#0xffffffff        ;2160
00008a  e7f5              B        |L24.120|
                  |L24.140|
00008c  f1060114          ADD      r1,r6,#0x14           ;2169
000090  6860              LDR      r0,[r4,#4]            ;2173
000092  8923              LDRH     r3,[r4,#8]            ;2173
000094  8902              LDRH     r2,[r0,#8]            ;2173
000096  1ad2              SUBS     r2,r2,r3              ;2173
000098  b293              UXTH     r3,r2                 ;2173
00009a  2201              MOVS     r2,#1                 ;2173
00009c  f7fffffe          BL       pbuf_copy_partial
                  |L24.160|
0000a0  68e0              LDR      r0,[r4,#0xc]          ;2177
0000a2  6840              LDR      r0,[r0,#4]            ;2177
0000a4  f7fffffe          BL       lwip_htonl
0000a8  1c40              ADDS     r0,r0,#1              ;2177
0000aa  6d29              LDR      r1,[r5,#0x50]         ;2178
0000ac  1a09              SUBS     r1,r1,r0              ;2178
0000ae  d500              BPL      |L24.178|
0000b0  6528              STR      r0,[r5,#0x50]         ;2179
                  |L24.178|
0000b2  464b              MOV      r3,r9                 ;2181
0000b4  2200              MOVS     r2,#0                 ;2181
0000b6  4639              MOV      r1,r7                 ;2181
0000b8  4628              MOV      r0,r5                 ;2181
0000ba  f7fffffe          BL       tcp_output_fill_options
0000be  1d2b              ADDS     r3,r5,#4              ;2183
0000c0  462a              MOV      r2,r5                 ;2183
0000c2  4639              MOV      r1,r7                 ;2183
0000c4  4628              MOV      r0,r5                 ;2183
0000c6  e8bd47f0          POP      {r4-r10,lr}           ;2183
0000ca  f7ffbffe          B.W      tcp_output_control_segment
;;;2190   #endif /* LWIP_TCP */
                          ENDP

0000ce  0000              DCW      0x0000
                  |L24.208|
0000d0  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out."
0000d4  6964646c
0000d8  65776172
0000dc  65735c54
0000e0  68697264
0000e4  5f506172
0000e8  74795c4c
0000ec  7749505c
0000f0  7372635c
0000f4  636f7265
0000f8  5c746370
0000fc  5f6f7574
000100  2e      
000101  6300              DCB      "c",0
000103  00                DCB      0
                  |L24.260|
000104  7463705f          DCB      "tcp_zero_window_probe: invalid pcb",0
000108  7a65726f
00010c  5f77696e
000110  646f775f
000114  70726f62
000118  653a2069
00011c  6e76616c
000120  69642070
000124  636200  
000127  00                DCB      0
                  |L24.296|
000128  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00012c  7274696f
000130  6e202225
000134  73222066
000138  61696c65
00013c  64206174
000140  206c696e
000144  65202564
000148  20696e20
00014c  25730a00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  7463705f          DCB      "tcp_enqueue_flags: need either TCP_SYN or TCP_FIN in fl"
000004  656e7175
000008  6575655f
00000c  666c6167
000010  733a206e
000014  65656420
000018  65697468
00001c  65722054
000020  43505f53
000024  594e206f
000028  72205443
00002c  505f4649
000030  4e20696e
000034  20666c  
000037  61677320          DCB      "ags (programmer violates API)",0
00003b  2870726f
00003f  6772616d
000043  6d657220
000047  76696f6c
00004b  61746573
00004f  20415049
000053  2900    

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_out.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_tcp_out_c_bfdbc664____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___9_tcp_out_c_bfdbc664____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_tcp_out_c_bfdbc664____REVSH|
#line 478
|__asm___9_tcp_out_c_bfdbc664____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_tcp_out_c_bfdbc664____RRX|
#line 665
|__asm___9_tcp_out_c_bfdbc664____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
