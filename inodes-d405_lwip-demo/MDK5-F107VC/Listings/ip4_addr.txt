; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ip4_addr.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ip4_addr.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\ip4_addr.crf ..\Middlewares\Third_Party\LwIP\src\core\ipv4\ip4_addr.c]
                          THUMB

                          AREA ||i.ip4_addr_isbroadcast_u32||, CODE, READONLY, ALIGN=1

                  ip4_addr_isbroadcast_u32 PROC
;;;57     u8_t
;;;58     ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif)
000000  b508              PUSH     {r3,lr}
;;;59     {
;;;60       ip4_addr_t ipaddr;
;;;61       ip4_addr_set_u32(&ipaddr, addr);
000002  9000              STR      r0,[sp,#0]
;;;62     
;;;63       /* all ones (broadcast) or all zeroes (old skool broadcast) */
;;;64       if ((~addr == IPADDR_ANY) ||
000004  1c42              ADDS     r2,r0,#1
000006  d007              BEQ      |L1.24|
;;;65           (addr == IPADDR_ANY)) {
000008  0002              MOVS     r2,r0
00000a  d005              BEQ      |L1.24|
;;;66         return 1;
;;;67         /* no broadcast support on this network interface? */
;;;68       } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
00000c  f8912035          LDRB     r2,[r1,#0x35]
000010  0792              LSLS     r2,r2,#30
000012  d403              BMI      |L1.28|
;;;69         /* the given address cannot be a broadcast address
;;;70          * nor can we check against any broadcast addresses */
;;;71         return 0;
000014  2000              MOVS     r0,#0
;;;72         /* address matches network interface address exactly? => no broadcast */
;;;73       } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
;;;74         return 0;
;;;75         /*  on the same (sub) network... */
;;;76       } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
;;;77                  /* ...and host identifier bits are all ones? =>... */
;;;78                  && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
;;;79                      (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
;;;80         /* => network broadcast address */
;;;81         return 1;
;;;82       } else {
;;;83         return 0;
;;;84       }
;;;85     }
000016  bd08              POP      {r3,pc}
                  |L1.24|
000018  2001              MOVS     r0,#1                 ;66
00001a  bd08              POP      {r3,pc}
                  |L1.28|
00001c  684a              LDR      r2,[r1,#4]            ;73
00001e  4282              CMP      r2,r0                 ;73
000020  d101              BNE      |L1.38|
000022  2000              MOVS     r0,#0                 ;74
000024  bd08              POP      {r3,pc}
                  |L1.38|
000026  6889              LDR      r1,[r1,#8]            ;76
000028  ea000301          AND      r3,r0,r1              ;76
00002c  400a              ANDS     r2,r2,r1              ;76
00002e  4293              CMP      r3,r2                 ;76
000030  d102              BNE      |L1.56|
000032  4301              ORRS     r1,r1,r0              ;78
000034  1c49              ADDS     r1,r1,#1              ;78
000036  d001              BEQ      |L1.60|
                  |L1.56|
000038  2000              MOVS     r0,#0                 ;83
00003a  bd08              POP      {r3,pc}
                  |L1.60|
00003c  2001              MOVS     r0,#1                 ;81
00003e  bd08              POP      {r3,pc}
;;;86     
                          ENDP


                          AREA ||i.ip4_addr_netmask_valid||, CODE, READONLY, ALIGN=1

                  ip4_addr_netmask_valid PROC
;;;92     u8_t
;;;93     ip4_addr_netmask_valid(u32_t netmask)
000000  b510              PUSH     {r4,lr}
;;;94     {
;;;95       u32_t mask;
;;;96       u32_t nm_hostorder = lwip_htonl(netmask);
000002  f7fffffe          BL       lwip_htonl
;;;97     
;;;98       /* first, check for the first zero */
;;;99       for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
000006  f04f4100          MOV      r1,#0x80000000
                  |L2.10|
;;;100        if ((nm_hostorder & mask) == 0) {
00000a  4208              TST      r0,r1
00000c  d008              BEQ      |L2.32|
00000e  0849              LSRS     r1,r1,#1              ;99
000010  2900              CMP      r1,#0                 ;99
000012  d1fa              BNE      |L2.10|
000014  e004              B        |L2.32|
                  |L2.22|
;;;101          break;
;;;102        }
;;;103      }
;;;104      /* then check that there is no one */
;;;105      for (; mask != 0; mask >>= 1) {
;;;106        if ((nm_hostorder & mask) != 0) {
000016  4208              TST      r0,r1
000018  d001              BEQ      |L2.30|
;;;107          /* there is a one after the first zero -> invalid */
;;;108          return 0;
00001a  2000              MOVS     r0,#0
;;;109        }
;;;110      }
;;;111      /* no one after the first zero -> valid */
;;;112      return 1;
;;;113    }
00001c  bd10              POP      {r4,pc}
                  |L2.30|
00001e  0849              LSRS     r1,r1,#1              ;105
                  |L2.32|
000020  2900              CMP      r1,#0                 ;105
000022  d1f8              BNE      |L2.22|
000024  2001              MOVS     r0,#1                 ;112
000026  bd10              POP      {r4,pc}
;;;114    
                          ENDP


                          AREA ||i.ip4addr_aton||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  ip4addr_aton PROC
;;;144    int
;;;145    ip4addr_aton(const char *cp, ip4_addr_t *addr)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;146    {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;147      u32_t val;
;;;148      u8_t base;
;;;149      char c;
;;;150      u32_t parts[4];
;;;151      u32_t *pp = parts;
000008  466f              MOV      r7,sp
;;;152    
;;;153      c = *cp;
00000a  7834              LDRB     r4,[r6,#0]
;;;154      for (;;) {
;;;155        /*
;;;156         * Collect number up to ``.''.
;;;157         * Values are specified as for C:
;;;158         * 0x=hex, 0=octal, 1-9=decimal.
;;;159         */
;;;160        if (!lwip_isdigit(c)) {
00000c  f7fffffe          BL       __rt_ctype_table
000010  4684              MOV      r12,r0
                  |L3.18|
000012  f8dc3000          LDR      r3,[r12,#0]
000016  5d18              LDRB     r0,[r3,r4]
000018  2820              CMP      r0,#0x20
00001a  d003              BEQ      |L3.36|
;;;161          return 0;
00001c  2000              MOVS     r0,#0
                  |L3.30|
;;;162        }
;;;163        val = 0;
;;;164        base = 10;
;;;165        if (c == '0') {
;;;166          c = *++cp;
;;;167          if (c == 'x' || c == 'X') {
;;;168            base = 16;
;;;169            c = *++cp;
;;;170          } else {
;;;171            base = 8;
;;;172          }
;;;173        }
;;;174        for (;;) {
;;;175          if (lwip_isdigit(c)) {
;;;176            val = (val * base) + (u32_t)(c - '0');
;;;177            c = *++cp;
;;;178          } else if (base == 16 && lwip_isxdigit(c)) {
;;;179            val = (val << 4) | (u32_t)(c + 10 - (lwip_islower(c) ? 'a' : 'A'));
;;;180            c = *++cp;
;;;181          } else {
;;;182            break;
;;;183          }
;;;184        }
;;;185        if (c == '.') {
;;;186          /*
;;;187           * Internet format:
;;;188           *  a.b.c.d
;;;189           *  a.b.c   (with c treated as 16 bits)
;;;190           *  a.b (with b treated as 24 bits)
;;;191           */
;;;192          if (pp >= parts + 3) {
;;;193            return 0;
;;;194          }
;;;195          *pp++ = val;
;;;196          c = *++cp;
;;;197        } else {
;;;198          break;
;;;199        }
;;;200      }
;;;201      /*
;;;202       * Check for trailing characters.
;;;203       */
;;;204      if (c != '\0' && !lwip_isspace(c)) {
;;;205        return 0;
;;;206      }
;;;207      /*
;;;208       * Concoct the address according to
;;;209       * the number of parts specified.
;;;210       */
;;;211      switch (pp - parts + 1) {
;;;212    
;;;213        case 0:
;;;214          return 0;       /* initial nondigit */
;;;215    
;;;216        case 1:             /* a -- 32 bits */
;;;217          break;
;;;218    
;;;219        case 2:             /* a.b -- 8.24 bits */
;;;220          if (val > 0xffffffUL) {
;;;221            return 0;
;;;222          }
;;;223          if (parts[0] > 0xff) {
;;;224            return 0;
;;;225          }
;;;226          val |= parts[0] << 24;
;;;227          break;
;;;228    
;;;229        case 3:             /* a.b.c -- 8.8.16 bits */
;;;230          if (val > 0xffff) {
;;;231            return 0;
;;;232          }
;;;233          if ((parts[0] > 0xff) || (parts[1] > 0xff)) {
;;;234            return 0;
;;;235          }
;;;236          val |= (parts[0] << 24) | (parts[1] << 16);
;;;237          break;
;;;238    
;;;239        case 4:             /* a.b.c.d -- 8.8.8.8 bits */
;;;240          if (val > 0xff) {
;;;241            return 0;
;;;242          }
;;;243          if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {
;;;244            return 0;
;;;245          }
;;;246          val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
;;;247          break;
;;;248        default:
;;;249          LWIP_ASSERT("unhandled", 0);
;;;250          break;
;;;251      }
;;;252      if (addr) {
;;;253        ip4_addr_set_u32(addr, lwip_htonl(val));
;;;254      }
;;;255      return 1;
;;;256    }
00001e  b004              ADD      sp,sp,#0x10
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L3.36|
000024  2500              MOVS     r5,#0                 ;163
000026  200a              MOVS     r0,#0xa               ;164
000028  2c30              CMP      r4,#0x30              ;165
00002a  d106              BNE      |L3.58|
00002c  f8164f01          LDRB     r4,[r6,#1]!           ;166
000030  2c78              CMP      r4,#0x78              ;167
000032  d008              BEQ      |L3.70|
000034  2c58              CMP      r4,#0x58              ;167
000036  d006              BEQ      |L3.70|
000038  2008              MOVS     r0,#8                 ;171
                  |L3.58|
00003a  5d1a              LDRB     r2,[r3,r4]            ;175
00003c  2a20              CMP      r2,#0x20              ;175
00003e  d006              BEQ      |L3.78|
000040  2810              CMP      r0,#0x10              ;178
000042  d00a              BEQ      |L3.90|
000044  e019              B        |L3.122|
                  |L3.70|
000046  2010              MOVS     r0,#0x10              ;168
000048  f8164f01          LDRB     r4,[r6,#1]!           ;169
00004c  e7f5              B        |L3.58|
                  |L3.78|
00004e  3c30              SUBS     r4,r4,#0x30           ;176
000050  fb054500          MLA      r5,r5,r0,r4           ;176
000054  f8164f01          LDRB     r4,[r6,#1]!           ;177
000058  e7ef              B        |L3.58|
                  |L3.90|
00005a  ea820182          EOR      r1,r2,r2,LSL #2       ;177
00005e  0609              LSLS     r1,r1,#24             ;178
000060  d50b              BPL      |L3.122|
000062  0711              LSLS     r1,r2,#28             ;179
000064  d501              BPL      |L3.106|
000066  2161              MOVS     r1,#0x61              ;179
000068  e000              B        |L3.108|
                  |L3.106|
00006a  2141              MOVS     r1,#0x41              ;179
                  |L3.108|
00006c  1a61              SUBS     r1,r4,r1              ;179
00006e  310a              ADDS     r1,r1,#0xa            ;179
000070  ea411505          ORR      r5,r1,r5,LSL #4       ;179
000074  f8164f01          LDRB     r4,[r6,#1]!           ;180
000078  e7df              B        |L3.58|
                  |L3.122|
00007a  2c2e              CMP      r4,#0x2e              ;185
00007c  d011              BEQ      |L3.162|
00007e  b124              CBZ      r4,|L3.138|
000080  f8dc0000          LDR      r0,[r12,#0]           ;204
000084  5d00              LDRB     r0,[r0,r4]            ;204
000086  07c0              LSLS     r0,r0,#31             ;204
000088  d014              BEQ      |L3.180|
                  |L3.138|
00008a  4668              MOV      r0,sp                 ;211
00008c  1a38              SUBS     r0,r7,r0              ;211
00008e  2101              MOVS     r1,#1                 ;211
000090  eb0100a0          ADD      r0,r1,r0,ASR #2       ;211
000094  2805              CMP      r0,#5                 ;211
000096  d24c              BCS      |L3.306|
000098  e8dff000          TBB      [pc,r0]               ;211
00009c  0e51101e          DCB      0x0e,0x51,0x10,0x1e
0000a0  3200              DCB      0x32,0x00
                  |L3.162|
0000a2  a803              ADD      r0,sp,#0xc            ;192
0000a4  4287              CMP      r7,r0                 ;192
0000a6  d301              BCC      |L3.172|
0000a8  2000              MOVS     r0,#0                 ;193
0000aa  e7b8              B        |L3.30|
                  |L3.172|
0000ac  c720              STM      r7!,{r5}              ;195
0000ae  f8164f01          LDRB     r4,[r6,#1]!           ;196
0000b2  e7ae              B        |L3.18|
                  |L3.180|
0000b4  2000              MOVS     r0,#0                 ;205
0000b6  e7b2              B        |L3.30|
0000b8  2000              MOVS     r0,#0                 ;214
0000ba  e7b0              B        |L3.30|
0000bc  f1b57f80          CMP      r5,#0x1000000         ;220
0000c0  d301              BCC      |L3.198|
0000c2  2000              MOVS     r0,#0                 ;221
0000c4  e7ab              B        |L3.30|
                  |L3.198|
0000c6  9800              LDR      r0,[sp,#0]            ;223
0000c8  28ff              CMP      r0,#0xff              ;223
0000ca  d901              BLS      |L3.208|
0000cc  2000              MOVS     r0,#0                 ;224
0000ce  e7a6              B        |L3.30|
                  |L3.208|
0000d0  9800              LDR      r0,[sp,#0]            ;226
0000d2  ea456500          ORR      r5,r5,r0,LSL #24      ;226
0000d6  e032              B        |L3.318|
0000d8  f5b53f80          CMP      r5,#0x10000           ;230
0000dc  d301              BCC      |L3.226|
0000de  2000              MOVS     r0,#0                 ;231
0000e0  e79d              B        |L3.30|
                  |L3.226|
0000e2  9800              LDR      r0,[sp,#0]            ;233
0000e4  28ff              CMP      r0,#0xff              ;233
0000e6  d802              BHI      |L3.238|
0000e8  9801              LDR      r0,[sp,#4]            ;233
0000ea  28ff              CMP      r0,#0xff              ;233
0000ec  d901              BLS      |L3.242|
                  |L3.238|
0000ee  2000              MOVS     r0,#0                 ;234
0000f0  e795              B        |L3.30|
                  |L3.242|
0000f2  9800              LDR      r0,[sp,#0]            ;236
0000f4  9901              LDR      r1,[sp,#4]            ;236
0000f6  0600              LSLS     r0,r0,#24             ;236
0000f8  ea404001          ORR      r0,r0,r1,LSL #16      ;236
0000fc  4305              ORRS     r5,r5,r0              ;236
0000fe  e01e              B        |L3.318|
000100  2dff              CMP      r5,#0xff              ;240
000102  d901              BLS      |L3.264|
000104  2000              MOVS     r0,#0                 ;241
000106  e78a              B        |L3.30|
                  |L3.264|
000108  9800              LDR      r0,[sp,#0]            ;243
00010a  28ff              CMP      r0,#0xff              ;243
00010c  d805              BHI      |L3.282|
00010e  9801              LDR      r0,[sp,#4]            ;243
000110  28ff              CMP      r0,#0xff              ;243
000112  d802              BHI      |L3.282|
000114  9802              LDR      r0,[sp,#8]            ;243
000116  28ff              CMP      r0,#0xff              ;243
000118  d901              BLS      |L3.286|
                  |L3.282|
00011a  2000              MOVS     r0,#0                 ;244
00011c  e77f              B        |L3.30|
                  |L3.286|
00011e  9800              LDR      r0,[sp,#0]            ;246
000120  9901              LDR      r1,[sp,#4]            ;246
000122  0600              LSLS     r0,r0,#24             ;246
000124  ea404001          ORR      r0,r0,r1,LSL #16      ;246
000128  9902              LDR      r1,[sp,#8]            ;246
00012a  ea402001          ORR      r0,r0,r1,LSL #8       ;246
00012e  4305              ORRS     r5,r5,r0              ;246
000130  e005              B        |L3.318|
                  |L3.306|
000132  a308              ADR      r3,|L3.340|
000134  22f9              MOVS     r2,#0xf9              ;249
000136  a116              ADR      r1,|L3.400|
000138  a018              ADR      r0,|L3.412|
00013a  f7fffffe          BL       __2printf
                  |L3.318|
00013e  f1b80f00          CMP      r8,#0                 ;252
000142  d004              BEQ      |L3.334|
000144  4628              MOV      r0,r5                 ;253
000146  f7fffffe          BL       lwip_htonl
00014a  f8c80000          STR      r0,[r8,#0]            ;253
                  |L3.334|
00014e  2001              MOVS     r0,#1                 ;255
000150  e765              B        |L3.30|
;;;257    
                          ENDP

000152  0000              DCW      0x0000
                  |L3.340|
000154  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip"
000158  6964646c
00015c  65776172
000160  65735c54
000164  68697264
000168  5f506172
00016c  74795c4c
000170  7749505c
000174  7372635c
000178  636f7265
00017c  5c697076
000180  345c6970
000184  345f6164          DCB      "4_addr.c",0
000188  64722e63
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L3.400|
000190  756e6861          DCB      "unhandled",0
000194  6e646c65
000198  6400    
00019a  00                DCB      0
00019b  00                DCB      0
                  |L3.412|
00019c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001a0  7274696f
0001a4  6e202225
0001a8  73222066
0001ac  61696c65
0001b0  64206174
0001b4  206c696e
0001b8  65202564
0001bc  20696e20
0001c0  25730a00

                          AREA ||i.ip4addr_ntoa||, CODE, READONLY, ALIGN=2

                  ip4addr_ntoa PROC
;;;266    char *
;;;267    ip4addr_ntoa(const ip4_addr_t *addr)
000000  2210              MOVS     r2,#0x10
;;;268    {
;;;269      static char str[IP4ADDR_STRLEN_MAX];
;;;270      return ip4addr_ntoa_r(addr, str, IP4ADDR_STRLEN_MAX);
000002  4901              LDR      r1,|L4.8|
000004  f7ffbffe          B.W      ip4addr_ntoa_r
;;;271    }
;;;272    
                          ENDP

                  |L4.8|
                          DCD      ||.bss||

                          AREA ||i.ip4addr_ntoa_r||, CODE, READONLY, ALIGN=1

                  ip4addr_ntoa_r PROC
;;;282    char *
;;;283    ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;284    {
000004  4603              MOV      r3,r0
000006  4608              MOV      r0,r1
;;;285      u32_t s_addr;
;;;286      char inv[3];
;;;287      char *rp;
;;;288      u8_t *ap;
;;;289      u8_t rem;
;;;290      u8_t n;
;;;291      u8_t i;
;;;292      int len = 0;
000008  2500              MOVS     r5,#0
;;;293    
;;;294      s_addr = ip4_addr_get_u32(addr);
00000a  6819              LDR      r1,[r3,#0]
00000c  9101              STR      r1,[sp,#4]
;;;295    
;;;296      rp = buf;
00000e  4604              MOV      r4,r0
;;;297      ap = (u8_t *)&s_addr;
000010  af01              ADD      r7,sp,#4
;;;298      for (n = 0; n < 4; n++) {
000012  46ac              MOV      r12,r5
;;;299        i = 0;
;;;300        do {
;;;301          rem = *ap % (u8_t)10;
000014  f04f090a          MOV      r9,#0xa
000018  46ea              MOV      r10,sp                ;286
                  |L5.26|
00001a  2300              MOVS     r3,#0                 ;299
                  |L5.28|
00001c  783e              LDRB     r6,[r7,#0]
00001e  fbb6f8f9          UDIV     r8,r6,r9
000022  fb096818          MLS      r8,r9,r8,r6
;;;302          *ap /= (u8_t)10;
000026  fbb6f1f9          UDIV     r1,r6,r9
00002a  7039              STRB     r1,[r7,#0]
;;;303          inv[i++] = (char)('0' + rem);
00002c  461e              MOV      r6,r3
00002e  f1080830          ADD      r8,r8,#0x30
000032  1c5b              ADDS     r3,r3,#1
000034  b2db              UXTB     r3,r3
000036  f80a8006          STRB     r8,[r10,r6]
;;;304        } while (*ap);
00003a  2900              CMP      r1,#0
00003c  d1ee              BNE      |L5.28|
00003e  e00a              B        |L5.86|
                  |L5.64|
;;;305        while (i--) {
;;;306          if (len++ >= buflen) {
000040  4629              MOV      r1,r5
000042  1c6d              ADDS     r5,r5,#1
000044  4291              CMP      r1,r2
000046  db02              BLT      |L5.78|
;;;307            return NULL;
000048  2000              MOVS     r0,#0
                  |L5.74|
;;;308          }
;;;309          *rp++ = inv[i];
;;;310        }
;;;311        if (len++ >= buflen) {
;;;312          return NULL;
;;;313        }
;;;314        *rp++ = '.';
;;;315        ap++;
;;;316      }
;;;317      *--rp = 0;
;;;318      return buf;
;;;319    }
00004a  e8bd87fc          POP      {r2-r10,pc}
                  |L5.78|
00004e  f81a1003          LDRB     r1,[r10,r3]           ;309
000052  f8041b01          STRB     r1,[r4],#1            ;309
                  |L5.86|
000056  1e5b              SUBS     r3,r3,#1              ;305
000058  b2db              UXTB     r3,r3                 ;305
00005a  d2f1              BCS      |L5.64|
00005c  4629              MOV      r1,r5                 ;311
00005e  1c6d              ADDS     r5,r5,#1              ;311
000060  4291              CMP      r1,r2                 ;311
000062  db01              BLT      |L5.104|
000064  2000              MOVS     r0,#0                 ;312
000066  e7f0              B        |L5.74|
                  |L5.104|
000068  212e              MOVS     r1,#0x2e              ;314
00006a  f8041b01          STRB     r1,[r4],#1            ;314
00006e  1c7f              ADDS     r7,r7,#1              ;315
000070  f10c0c01          ADD      r12,r12,#1            ;298
000074  f00c0cff          AND      r12,r12,#0xff         ;298
000078  f1bc0f04          CMP      r12,#4                ;298
00007c  d3cd              BCC      |L5.26|
00007e  2100              MOVS     r1,#0                 ;317
000080  f8041c01          STRB     r1,[r4,#-1]           ;317
000084  e7e1              B        |L5.74|
;;;320    
                          ENDP


                          AREA ||i.ipaddr_addr||, CODE, READONLY, ALIGN=1

                  ipaddr_addr PROC
;;;122    u32_t
;;;123    ipaddr_addr(const char *cp)
000000  b508              PUSH     {r3,lr}
;;;124    {
;;;125      ip4_addr_t val;
;;;126    
;;;127      if (ip4addr_aton(cp, &val)) {
000002  4669              MOV      r1,sp
000004  f7fffffe          BL       ip4addr_aton
000008  b108              CBZ      r0,|L6.14|
;;;128        return ip4_addr_get_u32(&val);
00000a  9800              LDR      r0,[sp,#0]
;;;129      }
;;;130      return (IPADDR_NONE);
;;;131    }
00000c  bd08              POP      {r3,pc}
                  |L6.14|
00000e  f04f30ff          MOV      r0,#0xffffffff        ;130
000012  bd08              POP      {r3,pc}
;;;132    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ||str||
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  ip_addr_any
                          DCD      0x00000000

                          AREA ||area_number.11||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.constdata||
                  ip_addr_broadcast
                          DCD      0xffffffff

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip4_addr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_ip4_addr_c_60af150c____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_ip4_addr_c_60af150c____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_ip4_addr_c_60af150c____REVSH|
#line 478
|__asm___10_ip4_addr_c_60af150c____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_ip4_addr_c_60af150c____RRX|
#line 665
|__asm___10_ip4_addr_c_60af150c____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
