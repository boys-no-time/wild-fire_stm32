; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ip4_addr.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ip4_addr.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\ip4_addr.crf ..\Middlewares\Third_Party\LwIP\src\core\ipv4\ip4_addr.c]
                          THUMB

                          AREA ||i.ip4_addr_isbroadcast_u32||, CODE, READONLY, ALIGN=1

                  ip4_addr_isbroadcast_u32 PROC
;;;57     u8_t
;;;58     ip4_addr_isbroadcast_u32(u32_t addr, const struct netif *netif)
000000  b508              PUSH     {r3,lr}
;;;59     {
;;;60       ip4_addr_t ipaddr;
;;;61       ip4_addr_set_u32(&ipaddr, addr);
000002  9000              STR      r0,[sp,#0]
;;;62     
;;;63       /* all ones (broadcast) or all zeroes (old skool broadcast) */
;;;64       if ((~addr == IPADDR_ANY) ||
000004  1c42              ADDS     r2,r0,#1
000006  d007              BEQ      |L1.24|
;;;65           (addr == IPADDR_ANY)) {
000008  0002              MOVS     r2,r0
00000a  d005              BEQ      |L1.24|
;;;66         return 1;
;;;67       /* no broadcast support on this network interface? */
;;;68       } else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0) {
00000c  f8912037          LDRB     r2,[r1,#0x37]
000010  0792              LSLS     r2,r2,#30
000012  d403              BMI      |L1.28|
;;;69         /* the given address cannot be a broadcast address
;;;70          * nor can we check against any broadcast addresses */
;;;71         return 0;
000014  2000              MOVS     r0,#0
;;;72       /* address matches network interface address exactly? => no broadcast */
;;;73       } else if (addr == ip4_addr_get_u32(netif_ip4_addr(netif))) {
;;;74         return 0;
;;;75       /*  on the same (sub) network... */
;;;76       } else if (ip4_addr_netcmp(&ipaddr, netif_ip4_addr(netif), netif_ip4_netmask(netif))
;;;77              /* ...and host identifier bits are all ones? =>... */
;;;78               && ((addr & ~ip4_addr_get_u32(netif_ip4_netmask(netif))) ==
;;;79                (IPADDR_BROADCAST & ~ip4_addr_get_u32(netif_ip4_netmask(netif))))) {
;;;80         /* => network broadcast address */
;;;81         return 1;
;;;82       } else {
;;;83         return 0;
;;;84       }
;;;85     }
000016  bd08              POP      {r3,pc}
                  |L1.24|
000018  2001              MOVS     r0,#1                 ;66
00001a  bd08              POP      {r3,pc}
                  |L1.28|
00001c  684a              LDR      r2,[r1,#4]            ;73
00001e  4282              CMP      r2,r0                 ;73
000020  d101              BNE      |L1.38|
000022  2000              MOVS     r0,#0                 ;74
000024  bd08              POP      {r3,pc}
                  |L1.38|
000026  6889              LDR      r1,[r1,#8]            ;76
000028  ea000301          AND      r3,r0,r1              ;76
00002c  400a              ANDS     r2,r2,r1              ;76
00002e  4293              CMP      r3,r2                 ;76
000030  d102              BNE      |L1.56|
000032  4301              ORRS     r1,r1,r0              ;78
000034  1c49              ADDS     r1,r1,#1              ;78
000036  d001              BEQ      |L1.60|
                  |L1.56|
000038  2000              MOVS     r0,#0                 ;83
00003a  bd08              POP      {r3,pc}
                  |L1.60|
00003c  2001              MOVS     r0,#1                 ;81
00003e  bd08              POP      {r3,pc}
;;;86     
                          ENDP


                          AREA ||i.ip4_addr_netmask_valid||, CODE, READONLY, ALIGN=1

                  ip4_addr_netmask_valid PROC
;;;92     u8_t
;;;93     ip4_addr_netmask_valid(u32_t netmask)
000000  b510              PUSH     {r4,lr}
;;;94     {
;;;95       u32_t mask;
;;;96       u32_t nm_hostorder = lwip_htonl(netmask);
000002  f7fffffe          BL       lwip_htonl
;;;97     
;;;98       /* first, check for the first zero */
;;;99       for (mask = 1UL << 31 ; mask != 0; mask >>= 1) {
000006  f04f4100          MOV      r1,#0x80000000
                  |L2.10|
;;;100        if ((nm_hostorder & mask) == 0) {
00000a  4208              TST      r0,r1
00000c  d008              BEQ      |L2.32|
00000e  0849              LSRS     r1,r1,#1              ;99
000010  2900              CMP      r1,#0                 ;99
000012  d1fa              BNE      |L2.10|
000014  e004              B        |L2.32|
                  |L2.22|
;;;101          break;
;;;102        }
;;;103      }
;;;104      /* then check that there is no one */
;;;105      for (; mask != 0; mask >>= 1) {
;;;106        if ((nm_hostorder & mask) != 0) {
000016  4208              TST      r0,r1
000018  d001              BEQ      |L2.30|
;;;107          /* there is a one after the first zero -> invalid */
;;;108          return 0;
00001a  2000              MOVS     r0,#0
;;;109        }
;;;110      }
;;;111      /* no one after the first zero -> valid */
;;;112      return 1;
;;;113    }
00001c  bd10              POP      {r4,pc}
                  |L2.30|
00001e  0849              LSRS     r1,r1,#1              ;105
                  |L2.32|
000020  2900              CMP      r1,#0                 ;105
000022  d1f8              BNE      |L2.22|
000024  2001              MOVS     r0,#1                 ;112
000026  bd10              POP      {r4,pc}
;;;114    
                          ENDP


                          AREA ||i.ip4addr_aton||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  ip4addr_aton PROC
;;;154    int
;;;155    ip4addr_aton(const char *cp, ip4_addr_t *addr)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;156    {
000004  460f              MOV      r7,r1
;;;157      u32_t val;
;;;158      u8_t base;
;;;159      char c;
;;;160      u32_t parts[4];
;;;161      u32_t *pp = parts;
000006  466d              MOV      r5,sp
;;;162    
;;;163      c = *cp;
000008  7802              LDRB     r2,[r0,#0]
                  |L3.10|
;;;164      for (;;) {
;;;165        /*
;;;166         * Collect number up to ``.''.
;;;167         * Values are specified as for C:
;;;168         * 0x=hex, 0=octal, 1-9=decimal.
;;;169         */
;;;170        if (!isdigit(c)) {
00000a  f1a20130          SUB      r1,r2,#0x30
00000e  290a              CMP      r1,#0xa
000010  d303              BCC      |L3.26|
;;;171          return 0;
000012  2000              MOVS     r0,#0
                  |L3.20|
;;;172        }
;;;173        val = 0;
;;;174        base = 10;
;;;175        if (c == '0') {
;;;176          c = *++cp;
;;;177          if (c == 'x' || c == 'X') {
;;;178            base = 16;
;;;179            c = *++cp;
;;;180          } else {
;;;181            base = 8;
;;;182          }
;;;183        }
;;;184        for (;;) {
;;;185          if (isdigit(c)) {
;;;186            val = (val * base) + (u32_t)(c - '0');
;;;187            c = *++cp;
;;;188          } else if (base == 16 && isxdigit(c)) {
;;;189            val = (val << 4) | (u32_t)(c + 10 - (islower(c) ? 'a' : 'A'));
;;;190            c = *++cp;
;;;191          } else {
;;;192            break;
;;;193          }
;;;194        }
;;;195        if (c == '.') {
;;;196          /*
;;;197           * Internet format:
;;;198           *  a.b.c.d
;;;199           *  a.b.c   (with c treated as 16 bits)
;;;200           *  a.b (with b treated as 24 bits)
;;;201           */
;;;202          if (pp >= parts + 3) {
;;;203            return 0;
;;;204          }
;;;205          *pp++ = val;
;;;206          c = *++cp;
;;;207        } else {
;;;208          break;
;;;209        }
;;;210      }
;;;211      /*
;;;212       * Check for trailing characters.
;;;213       */
;;;214      if (c != '\0' && !isspace(c)) {
;;;215        return 0;
;;;216      }
;;;217      /*
;;;218       * Concoct the address according to
;;;219       * the number of parts specified.
;;;220       */
;;;221      switch (pp - parts + 1) {
;;;222    
;;;223      case 0:
;;;224        return 0;       /* initial nondigit */
;;;225    
;;;226      case 1:             /* a -- 32 bits */
;;;227        break;
;;;228    
;;;229      case 2:             /* a.b -- 8.24 bits */
;;;230        if (val > 0xffffffUL) {
;;;231          return 0;
;;;232        }
;;;233        if (parts[0] > 0xff) {
;;;234          return 0;
;;;235        }
;;;236        val |= parts[0] << 24;
;;;237        break;
;;;238    
;;;239      case 3:             /* a.b.c -- 8.8.16 bits */
;;;240        if (val > 0xffff) {
;;;241          return 0;
;;;242        }
;;;243        if ((parts[0] > 0xff) || (parts[1] > 0xff)) {
;;;244          return 0;
;;;245        }
;;;246        val |= (parts[0] << 24) | (parts[1] << 16);
;;;247        break;
;;;248    
;;;249      case 4:             /* a.b.c.d -- 8.8.8.8 bits */
;;;250        if (val > 0xff) {
;;;251          return 0;
;;;252        }
;;;253        if ((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff)) {
;;;254          return 0;
;;;255        }
;;;256        val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
;;;257        break;
;;;258      default:
;;;259        LWIP_ASSERT("unhandled", 0);
;;;260        break;
;;;261      }
;;;262      if (addr) {
;;;263        ip4_addr_set_u32(addr, lwip_htonl(val));
;;;264      }
;;;265      return 1;
;;;266    }
000014  b004              ADD      sp,sp,#0x10
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L3.26|
00001a  2400              MOVS     r4,#0                 ;173
00001c  230a              MOVS     r3,#0xa               ;174
00001e  2a30              CMP      r2,#0x30              ;175
000020  d106              BNE      |L3.48|
000022  f8102f01          LDRB     r2,[r0,#1]!           ;176
000026  2a78              CMP      r2,#0x78              ;177
000028  d00b              BEQ      |L3.66|
00002a  2a58              CMP      r2,#0x58              ;177
00002c  d009              BEQ      |L3.66|
00002e  2308              MOVS     r3,#8                 ;181
                  |L3.48|
000030  f1a20630          SUB      r6,r2,#0x30           ;185
000034  2e09              CMP      r6,#9                 ;185
000036  d808              BHI      |L3.74|
000038  fb046403          MLA      r4,r4,r3,r6           ;186
00003c  f8102f01          LDRB     r2,[r0,#1]!           ;187
000040  e7f6              B        |L3.48|
                  |L3.66|
000042  2310              MOVS     r3,#0x10              ;178
000044  f8102f01          LDRB     r2,[r0,#1]!           ;179
000048  e7f2              B        |L3.48|
                  |L3.74|
00004a  2b10              CMP      r3,#0x10              ;188
00004c  d113              BNE      |L3.118|
00004e  f1a20661          SUB      r6,r2,#0x61           ;188
000052  2e05              CMP      r6,#5                 ;188
000054  d903              BLS      |L3.94|
000056  f1a20141          SUB      r1,r2,#0x41           ;188
00005a  2905              CMP      r1,#5                 ;188
00005c  d80b              BHI      |L3.118|
                  |L3.94|
00005e  2e19              CMP      r6,#0x19              ;189
000060  d801              BHI      |L3.102|
000062  2161              MOVS     r1,#0x61              ;189
000064  e000              B        |L3.104|
                  |L3.102|
000066  2141              MOVS     r1,#0x41              ;189
                  |L3.104|
000068  1a51              SUBS     r1,r2,r1              ;189
00006a  310a              ADDS     r1,r1,#0xa            ;189
00006c  ea411404          ORR      r4,r1,r4,LSL #4       ;189
000070  f8102f01          LDRB     r2,[r0,#1]!           ;190
000074  e7dc              B        |L3.48|
                  |L3.118|
000076  2a2e              CMP      r2,#0x2e              ;195
000078  d00e              BEQ      |L3.152|
00007a  b1b2              CBZ      r2,|L3.170|
00007c  2a20              CMP      r2,#0x20              ;214
00007e  d014              BEQ      |L3.170|
000080  2a0c              CMP      r2,#0xc               ;214
000082  d012              BEQ      |L3.170|
000084  2a0a              CMP      r2,#0xa               ;214
000086  d010              BEQ      |L3.170|
000088  2a0d              CMP      r2,#0xd               ;214
00008a  d00e              BEQ      |L3.170|
00008c  2a09              CMP      r2,#9                 ;214
00008e  d00c              BEQ      |L3.170|
000090  2a0b              CMP      r2,#0xb               ;214
000092  d00a              BEQ      |L3.170|
000094  2000              MOVS     r0,#0                 ;215
000096  e7bd              B        |L3.20|
                  |L3.152|
000098  a903              ADD      r1,sp,#0xc            ;202
00009a  428d              CMP      r5,r1                 ;202
00009c  d301              BCC      |L3.162|
00009e  2000              MOVS     r0,#0                 ;203
0000a0  e7b8              B        |L3.20|
                  |L3.162|
0000a2  c510              STM      r5!,{r4}              ;205
0000a4  f8102f01          LDRB     r2,[r0,#1]!           ;206
0000a8  e7af              B        |L3.10|
                  |L3.170|
0000aa  4668              MOV      r0,sp                 ;221
0000ac  1a28              SUBS     r0,r5,r0              ;221
0000ae  2101              MOVS     r1,#1                 ;221
0000b0  eb0100a0          ADD      r0,r1,r0,ASR #2       ;221
0000b4  2805              CMP      r0,#5                 ;221
0000b6  d241              BCS      |L3.316|
0000b8  e8dff000          TBB      [pc,r0]               ;221
0000bc  03470513          DCB      0x03,0x47,0x05,0x13
0000c0  2700              DCB      0x27,0x00
0000c2  2000              MOVS     r0,#0                 ;224
0000c4  e7a6              B        |L3.20|
0000c6  f1b47f80          CMP      r4,#0x1000000         ;230
0000ca  d301              BCC      |L3.208|
0000cc  2000              MOVS     r0,#0                 ;231
0000ce  e7a1              B        |L3.20|
                  |L3.208|
0000d0  9800              LDR      r0,[sp,#0]            ;233
0000d2  28ff              CMP      r0,#0xff              ;233
0000d4  d901              BLS      |L3.218|
0000d6  2000              MOVS     r0,#0                 ;234
0000d8  e79c              B        |L3.20|
                  |L3.218|
0000da  9800              LDR      r0,[sp,#0]            ;236
0000dc  ea446400          ORR      r4,r4,r0,LSL #24      ;236
0000e0  e033              B        |L3.330|
0000e2  f5b43f80          CMP      r4,#0x10000           ;240
0000e6  d301              BCC      |L3.236|
0000e8  2000              MOVS     r0,#0                 ;241
0000ea  e793              B        |L3.20|
                  |L3.236|
0000ec  9800              LDR      r0,[sp,#0]            ;243
0000ee  28ff              CMP      r0,#0xff              ;243
0000f0  d802              BHI      |L3.248|
0000f2  9801              LDR      r0,[sp,#4]            ;243
0000f4  28ff              CMP      r0,#0xff              ;243
0000f6  d901              BLS      |L3.252|
                  |L3.248|
0000f8  2000              MOVS     r0,#0                 ;244
0000fa  e78b              B        |L3.20|
                  |L3.252|
0000fc  9800              LDR      r0,[sp,#0]            ;246
0000fe  9901              LDR      r1,[sp,#4]            ;246
000100  0600              LSLS     r0,r0,#24             ;246
000102  ea404001          ORR      r0,r0,r1,LSL #16      ;246
000106  4304              ORRS     r4,r4,r0              ;246
000108  e01f              B        |L3.330|
00010a  2cff              CMP      r4,#0xff              ;250
00010c  d901              BLS      |L3.274|
00010e  2000              MOVS     r0,#0                 ;251
000110  e780              B        |L3.20|
                  |L3.274|
000112  9800              LDR      r0,[sp,#0]            ;253
000114  28ff              CMP      r0,#0xff              ;253
000116  d805              BHI      |L3.292|
000118  9801              LDR      r0,[sp,#4]            ;253
00011a  28ff              CMP      r0,#0xff              ;253
00011c  d802              BHI      |L3.292|
00011e  9802              LDR      r0,[sp,#8]            ;253
000120  28ff              CMP      r0,#0xff              ;253
000122  d901              BLS      |L3.296|
                  |L3.292|
000124  2000              MOVS     r0,#0                 ;254
000126  e775              B        |L3.20|
                  |L3.296|
000128  9800              LDR      r0,[sp,#0]            ;256
00012a  9901              LDR      r1,[sp,#4]            ;256
00012c  0600              LSLS     r0,r0,#24             ;256
00012e  ea404001          ORR      r0,r0,r1,LSL #16      ;256
000132  9902              LDR      r1,[sp,#8]            ;256
000134  ea402001          ORR      r0,r0,r1,LSL #8       ;256
000138  4304              ORRS     r4,r4,r0              ;256
00013a  e006              B        |L3.330|
                  |L3.316|
00013c  a306              ADR      r3,|L3.344|
00013e  f2401203          MOV      r2,#0x103             ;259
000142  a114              ADR      r1,|L3.404|
000144  a016              ADR      r0,|L3.416|
000146  f7fffffe          BL       __2printf
                  |L3.330|
00014a  b11f              CBZ      r7,|L3.340|
00014c  4620              MOV      r0,r4                 ;263
00014e  f7fffffe          BL       lwip_htonl
000152  6038              STR      r0,[r7,#0]            ;263
                  |L3.340|
000154  2001              MOVS     r0,#1                 ;265
000156  e75d              B        |L3.20|
;;;267    
                          ENDP

                  |L3.344|
000158  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip"
00015c  6964646c
000160  65776172
000164  65735c54
000168  68697264
00016c  5f506172
000170  74795c4c
000174  7749505c
000178  7372635c
00017c  636f7265
000180  5c697076
000184  345c6970
000188  345f6164          DCB      "4_addr.c",0
00018c  64722e63
000190  00      
000191  00                DCB      0
000192  00                DCB      0
000193  00                DCB      0
                  |L3.404|
000194  756e6861          DCB      "unhandled",0
000198  6e646c65
00019c  6400    
00019e  00                DCB      0
00019f  00                DCB      0
                  |L3.416|
0001a0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001a4  7274696f
0001a8  6e202225
0001ac  73222066
0001b0  61696c65
0001b4  64206174
0001b8  206c696e
0001bc  65202564
0001c0  20696e20
0001c4  25730a00

                          AREA ||i.ip4addr_ntoa||, CODE, READONLY, ALIGN=2

                  ip4addr_ntoa PROC
;;;276    char*
;;;277    ip4addr_ntoa(const ip4_addr_t *addr)
000000  2210              MOVS     r2,#0x10
;;;278    {
;;;279      static char str[IP4ADDR_STRLEN_MAX];
;;;280      return ip4addr_ntoa_r(addr, str, IP4ADDR_STRLEN_MAX);
000002  4901              LDR      r1,|L4.8|
000004  f7ffbffe          B.W      ip4addr_ntoa_r
;;;281    }
;;;282    
                          ENDP

                  |L4.8|
                          DCD      ||.bss||

                          AREA ||i.ip4addr_ntoa_r||, CODE, READONLY, ALIGN=1

                  ip4addr_ntoa_r PROC
;;;292    char*
;;;293    ip4addr_ntoa_r(const ip4_addr_t *addr, char *buf, int buflen)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;294    {
000004  4603              MOV      r3,r0
000006  4608              MOV      r0,r1
;;;295      u32_t s_addr;
;;;296      char inv[3];
;;;297      char *rp;
;;;298      u8_t *ap;
;;;299      u8_t rem;
;;;300      u8_t n;
;;;301      u8_t i;
;;;302      int len = 0;
000008  2500              MOVS     r5,#0
;;;303    
;;;304      s_addr = ip4_addr_get_u32(addr);
00000a  6819              LDR      r1,[r3,#0]
00000c  9101              STR      r1,[sp,#4]
;;;305    
;;;306      rp = buf;
00000e  4604              MOV      r4,r0
;;;307      ap = (u8_t *)&s_addr;
000010  af01              ADD      r7,sp,#4
;;;308      for (n = 0; n < 4; n++) {
000012  46ac              MOV      r12,r5
;;;309        i = 0;
;;;310        do {
;;;311          rem = *ap % (u8_t)10;
000014  f04f090a          MOV      r9,#0xa
000018  46ea              MOV      r10,sp                ;296
                  |L5.26|
00001a  2300              MOVS     r3,#0                 ;309
                  |L5.28|
00001c  783e              LDRB     r6,[r7,#0]
00001e  fbb6f8f9          UDIV     r8,r6,r9
000022  fb096818          MLS      r8,r9,r8,r6
;;;312          *ap /= (u8_t)10;
000026  fbb6f1f9          UDIV     r1,r6,r9
00002a  7039              STRB     r1,[r7,#0]
;;;313          inv[i++] = (char)('0' + rem);
00002c  461e              MOV      r6,r3
00002e  f1080830          ADD      r8,r8,#0x30
000032  1c5b              ADDS     r3,r3,#1
000034  b2db              UXTB     r3,r3
000036  f80a8006          STRB     r8,[r10,r6]
;;;314        } while (*ap);
00003a  2900              CMP      r1,#0
00003c  d1ee              BNE      |L5.28|
00003e  e00a              B        |L5.86|
                  |L5.64|
;;;315        while (i--) {
;;;316          if (len++ >= buflen) {
000040  4629              MOV      r1,r5
000042  1c6d              ADDS     r5,r5,#1
000044  4291              CMP      r1,r2
000046  db02              BLT      |L5.78|
;;;317            return NULL;
000048  2000              MOVS     r0,#0
                  |L5.74|
;;;318          }
;;;319          *rp++ = inv[i];
;;;320        }
;;;321        if (len++ >= buflen) {
;;;322          return NULL;
;;;323        }
;;;324        *rp++ = '.';
;;;325        ap++;
;;;326      }
;;;327      *--rp = 0;
;;;328      return buf;
;;;329    }
00004a  e8bd87fc          POP      {r2-r10,pc}
                  |L5.78|
00004e  f81a1003          LDRB     r1,[r10,r3]           ;319
000052  f8041b01          STRB     r1,[r4],#1            ;319
                  |L5.86|
000056  1e5b              SUBS     r3,r3,#1              ;315
000058  b2db              UXTB     r3,r3                 ;315
00005a  d2f1              BCS      |L5.64|
00005c  4629              MOV      r1,r5                 ;321
00005e  1c6d              ADDS     r5,r5,#1              ;321
000060  4291              CMP      r1,r2                 ;321
000062  db01              BLT      |L5.104|
000064  2000              MOVS     r0,#0                 ;322
000066  e7f0              B        |L5.74|
                  |L5.104|
000068  212e              MOVS     r1,#0x2e              ;324
00006a  f8041b01          STRB     r1,[r4],#1            ;324
00006e  1c7f              ADDS     r7,r7,#1              ;325
000070  f10c0c01          ADD      r12,r12,#1            ;308
000074  f00c0cff          AND      r12,r12,#0xff         ;308
000078  f1bc0f04          CMP      r12,#4                ;308
00007c  d3cd              BCC      |L5.26|
00007e  2100              MOVS     r1,#0                 ;327
000080  f8041c01          STRB     r1,[r4,#-1]           ;327
000084  e7e1              B        |L5.74|
;;;330    
                          ENDP


                          AREA ||i.ipaddr_addr||, CODE, READONLY, ALIGN=1

                  ipaddr_addr PROC
;;;132    u32_t
;;;133    ipaddr_addr(const char *cp)
000000  b508              PUSH     {r3,lr}
;;;134    {
;;;135      ip4_addr_t val;
;;;136    
;;;137      if (ip4addr_aton(cp, &val)) {
000002  4669              MOV      r1,sp
000004  f7fffffe          BL       ip4addr_aton
000008  b108              CBZ      r0,|L6.14|
;;;138        return ip4_addr_get_u32(&val);
00000a  9800              LDR      r0,[sp,#0]
;;;139      }
;;;140      return (IPADDR_NONE);
;;;141    }
00000c  bd08              POP      {r3,pc}
                  |L6.14|
00000e  f04f30ff          MOV      r0,#0xffffffff        ;140
000012  bd08              POP      {r3,pc}
;;;142    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ||str||
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  ip_addr_any
                          DCD      0x00000000

                          AREA ||area_number.11||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.constdata||
                  ip_addr_broadcast
                          DCD      0xffffffff

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip4_addr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_ip4_addr_c_60af150c____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_ip4_addr_c_60af150c____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_ip4_addr_c_60af150c____REVSH|
#line 478
|__asm___10_ip4_addr_c_60af150c____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_ip4_addr_c_60af150c____RRX|
#line 665
|__asm___10_ip4_addr_c_60af150c____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
