; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\udp.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\udp.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\system\arch -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Inc -I..\Middlewares\Third_Party\LwIP\src\include -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\udp.crf ..\Middlewares\Third_Party\LwIP\src\core\udp.c]
                          THUMB

                          AREA ||i.udp_bind||, CODE, READONLY, ALIGN=2

                  udp_bind PROC
;;;881    err_t
;;;882    udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;883    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;884      struct udp_pcb *ipcb;
;;;885      u8_t rebind;
;;;886    
;;;887    #if LWIP_IPV4
;;;888      /* Don't propagate NULL pointer (IPv4 ANY) to subsequent functions */
;;;889      if (ipaddr == NULL) {
000008  2d00              CMP      r5,#0
00000a  d100              BNE      |L1.14|
;;;890        ipaddr = IP4_ADDR_ANY;
00000c  4d1b              LDR      r5,|L1.124|
                  |L1.14|
;;;891      }
;;;892    #endif /* LWIP_IPV4 */
;;;893    
;;;894      /* still need to check for ipaddr == NULL in IPv6 only case */
;;;895      if ((pcb == NULL) || (ipaddr == NULL)) {
00000e  b12c              CBZ      r4,|L1.28|
000010  b125              CBZ      r5,|L1.28|
;;;896        return ERR_VAL;
;;;897      }
;;;898    
;;;899      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_bind(ipaddr = "));
;;;900      ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE, ipaddr);
;;;901      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, (", port = %"U16_F")\n", port));
;;;902    
;;;903      rebind = 0;
000012  2600              MOVS     r6,#0
;;;904      /* Check for double bind and rebind of the same pcb */
;;;905      for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
000014  4f1a              LDR      r7,|L1.128|
000016  687b              LDR      r3,[r7,#4]  ; udp_pcbs
000018  4618              MOV      r0,r3
00001a  e008              B        |L1.46|
                  |L1.28|
00001c  f06f0005          MVN      r0,#5                 ;896
                  |L1.32|
;;;906        /* is this UDP PCB already on active list? */
;;;907        if (pcb == ipcb) {
;;;908          rebind = 1;
;;;909          break;
;;;910        }
;;;911      }
;;;912    
;;;913      /* no port specified? */
;;;914      if (port == 0) {
;;;915        port = udp_new_port();
;;;916        if (port == 0) {
;;;917          /* no more ports available in local range */
;;;918          LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
;;;919          return ERR_USE;
;;;920        }
;;;921      } else {
;;;922        for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
;;;923          if (pcb != ipcb) {
;;;924          /* By default, we don't allow to bind to a port that any other udp
;;;925             PCB is already bound to, unless *all* PCBs with that port have tha
;;;926             REUSEADDR flag set. */
;;;927    #if SO_REUSE
;;;928            if (!ip_get_option(pcb, SOF_REUSEADDR) ||
;;;929                !ip_get_option(ipcb, SOF_REUSEADDR))
;;;930    #endif /* SO_REUSE */
;;;931            {
;;;932              /* port matches that of PCB in list and REUSEADDR not set -> reject */
;;;933              if ((ipcb->local_port == port) &&
;;;934                  /* IP address matches? */
;;;935                  ip_addr_cmp(&ipcb->local_ip, ipaddr)) {
;;;936                /* other PCB already binds to this local IP and port */
;;;937                LWIP_DEBUGF(UDP_DEBUG,
;;;938                            ("udp_bind: local port %"U16_F" already bound by another pcb\n", port));
;;;939                return ERR_USE;
;;;940              }
;;;941            }
;;;942          }
;;;943        }
;;;944      }
;;;945    
;;;946      ip_addr_set_ipaddr(&pcb->local_ip, ipaddr);
;;;947    
;;;948      pcb->local_port = port;
;;;949      mib2_udp_bind(pcb);
;;;950      /* pcb not active yet? */
;;;951      if (rebind == 0) {
;;;952        /* place the PCB on the active list if not already there */
;;;953        pcb->next = udp_pcbs;
;;;954        udp_pcbs = pcb;
;;;955      }
;;;956      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_bind: bound to "));
;;;957      ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, &pcb->local_ip);
;;;958      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->local_port));
;;;959      return ERR_OK;
;;;960    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L1.36|
000024  429c              CMP      r4,r3                 ;907
000026  d101              BNE      |L1.44|
000028  2601              MOVS     r6,#1                 ;908
00002a  e002              B        |L1.50|
                  |L1.44|
00002c  68db              LDR      r3,[r3,#0xc]          ;905
                  |L1.46|
00002e  2b00              CMP      r3,#0                 ;905
000030  d1f8              BNE      |L1.36|
                  |L1.50|
000032  f06f0807          MVN      r8,#7                 ;919
000036  b992              CBNZ     r2,|L1.94|
000038  f7fffffe          BL       udp_new_port
00003c  4602              MOV      r2,r0                 ;915
00003e  0010              MOVS     r0,r2                 ;916
000040  d10f              BNE      |L1.98|
000042  4640              MOV      r0,r8                 ;919
000044  e7ec              B        |L1.32|
                  |L1.70|
000046  4284              CMP      r4,r0                 ;923
000048  d008              BEQ      |L1.92|
00004a  8a41              LDRH     r1,[r0,#0x12]         ;933
00004c  4291              CMP      r1,r2                 ;933
00004e  d105              BNE      |L1.92|
000050  6801              LDR      r1,[r0,#0]            ;935
000052  682b              LDR      r3,[r5,#0]            ;935
000054  4299              CMP      r1,r3                 ;935
000056  d101              BNE      |L1.92|
000058  4640              MOV      r0,r8                 ;939
00005a  e7e1              B        |L1.32|
                  |L1.92|
00005c  68c0              LDR      r0,[r0,#0xc]          ;922
                  |L1.94|
00005e  2800              CMP      r0,#0                 ;922
000060  d1f1              BNE      |L1.70|
                  |L1.98|
000062  b125              CBZ      r5,|L1.110|
000064  6828              LDR      r0,[r5,#0]            ;946
                  |L1.102|
000066  6020              STR      r0,[r4,#0]            ;946
000068  8262              STRH     r2,[r4,#0x12]         ;948
00006a  b116              CBZ      r6,|L1.114|
00006c  e004              B        |L1.120|
                  |L1.110|
00006e  2000              MOVS     r0,#0                 ;946
000070  e7f9              B        |L1.102|
                  |L1.114|
000072  6878              LDR      r0,[r7,#4]            ;953  ; udp_pcbs
000074  60e0              STR      r0,[r4,#0xc]          ;953
000076  607c              STR      r4,[r7,#4]            ;954  ; udp_pcbs
                  |L1.120|
000078  2000              MOVS     r0,#0                 ;959
00007a  e7d1              B        |L1.32|
;;;961    
                          ENDP

                  |L1.124|
                          DCD      ip_addr_any
                  |L1.128|
                          DCD      ||.data||

                          AREA ||i.udp_connect||, CODE, READONLY, ALIGN=2

                  udp_connect PROC
;;;980    err_t
;;;981    udp_connect(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port)
000000  b570              PUSH     {r4-r6,lr}
;;;982    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;983      struct udp_pcb *ipcb;
;;;984    
;;;985      if ((pcb == NULL) || (ipaddr == NULL)) {
000008  2c00              CMP      r4,#0
00000a  d003              BEQ      |L2.20|
00000c  b115              CBZ      r5,|L2.20|
;;;986        return ERR_VAL;
;;;987      }
;;;988    
;;;989      if (pcb->local_port == 0) {
00000e  8a62              LDRH     r2,[r4,#0x12]
000010  b11a              CBZ      r2,|L2.26|
000012  e008              B        |L2.38|
                  |L2.20|
000014  f06f0005          MVN      r0,#5                 ;986
                  |L2.24|
;;;990        err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
;;;991        if (err != ERR_OK) {
;;;992          return err;
;;;993        }
;;;994      }
;;;995    
;;;996      ip_addr_set_ipaddr(&pcb->remote_ip, ipaddr);
;;;997      pcb->remote_port = port;
;;;998      pcb->flags |= UDP_FLAGS_CONNECTED;
;;;999    
;;;1000     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("udp_connect: connected to "));
;;;1001     ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
;;;1002                         &pcb->remote_ip);
;;;1003     LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, (", port %"U16_F")\n", pcb->remote_port));
;;;1004   
;;;1005     /* Insert UDP PCB into the list of active UDP PCBs. */
;;;1006     for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
;;;1007       if (pcb == ipcb) {
;;;1008         /* already on the list, just return */
;;;1009         return ERR_OK;
;;;1010       }
;;;1011     }
;;;1012     /* PCB not yet on the list, add PCB now */
;;;1013     pcb->next = udp_pcbs;
;;;1014     udp_pcbs = pcb;
;;;1015     return ERR_OK;
;;;1016   }
000018  bd70              POP      {r4-r6,pc}
                  |L2.26|
00001a  4621              MOV      r1,r4                 ;990
00001c  4620              MOV      r0,r4                 ;990
00001e  f7fffffe          BL       udp_bind
000022  2800              CMP      r0,#0                 ;991
000024  d1f8              BNE      |L2.24|
                  |L2.38|
000026  6828              LDR      r0,[r5,#0]            ;996
000028  6060              STR      r0,[r4,#4]            ;996
00002a  82a6              STRH     r6,[r4,#0x14]         ;997
00002c  7c20              LDRB     r0,[r4,#0x10]         ;998
00002e  f0400004          ORR      r0,r0,#4              ;998
000032  7420              STRB     r0,[r4,#0x10]         ;998
000034  4a06              LDR      r2,|L2.80|
000036  6850              LDR      r0,[r2,#4]            ;1006  ; udp_pcbs
000038  4601              MOV      r1,r0                 ;1006
00003a  e004              B        |L2.70|
                  |L2.60|
00003c  4284              CMP      r4,r0                 ;1007
00003e  d101              BNE      |L2.68|
000040  2000              MOVS     r0,#0                 ;1009
000042  bd70              POP      {r4-r6,pc}
                  |L2.68|
000044  68c0              LDR      r0,[r0,#0xc]          ;1006
                  |L2.70|
000046  2800              CMP      r0,#0                 ;1006
000048  d1f8              BNE      |L2.60|
00004a  60e1              STR      r1,[r4,#0xc]          ;1013
00004c  6054              STR      r4,[r2,#4]            ;1014  ; udp_pcbs
00004e  bd70              POP      {r4-r6,pc}
;;;1017   
                          ENDP

                  |L2.80|
                          DCD      ||.data||

                          AREA ||i.udp_disconnect||, CODE, READONLY, ALIGN=1

                  udp_disconnect PROC
;;;1024   void
;;;1025   udp_disconnect(struct udp_pcb *pcb)
000000  2100              MOVS     r1,#0
;;;1026   {
;;;1027     /* reset remote address association */
;;;1028   #if LWIP_IPV4 && LWIP_IPV6
;;;1029     if (IP_IS_ANY_TYPE_VAL(pcb->local_ip)) {
;;;1030       ip_addr_copy(pcb->remote_ip, *IP_ANY_TYPE);
;;;1031     } else {
;;;1032   #endif
;;;1033       ip_addr_set_any(IP_IS_V6_VAL(pcb->remote_ip), &pcb->remote_ip);
000002  6041              STR      r1,[r0,#4]
;;;1034   #if LWIP_IPV4 && LWIP_IPV6
;;;1035     }
;;;1036   #endif
;;;1037     pcb->remote_port = 0;
000004  8281              STRH     r1,[r0,#0x14]
;;;1038     /* mark PCB as unconnected */
;;;1039     pcb->flags &= ~UDP_FLAGS_CONNECTED;
000006  7c01              LDRB     r1,[r0,#0x10]
000008  f0210104          BIC      r1,r1,#4
00000c  7401              STRB     r1,[r0,#0x10]
;;;1040   }
00000e  4770              BX       lr
;;;1041   
                          ENDP


                          AREA ||i.udp_init||, CODE, READONLY, ALIGN=1

                  udp_init PROC
;;;86     void
;;;87     udp_init(void)
000000  4770              BX       lr
;;;88     {
;;;89     #if LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND)
;;;90       udp_port = UDP_ENSURE_LOCAL_PORT_RANGE(LWIP_RAND());
;;;91     #endif /* LWIP_RANDOMIZE_INITIAL_LOCAL_PORTS && defined(LWIP_RAND) */
;;;92     }
;;;93     
                          ENDP


                          AREA ||i.udp_input||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  udp_input PROC
;;;184    void
;;;185    udp_input(struct pbuf *p, struct netif *inp)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;186    {
000004  b083              SUB      sp,sp,#0xc
000006  4607              MOV      r7,r0
;;;187      struct udp_hdr *udphdr;
;;;188      struct udp_pcb *pcb, *prev;
;;;189      struct udp_pcb *uncon_pcb;
;;;190      u16_t src, dest;
;;;191      u8_t broadcast;
;;;192      u8_t for_us = 0;
;;;193    
;;;194      LWIP_UNUSED_ARG(inp);
;;;195    
;;;196      PERF_START;
;;;197    
;;;198      UDP_STATS_INC(udp.recv);
;;;199    
;;;200      /* Check minimum length (UDP header) */
;;;201      if (p->len < UDP_HLEN) {
000008  8978              LDRH     r0,[r7,#0xa]
00000a  2808              CMP      r0,#8
00000c  d205              BCS      |L5.26|
;;;202        /* drop short packets */
;;;203        LWIP_DEBUGF(UDP_DEBUG,
;;;204                    ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
;;;205        UDP_STATS_INC(udp.lenerr);
;;;206        UDP_STATS_INC(udp.drop);
;;;207        MIB2_STATS_INC(mib2.udpinerrors);
;;;208        pbuf_free(p);
00000e  b005              ADD      sp,sp,#0x14
000010  4638              MOV      r0,r7
000012  e8bd4ff0          POP      {r4-r11,lr}
000016  f7ffbffe          B.W      pbuf_free
                  |L5.26|
;;;209        goto end;
;;;210      }
;;;211    
;;;212      udphdr = (struct udp_hdr *)p->payload;
00001a  687c              LDR      r4,[r7,#4]
;;;213    
;;;214      /* is broadcast packet ? */
;;;215      broadcast = ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif());
00001c  f8dfa120          LDR      r10,|L5.320|
000020  f8da1000          LDR      r1,[r10,#0]  ; ip_data
000024  f8da0014          LDR      r0,[r10,#0x14]  ; ip_data
000028  f7fffffe          BL       ip4_addr_isbroadcast_u32
00002c  9002              STR      r0,[sp,#8]
;;;216    
;;;217      LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));
;;;218    
;;;219      /* convert src and dest ports to host byte order */
;;;220      src = lwip_ntohs(udphdr->src);
00002e  8820              LDRH     r0,[r4,#0]
000030  f7fffffe          BL       lwip_htons
000034  4680              MOV      r8,r0
;;;221      dest = lwip_ntohs(udphdr->dest);
000036  8860              LDRH     r0,[r4,#2]
000038  f7fffffe          BL       lwip_htons
00003c  4681              MOV      r9,r0
;;;222    
;;;223      udp_debug_print(udphdr);
;;;224    
;;;225      /* print the UDP source and destination */
;;;226      LWIP_DEBUGF(UDP_DEBUG, ("udp ("));
;;;227      ip_addr_debug_print(UDP_DEBUG, ip_current_dest_addr());
;;;228      LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", lwip_ntohs(udphdr->dest)));
;;;229      ip_addr_debug_print(UDP_DEBUG, ip_current_src_addr());
;;;230      LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", lwip_ntohs(udphdr->src)));
;;;231    
;;;232      pcb = NULL;
;;;233      prev = NULL;
00003e  2600              MOVS     r6,#0
;;;234      uncon_pcb = NULL;
000040  2500              MOVS     r5,#0
;;;235      /* Iterate through the UDP pcb list for a matching pcb.
;;;236       * 'Perfect match' pcbs (connected to the remote port & ip address) are
;;;237       * preferred. If no perfect match is found, the first unconnected pcb that
;;;238       * matches the local port and ip address gets the datagram. */
;;;239      for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
000042  f8dfb100          LDR      r11,|L5.324|
000046  f8db4004          LDR      r4,[r11,#4]  ; udp_pcbs
00004a  e021              B        |L5.144|
                  |L5.76|
;;;240        /* print the PCB local and remote address */
;;;241        LWIP_DEBUGF(UDP_DEBUG, ("pcb ("));
;;;242        ip_addr_debug_print(UDP_DEBUG, &pcb->local_ip);
;;;243        LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F") <-- (", pcb->local_port));
;;;244        ip_addr_debug_print(UDP_DEBUG, &pcb->remote_ip);
;;;245        LWIP_DEBUGF(UDP_DEBUG, (", %"U16_F")\n", pcb->remote_port));
;;;246    
;;;247        /* compare PCB local addr+port to UDP destination addr+port */
;;;248        if ((pcb->local_port == dest) &&
00004c  8a60              LDRH     r0,[r4,#0x12]
00004e  4548              CMP      r0,r9
000050  d11c              BNE      |L5.140|
;;;249            (udp_input_local_match(pcb, inp, broadcast) != 0)) {
000052  4620              MOV      r0,r4
000054  9a02              LDR      r2,[sp,#8]
000056  9904              LDR      r1,[sp,#0x10]
000058  f7fffffe          BL       udp_input_local_match
00005c  b1b0              CBZ      r0,|L5.140|
;;;250          if (((pcb->flags & UDP_FLAGS_CONNECTED) == 0) &&
00005e  7c20              LDRB     r0,[r4,#0x10]
000060  0740              LSLS     r0,r0,#29
000062  d401              BMI      |L5.104|
;;;251              ((uncon_pcb == NULL)
000064  b905              CBNZ     r5,|L5.104|
;;;252    #if SO_REUSE
;;;253              /* prefer specific IPs over cath-all */
;;;254              || !ip_addr_isany(&pcb->local_ip)
;;;255    #endif /* SO_REUSE */
;;;256              )) {
;;;257            /* the first unconnected matching PCB */
;;;258            uncon_pcb = pcb;
000066  4625              MOV      r5,r4
                  |L5.104|
;;;259          }
;;;260    
;;;261          /* compare PCB remote addr+port to UDP source addr+port */
;;;262          if ((pcb->remote_port == src) &&
000068  8aa0              LDRH     r0,[r4,#0x14]
00006a  4540              CMP      r0,r8
00006c  d10e              BNE      |L5.140|
;;;263              (ip_addr_isany_val(pcb->remote_ip) ||
00006e  6860              LDR      r0,[r4,#4]
000070  b118              CBZ      r0,|L5.122|
;;;264              ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()))) {
000072  f8da1010          LDR      r1,[r10,#0x10]  ; ip_data
000076  4288              CMP      r0,r1
000078  d108              BNE      |L5.140|
                  |L5.122|
;;;265            /* the first fully matching PCB */
;;;266            if (prev != NULL) {
00007a  b15e              CBZ      r6,|L5.148|
;;;267              /* move the pcb to the front of udp_pcbs so that is
;;;268                 found faster next time */
;;;269              prev->next = pcb->next;
00007c  68e0              LDR      r0,[r4,#0xc]
00007e  60f0              STR      r0,[r6,#0xc]
;;;270              pcb->next = udp_pcbs;
000080  f8db0004          LDR      r0,[r11,#4]  ; udp_pcbs
000084  60e0              STR      r0,[r4,#0xc]
;;;271              udp_pcbs = pcb;
000086  f8cb4004          STR      r4,[r11,#4]  ; udp_pcbs
00008a  e003              B        |L5.148|
                  |L5.140|
;;;272            } else {
;;;273              UDP_STATS_INC(udp.cachehit);
;;;274            }
;;;275            break;
;;;276          }
;;;277        }
;;;278    
;;;279        prev = pcb;
00008c  4626              MOV      r6,r4
00008e  68e4              LDR      r4,[r4,#0xc]          ;239
                  |L5.144|
000090  2c00              CMP      r4,#0                 ;239
000092  d1db              BNE      |L5.76|
                  |L5.148|
;;;280      }
;;;281      /* no fully matching pcb found? then look for an unconnected pcb */
;;;282      if (pcb == NULL) {
000094  b904              CBNZ     r4,|L5.152|
;;;283        pcb = uncon_pcb;
000096  462c              MOV      r4,r5
                  |L5.152|
;;;284      }
;;;285    
;;;286      /* Check checksum if this is a match or if it was directed at us. */
;;;287      if (pcb != NULL) {
000098  b10c              CBZ      r4,|L5.158|
;;;288        for_us = 1;
00009a  2001              MOVS     r0,#1
00009c  e008              B        |L5.176|
                  |L5.158|
;;;289      } else {
;;;290    #if LWIP_IPV6
;;;291        if (ip_current_is_v6()) {
;;;292          for_us = netif_get_ip6_addr_match(inp, ip6_current_dest_addr()) >= 0;
;;;293        }
;;;294    #endif /* LWIP_IPV6 */
;;;295    #if LWIP_IPV4
;;;296        if (!ip_current_is_v6()) {
;;;297          for_us = ip4_addr_cmp(netif_ip4_addr(inp), ip4_current_dest_addr());
00009e  9804              LDR      r0,[sp,#0x10]
0000a0  f8da1014          LDR      r1,[r10,#0x14]  ; ip_data
0000a4  6840              LDR      r0,[r0,#4]
0000a6  4288              CMP      r0,r1
0000a8  d101              BNE      |L5.174|
0000aa  2001              MOVS     r0,#1
0000ac  e000              B        |L5.176|
                  |L5.174|
0000ae  2000              MOVS     r0,#0
                  |L5.176|
;;;298        }
;;;299    #endif /* LWIP_IPV4 */
;;;300      }
;;;301    
;;;302      if (for_us) {
0000b0  2800              CMP      r0,#0
0000b2  d03f              BEQ      |L5.308|
;;;303        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: calculating checksum\n"));
;;;304    #if CHECKSUM_CHECK_UDP
;;;305        IF__NETIF_CHECKSUM_ENABLED(inp, CHECKSUM_CHECK_UDP) {
;;;306    #if LWIP_UDPLITE
;;;307          if (ip_current_header_proto() == IP_PROTO_UDPLITE) {
;;;308            /* Do the UDP Lite checksum */
;;;309            u16_t chklen = lwip_ntohs(udphdr->len);
;;;310            if (chklen < sizeof(struct udp_hdr)) {
;;;311              if (chklen == 0) {
;;;312                /* For UDP-Lite, checksum length of 0 means checksum
;;;313                   over the complete packet (See RFC 3828 chap. 3.1) */
;;;314                chklen = p->tot_len;
;;;315              } else {
;;;316                /* At least the UDP-Lite header must be covered by the
;;;317                   checksum! (Again, see RFC 3828 chap. 3.1) */
;;;318                goto chkerr;
;;;319              }
;;;320            }
;;;321            if (ip_chksum_pseudo_partial(p, IP_PROTO_UDPLITE,
;;;322                         p->tot_len, chklen,
;;;323                         ip_current_src_addr(), ip_current_dest_addr()) != 0) {
;;;324              goto chkerr;
;;;325            }
;;;326          } else
;;;327    #endif /* LWIP_UDPLITE */
;;;328          {
;;;329            if (udphdr->chksum != 0) {
;;;330              if (ip_chksum_pseudo(p, IP_PROTO_UDP, p->tot_len,
;;;331                                   ip_current_src_addr(),
;;;332                                   ip_current_dest_addr()) != 0) {
;;;333                goto chkerr;
;;;334              }
;;;335            }
;;;336          }
;;;337        }
;;;338    #endif /* CHECKSUM_CHECK_UDP */
;;;339        if (pbuf_header(p, -UDP_HLEN)) {
0000b4  f06f0107          MVN      r1,#7
0000b8  4638              MOV      r0,r7
0000ba  f7fffffe          BL       pbuf_header
0000be  b160              CBZ      r0,|L5.218|
;;;340          /* Can we cope with this failing? Just assert for now */
;;;341          LWIP_ASSERT("pbuf_header failed\n", 0);
0000c0  a321              ADR      r3,|L5.328|
0000c2  f2401255          MOV      r2,#0x155
0000c6  a12c              ADR      r1,|L5.376|
0000c8  a030              ADR      r0,|L5.396|
0000ca  f7fffffe          BL       __2printf
;;;342          UDP_STATS_INC(udp.drop);
;;;343          MIB2_STATS_INC(mib2.udpinerrors);
;;;344          pbuf_free(p);
0000ce  b005              ADD      sp,sp,#0x14
0000d0  4638              MOV      r0,r7
0000d2  e8bd4ff0          POP      {r4-r11,lr}
0000d6  f7ffbffe          B.W      pbuf_free
                  |L5.218|
;;;345          goto end;
;;;346        }
;;;347    
;;;348        if (pcb != NULL) {
0000da  b194              CBZ      r4,|L5.258|
;;;349          MIB2_STATS_INC(mib2.udpindatagrams);
;;;350    #if SO_REUSE && SO_REUSE_RXTOALL
;;;351          if (ip_get_option(pcb, SOF_REUSEADDR) &&
;;;352              (broadcast || ip_addr_ismulticast(ip_current_dest_addr()))) {
;;;353            /* pass broadcast- or multicast packets to all multicast pcbs
;;;354               if SOF_REUSEADDR is set on the first match */
;;;355            struct udp_pcb *mpcb;
;;;356            u8_t p_header_changed = 0;
;;;357            s16_t hdrs_len = (s16_t)(ip_current_header_tot_len() + UDP_HLEN);
;;;358            for (mpcb = udp_pcbs; mpcb != NULL; mpcb = mpcb->next) {
;;;359              if (mpcb != pcb) {
;;;360                /* compare PCB local addr+port to UDP destination addr+port */
;;;361                if ((mpcb->local_port == dest) &&
;;;362                    (udp_input_local_match(mpcb, inp, broadcast) != 0)) {
;;;363                  /* pass a copy of the packet to all local matches */
;;;364                  if (mpcb->recv != NULL) {
;;;365                    struct pbuf *q;
;;;366                    /* for that, move payload to IP header again */
;;;367                    if (p_header_changed == 0) {
;;;368                      pbuf_header_force(p, hdrs_len);
;;;369                      p_header_changed = 1;
;;;370                    }
;;;371                    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
;;;372                    if (q != NULL) {
;;;373                      err_t err = pbuf_copy(q, p);
;;;374                      if (err == ERR_OK) {
;;;375                        /* move payload to UDP data */
;;;376                        pbuf_header(q, -hdrs_len);
;;;377                        mpcb->recv(mpcb->recv_arg, mpcb, q, ip_current_src_addr(), src);
;;;378                      }
;;;379                    }
;;;380                  }
;;;381                }
;;;382              }
;;;383            }
;;;384            if (p_header_changed) {
;;;385              /* and move payload to UDP data again */
;;;386              pbuf_header(p, -hdrs_len);
;;;387            }
;;;388          }
;;;389    #endif /* SO_REUSE && SO_REUSE_RXTOALL */
;;;390          /* callback */
;;;391          if (pcb->recv != NULL) {
0000dc  69a5              LDR      r5,[r4,#0x18]
0000de  b155              CBZ      r5,|L5.246|
;;;392            /* now the recv function is responsible for freeing p */
;;;393            pcb->recv(pcb->recv_arg, pcb, p, ip_current_src_addr(), src);
0000e0  4b17              LDR      r3,|L5.320|
0000e2  f8cd8000          STR      r8,[sp,#0]
0000e6  3310              ADDS     r3,r3,#0x10
0000e8  463a              MOV      r2,r7
0000ea  4621              MOV      r1,r4
0000ec  69e0              LDR      r0,[r4,#0x1c]
0000ee  47a8              BLX      r5
;;;394          } else {
;;;395            /* no recv function registered? then we have to free the pbuf! */
;;;396            pbuf_free(p);
;;;397            goto end;
;;;398          }
;;;399        } else {
;;;400          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));
;;;401    
;;;402    #if LWIP_ICMP || LWIP_ICMP6
;;;403          /* No match was found, send ICMP destination port unreachable unless
;;;404             destination address was broadcast/multicast. */
;;;405          if (!broadcast && !ip_addr_ismulticast(ip_current_dest_addr())) {
;;;406            /* move payload pointer back to ip header */
;;;407            pbuf_header_force(p, (s16_t)(ip_current_header_tot_len() + UDP_HLEN));
;;;408            icmp_port_unreach(ip_current_is_v6(), p);
;;;409          }
;;;410    #endif /* LWIP_ICMP || LWIP_ICMP6 */
;;;411          UDP_STATS_INC(udp.proterr);
;;;412          UDP_STATS_INC(udp.drop);
;;;413          MIB2_STATS_INC(mib2.udpnoports);
;;;414          pbuf_free(p);
;;;415        }
;;;416      } else {
;;;417        pbuf_free(p);
;;;418      }
;;;419    end:
;;;420      PERF_STOP("udp_input");
;;;421      return;
;;;422    #if CHECKSUM_CHECK_UDP
;;;423    chkerr:
;;;424      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;425                  ("udp_input: UDP (or UDP Lite) datagram discarded due to failing checksum\n"));
;;;426      UDP_STATS_INC(udp.chkerr);
;;;427      UDP_STATS_INC(udp.drop);
;;;428      MIB2_STATS_INC(mib2.udpinerrors);
;;;429      pbuf_free(p);
;;;430      PERF_STOP("udp_input");
;;;431    #endif /* CHECKSUM_CHECK_UDP */
;;;432    }
0000f0  b005              ADD      sp,sp,#0x14
0000f2  e8bd8ff0          POP      {r4-r11,pc}
                  |L5.246|
0000f6  b005              ADD      sp,sp,#0x14           ;396
0000f8  4638              MOV      r0,r7                 ;396
0000fa  e8bd4ff0          POP      {r4-r11,lr}           ;396
0000fe  f7ffbffe          B.W      pbuf_free
                  |L5.258|
000102  9802              LDR      r0,[sp,#8]            ;405
000104  b980              CBNZ     r0,|L5.296|
000106  f89a0014          LDRB     r0,[r10,#0x14]        ;405  ; ip_data
00010a  f3c01003          UBFX     r0,r0,#4,#4           ;405
00010e  280e              CMP      r0,#0xe               ;405
000110  d00a              BEQ      |L5.296|
000112  f8ba000c          LDRH     r0,[r10,#0xc]         ;407  ; ip_data
000116  3008              ADDS     r0,r0,#8              ;407
000118  b201              SXTH     r1,r0                 ;407
00011a  4638              MOV      r0,r7                 ;407
00011c  f7fffffe          BL       pbuf_header_force
000120  2103              MOVS     r1,#3                 ;408
000122  4638              MOV      r0,r7                 ;408
000124  f7fffffe          BL       icmp_dest_unreach
                  |L5.296|
000128  b005              ADD      sp,sp,#0x14           ;414
00012a  4638              MOV      r0,r7                 ;414
00012c  e8bd4ff0          POP      {r4-r11,lr}           ;414
000130  f7ffbffe          B.W      pbuf_free
                  |L5.308|
000134  b005              ADD      sp,sp,#0x14           ;417
000136  4638              MOV      r0,r7                 ;417
000138  e8bd4ff0          POP      {r4-r11,lr}           ;417
00013c  f7ffbffe          B.W      pbuf_free
;;;433    
                          ENDP

                  |L5.320|
                          DCD      ip_data
                  |L5.324|
                          DCD      ||.data||
                  |L5.328|
000148  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\udp.c",0
00014c  6964646c
000150  65776172
000154  65735c54
000158  68697264
00015c  5f506172
000160  74795c4c
000164  7749505c
000168  7372635c
00016c  636f7265
000170  5c756470
000174  2e6300  
000177  00                DCB      0
                  |L5.376|
000178  70627566          DCB      "pbuf_header failed\n",0
00017c  5f686561
000180  64657220
000184  6661696c
000188  65640a00
                  |L5.396|
00018c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000190  7274696f
000194  6e202225
000198  73222066
00019c  61696c65
0001a0  64206174
0001a4  206c696e
0001a8  65202564
0001ac  20696e20
0001b0  25730a00

                          AREA ||i.udp_input_local_match||, CODE, READONLY, ALIGN=2

                  udp_input_local_match PROC
;;;129    static u8_t
;;;130    udp_input_local_match(struct udp_pcb *pcb, struct netif *inp, u8_t broadcast)
000000  4b0c              LDR      r3,|L6.52|
;;;131    {
;;;132      LWIP_UNUSED_ARG(inp);       /* in IPv6 only case */
;;;133      LWIP_UNUSED_ARG(broadcast); /* in IPv6 only case */
;;;134    
;;;135      /* Dual-stack: PCBs listening to any IP type also listen to any IP address */
;;;136      if (IP_IS_ANY_TYPE_VAL(pcb->local_ip)) {
;;;137    #if LWIP_IPV4 && IP_SOF_BROADCAST_RECV
;;;138        if ((broadcast != 0) && !ip_get_option(pcb, SOF_BROADCAST)) {
;;;139          return 0;
;;;140        }
;;;141    #endif /* LWIP_IPV4 && IP_SOF_BROADCAST_RECV */
;;;142        return 1;
;;;143      }
;;;144    
;;;145      /* Only need to check PCB if incoming IP version matches PCB IP version */
;;;146      if (IP_ADDR_PCB_VERSION_MATCH_EXACT(pcb, ip_current_dest_addr())) {
;;;147    #if LWIP_IPV4
;;;148        /* Special case: IPv4 broadcast: all or broadcasts in my subnet
;;;149         * Note: broadcast variable can only be 1 if it is an IPv4 broadcast */
;;;150        if (broadcast != 0) {
000002  2a00              CMP      r2,#0
;;;151    #if IP_SOF_BROADCAST_RECV
;;;152          if (ip_get_option(pcb, SOF_BROADCAST))
;;;153    #endif /* IP_SOF_BROADCAST_RECV */
;;;154          {
;;;155            if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
;;;156              ((ip4_current_dest_addr()->addr == IPADDR_BROADCAST)) ||
000004  695b              LDR      r3,[r3,#0x14]
000006  d00b              BEQ      |L6.32|
000008  b140              CBZ      r0,|L6.28|
00000a  6802              LDR      r2,[r0,#0]            ;155
00000c  b132              CBZ      r2,|L6.28|
00000e  1c58              ADDS     r0,r3,#1
000010  d004              BEQ      |L6.28|
;;;157               ip4_addr_netcmp(ip_2_ip4(&pcb->local_ip), ip4_current_dest_addr(), netif_ip4_netmask(inp))) {
000012  6888              LDR      r0,[r1,#8]
000014  4002              ANDS     r2,r2,r0
000016  4003              ANDS     r3,r3,r0
000018  429a              CMP      r2,r3
00001a  d108              BNE      |L6.46|
                  |L6.28|
;;;158              return 1;
00001c  2001              MOVS     r0,#1
;;;159            }
;;;160          }
;;;161        } else
;;;162    #endif /* LWIP_IPV4 */
;;;163        /* Handle IPv4 and IPv6: all or exact match */
;;;164        if (ip_addr_isany(&pcb->local_ip) || ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
;;;165          return 1;
;;;166        }
;;;167      }
;;;168    
;;;169      return 0;
;;;170    }
00001e  4770              BX       lr
                  |L6.32|
000020  b118              CBZ      r0,|L6.42|
000022  6800              LDR      r0,[r0,#0]            ;164
000024  b108              CBZ      r0,|L6.42|
000026  4298              CMP      r0,r3                 ;164
000028  d101              BNE      |L6.46|
                  |L6.42|
00002a  2001              MOVS     r0,#1                 ;165
00002c  4770              BX       lr
                  |L6.46|
00002e  2000              MOVS     r0,#0                 ;169
000030  4770              BX       lr
;;;171    
                          ENDP

000032  0000              DCW      0x0000
                  |L6.52|
                          DCD      ip_data

                          AREA ||i.udp_netif_ip_addr_changed||, CODE, READONLY, ALIGN=2

                  udp_netif_ip_addr_changed PROC
;;;1154    */
;;;1155   void udp_netif_ip_addr_changed(const ip_addr_t* old_addr, const ip_addr_t* new_addr)
000000  b510              PUSH     {r4,lr}
;;;1156   {
;;;1157     struct udp_pcb* upcb;
;;;1158   
;;;1159     if (!ip_addr_isany(old_addr) && !ip_addr_isany(new_addr)) {
000002  2800              CMP      r0,#0
000004  d013              BEQ      |L7.46|
000006  6802              LDR      r2,[r0,#0]
000008  2a00              CMP      r2,#0
00000a  d010              BEQ      |L7.46|
00000c  2900              CMP      r1,#0
00000e  d00e              BEQ      |L7.46|
000010  680a              LDR      r2,[r1,#0]
000012  2a00              CMP      r2,#0
000014  d00b              BEQ      |L7.46|
;;;1160       for (upcb = udp_pcbs; upcb != NULL; upcb = upcb->next) {
000016  4a06              LDR      r2,|L7.48|
000018  6852              LDR      r2,[r2,#4]  ; udp_pcbs
00001a  e006              B        |L7.42|
                  |L7.28|
;;;1161         /* PCB bound to current local interface address? */
;;;1162         if (ip_addr_cmp(&upcb->local_ip, old_addr)) {
00001c  6813              LDR      r3,[r2,#0]
00001e  6804              LDR      r4,[r0,#0]
000020  42a3              CMP      r3,r4
000022  d101              BNE      |L7.40|
;;;1163           /* The PCB is bound to the old ipaddr and
;;;1164            * is set to bound to the new one instead */
;;;1165           ip_addr_copy(upcb->local_ip, *new_addr);
000024  680b              LDR      r3,[r1,#0]
000026  6013              STR      r3,[r2,#0]
                  |L7.40|
000028  68d2              LDR      r2,[r2,#0xc]          ;1160
                  |L7.42|
00002a  2a00              CMP      r2,#0                 ;1160
00002c  d1f6              BNE      |L7.28|
                  |L7.46|
;;;1166         }
;;;1167       }
;;;1168     }
;;;1169   }
00002e  bd10              POP      {r4,pc}
;;;1170   
                          ENDP

                  |L7.48|
                          DCD      ||.data||

                          AREA ||i.udp_new||, CODE, READONLY, ALIGN=1

                  udp_new PROC
;;;1102   struct udp_pcb *
;;;1103   udp_new(void)
000000  b510              PUSH     {r4,lr}
;;;1104   {
;;;1105     struct udp_pcb *pcb;
;;;1106     pcb = (struct udp_pcb *)memp_malloc(MEMP_UDP_PCB);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       memp_malloc
000008  4604              MOV      r4,r0
;;;1107     /* could allocate UDP PCB? */
;;;1108     if (pcb != NULL) {
00000a  b12c              CBZ      r4,|L8.24|
;;;1109       /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
;;;1110        * which means checksum is generated over the whole datagram per default
;;;1111        * (recommended as default by RFC 3828). */
;;;1112       /* initialize PCB to all zeroes */
;;;1113       memset(pcb, 0, sizeof(struct udp_pcb));
00000c  2120              MOVS     r1,#0x20
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       __aeabi_memclr4
;;;1114       pcb->ttl = UDP_TTL;
000014  20ff              MOVS     r0,#0xff
000016  72a0              STRB     r0,[r4,#0xa]
                  |L8.24|
;;;1115   #if LWIP_MULTICAST_TX_OPTIONS
;;;1116       udp_set_multicast_ttl(pcb, UDP_TTL);
;;;1117   #endif /* LWIP_MULTICAST_TX_OPTIONS */
;;;1118     }
;;;1119     return pcb;
000018  4620              MOV      r0,r4
;;;1120   }
00001a  bd10              POP      {r4,pc}
;;;1121   
                          ENDP


                          AREA ||i.udp_new_ip_type||, CODE, READONLY, ALIGN=1

                  udp_new_ip_type PROC
;;;1134   struct udp_pcb *
;;;1135   udp_new_ip_type(u8_t type)
000000  f7ffbffe          B.W      udp_new
;;;1136   {
;;;1137     struct udp_pcb *pcb;
;;;1138     pcb = udp_new();
;;;1139   #if LWIP_IPV4 && LWIP_IPV6
;;;1140     if (pcb != NULL) {
;;;1141       IP_SET_TYPE_VAL(pcb->local_ip,  type);
;;;1142       IP_SET_TYPE_VAL(pcb->remote_ip, type);
;;;1143     }
;;;1144   #else
;;;1145     LWIP_UNUSED_ARG(type);
;;;1146   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1147     return pcb;
;;;1148   }
;;;1149   
                          ENDP


                          AREA ||i.udp_new_port||, CODE, READONLY, ALIGN=2

                  udp_new_port PROC
;;;99     static u16_t
;;;100    udp_new_port(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;101    {
;;;102      u16_t n = 0;
000002  2100              MOVS     r1,#0
;;;103      struct udp_pcb *pcb;
;;;104    
;;;105    again:
;;;106      if (udp_port++ == UDP_LOCAL_PORT_RANGE_END) {
000004  4d0f              LDR      r5,|L10.68|
000006  f64f76ff          MOV      r6,#0xffff
;;;107        udp_port = UDP_LOCAL_PORT_RANGE_START;
00000a  f44f4740          MOV      r7,#0xc000
;;;108      }
;;;109      /* Check all PCBs. */
;;;110      for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
;;;111        if (pcb->local_port == udp_port) {
;;;112          if (++n > (UDP_LOCAL_PORT_RANGE_END - UDP_LOCAL_PORT_RANGE_START)) {
00000e  686c              LDR      r4,[r5,#4]
000010  f44f4c80          MOV      r12,#0x4000
                  |L10.20|
000014  8828              LDRH     r0,[r5,#0]            ;106  ; udp_port
000016  1c42              ADDS     r2,r0,#1              ;106
000018  802a              STRH     r2,[r5,#0]            ;106
00001a  42b0              CMP      r0,r6                 ;106
00001c  d100              BNE      |L10.32|
00001e  802f              STRH     r7,[r5,#0]            ;107
                  |L10.32|
000020  4620              MOV      r0,r4                 ;110
000022  882a              LDRH     r2,[r5,#0]            ;106
000024  e009              B        |L10.58|
                  |L10.38|
000026  8a43              LDRH     r3,[r0,#0x12]         ;111
000028  4293              CMP      r3,r2                 ;111
00002a  d105              BNE      |L10.56|
00002c  1c49              ADDS     r1,r1,#1
00002e  b289              UXTH     r1,r1
000030  4561              CMP      r1,r12
000032  d3ef              BCC      |L10.20|
;;;113            return 0;
000034  2000              MOVS     r0,#0
;;;114          }
;;;115          goto again;
;;;116        }
;;;117      }
;;;118      return udp_port;
;;;119    }
000036  bdf0              POP      {r4-r7,pc}
                  |L10.56|
000038  68c0              LDR      r0,[r0,#0xc]          ;110
                  |L10.58|
00003a  2800              CMP      r0,#0                 ;110
00003c  d1f3              BNE      |L10.38|
00003e  8828              LDRH     r0,[r5,#0]            ;118  ; udp_port
000040  bdf0              POP      {r4-r7,pc}
;;;120    
                          ENDP

000042  0000              DCW      0x0000
                  |L10.68|
                          DCD      ||.data||

                          AREA ||i.udp_recv||, CODE, READONLY, ALIGN=1

                  udp_recv PROC
;;;1052   void
;;;1053   udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg)
000000  6181              STR      r1,[r0,#0x18]
;;;1054   {
;;;1055     /* remember recv() callback and user data */
;;;1056     pcb->recv = recv;
;;;1057     pcb->recv_arg = recv_arg;
000002  61c2              STR      r2,[r0,#0x1c]
;;;1058   }
000004  4770              BX       lr
;;;1059   
                          ENDP


                          AREA ||i.udp_remove||, CODE, READONLY, ALIGN=2

                  udp_remove PROC
;;;1069   void
;;;1070   udp_remove(struct udp_pcb *pcb)
000000  490a              LDR      r1,|L12.44|
;;;1071   {
;;;1072     struct udp_pcb *pcb2;
;;;1073   
;;;1074     mib2_udp_unbind(pcb);
;;;1075     /* pcb to be removed is first in list? */
;;;1076     if (udp_pcbs == pcb) {
000002  684a              LDR      r2,[r1,#4]  ; udp_pcbs
000004  4282              CMP      r2,r0
000006  d10a              BNE      |L12.30|
;;;1077       /* make list start at 2nd pcb */
;;;1078       udp_pcbs = udp_pcbs->next;
000008  68d2              LDR      r2,[r2,#0xc]
00000a  604a              STR      r2,[r1,#4]  ; udp_pcbs
00000c  e009              B        |L12.34|
                  |L12.14|
;;;1079       /* pcb not 1st in list */
;;;1080     } else {
;;;1081       for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
;;;1082         /* find pcb in udp_pcbs list */
;;;1083         if (pcb2->next != NULL && pcb2->next == pcb) {
00000e  68d3              LDR      r3,[r2,#0xc]
000010  b123              CBZ      r3,|L12.28|
000012  4283              CMP      r3,r0
000014  d102              BNE      |L12.28|
;;;1084           /* remove pcb from list */
;;;1085           pcb2->next = pcb->next;
000016  68c1              LDR      r1,[r0,#0xc]
000018  60d1              STR      r1,[r2,#0xc]
;;;1086           break;
00001a  e002              B        |L12.34|
                  |L12.28|
00001c  461a              MOV      r2,r3                 ;1081
                  |L12.30|
00001e  2a00              CMP      r2,#0                 ;1081
000020  d1f5              BNE      |L12.14|
                  |L12.34|
;;;1087         }
;;;1088       }
;;;1089     }
;;;1090     memp_free(MEMP_UDP_PCB, pcb);
000022  4601              MOV      r1,r0
000024  2000              MOVS     r0,#0
000026  f7ffbffe          B.W      memp_free
;;;1091   }
;;;1092   
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      ||.data||

                          AREA ||i.udp_send||, CODE, READONLY, ALIGN=1

                  udp_send PROC
;;;454    err_t
;;;455    udp_send(struct udp_pcb *pcb, struct pbuf *p)
000000  2800              CMP      r0,#0
;;;456    {
000002  d003              BEQ      |L13.12|
;;;457      if ((pcb == NULL) || IP_IS_ANY_TYPE_VAL(pcb->remote_ip)) {
;;;458        return ERR_VAL;
;;;459      }
;;;460    
;;;461      /* send to the packet using remote ip and port stored in the pcb */
;;;462      return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
000004  8a83              LDRH     r3,[r0,#0x14]
000006  1d02              ADDS     r2,r0,#4
000008  f7ffbffe          B.W      udp_sendto
                  |L13.12|
00000c  f06f0005          MVN      r0,#5                 ;458
;;;463    }
000010  4770              BX       lr
;;;464    
                          ENDP


                          AREA ||i.udp_sendto||, CODE, READONLY, ALIGN=1

                  udp_sendto PROC
;;;501    err_t
;;;502    udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
000000  b5f8              PUSH     {r3-r7,lr}
;;;503      const ip_addr_t *dst_ip, u16_t dst_port)
;;;504    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
000008  461f              MOV      r7,r3
;;;505    #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
;;;506      return udp_sendto_chksum(pcb, p, dst_ip, dst_port, 0, 0);
;;;507    }
;;;508    
;;;509    /** @ingroup udp_raw
;;;510     * Same as udp_sendto(), but with checksum */
;;;511    err_t
;;;512    udp_sendto_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
;;;513                      u16_t dst_port, u8_t have_chksum, u16_t chksum)
;;;514    {
;;;515    #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
;;;516      struct netif *netif;
;;;517      const ip_addr_t *dst_ip_route = dst_ip;
00000a  4620              MOV      r0,r4
;;;518    
;;;519      if ((pcb == NULL) || (dst_ip == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
00000c  2d00              CMP      r5,#0
00000e  d00b              BEQ      |L14.40|
000010  b154              CBZ      r4,|L14.40|
;;;520        return ERR_VAL;
;;;521      }
;;;522    
;;;523      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send\n"));
;;;524    
;;;525    #if LWIP_IPV6 || (LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS)
;;;526      if (ip_addr_ismulticast(dst_ip_route)) {
;;;527    #if LWIP_IPV6
;;;528        if (IP_IS_V6(dst_ip)) {
;;;529          /* For multicast, find a netif based on source address. */
;;;530          dst_ip_route = &pcb->local_ip;
;;;531        } else
;;;532    #endif /* LWIP_IPV6 */
;;;533        {
;;;534    #if LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS
;;;535          /* IPv4 does not use source-based routing by default, so we use an
;;;536             administratively selected interface for multicast by default.
;;;537             However, this can be overridden by setting an interface address
;;;538             in pcb->multicast_ip that is used for routing. */
;;;539          if (!ip_addr_isany_val(pcb->multicast_ip) &&
;;;540              !ip4_addr_cmp(ip_2_ip4(&pcb->multicast_ip), IP4_ADDR_BROADCAST)) {
;;;541            dst_ip_route = &pcb->multicast_ip;
;;;542          }
;;;543    #endif /* LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS */
;;;544        }
;;;545      }
;;;546    #endif /* LWIP_IPV6 || (LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS) */
;;;547    
;;;548      /* find the outgoing network interface for this packet */
;;;549      if(IP_IS_ANY_TYPE_VAL(pcb->local_ip)) {
;;;550        /* Don't call ip_route() with IP_ANY_TYPE */
;;;551        netif = ip_route(IP46_ADDR_ANY(IP_GET_TYPE(dst_ip_route)), dst_ip_route);
;;;552      } else {
;;;553        netif = ip_route(&pcb->local_ip, dst_ip_route);
000012  f7fffffe          BL       ip4_route
;;;554      }
;;;555    
;;;556      /* no outgoing network interface could be found? */
;;;557      if (netif == NULL) {
000016  b150              CBZ      r0,|L14.46|
;;;558        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: No route to "));
;;;559        ip_addr_debug_print(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, dst_ip);
;;;560        LWIP_DEBUGF(UDP_DEBUG, ("\n"));
;;;561        UDP_STATS_INC(udp.rterr);
;;;562        return ERR_RTE;
;;;563      }
;;;564    #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
;;;565      return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum);
;;;566    #else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
;;;567      return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
000018  9000              STR      r0,[sp,#0]
00001a  463b              MOV      r3,r7
00001c  4622              MOV      r2,r4
00001e  4631              MOV      r1,r6
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       udp_sendto_if
;;;568    #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
;;;569    }
000026  bdf8              POP      {r3-r7,pc}
                  |L14.40|
000028  f06f0005          MVN      r0,#5                 ;520
00002c  bdf8              POP      {r3-r7,pc}
                  |L14.46|
00002e  f06f0003          MVN      r0,#3                 ;562
000032  bdf8              POP      {r3-r7,pc}
;;;570    
                          ENDP


                          AREA ||i.udp_sendto_if||, CODE, READONLY, ALIGN=1

                  udp_sendto_if PROC
;;;591    err_t
;;;592    udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
000000  b57c              PUSH     {r2-r6,lr}
;;;593      const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif)
;;;594    {
000002  9d06              LDR      r5,[sp,#0x18]
;;;595    #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
;;;596      return udp_sendto_if_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0);
;;;597    }
;;;598    
;;;599    /** Same as udp_sendto_if(), but with checksum */
;;;600    err_t
;;;601    udp_sendto_if_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
;;;602                         u16_t dst_port, struct netif *netif, u8_t have_chksum,
;;;603                         u16_t chksum)
;;;604    {
;;;605    #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
;;;606      const ip_addr_t *src_ip;
;;;607    
;;;608      if ((pcb == NULL) || (dst_ip == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
000004  2800              CMP      r0,#0
000006  d00c              BEQ      |L15.34|
000008  b15a              CBZ      r2,|L15.34|
;;;609        return ERR_VAL;
;;;610      }
;;;611    
;;;612      /* PCB local address is IP_ANY_ADDR? */
;;;613    #if LWIP_IPV6
;;;614      if (IP_IS_V6(dst_ip)) {
;;;615        if (ip6_addr_isany(ip_2_ip6(&pcb->local_ip))) {
;;;616          src_ip = ip6_select_source_address(netif, ip_2_ip6(dst_ip));
;;;617          if (src_ip == NULL) {
;;;618            /* No suitable source address was found. */
;;;619            return ERR_RTE;
;;;620          }
;;;621        } else {
;;;622          /* use UDP PCB local IPv6 address as source address, if still valid. */
;;;623          if (netif_get_ip6_addr_match(netif, ip_2_ip6(&pcb->local_ip)) < 0) {
;;;624            /* Address isn't valid anymore. */
;;;625            return ERR_RTE;
;;;626          }
;;;627          src_ip = &pcb->local_ip;
;;;628        }
;;;629      }
;;;630    #endif /* LWIP_IPV6 */
;;;631    #if LWIP_IPV4 && LWIP_IPV6
;;;632      else
;;;633    #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;634    #if LWIP_IPV4
;;;635      if (ip4_addr_isany(ip_2_ip4(&pcb->local_ip)) ||
00000a  6804              LDR      r4,[r0,#0]
00000c  b164              CBZ      r4,|L15.40|
;;;636          ip4_addr_ismulticast(ip_2_ip4(&pcb->local_ip))) {
00000e  f3c41603          UBFX     r6,r4,#4,#4
000012  2e0e              CMP      r6,#0xe
000014  d008              BEQ      |L15.40|
;;;637        /* if the local_ip is any or multicast
;;;638         * use the outgoing network interface IP address as source address */
;;;639        src_ip = netif_ip_addr4(netif);
;;;640      } else {
;;;641        /* check if UDP PCB local IP address is correct
;;;642         * this could be an old address if netif->ip_addr has changed */
;;;643        if (!ip4_addr_cmp(ip_2_ip4(&(pcb->local_ip)), netif_ip4_addr(netif))) {
000016  686e              LDR      r6,[r5,#4]
000018  42b4              CMP      r4,r6
00001a  d007              BEQ      |L15.44|
;;;644          /* local_ip doesn't match, drop the packet */
;;;645          return ERR_RTE;
00001c  f06f0003          MVN      r0,#3
;;;646        }
;;;647        /* use UDP PCB local IP address as source address */
;;;648        src_ip = &pcb->local_ip;
;;;649      }
;;;650    #endif /* LWIP_IPV4 */
;;;651    #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
;;;652      return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, have_chksum, chksum, src_ip);
;;;653    #else /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
;;;654      return udp_sendto_if_src(pcb, p, dst_ip, dst_port, netif, src_ip);
;;;655    #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
;;;656    }
000020  bd7c              POP      {r2-r6,pc}
                  |L15.34|
000022  f06f0005          MVN      r0,#5                 ;609
000026  bd7c              POP      {r2-r6,pc}
                  |L15.40|
000028  1d2c              ADDS     r4,r5,#4              ;639
00002a  e000              B        |L15.46|
                  |L15.44|
00002c  4604              MOV      r4,r0                 ;648
                  |L15.46|
00002e  e9cd5400          STRD     r5,r4,[sp,#0]         ;654
000032  f7fffffe          BL       udp_sendto_if_src
000036  bd7c              POP      {r2-r6,pc}
;;;657    
                          ENDP


                          AREA ||i.udp_sendto_if_src||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  udp_sendto_if_src PROC
;;;660    err_t
;;;661    udp_sendto_if_src(struct udp_pcb *pcb, struct pbuf *p,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;662      const ip_addr_t *dst_ip, u16_t dst_port, struct netif *netif, const ip_addr_t *src_ip)
;;;663    {
000004  e9dd9b0c          LDRD     r9,r11,[sp,#0x30]
000008  4605              MOV      r5,r0
00000a  460f              MOV      r7,r1
00000c  4690              MOV      r8,r2
00000e  469a              MOV      r10,r3
;;;664    #if LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP
;;;665      return udp_sendto_if_src_chksum(pcb, p, dst_ip, dst_port, netif, 0, 0, src_ip);
;;;666    }
;;;667    
;;;668    /** Same as udp_sendto_if_src(), but with checksum */
;;;669    err_t
;;;670    udp_sendto_if_src_chksum(struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *dst_ip,
;;;671                         u16_t dst_port, struct netif *netif, u8_t have_chksum,
;;;672                         u16_t chksum, const ip_addr_t *src_ip)
;;;673    {
;;;674    #endif /* LWIP_CHECKSUM_ON_COPY && CHECKSUM_GEN_UDP */
;;;675      struct udp_hdr *udphdr;
;;;676      err_t err;
;;;677      struct pbuf *q; /* q will be sent down the stack */
;;;678      u8_t ip_proto;
;;;679      u8_t ttl;
;;;680    
;;;681      if ((pcb == NULL) || (dst_ip == NULL) || !IP_ADDR_PCB_VERSION_MATCH(pcb, src_ip) ||
000010  2d00              CMP      r5,#0
000012  d005              BEQ      |L16.32|
000014  f1b80f00          CMP      r8,#0
000018  d002              BEQ      |L16.32|
;;;682          !IP_ADDR_PCB_VERSION_MATCH(pcb, dst_ip)) {
;;;683        return ERR_VAL;
;;;684      }
;;;685    
;;;686    #if LWIP_IPV4 && IP_SOF_BROADCAST
;;;687      /* broadcast filter? */
;;;688      if (!ip_get_option(pcb, SOF_BROADCAST) &&
;;;689    #if LWIP_IPV6
;;;690          IP_IS_V4(dst_ip) &&
;;;691    #endif /* LWIP_IPV6 */
;;;692          ip_addr_isbroadcast(dst_ip, netif)) {
;;;693        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;694          ("udp_sendto_if: SOF_BROADCAST not enabled on pcb %p\n", (void *)pcb));
;;;695        return ERR_VAL;
;;;696      }
;;;697    #endif /* LWIP_IPV4 && IP_SOF_BROADCAST */
;;;698    
;;;699      /* if the PCB is not yet bound to a port, bind it here */
;;;700      if (pcb->local_port == 0) {
00001a  8a6a              LDRH     r2,[r5,#0x12]
00001c  b122              CBZ      r2,|L16.40|
00001e  e009              B        |L16.52|
                  |L16.32|
000020  f06f0005          MVN      r0,#5                 ;683
                  |L16.36|
;;;701        LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_send: not yet bound to a port, binding now\n"));
;;;702        err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
;;;703        if (err != ERR_OK) {
;;;704          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: forced port bind failed\n"));
;;;705          return err;
;;;706        }
;;;707      }
;;;708    
;;;709      /* not enough space to add an UDP header to first pbuf in given p chain? */
;;;710      if (pbuf_header(p, UDP_HLEN)) {
;;;711        /* allocate header in a separate new pbuf */
;;;712        q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
;;;713        /* new header pbuf could not be allocated? */
;;;714        if (q == NULL) {
;;;715          LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("udp_send: could not allocate header\n"));
;;;716          return ERR_MEM;
;;;717        }
;;;718        if (p->tot_len != 0) {
;;;719          /* chain header q in front of given pbuf p (only if p contains data) */
;;;720          pbuf_chain(q, p);
;;;721        }
;;;722        /* first pbuf q points to header pbuf */
;;;723        LWIP_DEBUGF(UDP_DEBUG,
;;;724                    ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
;;;725      } else {
;;;726        /* adding space for header within p succeeded */
;;;727        /* first pbuf q equals given pbuf */
;;;728        q = p;
;;;729        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
;;;730      }
;;;731      LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
;;;732                  (q->len >= sizeof(struct udp_hdr)));
;;;733      /* q now represents the packet to be sent */
;;;734      udphdr = (struct udp_hdr *)q->payload;
;;;735      udphdr->src = lwip_htons(pcb->local_port);
;;;736      udphdr->dest = lwip_htons(dst_port);
;;;737      /* in UDP, 0 checksum means 'no checksum' */
;;;738      udphdr->chksum = 0x0000;
;;;739    
;;;740      /* Multicast Loop? */
;;;741    #if (LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS) || (LWIP_IPV6 && LWIP_IPV6_MLD)
;;;742      if (((pcb->flags & UDP_FLAGS_MULTICAST_LOOP) != 0) && ip_addr_ismulticast(dst_ip)) {
;;;743        q->flags |= PBUF_FLAG_MCASTLOOP;
;;;744      }
;;;745    #endif /* (LWIP_IPV4 && LWIP_MULTICAST_TX_OPTIONS) || (LWIP_IPV6 && LWIP_IPV6_MLD) */
;;;746    
;;;747      LWIP_DEBUGF(UDP_DEBUG, ("udp_send: sending datagram of length %"U16_F"\n", q->tot_len));
;;;748    
;;;749    #if LWIP_UDPLITE
;;;750      /* UDP Lite protocol? */
;;;751      if (pcb->flags & UDP_FLAGS_UDPLITE) {
;;;752        u16_t chklen, chklen_hdr;
;;;753        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE packet length %"U16_F"\n", q->tot_len));
;;;754        /* set UDP message length in UDP header */
;;;755        chklen_hdr = chklen = pcb->chksum_len_tx;
;;;756        if ((chklen < sizeof(struct udp_hdr)) || (chklen > q->tot_len)) {
;;;757          if (chklen != 0) {
;;;758            LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP LITE pcb->chksum_len is illegal: %"U16_F"\n", chklen));
;;;759          }
;;;760          /* For UDP-Lite, checksum length of 0 means checksum
;;;761             over the complete packet. (See RFC 3828 chap. 3.1)
;;;762             At least the UDP-Lite header must be covered by the
;;;763             checksum, therefore, if chksum_len has an illegal
;;;764             value, we generate the checksum over the complete
;;;765             packet to be safe. */
;;;766          chklen_hdr = 0;
;;;767          chklen = q->tot_len;
;;;768        }
;;;769        udphdr->len = lwip_htons(chklen_hdr);
;;;770        /* calculate checksum */
;;;771    #if CHECKSUM_GEN_UDP
;;;772        IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_UDP) {
;;;773    #if LWIP_CHECKSUM_ON_COPY
;;;774          if (have_chksum) {
;;;775            chklen = UDP_HLEN;
;;;776          }
;;;777    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;778          udphdr->chksum = ip_chksum_pseudo_partial(q, IP_PROTO_UDPLITE,
;;;779            q->tot_len, chklen, src_ip, dst_ip);
;;;780    #if LWIP_CHECKSUM_ON_COPY
;;;781          if (have_chksum) {
;;;782            u32_t acc;
;;;783            acc = udphdr->chksum + (u16_t)~(chksum);
;;;784            udphdr->chksum = FOLD_U32T(acc);
;;;785          }
;;;786    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;787    
;;;788          /* chksum zero must become 0xffff, as zero means 'no checksum' */
;;;789          if (udphdr->chksum == 0x0000) {
;;;790            udphdr->chksum = 0xffff;
;;;791          }
;;;792        }
;;;793    #endif /* CHECKSUM_GEN_UDP */
;;;794    
;;;795        ip_proto = IP_PROTO_UDPLITE;
;;;796      } else
;;;797    #endif /* LWIP_UDPLITE */
;;;798      {      /* UDP */
;;;799        LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
;;;800        udphdr->len = lwip_htons(q->tot_len);
;;;801        /* calculate checksum */
;;;802    #if CHECKSUM_GEN_UDP
;;;803        IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_UDP) {
;;;804          /* Checksum is mandatory over IPv6. */
;;;805          if (IP_IS_V6(dst_ip) || (pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
;;;806            u16_t udpchksum;
;;;807    #if LWIP_CHECKSUM_ON_COPY
;;;808            if (have_chksum) {
;;;809              u32_t acc;
;;;810              udpchksum = ip_chksum_pseudo_partial(q, IP_PROTO_UDP,
;;;811                q->tot_len, UDP_HLEN, src_ip, dst_ip);
;;;812              acc = udpchksum + (u16_t)~(chksum);
;;;813              udpchksum = FOLD_U32T(acc);
;;;814            } else
;;;815    #endif /* LWIP_CHECKSUM_ON_COPY */
;;;816            {
;;;817              udpchksum = ip_chksum_pseudo(q, IP_PROTO_UDP, q->tot_len,
;;;818                src_ip, dst_ip);
;;;819            }
;;;820    
;;;821            /* chksum zero must become 0xffff, as zero means 'no checksum' */
;;;822            if (udpchksum == 0x0000) {
;;;823              udpchksum = 0xffff;
;;;824            }
;;;825            udphdr->chksum = udpchksum;
;;;826          }
;;;827        }
;;;828    #endif /* CHECKSUM_GEN_UDP */
;;;829        ip_proto = IP_PROTO_UDP;
;;;830      }
;;;831    
;;;832      /* Determine TTL to use */
;;;833    #if LWIP_MULTICAST_TX_OPTIONS
;;;834      ttl = (ip_addr_ismulticast(dst_ip) ? udp_get_multicast_ttl(pcb) : pcb->ttl);
;;;835    #else /* LWIP_MULTICAST_TX_OPTIONS */
;;;836      ttl = pcb->ttl;
;;;837    #endif /* LWIP_MULTICAST_TX_OPTIONS */
;;;838    
;;;839      LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP checksum 0x%04"X16_F"\n", udphdr->chksum));
;;;840      LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,0x%02"X16_F",)\n", (u16_t)ip_proto));
;;;841      /* output to IP */
;;;842      NETIF_SET_HWADDRHINT(netif, &(pcb->addr_hint));
;;;843      err = ip_output_if_src(q, src_ip, dst_ip, ttl, pcb->tos, ip_proto, netif);
;;;844      NETIF_SET_HWADDRHINT(netif, NULL);
;;;845    
;;;846      /* @todo: must this be increased even if error occurred? */
;;;847      MIB2_STATS_INC(mib2.udpoutdatagrams);
;;;848    
;;;849      /* did we chain a separate header pbuf earlier? */
;;;850      if (q != p) {
;;;851        /* free the header pbuf */
;;;852        pbuf_free(q);
;;;853        q = NULL;
;;;854        /* p is still referenced by the caller, and will live on */
;;;855      }
;;;856    
;;;857      UDP_STATS_INC(udp.xmit);
;;;858      return err;
;;;859    }
000024  e8bd8ffe          POP      {r1-r11,pc}
                  |L16.40|
000028  4629              MOV      r1,r5                 ;702
00002a  4628              MOV      r0,r5                 ;702
00002c  f7fffffe          BL       udp_bind
000030  2800              CMP      r0,#0                 ;703
000032  d1f7              BNE      |L16.36|
                  |L16.52|
000034  2108              MOVS     r1,#8                 ;710
000036  4638              MOV      r0,r7                 ;710
000038  f7fffffe          BL       pbuf_header
00003c  b188              CBZ      r0,|L16.98|
00003e  2200              MOVS     r2,#0                 ;712
000040  2108              MOVS     r1,#8                 ;712
000042  2001              MOVS     r0,#1                 ;712
000044  f7fffffe          BL       pbuf_alloc
000048  4604              MOV      r4,r0                 ;712
00004a  0020              MOVS     r0,r4                 ;714
00004c  d006              BEQ      |L16.92|
00004e  8938              LDRH     r0,[r7,#8]            ;718
000050  b140              CBZ      r0,|L16.100|
000052  4639              MOV      r1,r7                 ;720
000054  4620              MOV      r0,r4                 ;720
000056  f7fffffe          BL       pbuf_chain
00005a  e003              B        |L16.100|
                  |L16.92|
00005c  f04f30ff          MOV      r0,#0xffffffff        ;716
000060  e7e0              B        |L16.36|
                  |L16.98|
000062  463c              MOV      r4,r7                 ;728
                  |L16.100|
000064  8960              LDRH     r0,[r4,#0xa]          ;731
000066  2808              CMP      r0,#8                 ;731
000068  d206              BCS      |L16.120|
00006a  a314              ADR      r3,|L16.188|
00006c  f24022db          MOV      r2,#0x2db             ;731
000070  a11e              ADR      r1,|L16.236|
000072  a02a              ADR      r0,|L16.284|
000074  f7fffffe          BL       __2printf
                  |L16.120|
000078  6866              LDR      r6,[r4,#4]            ;734
00007a  8a68              LDRH     r0,[r5,#0x12]         ;735
00007c  f7fffffe          BL       lwip_htons
000080  8030              STRH     r0,[r6,#0]            ;735
000082  4650              MOV      r0,r10                ;736
000084  f7fffffe          BL       lwip_htons
000088  8070              STRH     r0,[r6,#2]            ;736
00008a  2000              MOVS     r0,#0                 ;738
00008c  80f0              STRH     r0,[r6,#6]            ;738
00008e  8920              LDRH     r0,[r4,#8]            ;800
000090  f7fffffe          BL       lwip_htons
000094  80b0              STRH     r0,[r6,#4]            ;800
000096  2011              MOVS     r0,#0x11              ;829
000098  7aab              LDRB     r3,[r5,#0xa]          ;836
00009a  7a69              LDRB     r1,[r5,#9]            ;843
00009c  e9cd0901          STRD     r0,r9,[sp,#4]         ;843
0000a0  9100              STR      r1,[sp,#0]            ;843
0000a2  4642              MOV      r2,r8                 ;843
0000a4  4659              MOV      r1,r11                ;843
0000a6  4620              MOV      r0,r4                 ;843
0000a8  f7fffffe          BL       ip4_output_if_src
0000ac  4605              MOV      r5,r0                 ;843
0000ae  42bc              CMP      r4,r7                 ;850
0000b0  d002              BEQ      |L16.184|
0000b2  4620              MOV      r0,r4                 ;852
0000b4  f7fffffe          BL       pbuf_free
                  |L16.184|
0000b8  4628              MOV      r0,r5                 ;858
0000ba  e7b3              B        |L16.36|
;;;860    
                          ENDP

                  |L16.188|
0000bc  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\udp.c",0
0000c0  6964646c
0000c4  65776172
0000c8  65735c54
0000cc  68697264
0000d0  5f506172
0000d4  74795c4c
0000d8  7749505c
0000dc  7372635c
0000e0  636f7265
0000e4  5c756470
0000e8  2e6300  
0000eb  00                DCB      0
                  |L16.236|
0000ec  63686563          DCB      "check that first pbuf can hold struct udp_hdr",0
0000f0  6b207468
0000f4  61742066
0000f8  69727374
0000fc  20706275
000100  66206361
000104  6e20686f
000108  6c642073
00010c  74727563
000110  74207564
000114  705f6864
000118  7200    
00011a  00                DCB      0
00011b  00                DCB      0
                  |L16.284|
00011c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000120  7274696f
000124  6e202225
000128  73222066
00012c  61696c65
000130  64206174
000134  206c696e
000138  65202564
00013c  20696e20
000140  25730a00

                          AREA ||.data||, DATA, ALIGN=2

                  udp_port
000000  c000              DCW      0xc000
000002  0000              DCB      0x00,0x00
                  udp_pcbs
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\udp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_udp_c_udp_init____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_udp_c_udp_init____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_udp_c_udp_init____REVSH|
#line 478
|__asm___5_udp_c_udp_init____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_udp_c_udp_init____RRX|
#line 665
|__asm___5_udp_c_udp_init____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
