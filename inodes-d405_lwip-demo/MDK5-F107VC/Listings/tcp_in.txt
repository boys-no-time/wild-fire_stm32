; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\tcp_in.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\tcp_in.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\tcp_in.crf ..\Middlewares\Third_Party\LwIP\src\core\tcp_in.c]
                          THUMB

                          AREA ||i.tcp_free_acked_segments||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_free_acked_segments PROC
;;;1087   static struct tcp_seg *
;;;1088   tcp_free_acked_segments(struct tcp_pcb *pcb, struct tcp_seg *seg_list, const char *dbg_list_name,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1089                           struct tcp_seg *dbg_other_seg_list)
;;;1090   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4698              MOV      r8,r3
;;;1091     struct tcp_seg *next;
;;;1092     u16_t clen;
;;;1093   
;;;1094     LWIP_UNUSED_ARG(dbg_list_name);
;;;1095     LWIP_UNUSED_ARG(dbg_other_seg_list);
;;;1096   
;;;1097     while (seg_list != NULL &&
;;;1098            TCP_SEQ_LEQ(lwip_ntohl(seg_list->tcphdr->seqno) +
;;;1099                        TCP_TCPLEN(seg_list), ackno)) {
;;;1100       LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->%s\n",
;;;1101                                     lwip_ntohl(seg_list->tcphdr->seqno),
;;;1102                                     lwip_ntohl(seg_list->tcphdr->seqno) + TCP_TCPLEN(seg_list),
;;;1103                                     dbg_list_name));
;;;1104   
;;;1105       next = seg_list;
;;;1106       seg_list = seg_list->next;
;;;1107   
;;;1108       clen = pbuf_clen(next->p);
;;;1109       LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ",
;;;1110                                    (tcpwnd_size_t)pcb->snd_queuelen));
;;;1111       LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= clen));
;;;1112   
;;;1113       pcb->snd_queuelen = (u16_t)(pcb->snd_queuelen - clen);
;;;1114       recv_acked = (tcpwnd_size_t)(recv_acked + next->len);
00000a  f8df9090          LDR      r9,|L1.156|
00000e  e02b              B        |L1.104|
                  |L1.16|
000010  4626              MOV      r6,r4                 ;1105
000012  6824              LDR      r4,[r4,#0]            ;1106
000014  6870              LDR      r0,[r6,#4]            ;1108
000016  f7fffffe          BL       pbuf_clen
00001a  4607              MOV      r7,r0                 ;1108
00001c  f8b50066          LDRH     r0,[r5,#0x66]         ;1111
000020  42b8              CMP      r0,r7                 ;1111
000022  d206              BCS      |L1.50|
000024  a31e              ADR      r3,|L1.160|
000026  f2404257          MOV      r2,#0x457             ;1111
00002a  a12a              ADR      r1,|L1.212|
00002c  a033              ADR      r0,|L1.252|
00002e  f7fffffe          BL       __2printf
                  |L1.50|
000032  f8350f66          LDRH     r0,[r5,#0x66]!        ;1113
000036  1bc0              SUBS     r0,r0,r7              ;1113
000038  8028              STRH     r0,[r5,#0]            ;1113
00003a  8930              LDRH     r0,[r6,#8]
00003c  f8b91008          LDRH     r1,[r9,#8]  ; recv_acked
000040  4408              ADD      r0,r0,r1
000042  f8a90008          STRH     r0,[r9,#8]
;;;1115       tcp_seg_free(next);
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       tcp_seg_free
;;;1116   
;;;1117       LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"TCPWNDSIZE_F" (after freeing %s)\n",
;;;1118                                    (tcpwnd_size_t)pcb->snd_queuelen,
;;;1119                                    dbg_list_name));
;;;1120       if (pcb->snd_queuelen != 0) {
00004c  f8350966          LDRH     r0,[r5],#-0x66
000050  2800              CMP      r0,#0
000052  d009              BEQ      |L1.104|
;;;1121         LWIP_ASSERT("tcp_receive: valid queue length",
000054  ea540008          ORRS     r0,r4,r8
000058  d106              BNE      |L1.104|
00005a  a311              ADR      r3,|L1.160|
00005c  f2404261          MOV      r2,#0x461
000060  a130              ADR      r1,|L1.292|
000062  a026              ADR      r0,|L1.252|
000064  f7fffffe          BL       __2printf
                  |L1.104|
000068  b1ac              CBZ      r4,|L1.150|
00006a  68e0              LDR      r0,[r4,#0xc]          ;1098
00006c  6840              LDR      r0,[r0,#4]            ;1098
00006e  f7fffffe          BL       lwip_htonl
000072  4606              MOV      r6,r0                 ;1098
000074  68e0              LDR      r0,[r4,#0xc]          ;1098
000076  8980              LDRH     r0,[r0,#0xc]          ;1098
000078  f7fffffe          BL       lwip_htons
00007c  0780              LSLS     r0,r0,#30             ;1098
00007e  d001              BEQ      |L1.132|
000080  2001              MOVS     r0,#1                 ;1098
000082  e000              B        |L1.134|
                  |L1.132|
000084  2000              MOVS     r0,#0                 ;1098
                  |L1.134|
000086  8921              LDRH     r1,[r4,#8]            ;1098
000088  4430              ADD      r0,r0,r6              ;1098
00008a  4408              ADD      r0,r0,r1              ;1098
00008c  f8d91018          LDR      r1,[r9,#0x18]         ;1098  ; ackno
000090  1a40              SUBS     r0,r0,r1              ;1098
000092  2800              CMP      r0,#0                 ;1098
000094  ddbc              BLE      |L1.16|
                  |L1.150|
;;;1122                     seg_list != NULL || dbg_other_seg_list != NULL);
;;;1123       }
;;;1124     }
;;;1125     return seg_list;
000096  4620              MOV      r0,r4
;;;1126   }
000098  e8bd87f0          POP      {r4-r10,pc}
;;;1127   
                          ENDP

                  |L1.156|
                          DCD      ||.data||
                  |L1.160|
0000a0  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_in.c"
0000a4  6964646c
0000a8  65776172
0000ac  65735c54
0000b0  68697264
0000b4  5f506172
0000b8  74795c4c
0000bc  7749505c
0000c0  7372635c
0000c4  636f7265
0000c8  5c746370
0000cc  5f696e2e
0000d0  63      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L1.212|
0000d4  7063622d          DCB      "pcb->snd_queuelen >= pbuf_clen(next->p)",0
0000d8  3e736e64
0000dc  5f717565
0000e0  75656c65
0000e4  6e203e3d
0000e8  20706275
0000ec  665f636c
0000f0  656e286e
0000f4  6578742d
0000f8  3e702900
                  |L1.252|
0000fc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000100  7274696f
000104  6e202225
000108  73222066
00010c  61696c65
000110  64206174
000114  206c696e
000118  65202564
00011c  20696e20
000120  25730a00
                  |L1.292|
000124  7463705f          DCB      "tcp_receive: valid queue length",0
000128  72656365
00012c  6976653a
000130  2076616c
000134  69642071
000138  75657565
00013c  206c656e
000140  67746800

                          AREA ||i.tcp_get_next_optbyte||, CODE, READONLY, ALIGN=2

                  tcp_get_next_optbyte PROC
;;;1887   static u8_t
;;;1888   tcp_get_next_optbyte(void)
000000  4b08              LDR      r3,|L2.36|
;;;1889   {
;;;1890     u16_t optidx = tcp_optidx++;
000002  88d8              LDRH     r0,[r3,#6]  ; tcp_optidx
000004  1c41              ADDS     r1,r0,#1
000006  80d9              STRH     r1,[r3,#6]
;;;1891     if ((tcphdr_opt2 == NULL) || (optidx < tcphdr_opt1len)) {
000008  6919              LDR      r1,[r3,#0x10]  ; tcphdr_opt2
00000a  2900              CMP      r1,#0
00000c  d002              BEQ      |L2.20|
00000e  889a              LDRH     r2,[r3,#4]  ; tcphdr_opt1len
000010  4290              CMP      r0,r2
000012  d203              BCS      |L2.28|
                  |L2.20|
;;;1892       u8_t *opts = (u8_t *)tcphdr + TCP_HLEN;
000014  68d9              LDR      r1,[r3,#0xc]  ; tcphdr
000016  3114              ADDS     r1,r1,#0x14
;;;1893       return opts[optidx];
000018  5c08              LDRB     r0,[r1,r0]
;;;1894     } else {
;;;1895       u8_t idx = (u8_t)(optidx - tcphdr_opt1len);
;;;1896       return tcphdr_opt2[idx];
;;;1897     }
;;;1898   }
00001a  4770              BX       lr
                  |L2.28|
00001c  1a80              SUBS     r0,r0,r2              ;1895
00001e  b2c0              UXTB     r0,r0                 ;1895
000020  5c08              LDRB     r0,[r1,r0]            ;1896
000022  4770              BX       lr
;;;1899   
                          ENDP

                  |L2.36|
                          DCD      ||.data||

                          AREA ||i.tcp_input||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_input PROC
;;;117    void
;;;118    tcp_input(struct pbuf *p, struct netif *inp)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;119    {
000004  4605              MOV      r5,r0
;;;120      struct tcp_pcb *pcb, *prev;
;;;121      struct tcp_pcb_listen *lpcb;
;;;122    #if SO_REUSE
;;;123      struct tcp_pcb *lpcb_prev = NULL;
;;;124      struct tcp_pcb_listen *lpcb_any = NULL;
;;;125    #endif /* SO_REUSE */
;;;126      u8_t hdrlen_bytes;
;;;127      err_t err;
;;;128    
;;;129      LWIP_UNUSED_ARG(inp);
;;;130      LWIP_ASSERT_CORE_LOCKED();
;;;131      LWIP_ASSERT("tcp_input: invalid pbuf", p != NULL);
000006  2d00              CMP      r5,#0
000008  d105              BNE      |L3.22|
00000a  a3e7              ADR      r3,|L3.936|
00000c  2283              MOVS     r2,#0x83
00000e  a1f3              ADR      r1,|L3.988|
000010  a0f8              ADR      r0,|L3.1012|
000012  f7fffffe          BL       __2printf
                  |L3.22|
;;;132    
;;;133      PERF_START;
;;;134    
;;;135      TCP_STATS_INC(tcp.recv);
;;;136      MIB2_STATS_INC(mib2.tcpinsegs);
;;;137    
;;;138      tcphdr = (struct tcp_hdr *)p->payload;
000016  f8df8404          LDR      r8,|L3.1052|
00001a  6868              LDR      r0,[r5,#4]
00001c  f8c8000c          STR      r0,[r8,#0xc]  ; tcphdr
;;;139    
;;;140    #if TCP_INPUT_DEBUG
;;;141      tcp_debug_print(tcphdr);
;;;142    #endif
;;;143    
;;;144      /* Check that TCP header fits in payload */
;;;145      if (p->len < TCP_HLEN) {
000020  8968              LDRH     r0,[r5,#0xa]
000022  2814              CMP      r0,#0x14
                  |L3.36|
000024  d37d              BCC      |L3.290|
;;;146        /* drop short packets */
;;;147        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
;;;148        TCP_STATS_INC(tcp.lenerr);
;;;149        goto dropped;
;;;150      }
;;;151    
;;;152      /* Don't even process incoming broadcasts/multicasts. */
;;;153      if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
000026  4ffe              LDR      r7,|L3.1056|
000028  6839              LDR      r1,[r7,#0]  ; ip_data
00002a  6978              LDR      r0,[r7,#0x14]  ; ip_data
00002c  f7fffffe          BL       ip4_addr_isbroadcast_u32
000030  2800              CMP      r0,#0
000032  d176              BNE      |L3.290|
;;;154          ip_addr_ismulticast(ip_current_dest_addr())) {
000034  7d38              LDRB     r0,[r7,#0x14]  ; ip_data
000036  f3c01003          UBFX     r0,r0,#4,#4
00003a  280e              CMP      r0,#0xe
00003c  d071              BEQ      |L3.290|
;;;155        TCP_STATS_INC(tcp.proterr);
;;;156        goto dropped;
;;;157      }
;;;158    
;;;159    #if CHECKSUM_CHECK_TCP
;;;160      IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_TCP) {
;;;161        /* Verify TCP checksum. */
;;;162        u16_t chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
;;;163                                        ip_current_src_addr(), ip_current_dest_addr());
;;;164        if (chksum != 0) {
;;;165          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
;;;166                                        chksum));
;;;167          tcp_debug_print(tcphdr);
;;;168          TCP_STATS_INC(tcp.chkerr);
;;;169          goto dropped;
;;;170        }
;;;171      }
;;;172    #endif /* CHECKSUM_CHECK_TCP */
;;;173    
;;;174      /* sanity-check header length */
;;;175      hdrlen_bytes = TCPH_HDRLEN_BYTES(tcphdr);
00003e  f8d8000c          LDR      r0,[r8,#0xc]  ; tcphdr
000042  8980              LDRH     r0,[r0,#0xc]
000044  f7fffffe          BL       lwip_htons
000048  0b00              LSRS     r0,r0,#12
00004a  0081              LSLS     r1,r0,#2
;;;176      if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
00004c  2914              CMP      r1,#0x14
00004e  d3e9              BCC      |L3.36|
000050  8928              LDRH     r0,[r5,#8]
000052  4288              CMP      r0,r1
000054  d3e6              BCC      |L3.36|
;;;177        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: invalid header length (%"U16_F")\n", (u16_t)hdrlen_bytes));
;;;178        TCP_STATS_INC(tcp.lenerr);
;;;179        goto dropped;
;;;180      }
;;;181    
;;;182      /* Move the payload pointer in the pbuf so that it points to the
;;;183         TCP data instead of the TCP header. */
;;;184      tcphdr_optlen = (u16_t)(hdrlen_bytes - TCP_HLEN);
000056  f1a10014          SUB      r0,r1,#0x14
00005a  b280              UXTH     r0,r0
00005c  f8a80002          STRH     r0,[r8,#2]
;;;185      tcphdr_opt2 = NULL;
000060  f04f0900          MOV      r9,#0
000064  f8c89010          STR      r9,[r8,#0x10]  ; tcphdr_opt2
;;;186      if (p->len >= hdrlen_bytes) {
000068  896a              LDRH     r2,[r5,#0xa]
00006a  428a              CMP      r2,r1
00006c  d305              BCC      |L3.122|
;;;187        /* all options are in the first pbuf */
;;;188        tcphdr_opt1len = tcphdr_optlen;
00006e  f8a80004          STRH     r0,[r8,#4]
;;;189        pbuf_remove_header(p, hdrlen_bytes); /* cannot fail */
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       pbuf_remove_header
000078  e035              B        |L3.230|
                  |L3.122|
;;;190      } else {
;;;191        u16_t opt2len;
;;;192        /* TCP header fits into first pbuf, options don't - data is in the next pbuf */
;;;193        /* there must be a next pbuf, due to hdrlen_bytes sanity check above */
;;;194        LWIP_ASSERT("p->next != NULL", p->next != NULL);
00007a  6828              LDR      r0,[r5,#0]
00007c  b928              CBNZ     r0,|L3.138|
00007e  a3ca              ADR      r3,|L3.936|
000080  22c2              MOVS     r2,#0xc2
000082  a1e8              ADR      r1,|L3.1060|
000084  a0db              ADR      r0,|L3.1012|
000086  f7fffffe          BL       __2printf
                  |L3.138|
;;;195    
;;;196        /* advance over the TCP header (cannot fail) */
;;;197        pbuf_remove_header(p, TCP_HLEN);
00008a  2114              MOVS     r1,#0x14
00008c  4628              MOV      r0,r5
00008e  f7fffffe          BL       pbuf_remove_header
;;;198    
;;;199        /* determine how long the first and second parts of the options are */
;;;200        tcphdr_opt1len = p->len;
000092  8969              LDRH     r1,[r5,#0xa]
000094  f8a81004          STRH     r1,[r8,#4]
;;;201        opt2len = (u16_t)(tcphdr_optlen - tcphdr_opt1len);
000098  f8b80002          LDRH     r0,[r8,#2]  ; tcphdr_optlen
00009c  1a40              SUBS     r0,r0,r1
00009e  b284              UXTH     r4,r0
;;;202    
;;;203        /* options continue in the next pbuf: set p to zero length and hide the
;;;204            options in the next pbuf (adjusting p->tot_len) */
;;;205        pbuf_remove_header(p, tcphdr_opt1len);
0000a0  4628              MOV      r0,r5
0000a2  f7fffffe          BL       pbuf_remove_header
;;;206    
;;;207        /* check that the options fit in the second pbuf */
;;;208        if (opt2len > p->next->len) {
0000a6  6828              LDR      r0,[r5,#0]
0000a8  8941              LDRH     r1,[r0,#0xa]
0000aa  42a1              CMP      r1,r4
0000ac  d3ba              BCC      |L3.36|
;;;209          /* drop short packets */
;;;210          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: options overflow second pbuf (%"U16_F" bytes)\n", p->next->len));
;;;211          TCP_STATS_INC(tcp.lenerr);
;;;212          goto dropped;
;;;213        }
;;;214    
;;;215        /* remember the pointer to the second part of the options */
;;;216        tcphdr_opt2 = (u8_t *)p->next->payload;
0000ae  6841              LDR      r1,[r0,#4]
0000b0  f8c81010          STR      r1,[r8,#0x10]  ; tcphdr_opt2
;;;217    
;;;218        /* advance p->next to point after the options, and manually
;;;219            adjust p->tot_len to keep it consistent with the changed p->next */
;;;220        pbuf_remove_header(p->next, opt2len);
0000b4  4621              MOV      r1,r4
0000b6  f7fffffe          BL       pbuf_remove_header
;;;221        p->tot_len = (u16_t)(p->tot_len - opt2len);
0000ba  8928              LDRH     r0,[r5,#8]
0000bc  1b00              SUBS     r0,r0,r4
0000be  8128              STRH     r0,[r5,#8]
;;;222    
;;;223        LWIP_ASSERT("p->len == 0", p->len == 0);
0000c0  8968              LDRH     r0,[r5,#0xa]
0000c2  b128              CBZ      r0,|L3.208|
0000c4  a3b8              ADR      r3,|L3.936|
0000c6  22df              MOVS     r2,#0xdf
0000c8  a1da              ADR      r1,|L3.1076|
0000ca  a0ca              ADR      r0,|L3.1012|
0000cc  f7fffffe          BL       __2printf
                  |L3.208|
;;;224        LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
0000d0  6828              LDR      r0,[r5,#0]
0000d2  8929              LDRH     r1,[r5,#8]
0000d4  8900              LDRH     r0,[r0,#8]
0000d6  4281              CMP      r1,r0
0000d8  d005              BEQ      |L3.230|
0000da  a3b3              ADR      r3,|L3.936|
0000dc  22e0              MOVS     r2,#0xe0
0000de  a1d8              ADR      r1,|L3.1088|
0000e0  a0c4              ADR      r0,|L3.1012|
0000e2  f7fffffe          BL       __2printf
                  |L3.230|
;;;225      }
;;;226    
;;;227      /* Convert fields in TCP header to host byte order. */
;;;228      tcphdr->src = lwip_ntohs(tcphdr->src);
0000e6  f8d8000c          LDR      r0,[r8,#0xc]  ; tcphdr
0000ea  8800              LDRH     r0,[r0,#0]
0000ec  f7fffffe          BL       lwip_htons
0000f0  4601              MOV      r1,r0
0000f2  f8d8000c          LDR      r0,[r8,#0xc]  ; tcphdr
0000f6  8001              STRH     r1,[r0,#0]
;;;229      tcphdr->dest = lwip_ntohs(tcphdr->dest);
0000f8  8840              LDRH     r0,[r0,#2]
0000fa  f7fffffe          BL       lwip_htons
0000fe  4601              MOV      r1,r0
000100  f8d8000c          LDR      r0,[r8,#0xc]  ; tcphdr
000104  8041              STRH     r1,[r0,#2]
;;;230      seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
000106  6840              LDR      r0,[r0,#4]
000108  f7fffffe          BL       lwip_htonl
00010c  4601              MOV      r1,r0
00010e  f8d8000c          LDR      r0,[r8,#0xc]  ; tcphdr
000112  6041              STR      r1,[r0,#4]
000114  f8c81014          STR      r1,[r8,#0x14]  ; seqno
;;;231      ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
000118  6880              LDR      r0,[r0,#8]
00011a  f7fffffe          BL       lwip_htonl
00011e  4601              MOV      r1,r0
000120  e000              B        |L3.292|
                  |L3.290|
000122  e09b              B        |L3.604|
                  |L3.292|
000124  f8d8000c          LDR      r0,[r8,#0xc]  ; tcphdr
000128  6081              STR      r1,[r0,#8]
00012a  f8c81018          STR      r1,[r8,#0x18]  ; ackno
;;;232      tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
00012e  89c0              LDRH     r0,[r0,#0xe]
000130  f7fffffe          BL       lwip_htons
000134  4601              MOV      r1,r0
000136  f8d8000c          LDR      r0,[r8,#0xc]  ; tcphdr
00013a  81c1              STRH     r1,[r0,#0xe]
;;;233    
;;;234      flags = TCPH_FLAGS(tcphdr);
00013c  8980              LDRH     r0,[r0,#0xc]
00013e  f7fffffe          BL       lwip_htons
000142  f000013f          AND      r1,r0,#0x3f
000146  f8881000          STRB     r1,[r8,#0]
;;;235      tcplen = p->tot_len;
00014a  8928              LDRH     r0,[r5,#8]
00014c  f8a8000a          STRH     r0,[r8,#0xa]
;;;236      if (flags & (TCP_FIN | TCP_SYN)) {
000150  0789              LSLS     r1,r1,#30
000152  d005              BEQ      |L3.352|
;;;237        tcplen++;
000154  1c41              ADDS     r1,r0,#1
000156  b289              UXTH     r1,r1
000158  f8a8100a          STRH     r1,[r8,#0xa]
;;;238        if (tcplen < p->tot_len) {
00015c  4288              CMP      r0,r1
00015e  d87d              BHI      |L3.604|
                  |L3.352|
;;;239          /* u16_t overflow, cannot handle this */
;;;240          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: length u16_t overflow, cannot handle this\n"));
;;;241          TCP_STATS_INC(tcp.lenerr);
;;;242          goto dropped;
;;;243        }
;;;244      }
;;;245    
;;;246      /* Demultiplex an incoming segment. First, we check if it is destined
;;;247         for an active connection. */
;;;248      prev = NULL;
000160  2600              MOVS     r6,#0
;;;249    
;;;250      for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000162  f8dfa2fc          LDR      r10,|L3.1120|
000166  f8da4000          LDR      r4,[r10,#0]  ; tcp_active_pcbs
00016a  e055              B        |L3.536|
                  |L3.364|
;;;251        LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
00016c  7d20              LDRB     r0,[r4,#0x14]
00016e  b928              CBNZ     r0,|L3.380|
000170  a38d              ADR      r3,|L3.936|
000172  22fb              MOVS     r2,#0xfb
000174  a1bb              ADR      r1,|L3.1124|
000176  a09f              ADR      r0,|L3.1012|
000178  f7fffffe          BL       __2printf
                  |L3.380|
;;;252        LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
00017c  7d20              LDRB     r0,[r4,#0x14]
00017e  280a              CMP      r0,#0xa
000180  d105              BNE      |L3.398|
000182  a389              ADR      r3,|L3.936|
000184  22fc              MOVS     r2,#0xfc
000186  a1c1              ADR      r1,|L3.1164|
000188  a09a              ADR      r0,|L3.1012|
00018a  f7fffffe          BL       __2printf
                  |L3.398|
;;;253        LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
00018e  7d20              LDRB     r0,[r4,#0x14]
000190  2801              CMP      r0,#1
000192  d105              BNE      |L3.416|
000194  a384              ADR      r3,|L3.936|
000196  22fd              MOVS     r2,#0xfd
000198  a1c7              ADR      r1,|L3.1208|
00019a  a096              ADR      r0,|L3.1012|
00019c  f7fffffe          BL       __2printf
                  |L3.416|
;;;254    
;;;255        /* check if PCB is bound to specific netif */
;;;256        if ((pcb->netif_idx != NETIF_NO_INDEX) &&
0001a0  7a20              LDRB     r0,[r4,#8]
0001a2  b140              CBZ      r0,|L3.438|
;;;257            (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
0001a4  6879              LDR      r1,[r7,#4]  ; ip_data
0001a6  f8911038          LDRB     r1,[r1,#0x38]
0001aa  1c49              ADDS     r1,r1,#1
0001ac  b2c9              UXTB     r1,r1
0001ae  4288              CMP      r0,r1
0001b0  d001              BEQ      |L3.438|
;;;258          prev = pcb;
0001b2  4626              MOV      r6,r4
;;;259          continue;
0001b4  e02f              B        |L3.534|
                  |L3.438|
;;;260        }
;;;261    
;;;262        if (pcb->remote_port == tcphdr->src &&
0001b6  f8d8000c          LDR      r0,[r8,#0xc]  ; tcphdr
0001ba  8b21              LDRH     r1,[r4,#0x18]
0001bc  8802              LDRH     r2,[r0,#0]
0001be  4291              CMP      r1,r2
0001c0  d128              BNE      |L3.532|
;;;263            pcb->local_port == tcphdr->dest &&
0001c2  8ae1              LDRH     r1,[r4,#0x16]
0001c4  8840              LDRH     r0,[r0,#2]
0001c6  4281              CMP      r1,r0
0001c8  d124              BNE      |L3.532|
;;;264            ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
0001ca  6860              LDR      r0,[r4,#4]
0001cc  6939              LDR      r1,[r7,#0x10]  ; ip_data
0001ce  4288              CMP      r0,r1
0001d0  d120              BNE      |L3.532|
;;;265            ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
0001d2  6820              LDR      r0,[r4,#0]
0001d4  6979              LDR      r1,[r7,#0x14]  ; ip_data
0001d6  4288              CMP      r0,r1
0001d8  d11c              BNE      |L3.532|
;;;266          /* Move this PCB to the front of the list so that subsequent
;;;267             lookups will be faster (we exploit locality in TCP segment
;;;268             arrivals). */
;;;269          LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
0001da  68e0              LDR      r0,[r4,#0xc]
0001dc  42a0              CMP      r0,r4
0001de  d106              BNE      |L3.494|
0001e0  a371              ADR      r3,|L3.936|
0001e2  f240120d          MOV      r2,#0x10d
0001e6  a1be              ADR      r1,|L3.1248|
0001e8  a082              ADR      r0,|L3.1012|
0001ea  f7fffffe          BL       __2printf
                  |L3.494|
;;;270          if (prev != NULL) {
0001ee  b136              CBZ      r6,|L3.510|
;;;271            prev->next = pcb->next;
0001f0  68e0              LDR      r0,[r4,#0xc]
0001f2  60f0              STR      r0,[r6,#0xc]
;;;272            pcb->next = tcp_active_pcbs;
0001f4  f8da0000          LDR      r0,[r10,#0]  ; tcp_active_pcbs
0001f8  60e0              STR      r0,[r4,#0xc]
;;;273            tcp_active_pcbs = pcb;
0001fa  f8ca4000          STR      r4,[r10,#0]  ; tcp_active_pcbs
                  |L3.510|
;;;274          } else {
;;;275            TCP_STATS_INC(tcp.cachehit);
;;;276          }
;;;277          LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
0001fe  68e0              LDR      r0,[r4,#0xc]
000200  42a0              CMP      r0,r4
000202  d10b              BNE      |L3.540|
000204  a368              ADR      r3,|L3.936|
000206  f2401215          MOV      r2,#0x115
00020a  a1c0              ADR      r1,|L3.1292|
00020c  a079              ADR      r0,|L3.1012|
00020e  f7fffffe          BL       __2printf
000212  e003              B        |L3.540|
                  |L3.532|
;;;278          break;
;;;279        }
;;;280        prev = pcb;
000214  4626              MOV      r6,r4
                  |L3.534|
000216  68e4              LDR      r4,[r4,#0xc]          ;250
                  |L3.536|
000218  2c00              CMP      r4,#0                 ;250
00021a  d1a7              BNE      |L3.364|
                  |L3.540|
;;;281      }
;;;282    
;;;283      if (pcb == NULL) {
00021c  2c00              CMP      r4,#0
00021e  d168              BNE      |L3.754|
;;;284        /* If it did not go to an active connection, we check the connections
;;;285           in the TIME-WAIT state. */
;;;286        for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
000220  48c5              LDR      r0,|L3.1336|
000222  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
000224  e02f              B        |L3.646|
                  |L3.550|
;;;287          LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
000226  7d20              LDRB     r0,[r4,#0x14]
000228  280a              CMP      r0,#0xa
00022a  d006              BEQ      |L3.570|
00022c  a35e              ADR      r3,|L3.936|
00022e  f240121f          MOV      r2,#0x11f
000232  a1c2              ADR      r1,|L3.1340|
000234  a06f              ADR      r0,|L3.1012|
000236  f7fffffe          BL       __2printf
                  |L3.570|
;;;288    
;;;289          /* check if PCB is bound to specific netif */
;;;290          if ((pcb->netif_idx != NETIF_NO_INDEX) &&
00023a  7a20              LDRB     r0,[r4,#8]
00023c  b130              CBZ      r0,|L3.588|
;;;291              (pcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
00023e  6879              LDR      r1,[r7,#4]  ; ip_data
000240  f8911038          LDRB     r1,[r1,#0x38]
000244  1c49              ADDS     r1,r1,#1
000246  b2c9              UXTB     r1,r1
000248  4288              CMP      r0,r1
00024a  d11b              BNE      |L3.644|
                  |L3.588|
;;;292            continue;
;;;293          }
;;;294    
;;;295          if (pcb->remote_port == tcphdr->src &&
00024c  f8d8000c          LDR      r0,[r8,#0xc]  ; tcphdr
000250  8b21              LDRH     r1,[r4,#0x18]
000252  8802              LDRH     r2,[r0,#0]
000254  4291              CMP      r1,r2
000256  d115              BNE      |L3.644|
;;;296              pcb->local_port == tcphdr->dest &&
000258  8ae1              LDRH     r1,[r4,#0x16]
00025a  e000              B        |L3.606|
                  |L3.604|
00025c  e210              B        |L3.1664|
                  |L3.606|
00025e  8840              LDRH     r0,[r0,#2]
000260  4281              CMP      r1,r0
000262  d10f              BNE      |L3.644|
;;;297              ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
000264  6860              LDR      r0,[r4,#4]
000266  6939              LDR      r1,[r7,#0x10]  ; ip_data
000268  4288              CMP      r0,r1
00026a  d10b              BNE      |L3.644|
;;;298              ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
00026c  6820              LDR      r0,[r4,#0]
00026e  6979              LDR      r1,[r7,#0x14]  ; ip_data
000270  4288              CMP      r0,r1
000272  d107              BNE      |L3.644|
;;;299            /* We don't really care enough to move this PCB to the front
;;;300               of the list since we are not very likely to receive that
;;;301               many segments for connections in TIME-WAIT. */
;;;302            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
;;;303    #ifdef LWIP_HOOK_TCP_INPACKET_PCB
;;;304            if (LWIP_HOOK_TCP_INPACKET_PCB(pcb, tcphdr, tcphdr_optlen, tcphdr_opt1len,
;;;305                                           tcphdr_opt2, p) == ERR_OK)
;;;306    #endif
;;;307            {
;;;308              tcp_timewait_input(pcb);
000274  4620              MOV      r0,r4
000276  f7fffffe          BL       tcp_timewait_input
;;;309            }
;;;310            pbuf_free(p);
00027a  4628              MOV      r0,r5
00027c  e8bd4ffe          POP      {r1-r11,lr}
000280  f7ffbffe          B.W      pbuf_free
                  |L3.644|
000284  68e4              LDR      r4,[r4,#0xc]          ;286
                  |L3.646|
000286  2c00              CMP      r4,#0                 ;286
000288  d1cd              BNE      |L3.550|
;;;311            return;
;;;312          }
;;;313        }
;;;314    
;;;315        /* Finally, if we still did not get a match, we check all PCBs that
;;;316           are LISTENing for incoming connections. */
;;;317        prev = NULL;
00028a  2100              MOVS     r1,#0
;;;318        for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
00028c  f8dfa2dc          LDR      r10,|L3.1388|
000290  f8da0000          LDR      r0,[r10,#0]  ; tcp_listen_pcbs
000294  4684              MOV      r12,r0
000296  687b              LDR      r3,[r7,#4]            ;138
000298  f8d8600c          LDR      r6,[r8,#0xc]          ;153
00029c  697f              LDR      r7,[r7,#0x14]         ;153
00029e  e017              B        |L3.720|
                  |L3.672|
;;;319          /* check if PCB is bound to specific netif */
;;;320          if ((lpcb->netif_idx != NETIF_NO_INDEX) &&
0002a0  7a02              LDRB     r2,[r0,#8]
0002a2  b14a              CBZ      r2,|L3.696|
;;;321              (lpcb->netif_idx != netif_get_index(ip_data.current_input_netif))) {
0002a4  f893b038          LDRB     r11,[r3,#0x38]
0002a8  f10b0b01          ADD      r11,r11,#1
0002ac  f00b0bff          AND      r11,r11,#0xff
0002b0  455a              CMP      r2,r11
0002b2  d001              BEQ      |L3.696|
;;;322            prev = (struct tcp_pcb *)lpcb;
0002b4  4601              MOV      r1,r0
;;;323            continue;
0002b6  e00a              B        |L3.718|
                  |L3.696|
;;;324          }
;;;325    
;;;326          if (lpcb->local_port == tcphdr->dest) {
0002b8  8ac2              LDRH     r2,[r0,#0x16]
0002ba  f8b6b002          LDRH     r11,[r6,#2]
0002be  455a              CMP      r2,r11
0002c0  d104              BNE      |L3.716|
;;;327            if (IP_IS_ANY_TYPE_VAL(lpcb->local_ip)) {
;;;328              /* found an ANY TYPE (IPv4/IPv6) match */
;;;329    #if SO_REUSE
;;;330              lpcb_any = lpcb;
;;;331              lpcb_prev = prev;
;;;332    #else /* SO_REUSE */
;;;333              break;
;;;334    #endif /* SO_REUSE */
;;;335            } else if (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) {
;;;336              if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
0002c2  6802              LDR      r2,[r0,#0]
0002c4  42ba              CMP      r2,r7
0002c6  d005              BEQ      |L3.724|
;;;337                /* found an exact match */
;;;338                break;
;;;339              } else if (ip_addr_isany(&lpcb->local_ip)) {
0002c8  b120              CBZ      r0,|L3.724|
0002ca  b11a              CBZ      r2,|L3.724|
                  |L3.716|
;;;340                /* found an ANY-match */
;;;341    #if SO_REUSE
;;;342                lpcb_any = lpcb;
;;;343                lpcb_prev = prev;
;;;344    #else /* SO_REUSE */
;;;345                break;
;;;346    #endif /* SO_REUSE */
;;;347              }
;;;348            }
;;;349          }
;;;350          prev = (struct tcp_pcb *)lpcb;
0002cc  4601              MOV      r1,r0
                  |L3.718|
0002ce  68c0              LDR      r0,[r0,#0xc]          ;318
                  |L3.720|
0002d0  2800              CMP      r0,#0                 ;318
0002d2  d1e5              BNE      |L3.672|
                  |L3.724|
;;;351        }
;;;352    #if SO_REUSE
;;;353        /* first try specific local IP */
;;;354        if (lpcb == NULL) {
;;;355          /* only pass to ANY if no specific local IP has been found */
;;;356          lpcb = lpcb_any;
;;;357          prev = lpcb_prev;
;;;358        }
;;;359    #endif /* SO_REUSE */
;;;360        if (lpcb != NULL) {
0002d4  b168              CBZ      r0,|L3.754|
;;;361          /* Move this PCB to the front of the list so that subsequent
;;;362             lookups will be faster (we exploit locality in TCP segment
;;;363             arrivals). */
;;;364          if (prev != NULL) {
0002d6  b129              CBZ      r1,|L3.740|
;;;365            ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
0002d8  68c2              LDR      r2,[r0,#0xc]
0002da  60ca              STR      r2,[r1,#0xc]
;;;366            /* our successor is the remainder of the listening list */
;;;367            lpcb->next = tcp_listen_pcbs.listen_pcbs;
0002dc  f8c0c00c          STR      r12,[r0,#0xc]
;;;368            /* put this listening pcb at the head of the listening list */
;;;369            tcp_listen_pcbs.listen_pcbs = lpcb;
0002e0  f8ca0000          STR      r0,[r10,#0]  ; tcp_listen_pcbs
                  |L3.740|
;;;370          } else {
;;;371            TCP_STATS_INC(tcp.cachehit);
;;;372          }
;;;373    
;;;374          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
;;;375    #ifdef LWIP_HOOK_TCP_INPACKET_PCB
;;;376          if (LWIP_HOOK_TCP_INPACKET_PCB((struct tcp_pcb *)lpcb, tcphdr, tcphdr_optlen,
;;;377                                         tcphdr_opt1len, tcphdr_opt2, p) == ERR_OK)
;;;378    #endif
;;;379          {
;;;380            tcp_listen_input(lpcb);
0002e4  f7fffffe          BL       tcp_listen_input
;;;381          }
;;;382          pbuf_free(p);
0002e8  4628              MOV      r0,r5
0002ea  e8bd4ffe          POP      {r1-r11,lr}
0002ee  f7ffbffe          B.W      pbuf_free
                  |L3.754|
;;;383          return;
;;;384        }
;;;385      }
;;;386    
;;;387    #if TCP_INPUT_DEBUG
;;;388      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
;;;389      tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
;;;390      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
;;;391    #endif /* TCP_INPUT_DEBUG */
;;;392    
;;;393    
;;;394    #ifdef LWIP_HOOK_TCP_INPACKET_PCB
;;;395      if ((pcb != NULL) && LWIP_HOOK_TCP_INPACKET_PCB(pcb, tcphdr, tcphdr_optlen,
;;;396          tcphdr_opt1len, tcphdr_opt2, p) != ERR_OK) {
;;;397        pbuf_free(p);
;;;398        return;
;;;399      }
;;;400    #endif
;;;401      if (pcb != NULL) {
0002f2  2c00              CMP      r4,#0
0002f4  d055              BEQ      |L3.930|
;;;402        /* The incoming segment belongs to a connection. */
;;;403    #if TCP_INPUT_DEBUG
;;;404        tcp_debug_print_state(pcb->state);
;;;405    #endif /* TCP_INPUT_DEBUG */
;;;406    
;;;407        /* Set up a tcp_seg structure. */
;;;408        inseg.next = NULL;
0002f6  4e9e              LDR      r6,|L3.1392|
0002f8  f8c69000          STR      r9,[r6,#0]  ; inseg
;;;409        inseg.len = p->tot_len;
0002fc  8928              LDRH     r0,[r5,#8]
0002fe  8130              STRH     r0,[r6,#8]
;;;410        inseg.p = p;
000300  6075              STR      r5,[r6,#4]  ; inseg
;;;411        inseg.tcphdr = tcphdr;
000302  f8d8000c          LDR      r0,[r8,#0xc]  ; tcphdr
000306  60f0              STR      r0,[r6,#0xc]  ; inseg
;;;412    
;;;413        recv_data = NULL;
000308  f8c8901c          STR      r9,[r8,#0x1c]  ; recv_data
;;;414        recv_flags = 0;
00030c  f8889001          STRB     r9,[r8,#1]
;;;415        recv_acked = 0;
000310  f8a89008          STRH     r9,[r8,#8]
;;;416    
;;;417        if (flags & TCP_PSH) {
000314  f8980000          LDRB     r0,[r8,#0]  ; flags
000318  0700              LSLS     r0,r0,#28
00031a  d503              BPL      |L3.804|
;;;418          p->flags |= PBUF_FLAG_PUSH;
00031c  7b68              LDRB     r0,[r5,#0xd]
00031e  f0400001          ORR      r0,r0,#1
000322  7368              STRB     r0,[r5,#0xd]
                  |L3.804|
;;;419        }
;;;420    
;;;421        /* If there is data which was previously "refused" by upper layer */
;;;422        if (pcb->refused_data != NULL) {
000324  6fa0              LDR      r0,[r4,#0x78]
000326  b180              CBZ      r0,|L3.842|
;;;423          if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
000328  4620              MOV      r0,r4
00032a  f7fffffe          BL       tcp_process_refused_data
00032e  300d              ADDS     r0,r0,#0xd
000330  d004              BEQ      |L3.828|
;;;424              ((pcb->refused_data != NULL) && (tcplen > 0))) {
000332  6fa0              LDR      r0,[r4,#0x78]
000334  b148              CBZ      r0,|L3.842|
000336  f8b8000a          LDRH     r0,[r8,#0xa]  ; tcplen
00033a  b130              CBZ      r0,|L3.842|
                  |L3.828|
;;;425            /* pcb has been aborted or refused data is still refused and the new
;;;426               segment contains data */
;;;427            if (pcb->rcv_ann_wnd == 0) {
00033c  8d60              LDRH     r0,[r4,#0x2a]
00033e  2800              CMP      r0,#0
000340  d102              BNE      |L3.840|
;;;428              /* this is a zero-window probe, we respond to it with current RCV.NXT
;;;429              and drop the data segment */
;;;430              tcp_send_empty_ack(pcb);
000342  4620              MOV      r0,r4
000344  f7fffffe          BL       tcp_send_empty_ack
                  |L3.840|
000348  e16d              B        |L3.1574|
                  |L3.842|
;;;431            }
;;;432            TCP_STATS_INC(tcp.drop);
;;;433            MIB2_STATS_INC(mib2.tcpinerrs);
;;;434            goto aborted;
;;;435          }
;;;436        }
;;;437        tcp_input_pcb = pcb;
00034a  f8c84020          STR      r4,[r8,#0x20]  ; tcp_input_pcb
;;;438        err = tcp_process(pcb);
00034e  4620              MOV      r0,r4
000350  f7fffffe          BL       tcp_process
;;;439        /* A return value of ERR_ABRT means that tcp_abort() was called
;;;440           and that the pcb has been freed. If so, we don't do anything. */
;;;441        if (err != ERR_ABRT) {
000354  300d              ADDS     r0,r0,#0xd
000356  d011              BEQ      |L3.892|
;;;442          if (recv_flags & TF_RESET) {
000358  f8980001          LDRB     r0,[r8,#1]  ; recv_flags
00035c  0700              LSLS     r0,r0,#28
00035e  d50e              BPL      |L3.894|
;;;443            /* TF_RESET means that the connection was reset by the other
;;;444               end. We then call the error callback to inform the
;;;445               application that the connection is dead before we
;;;446               deallocate the PCB. */
;;;447            TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
000360  f8d42090          LDR      r2,[r4,#0x90]
000364  b11a              CBZ      r2,|L3.878|
000366  f06f010d          MVN      r1,#0xd
00036a  6920              LDR      r0,[r4,#0x10]
00036c  4790              BLX      r2
                  |L3.878|
;;;448            tcp_pcb_remove(&tcp_active_pcbs, pcb);
00036e  4621              MOV      r1,r4
000370  483b              LDR      r0,|L3.1120|
000372  f7fffffe          BL       tcp_pcb_remove
;;;449            tcp_free(pcb);
000376  4620              MOV      r0,r4
000378  f7fffffe          BL       tcp_free
                  |L3.892|
00037c  e153              B        |L3.1574|
                  |L3.894|
;;;450          } else {
;;;451            err = ERR_OK;
00037e  2000              MOVS     r0,#0
;;;452            /* If the application has registered a "sent" function to be
;;;453               called when new send buffer space is available, we call it
;;;454               now. */
;;;455            if (recv_acked > 0) {
000380  f8b82008          LDRH     r2,[r8,#8]  ; recv_acked
000384  b14a              CBZ      r2,|L3.922|
;;;456              u16_t acked16;
;;;457    #if LWIP_WND_SCALE
;;;458              /* recv_acked is u32_t but the sent callback only takes a u16_t,
;;;459                 so we might have to call it multiple times. */
;;;460              u32_t acked = recv_acked;
;;;461              while (acked > 0) {
;;;462                acked16 = (u16_t)LWIP_MIN(acked, 0xffffu);
;;;463                acked -= acked16;
;;;464    #else
;;;465              {
;;;466                acked16 = recv_acked;
;;;467    #endif
;;;468                TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
000386  f8d43080          LDR      r3,[r4,#0x80]
00038a  b113              CBZ      r3,|L3.914|
00038c  4621              MOV      r1,r4
00038e  6920              LDR      r0,[r4,#0x10]
000390  4798              BLX      r3
                  |L3.914|
;;;469                if (err == ERR_ABRT) {
000392  300d              ADDS     r0,r0,#0xd
000394  d006              BEQ      |L3.932|
;;;470                  goto aborted;
;;;471                }
;;;472              }
;;;473              recv_acked = 0;
000396  f8a89008          STRH     r9,[r8,#8]
                  |L3.922|
;;;474            }
;;;475            if (tcp_input_delayed_close(pcb)) {
00039a  4620              MOV      r0,r4
00039c  f7fffffe          BL       tcp_input_delayed_close
0003a0  e0e8              B        |L3.1396|
                  |L3.930|
0003a2  e14d              B        |L3.1600|
                  |L3.932|
0003a4  e123              B        |L3.1518|
0003a6  0000              DCW      0x0000
                  |L3.936|
0003a8  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_in.c"
0003ac  6964646c
0003b0  65776172
0003b4  65735c54
0003b8  68697264
0003bc  5f506172
0003c0  74795c4c
0003c4  7749505c
0003c8  7372635c
0003cc  636f7265
0003d0  5c746370
0003d4  5f696e2e
0003d8  63      
0003d9  00                DCB      0
0003da  00                DCB      0
0003db  00                DCB      0
                  |L3.988|
0003dc  7463705f          DCB      "tcp_input: invalid pbuf",0
0003e0  696e7075
0003e4  743a2069
0003e8  6e76616c
0003ec  69642070
0003f0  62756600
                  |L3.1012|
0003f4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0003f8  7274696f
0003fc  6e202225
000400  73222066
000404  61696c65
000408  64206174
00040c  206c696e
000410  65202564
000414  20696e20
000418  25730a00
                  |L3.1052|
                          DCD      ||.data||
                  |L3.1056|
                          DCD      ip_data
                  |L3.1060|
000424  702d3e6e          DCB      "p->next != NULL",0
000428  65787420
00042c  213d204e
000430  554c4c00
                  |L3.1076|
000434  702d3e6c          DCB      "p->len == 0",0
000438  656e203d
00043c  3d203000
                  |L3.1088|
000440  702d3e74          DCB      "p->tot_len == p->next->tot_len",0
000444  6f745f6c
000448  656e203d
00044c  3d20702d
000450  3e6e6578
000454  742d3e74
000458  6f745f6c
00045c  656e00  
00045f  00                DCB      0
                  |L3.1120|
                          DCD      tcp_active_pcbs
                  |L3.1124|
000464  7463705f          DCB      "tcp_input: active pcb->state != CLOSED",0
000468  696e7075
00046c  743a2061
000470  63746976
000474  65207063
000478  622d3e73
00047c  74617465
000480  20213d20
000484  434c4f53
000488  454400  
00048b  00                DCB      0
                  |L3.1164|
00048c  7463705f          DCB      "tcp_input: active pcb->state != TIME-WAIT",0
000490  696e7075
000494  743a2061
000498  63746976
00049c  65207063
0004a0  622d3e73
0004a4  74617465
0004a8  20213d20
0004ac  54494d45
0004b0  2d574149
0004b4  5400    
0004b6  00                DCB      0
0004b7  00                DCB      0
                  |L3.1208|
0004b8  7463705f          DCB      "tcp_input: active pcb->state != LISTEN",0
0004bc  696e7075
0004c0  743a2061
0004c4  63746976
0004c8  65207063
0004cc  622d3e73
0004d0  74617465
0004d4  20213d20
0004d8  4c495354
0004dc  454e00  
0004df  00                DCB      0
                  |L3.1248|
0004e0  7463705f          DCB      "tcp_input: pcb->next != pcb (before cache)",0
0004e4  696e7075
0004e8  743a2070
0004ec  63622d3e
0004f0  6e657874
0004f4  20213d20
0004f8  70636220
0004fc  28626566
000500  6f726520
000504  63616368
000508  652900  
00050b  00                DCB      0
                  |L3.1292|
00050c  7463705f          DCB      "tcp_input: pcb->next != pcb (after cache)",0
000510  696e7075
000514  743a2070
000518  63622d3e
00051c  6e657874
000520  20213d20
000524  70636220
000528  28616674
00052c  65722063
000530  61636865
000534  2900    
000536  00                DCB      0
000537  00                DCB      0
                  |L3.1336|
                          DCD      tcp_tw_pcbs
                  |L3.1340|
00053c  7463705f          DCB      "tcp_input: TIME-WAIT pcb->state == TIME-WAIT",0
000540  696e7075
000544  743a2054
000548  494d452d
00054c  57414954
000550  20706362
000554  2d3e7374
000558  61746520
00055c  3d3d2054
000560  494d452d
000564  57414954
000568  00      
000569  00                DCB      0
00056a  00                DCB      0
00056b  00                DCB      0
                  |L3.1388|
                          DCD      tcp_listen_pcbs
                  |L3.1392|
                          DCD      ||.bss||
                  |L3.1396|
000574  bbd8              CBNZ     r0,|L3.1518|
;;;476              goto aborted;
;;;477            }
;;;478    #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;479            while (recv_data != NULL) {
;;;480              struct pbuf *rest = NULL;
;;;481              pbuf_split_64k(recv_data, &rest);
;;;482    #else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;483            if (recv_data != NULL) {
000576  f8d8001c          LDR      r0,[r8,#0x1c]  ; recv_data
00057a  b368              CBZ      r0,|L3.1496|
;;;484    #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;485    
;;;486              LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
00057c  6fa0              LDR      r0,[r4,#0x78]
00057e  b140              CBZ      r0,|L3.1426|
000580  f2af13dc          ADR      r3,|L3.936|
000584  f44f72f3          MOV      r2,#0x1e6
000588  a140              ADR      r1,|L3.1676|
00058a  f2af1098          ADR      r0,|L3.1012|
00058e  f7fffffe          BL       __2printf
                  |L3.1426|
;;;487              if (pcb->flags & TF_RXCLOSED) {
000592  7ea0              LDRB     r0,[r4,#0x1a]
000594  06c0              LSLS     r0,r0,#27
000596  d507              BPL      |L3.1448|
;;;488                /* received data although already closed -> abort (send RST) to
;;;489                   notify the remote host that not all data has been processed */
;;;490                pbuf_free(recv_data);
000598  f8d8001c          LDR      r0,[r8,#0x1c]  ; recv_data
00059c  f7fffffe          BL       pbuf_free
;;;491    #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;492                if (rest != NULL) {
;;;493                  pbuf_free(rest);
;;;494                }
;;;495    #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;496                tcp_abort(pcb);
0005a0  4620              MOV      r0,r4
0005a2  f7fffffe          BL       tcp_abort
;;;497                goto aborted;
0005a6  e03e              B        |L3.1574|
                  |L3.1448|
;;;498              }
;;;499    
;;;500              /* Notify application that data has been received. */
;;;501              TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
0005a8  f8d45084          LDR      r5,[r4,#0x84]
0005ac  b135              CBZ      r5,|L3.1468|
0005ae  2300              MOVS     r3,#0
0005b0  6920              LDR      r0,[r4,#0x10]
0005b2  4621              MOV      r1,r4
0005b4  f8d8201c          LDR      r2,[r8,#0x1c]  ; recv_data
0005b8  47a8              BLX      r5
0005ba  e006              B        |L3.1482|
                  |L3.1468|
0005bc  2300              MOVS     r3,#0
0005be  4621              MOV      r1,r4
0005c0  4618              MOV      r0,r3
0005c2  f8d8201c          LDR      r2,[r8,#0x1c]  ; recv_data
0005c6  f7fffffe          BL       tcp_recv_null
                  |L3.1482|
;;;502              if (err == ERR_ABRT) {
0005ca  f1100f0d          CMN      r0,#0xd
0005ce  d02a              BEQ      |L3.1574|
;;;503    #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;504                if (rest != NULL) {
;;;505                  pbuf_free(rest);
;;;506                }
;;;507    #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;508                goto aborted;
;;;509              }
;;;510    
;;;511              /* If the upper layer can't receive this data, store it */
;;;512              if (err != ERR_OK) {
0005d0  b110              CBZ      r0,|L3.1496|
;;;513    #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;514                if (rest != NULL) {
;;;515                  pbuf_cat(recv_data, rest);
;;;516                }
;;;517    #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;518                pcb->refused_data = recv_data;
0005d2  f8d8001c          LDR      r0,[r8,#0x1c]  ; recv_data
0005d6  67a0              STR      r0,[r4,#0x78]
                  |L3.1496|
;;;519                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"\n"));
;;;520    #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;521                break;
;;;522              } else {
;;;523                /* Upper layer received the data, go on with the rest if > 64K */
;;;524                recv_data = rest;
;;;525    #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;526              }
;;;527            }
;;;528    
;;;529            /* If a FIN segment was received, we call the callback
;;;530               function with a NULL buffer to indicate EOF. */
;;;531            if (recv_flags & TF_GOT_FIN) {
0005d8  f8980001          LDRB     r0,[r8,#1]  ; recv_flags
0005dc  0680              LSLS     r0,r0,#26
0005de  d519              BPL      |L3.1556|
;;;532              if (pcb->refused_data != NULL) {
0005e0  6fa0              LDR      r0,[r4,#0x78]
0005e2  b128              CBZ      r0,|L3.1520|
;;;533                /* Delay this if we have refused data. */
;;;534                pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
0005e4  7b41              LDRB     r1,[r0,#0xd]
0005e6  f0410120          ORR      r1,r1,#0x20
0005ea  7341              STRB     r1,[r0,#0xd]
0005ec  e012              B        |L3.1556|
                  |L3.1518|
0005ee  e01a              B        |L3.1574|
                  |L3.1520|
;;;535              } else {
;;;536                /* correct rcv_wnd as the application won't call tcp_recved()
;;;537                   for the FIN's seqno */
;;;538                if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
0005f0  8d20              LDRH     r0,[r4,#0x28]
0005f2  f5b06f06          CMP      r0,#0x860
0005f6  d001              BEQ      |L3.1532|
;;;539                  pcb->rcv_wnd++;
0005f8  1c40              ADDS     r0,r0,#1
0005fa  8520              STRH     r0,[r4,#0x28]
                  |L3.1532|
;;;540                }
;;;541                TCP_EVENT_CLOSED(pcb, err);
0005fc  f8d45084          LDR      r5,[r4,#0x84]
000600  b12d              CBZ      r5,|L3.1550|
000602  2300              MOVS     r3,#0
000604  461a              MOV      r2,r3
000606  4621              MOV      r1,r4
000608  6920              LDR      r0,[r4,#0x10]
00060a  47a8              BLX      r5
00060c  e000              B        |L3.1552|
                  |L3.1550|
00060e  2000              MOVS     r0,#0
                  |L3.1552|
;;;542                if (err == ERR_ABRT) {
000610  300d              ADDS     r0,r0,#0xd
000612  d008              BEQ      |L3.1574|
                  |L3.1556|
;;;543                  goto aborted;
;;;544                }
;;;545              }
;;;546            }
;;;547    
;;;548            tcp_input_pcb = NULL;
000614  f8c89020          STR      r9,[r8,#0x20]  ; tcp_input_pcb
;;;549            if (tcp_input_delayed_close(pcb)) {
000618  4620              MOV      r0,r4
00061a  f7fffffe          BL       tcp_input_delayed_close
00061e  b910              CBNZ     r0,|L3.1574|
;;;550              goto aborted;
;;;551            }
;;;552            /* Try to send something out. */
;;;553            tcp_output(pcb);
000620  4620              MOV      r0,r4
000622  f7fffffe          BL       tcp_output
                  |L3.1574|
;;;554    #if TCP_INPUT_DEBUG
;;;555    #if TCP_DEBUG
;;;556            tcp_debug_print_state(pcb->state);
;;;557    #endif /* TCP_DEBUG */
;;;558    #endif /* TCP_INPUT_DEBUG */
;;;559          }
;;;560        }
;;;561        /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
;;;562           Below this line, 'pcb' may not be dereferenced! */
;;;563    aborted:
;;;564        tcp_input_pcb = NULL;
000626  f8c89020          STR      r9,[r8,#0x20]  ; tcp_input_pcb
;;;565        recv_data = NULL;
00062a  f8c8901c          STR      r9,[r8,#0x1c]  ; recv_data
;;;566    
;;;567        /* give up our reference to inseg.p */
;;;568        if (inseg.p != NULL) {
00062e  6870              LDR      r0,[r6,#4]  ; inseg
000630  2800              CMP      r0,#0
000632  d003              BEQ      |L3.1596|
;;;569          pbuf_free(inseg.p);
000634  f7fffffe          BL       pbuf_free
;;;570          inseg.p = NULL;
000638  f8c69004          STR      r9,[r6,#4]  ; inseg
                  |L3.1596|
;;;571        }
;;;572      } else {
;;;573        /* If no matching PCB was found, send a TCP RST (reset) to the
;;;574           sender. */
;;;575        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
;;;576        if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
;;;577          TCP_STATS_INC(tcp.proterr);
;;;578          TCP_STATS_INC(tcp.drop);
;;;579          tcp_rst(NULL, ackno, seqno + tcplen, ip_current_dest_addr(),
;;;580                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;581        }
;;;582        pbuf_free(p);
;;;583      }
;;;584    
;;;585      LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;586      PERF_STOP("tcp_input");
;;;587      return;
;;;588    dropped:
;;;589      TCP_STATS_INC(tcp.drop);
;;;590      MIB2_STATS_INC(mib2.tcpinerrs);
;;;591      pbuf_free(p);
;;;592    }
00063c  e8bd8ffe          POP      {r1-r11,pc}
                  |L3.1600|
000640  f8d8000c          LDR      r0,[r8,#0xc]          ;576  ; tcphdr
000644  8980              LDRH     r0,[r0,#0xc]          ;576
000646  f7fffffe          BL       lwip_htons
00064a  0740              LSLS     r0,r0,#29             ;576
00064c  d413              BMI      |L3.1654|
00064e  f8d8000c          LDR      r0,[r8,#0xc]          ;579  ; tcphdr
000652  4a15              LDR      r2,|L3.1704|
000654  4b14              LDR      r3,|L3.1704|
000656  8801              LDRH     r1,[r0,#0]            ;579
000658  8840              LDRH     r0,[r0,#2]            ;579
00065a  9102              STR      r1,[sp,#8]            ;579
00065c  e9cd2000          STRD     r2,r0,[sp,#0]         ;579
000660  f8b8100a          LDRH     r1,[r8,#0xa]          ;579  ; tcplen
000664  f8d80014          LDR      r0,[r8,#0x14]         ;579  ; seqno
000668  1d1b              ADDS     r3,r3,#4              ;579
00066a  1842              ADDS     r2,r0,r1              ;579
00066c  2000              MOVS     r0,#0                 ;579
00066e  f8d81018          LDR      r1,[r8,#0x18]         ;579  ; ackno
000672  f7fffffe          BL       tcp_rst
                  |L3.1654|
000676  4628              MOV      r0,r5                 ;582
000678  e8bd4ffe          POP      {r1-r11,lr}           ;582
00067c  f7ffbffe          B.W      pbuf_free
                  |L3.1664|
000680  4628              MOV      r0,r5                 ;591
000682  e8bd4ffe          POP      {r1-r11,lr}           ;591
000686  f7ffbffe          B.W      pbuf_free
;;;593    
                          ENDP

00068a  0000              DCW      0x0000
                  |L3.1676|
00068c  7063622d          DCB      "pcb->refused_data == NULL",0
000690  3e726566
000694  75736564
000698  5f646174
00069c  61203d3d
0006a0  204e554c
0006a4  4c00    
0006a6  00                DCB      0
0006a7  00                DCB      0
                  |L3.1704|
                          DCD      ip_data+0x10

                          AREA ||i.tcp_input_delayed_close||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_input_delayed_close PROC
;;;599    static int
;;;600    tcp_input_delayed_close(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;601    {
000002  4604              MOV      r4,r0
;;;602      LWIP_ASSERT("tcp_input_delayed_close: invalid pcb", pcb != NULL);
000004  2c00              CMP      r4,#0
000006  d106              BNE      |L4.22|
000008  a30f              ADR      r3,|L4.72|
00000a  f240225a          MOV      r2,#0x25a
00000e  a11b              ADR      r1,|L4.124|
000010  a024              ADR      r0,|L4.164|
000012  f7fffffe          BL       __2printf
                  |L4.22|
;;;603    
;;;604      if (recv_flags & TF_CLOSED) {
000016  482d              LDR      r0,|L4.204|
000018  7840              LDRB     r0,[r0,#1]  ; recv_flags
00001a  06c0              LSLS     r0,r0,#27
00001c  d512              BPL      |L4.68|
;;;605        /* The connection has been closed and we will deallocate the
;;;606            PCB. */
;;;607        if (!(pcb->flags & TF_RXCLOSED)) {
00001e  7ea0              LDRB     r0,[r4,#0x1a]
000020  06c0              LSLS     r0,r0,#27
000022  d406              BMI      |L4.50|
;;;608          /* Connection closed although the application has only shut down the
;;;609              tx side: call the PCB's err callback and indicate the closure to
;;;610              ensure the application doesn't continue using the PCB. */
;;;611          TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
000024  f8d42090          LDR      r2,[r4,#0x90]
000028  b11a              CBZ      r2,|L4.50|
00002a  f06f010e          MVN      r1,#0xe
00002e  6920              LDR      r0,[r4,#0x10]
000030  4790              BLX      r2
                  |L4.50|
;;;612        }
;;;613        tcp_pcb_remove(&tcp_active_pcbs, pcb);
000032  4621              MOV      r1,r4
000034  4826              LDR      r0,|L4.208|
000036  f7fffffe          BL       tcp_pcb_remove
;;;614        tcp_free(pcb);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       tcp_free
;;;615        return 1;
000040  2001              MOVS     r0,#1
;;;616      }
;;;617      return 0;
;;;618    }
000042  bd10              POP      {r4,pc}
                  |L4.68|
000044  2000              MOVS     r0,#0                 ;617
000046  bd10              POP      {r4,pc}
;;;619    
                          ENDP

                  |L4.72|
000048  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_in.c"
00004c  6964646c
000050  65776172
000054  65735c54
000058  68697264
00005c  5f506172
000060  74795c4c
000064  7749505c
000068  7372635c
00006c  636f7265
000070  5c746370
000074  5f696e2e
000078  63      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L4.124|
00007c  7463705f          DCB      "tcp_input_delayed_close: invalid pcb",0
000080  696e7075
000084  745f6465
000088  6c617965
00008c  645f636c
000090  6f73653a
000094  20696e76
000098  616c6964
00009c  20706362
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L4.164|
0000a4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000a8  7274696f
0000ac  6e202225
0000b0  73222066
0000b4  61696c65
0000b8  64206174
0000bc  206c696e
0000c0  65202564
0000c4  20696e20
0000c8  25730a00
                  |L4.204|
                          DCD      ||.data||
                  |L4.208|
                          DCD      tcp_active_pcbs

                          AREA ||i.tcp_listen_input||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_listen_input PROC
;;;629    static void
;;;630    tcp_listen_input(struct tcp_pcb_listen *pcb)
000000  b5fe              PUSH     {r1-r7,lr}
;;;631    {
000002  4605              MOV      r5,r0
;;;632      struct tcp_pcb *npcb;
;;;633      u32_t iss;
;;;634      err_t rc;
;;;635    
;;;636      if (flags & TCP_RST) {
000004  4e41              LDR      r6,|L5.268|
000006  7830              LDRB     r0,[r6,#0]  ; flags
000008  0740              LSLS     r0,r0,#29
00000a  d41b              BMI      |L5.68|
;;;637        /* An incoming RST should be ignored. Return. */
;;;638        return;
;;;639      }
;;;640    
;;;641      LWIP_ASSERT("tcp_listen_input: invalid pcb", pcb != NULL);
00000c  2d00              CMP      r5,#0
00000e  d106              BNE      |L5.30|
000010  a33f              ADR      r3,|L5.272|
000012  f2402281          MOV      r2,#0x281
000016  a14b              ADR      r1,|L5.324|
000018  a052              ADR      r0,|L5.356|
00001a  f7fffffe          BL       __2printf
                  |L5.30|
;;;642    
;;;643      /* In the LISTEN state, we check for incoming SYN segments,
;;;644         creates a new PCB, and responds with a SYN|ACK. */
;;;645      if (flags & TCP_ACK) {
00001e  7830              LDRB     r0,[r6,#0]  ; flags
000020  06c1              LSLS     r1,r0,#27
000022  d510              BPL      |L5.70|
;;;646        /* For incoming segments with the ACK flag set, respond with a
;;;647           RST. */
;;;648        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
;;;649        tcp_rst((const struct tcp_pcb *)pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
000024  68f0              LDR      r0,[r6,#0xc]  ; tcphdr
000026  4a59              LDR      r2,|L5.396|
000028  4b58              LDR      r3,|L5.396|
00002a  8801              LDRH     r1,[r0,#0]
00002c  8840              LDRH     r0,[r0,#2]
00002e  9102              STR      r1,[sp,#8]
000030  e9cd2000          STRD     r2,r0,[sp,#0]
000034  8971              LDRH     r1,[r6,#0xa]  ; tcplen
000036  6970              LDR      r0,[r6,#0x14]  ; seqno
000038  1d1b              ADDS     r3,r3,#4
00003a  1842              ADDS     r2,r0,r1
00003c  4628              MOV      r0,r5
00003e  69b1              LDR      r1,[r6,#0x18]  ; ackno
000040  f7fffffe          BL       tcp_rst
                  |L5.68|
;;;650                ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;651      } else if (flags & TCP_SYN) {
;;;652        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
;;;653    #if TCP_LISTEN_BACKLOG
;;;654        if (pcb->accepts_pending >= pcb->backlog) {
;;;655          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
;;;656          return;
;;;657        }
;;;658    #endif /* TCP_LISTEN_BACKLOG */
;;;659        npcb = tcp_alloc(pcb->prio);
;;;660        /* If a new PCB could not be created (probably due to lack of memory),
;;;661           we don't do anything, but rely on the sender will retransmit the
;;;662           SYN at a time when we have more memory available. */
;;;663        if (npcb == NULL) {
;;;664          err_t err;
;;;665          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
;;;666          TCP_STATS_INC(tcp.memerr);
;;;667          TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
;;;668          LWIP_UNUSED_ARG(err); /* err not useful here */
;;;669          return;
;;;670        }
;;;671    #if TCP_LISTEN_BACKLOG
;;;672        pcb->accepts_pending++;
;;;673        tcp_set_flags(npcb, TF_BACKLOGPEND);
;;;674    #endif /* TCP_LISTEN_BACKLOG */
;;;675        /* Set up the new PCB. */
;;;676        ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
;;;677        ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
;;;678        npcb->local_port = pcb->local_port;
;;;679        npcb->remote_port = tcphdr->src;
;;;680        npcb->state = SYN_RCVD;
;;;681        npcb->rcv_nxt = seqno + 1;
;;;682        npcb->rcv_ann_right_edge = npcb->rcv_nxt;
;;;683        iss = tcp_next_iss(npcb);
;;;684        npcb->snd_wl2 = iss;
;;;685        npcb->snd_nxt = iss;
;;;686        npcb->lastack = iss;
;;;687        npcb->snd_lbb = iss;
;;;688        npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
;;;689        npcb->callback_arg = pcb->callback_arg;
;;;690    #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
;;;691        npcb->listener = pcb;
;;;692    #endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
;;;693        /* inherit socket options */
;;;694        npcb->so_options = pcb->so_options & SOF_INHERITED;
;;;695        npcb->netif_idx = pcb->netif_idx;
;;;696        /* Register the new PCB so that we can begin receiving segments
;;;697           for it. */
;;;698        TCP_REG_ACTIVE(npcb);
;;;699    
;;;700        /* Parse any options in the SYN. */
;;;701        tcp_parseopt(npcb);
;;;702        npcb->snd_wnd = tcphdr->wnd;
;;;703        npcb->snd_wnd_max = npcb->snd_wnd;
;;;704    
;;;705    #if TCP_CALCULATE_EFF_SEND_MSS
;;;706        npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
;;;707    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;708    
;;;709        MIB2_STATS_INC(mib2.tcppassiveopens);
;;;710    
;;;711    #if LWIP_TCP_PCB_NUM_EXT_ARGS
;;;712        if (tcp_ext_arg_invoke_callbacks_passive_open(pcb, npcb) != ERR_OK) {
;;;713          tcp_abandon(npcb, 0);
;;;714          return;
;;;715        }
;;;716    #endif
;;;717    
;;;718        /* Send a SYN|ACK together with the MSS option. */
;;;719        rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
;;;720        if (rc != ERR_OK) {
;;;721          tcp_abandon(npcb, 0);
;;;722          return;
;;;723        }
;;;724        tcp_output(npcb);
;;;725      }
;;;726      return;
;;;727    }
000044  bdfe              POP      {r1-r7,pc}
                  |L5.70|
000046  0780              LSLS     r0,r0,#30             ;651
000048  d5fc              BPL      |L5.68|
00004a  7d68              LDRB     r0,[r5,#0x15]         ;659
00004c  f7fffffe          BL       tcp_alloc
000050  4604              MOV      r4,r0                 ;659
000052  0020              MOVS     r0,r4                 ;663
000054  d04a              BEQ      |L5.236|
000056  484d              LDR      r0,|L5.396|
000058  3810              SUBS     r0,r0,#0x10           ;676
00005a  6941              LDR      r1,[r0,#0x14]         ;676  ; ip_data
00005c  6021              STR      r1,[r4,#0]            ;676
00005e  6900              LDR      r0,[r0,#0x10]         ;677  ; ip_data
000060  6060              STR      r0,[r4,#4]            ;677
000062  8ae8              LDRH     r0,[r5,#0x16]         ;678
000064  82e0              STRH     r0,[r4,#0x16]         ;678
000066  68f0              LDR      r0,[r6,#0xc]          ;679  ; tcphdr
000068  8800              LDRH     r0,[r0,#0]            ;679
00006a  8320              STRH     r0,[r4,#0x18]         ;679
00006c  2003              MOVS     r0,#3                 ;680
00006e  7520              STRB     r0,[r4,#0x14]         ;680
000070  6970              LDR      r0,[r6,#0x14]         ;681  ; seqno
000072  1c40              ADDS     r0,r0,#1              ;681
000074  6260              STR      r0,[r4,#0x24]         ;681
000076  62e0              STR      r0,[r4,#0x2c]         ;682
000078  4620              MOV      r0,r4                 ;683
00007a  f7fffffe          BL       tcp_next_iss
00007e  65a0              STR      r0,[r4,#0x58]         ;684
000080  6520              STR      r0,[r4,#0x50]         ;685
000082  6460              STR      r0,[r4,#0x44]         ;686
000084  65e0              STR      r0,[r4,#0x5c]         ;687
000086  6970              LDR      r0,[r6,#0x14]         ;688  ; seqno
000088  1e40              SUBS     r0,r0,#1              ;688
00008a  6560              STR      r0,[r4,#0x54]         ;688
00008c  6928              LDR      r0,[r5,#0x10]         ;689
00008e  6120              STR      r0,[r4,#0x10]         ;689
000090  67e5              STR      r5,[r4,#0x7c]         ;691
000092  7a68              LDRB     r0,[r5,#9]            ;694
000094  f000000c          AND      r0,r0,#0xc            ;694
000098  7260              STRB     r0,[r4,#9]            ;694
00009a  7a28              LDRB     r0,[r5,#8]            ;695
00009c  7220              STRB     r0,[r4,#8]            ;695
00009e  483c              LDR      r0,|L5.400|
0000a0  6801              LDR      r1,[r0,#0]            ;698  ; tcp_active_pcbs
0000a2  60e1              STR      r1,[r4,#0xc]          ;698
0000a4  6004              STR      r4,[r0,#0]            ;698  ; tcp_active_pcbs
0000a6  f7fffffe          BL       tcp_timer_needed
0000aa  493a              LDR      r1,|L5.404|
0000ac  2001              MOVS     r0,#1                 ;698
0000ae  7008              STRB     r0,[r1,#0]            ;698
0000b0  4620              MOV      r0,r4                 ;701
0000b2  f7fffffe          BL       tcp_parseopt
0000b6  68f0              LDR      r0,[r6,#0xc]          ;702  ; tcphdr
0000b8  89c0              LDRH     r0,[r0,#0xe]          ;702
0000ba  f8a40060          STRH     r0,[r4,#0x60]         ;702
0000be  f8a40062          STRH     r0,[r4,#0x62]         ;703
0000c2  1d20              ADDS     r0,r4,#4              ;706
0000c4  f7fffffe          BL       ip4_route
0000c8  4601              MOV      r1,r0                 ;706
0000ca  8e60              LDRH     r0,[r4,#0x32]         ;706
0000cc  1d22              ADDS     r2,r4,#4              ;706
0000ce  f7fffffe          BL       tcp_eff_send_mss_netif
0000d2  8660              STRH     r0,[r4,#0x32]         ;706
0000d4  2112              MOVS     r1,#0x12              ;719
0000d6  4620              MOV      r0,r4                 ;719
0000d8  f7fffffe          BL       tcp_enqueue_flags
0000dc  b188              CBZ      r0,|L5.258|
0000de  b003              ADD      sp,sp,#0xc            ;721
0000e0  4620              MOV      r0,r4                 ;721
0000e2  e8bd40f0          POP      {r4-r7,lr}            ;721
0000e6  2100              MOVS     r1,#0                 ;721
0000e8  f7ffbffe          B.W      tcp_abandon
                  |L5.236|
0000ec  69ab              LDR      r3,[r5,#0x18]         ;667
0000ee  2b00              CMP      r3,#0                 ;667
0000f0  d0a8              BEQ      |L5.68|
0000f2  6928              LDR      r0,[r5,#0x10]         ;667
0000f4  b003              ADD      sp,sp,#0xc            ;667
0000f6  f04f32ff          MOV      r2,#0xffffffff        ;667
0000fa  e8bd40f0          POP      {r4-r7,lr}            ;667
0000fe  2100              MOVS     r1,#0                 ;667
000100  4718              BX       r3                    ;667
                  |L5.258|
000102  4620              MOV      r0,r4                 ;724
000104  e8bd40fe          POP      {r1-r7,lr}            ;724
000108  f7ffbffe          B.W      tcp_output
;;;728    
                          ENDP

                  |L5.268|
                          DCD      ||.data||
                  |L5.272|
000110  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_in.c"
000114  6964646c
000118  65776172
00011c  65735c54
000120  68697264
000124  5f506172
000128  74795c4c
00012c  7749505c
000130  7372635c
000134  636f7265
000138  5c746370
00013c  5f696e2e
000140  63      
000141  00                DCB      0
000142  00                DCB      0
000143  00                DCB      0
                  |L5.324|
000144  7463705f          DCB      "tcp_listen_input: invalid pcb",0
000148  6c697374
00014c  656e5f69
000150  6e707574
000154  3a20696e
000158  76616c69
00015c  64207063
000160  6200    
000162  00                DCB      0
000163  00                DCB      0
                  |L5.356|
000164  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000168  7274696f
00016c  6e202225
000170  73222066
000174  61696c65
000178  64206174
00017c  206c696e
000180  65202564
000184  20696e20
000188  25730a00
                  |L5.396|
                          DCD      ip_data+0x10
                  |L5.400|
                          DCD      tcp_active_pcbs
                  |L5.404|
                          DCD      tcp_active_pcbs_changed

                          AREA ||i.tcp_oos_insert_segment||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_oos_insert_segment PROC
;;;1050   static void
;;;1051   tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
000000  b570              PUSH     {r4-r6,lr}
;;;1052   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1053     struct tcp_seg *old_seg;
;;;1054   
;;;1055     LWIP_ASSERT("tcp_oos_insert_segment: invalid cseg", cseg != NULL);
000006  2d00              CMP      r5,#0
000008  d106              BNE      |L6.24|
00000a  a320              ADR      r3,|L6.140|
00000c  f240421f          MOV      r2,#0x41f
000010  a12b              ADR      r1,|L6.192|
000012  a035              ADR      r0,|L6.232|
000014  f7fffffe          BL       __2printf
                  |L6.24|
;;;1056   
;;;1057     if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
000018  68e8              LDR      r0,[r5,#0xc]
00001a  8980              LDRH     r0,[r0,#0xc]
00001c  f7fffffe          BL       lwip_htons
000020  07c0              LSLS     r0,r0,#31
000022  d004              BEQ      |L6.46|
;;;1058       /* received segment overlaps all following segments */
;;;1059       tcp_segs_free(next);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       tcp_segs_free
;;;1060       next = NULL;
00002a  2400              MOVS     r4,#0
00002c  e02b              B        |L6.134|
                  |L6.46|
;;;1061     } else {
;;;1062       /* delete some following segments
;;;1063          oos queue may have segments with FIN flag */
;;;1064       while (next &&
;;;1065              TCP_SEQ_GEQ((seqno + cseg->len),
00002e  4e38              LDR      r6,|L6.272|
000030  e010              B        |L6.84|
                  |L6.50|
;;;1066                          (next->tcphdr->seqno + next->len))) {
;;;1067         /* cseg with FIN already processed */
;;;1068         if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
000032  8980              LDRH     r0,[r0,#0xc]
000034  f7fffffe          BL       lwip_htons
000038  07c0              LSLS     r0,r0,#31
00003a  d007              BEQ      |L6.76|
;;;1069           TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
00003c  2001              MOVS     r0,#1
00003e  f7fffffe          BL       lwip_htons
000042  4601              MOV      r1,r0
000044  68e8              LDR      r0,[r5,#0xc]
000046  8982              LDRH     r2,[r0,#0xc]
000048  4311              ORRS     r1,r1,r2
00004a  8181              STRH     r1,[r0,#0xc]
                  |L6.76|
;;;1070         }
;;;1071         old_seg = next;
;;;1072         next = next->next;
00004c  4620              MOV      r0,r4
00004e  6824              LDR      r4,[r4,#0]
;;;1073         tcp_seg_free(old_seg);
000050  f7fffffe          BL       tcp_seg_free
                  |L6.84|
000054  b144              CBZ      r4,|L6.104|
000056  68e0              LDR      r0,[r4,#0xc]          ;1065
000058  8922              LDRH     r2,[r4,#8]            ;1065
00005a  6973              LDR      r3,[r6,#0x14]         ;1065  ; seqno
00005c  6841              LDR      r1,[r0,#4]            ;1065
00005e  4411              ADD      r1,r1,r2              ;1065
000060  892a              LDRH     r2,[r5,#8]            ;1065
000062  441a              ADD      r2,r2,r3              ;1065
000064  1a51              SUBS     r1,r2,r1              ;1065
000066  d5e4              BPL      |L6.50|
                  |L6.104|
;;;1074       }
;;;1075       if (next &&
000068  b16c              CBZ      r4,|L6.134|
;;;1076           TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
00006a  8928              LDRH     r0,[r5,#8]
00006c  6971              LDR      r1,[r6,#0x14]  ; seqno
00006e  1842              ADDS     r2,r0,r1
000070  68e0              LDR      r0,[r4,#0xc]
000072  6840              LDR      r0,[r0,#4]
000074  1a12              SUBS     r2,r2,r0
000076  2a00              CMP      r2,#0
000078  dd05              BLE      |L6.134|
;;;1077         /* We need to trim the incoming segment. */
;;;1078         cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
00007a  1a40              SUBS     r0,r0,r1
00007c  b281              UXTH     r1,r0
00007e  8129              STRH     r1,[r5,#8]
;;;1079         pbuf_realloc(cseg->p, cseg->len);
000080  6868              LDR      r0,[r5,#4]
000082  f7fffffe          BL       pbuf_realloc
                  |L6.134|
;;;1080       }
;;;1081     }
;;;1082     cseg->next = next;
000086  602c              STR      r4,[r5,#0]
;;;1083   }
000088  bd70              POP      {r4-r6,pc}
;;;1084   #endif /* TCP_QUEUE_OOSEQ */
                          ENDP

00008a  0000              DCW      0x0000
                  |L6.140|
00008c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_in.c"
000090  6964646c
000094  65776172
000098  65735c54
00009c  68697264
0000a0  5f506172
0000a4  74795c4c
0000a8  7749505c
0000ac  7372635c
0000b0  636f7265
0000b4  5c746370
0000b8  5f696e2e
0000bc  63      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L6.192|
0000c0  7463705f          DCB      "tcp_oos_insert_segment: invalid cseg",0
0000c4  6f6f735f
0000c8  696e7365
0000cc  72745f73
0000d0  65676d65
0000d4  6e743a20
0000d8  696e7661
0000dc  6c696420
0000e0  63736567
0000e4  00      
0000e5  00                DCB      0
0000e6  00                DCB      0
0000e7  00                DCB      0
                  |L6.232|
0000e8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000ec  7274696f
0000f0  6e202225
0000f4  73222066
0000f8  61696c65
0000fc  64206174
000100  206c696e
000104  65202564
000108  20696e20
00010c  25730a00
                  |L6.272|
                          DCD      ||.data||

                          AREA ||i.tcp_parseopt||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_parseopt PROC
;;;1908   static void
;;;1909   tcp_parseopt(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1910   {
000004  4605              MOV      r5,r0
;;;1911     u8_t data;
;;;1912     u16_t mss;
;;;1913   #if LWIP_TCP_TIMESTAMPS
;;;1914     u32_t tsval;
;;;1915   #endif
;;;1916   
;;;1917     LWIP_ASSERT("tcp_parseopt: invalid pcb", pcb != NULL);
000006  2d00              CMP      r5,#0
000008  d106              BNE      |L7.24|
00000a  a31d              ADR      r3,|L7.128|
00000c  f240727d          MOV      r2,#0x77d
000010  a128              ADR      r1,|L7.180|
000012  a02f              ADR      r0,|L7.208|
000014  f7fffffe          BL       __2printf
                  |L7.24|
;;;1918   
;;;1919     /* Parse the TCP MSS option, if present. */
;;;1920     if (tcphdr_optlen != 0) {
000018  4c37              LDR      r4,|L7.248|
00001a  8860              LDRH     r0,[r4,#2]  ; tcphdr_optlen
00001c  2800              CMP      r0,#0
00001e  d018              BEQ      |L7.82|
;;;1921       for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
000020  2000              MOVS     r0,#0
000022  80e0              STRH     r0,[r4,#6]
;;;1922         u8_t opt = tcp_get_next_optbyte();
;;;1923         switch (opt) {
;;;1924           case LWIP_TCP_OPT_EOL:
;;;1925             /* End of options. */
;;;1926             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
;;;1927             return;
;;;1928           case LWIP_TCP_OPT_NOP:
;;;1929             /* NOP option. */
;;;1930             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
;;;1931             break;
;;;1932           case LWIP_TCP_OPT_MSS:
;;;1933             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
;;;1934             if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
;;;1935               /* Bad length */
;;;1936               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1937               return;
;;;1938             }
;;;1939             /* An MSS option with the right option length. */
;;;1940             mss = (u16_t)(tcp_get_next_optbyte() << 8);
;;;1941             mss |= tcp_get_next_optbyte();
;;;1942             /* Limit the mss to the configured TCP_MSS and prevent division by zero */
;;;1943             pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
000024  f44f7606          MOV      r6,#0x218
000028  e00f              B        |L7.74|
                  |L7.42|
00002a  f7fffffe          BL       tcp_get_next_optbyte
00002e  2800              CMP      r0,#0                 ;1923
000030  d00f              BEQ      |L7.82|
000032  2801              CMP      r0,#1                 ;1923
000034  d009              BEQ      |L7.74|
000036  2802              CMP      r0,#2                 ;1923
000038  d00d              BEQ      |L7.86|
;;;1944             break;
;;;1945   #if LWIP_WND_SCALE
;;;1946           case LWIP_TCP_OPT_WS:
;;;1947             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: WND_SCALE\n"));
;;;1948             if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_WS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_WS) > tcphdr_optlen) {
;;;1949               /* Bad length */
;;;1950               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1951               return;
;;;1952             }
;;;1953             /* An WND_SCALE option with the right option length. */
;;;1954             data = tcp_get_next_optbyte();
;;;1955             /* If syn was received with wnd scale option,
;;;1956                activate wnd scale opt, but only if this is not a retransmission */
;;;1957             if ((flags & TCP_SYN) && !(pcb->flags & TF_WND_SCALE)) {
;;;1958               pcb->snd_scale = data;
;;;1959               if (pcb->snd_scale > 14U) {
;;;1960                 pcb->snd_scale = 14U;
;;;1961               }
;;;1962               pcb->rcv_scale = TCP_RCV_SCALE;
;;;1963               tcp_set_flags(pcb, TF_WND_SCALE);
;;;1964               /* window scaling is enabled, we can use the full receive window */
;;;1965               LWIP_ASSERT("window not at default value", pcb->rcv_wnd == TCPWND_MIN16(TCP_WND));
;;;1966               LWIP_ASSERT("window not at default value", pcb->rcv_ann_wnd == TCPWND_MIN16(TCP_WND));
;;;1967               pcb->rcv_wnd = pcb->rcv_ann_wnd = TCP_WND;
;;;1968             }
;;;1969             break;
;;;1970   #endif /* LWIP_WND_SCALE */
;;;1971   #if LWIP_TCP_TIMESTAMPS
;;;1972           case LWIP_TCP_OPT_TS:
;;;1973             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: TS\n"));
;;;1974             if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_TS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_TS) > tcphdr_optlen) {
;;;1975               /* Bad length */
;;;1976               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1977               return;
;;;1978             }
;;;1979             /* TCP timestamp option with valid length */
;;;1980             tsval = tcp_get_next_optbyte();
;;;1981             tsval |= (tcp_get_next_optbyte() << 8);
;;;1982             tsval |= (tcp_get_next_optbyte() << 16);
;;;1983             tsval |= (tcp_get_next_optbyte() << 24);
;;;1984             if (flags & TCP_SYN) {
;;;1985               pcb->ts_recent = lwip_ntohl(tsval);
;;;1986               /* Enable sending timestamps in every segment now that we know
;;;1987                  the remote host supports it. */
;;;1988               tcp_set_flags(pcb, TF_TIMESTAMP);
;;;1989             } else if (TCP_SEQ_BETWEEN(pcb->ts_lastacksent, seqno, seqno + tcplen)) {
;;;1990               pcb->ts_recent = lwip_ntohl(tsval);
;;;1991             }
;;;1992             /* Advance to next option (6 bytes already read) */
;;;1993             tcp_optidx += LWIP_TCP_OPT_LEN_TS - 6;
;;;1994             break;
;;;1995   #endif /* LWIP_TCP_TIMESTAMPS */
;;;1996   #if LWIP_TCP_SACK_OUT
;;;1997           case LWIP_TCP_OPT_SACK_PERM:
;;;1998             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: SACK_PERM\n"));
;;;1999             if (tcp_get_next_optbyte() != LWIP_TCP_OPT_LEN_SACK_PERM || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_SACK_PERM) > tcphdr_optlen) {
;;;2000               /* Bad length */
;;;2001               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;2002               return;
;;;2003             }
;;;2004             /* TCP SACK_PERM option with valid length */
;;;2005             if (flags & TCP_SYN) {
;;;2006               /* We only set it if we receive it in a SYN (or SYN+ACK) packet */
;;;2007               tcp_set_flags(pcb, TF_SACK);
;;;2008             }
;;;2009             break;
;;;2010   #endif /* LWIP_TCP_SACK_OUT */
;;;2011           default:
;;;2012             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
;;;2013             data = tcp_get_next_optbyte();
00003a  f7fffffe          BL       tcp_get_next_optbyte
;;;2014             if (data < 2) {
00003e  2802              CMP      r0,#2
000040  d307              BCC      |L7.82|
;;;2015               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;2016               /* If the length field is zero, the options are malformed
;;;2017                  and we don't process them further. */
;;;2018               return;
;;;2019             }
;;;2020             /* All other options have a length field, so that we easily
;;;2021                can skip past them. */
;;;2022             tcp_optidx += data - 2;
000042  88e1              LDRH     r1,[r4,#6]  ; tcp_optidx
000044  4408              ADD      r0,r0,r1
000046  1e80              SUBS     r0,r0,#2
000048  80e0              STRH     r0,[r4,#6]
                  |L7.74|
00004a  88e0              LDRH     r0,[r4,#6]            ;1921  ; tcp_optidx
00004c  8861              LDRH     r1,[r4,#2]            ;1921  ; tcphdr_optlen
00004e  4288              CMP      r0,r1                 ;1921
000050  d3eb              BCC      |L7.42|
                  |L7.82|
;;;2023         }
;;;2024       }
;;;2025     }
;;;2026   }
000052  e8bd81f0          POP      {r4-r8,pc}
                  |L7.86|
000056  f7fffffe          BL       tcp_get_next_optbyte
00005a  2804              CMP      r0,#4                 ;1934
00005c  d1f9              BNE      |L7.82|
00005e  88e0              LDRH     r0,[r4,#6]            ;1934  ; tcp_optidx
000060  8861              LDRH     r1,[r4,#2]            ;1934  ; tcphdr_optlen
000062  1c80              ADDS     r0,r0,#2              ;1934
000064  4288              CMP      r0,r1                 ;1934
000066  d8f4              BHI      |L7.82|
000068  f7fffffe          BL       tcp_get_next_optbyte
00006c  0207              LSLS     r7,r0,#8              ;1940
00006e  f7fffffe          BL       tcp_get_next_optbyte
000072  4338              ORRS     r0,r0,r7              ;1941
000074  42b0              CMP      r0,r6                 ;1943
000076  d800              BHI      |L7.122|
000078  b900              CBNZ     r0,|L7.124|
                  |L7.122|
00007a  4630              MOV      r0,r6                 ;1943
                  |L7.124|
00007c  8668              STRH     r0,[r5,#0x32]         ;1943
00007e  e7e4              B        |L7.74|
;;;2027   
                          ENDP

                  |L7.128|
000080  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_in.c"
000084  6964646c
000088  65776172
00008c  65735c54
000090  68697264
000094  5f506172
000098  74795c4c
00009c  7749505c
0000a0  7372635c
0000a4  636f7265
0000a8  5c746370
0000ac  5f696e2e
0000b0  63      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L7.180|
0000b4  7463705f          DCB      "tcp_parseopt: invalid pcb",0
0000b8  70617273
0000bc  656f7074
0000c0  3a20696e
0000c4  76616c69
0000c8  64207063
0000cc  6200    
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L7.208|
0000d0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000d4  7274696f
0000d8  6e202225
0000dc  73222066
0000e0  61696c65
0000e4  64206174
0000e8  206c696e
0000ec  65202564
0000f0  20696e20
0000f4  25730a00
                  |L7.248|
                          DCD      ||.data||

                          AREA ||i.tcp_process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_process PROC
;;;787    static err_t
;;;788    tcp_process(struct tcp_pcb *pcb)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;789    {
000004  4604              MOV      r4,r0
;;;790      struct tcp_seg *rseg;
;;;791      u8_t acceptable = 0;
000006  2500              MOVS     r5,#0
;;;792      err_t err;
;;;793    
;;;794      err = ERR_OK;
000008  2000              MOVS     r0,#0
00000a  9003              STR      r0,[sp,#0xc]
;;;795    
;;;796      LWIP_ASSERT("tcp_process: invalid pcb", pcb != NULL);
00000c  2c00              CMP      r4,#0
00000e  d106              BNE      |L8.30|
000010  a3e5              ADR      r3,|L8.936|
000012  f44f7247          MOV      r2,#0x31c
000016  a1f1              ADR      r1,|L8.988|
000018  a0f7              ADR      r0,|L8.1016|
00001a  f7fffffe          BL       __2printf
                  |L8.30|
;;;797    
;;;798      /* Process incoming RST segments. */
;;;799      if (flags & TCP_RST) {
00001e  f8dfb400          LDR      r11,|L8.1056|
000022  f89b0000          LDRB     r0,[r11,#0]  ; flags
000026  0741              LSLS     r1,r0,#29
000028  d536              BPL      |L8.152|
;;;800        /* First, determine if the reset is acceptable. */
;;;801        if (pcb->state == SYN_SENT) {
00002a  7d22              LDRB     r2,[r4,#0x14]
00002c  2a02              CMP      r2,#2
00002e  d006              BEQ      |L8.62|
;;;802          /* "In the SYN-SENT state (a RST received in response to an initial SYN),
;;;803              the RST is acceptable if the ACK field acknowledges the SYN." */
;;;804          if (ackno == pcb->snd_nxt) {
;;;805            acceptable = 1;
;;;806          }
;;;807        } else {
;;;808          /* "In all states except SYN-SENT, all reset (RST) segments are validated
;;;809              by checking their SEQ-fields." */
;;;810          if (seqno == pcb->rcv_nxt) {
000030  6a60              LDR      r0,[r4,#0x24]
000032  f8db1014          LDR      r1,[r11,#0x14]  ; seqno
000036  4288              CMP      r0,r1
000038  d108              BNE      |L8.76|
;;;811            acceptable = 1;
00003a  2501              MOVS     r5,#1
00003c  e011              B        |L8.98|
                  |L8.62|
00003e  6d20              LDR      r0,[r4,#0x50]         ;804
000040  f8db1018          LDR      r1,[r11,#0x18]        ;804  ; ackno
000044  4288              CMP      r0,r1                 ;804
000046  d10c              BNE      |L8.98|
000048  2501              MOVS     r5,#1                 ;805
00004a  e00a              B        |L8.98|
                  |L8.76|
;;;812          } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
00004c  1a0b              SUBS     r3,r1,r0
00004e  d408              BMI      |L8.98|
000050  8d23              LDRH     r3,[r4,#0x28]
000052  4418              ADD      r0,r0,r3
000054  1a08              SUBS     r0,r1,r0
000056  2800              CMP      r0,#0
000058  dc03              BGT      |L8.98|
;;;813                                      pcb->rcv_nxt + pcb->rcv_wnd)) {
;;;814            /* If the sequence number is inside the window, we send a challenge ACK
;;;815               and wait for a re-send with matching sequence number.
;;;816               This follows RFC 5961 section 3.2 and addresses CVE-2004-0230
;;;817               (RST spoofing attack), which is present in RFC 793 RST handling. */
;;;818            tcp_ack_now(pcb);
00005a  8b60              LDRH     r0,[r4,#0x1a]
00005c  f0400002          ORR      r0,r0,#2
000060  8360              STRH     r0,[r4,#0x1a]
                  |L8.98|
;;;819          }
;;;820        }
;;;821    
;;;822        if (acceptable) {
000062  2d00              CMP      r5,#0
000064  d016              BEQ      |L8.148|
;;;823          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
;;;824          LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
000066  b932              CBNZ     r2,|L8.118|
000068  a3cf              ADR      r3,|L8.936|
00006a  f44f724e          MOV      r2,#0x338
00006e  a1ed              ADR      r1,|L8.1060|
000070  a0e1              ADR      r0,|L8.1016|
000072  f7fffffe          BL       __2printf
                  |L8.118|
;;;825          recv_flags |= TF_RESET;
000076  f89b0001          LDRB     r0,[r11,#1]  ; recv_flags
00007a  f0400008          ORR      r0,r0,#8
00007e  f88b0001          STRB     r0,[r11,#1]
;;;826          tcp_clear_flags(pcb, TF_ACK_DELAY);
000082  8b60              LDRH     r0,[r4,#0x1a]
000084  f0200001          BIC      r0,r0,#1
000088  8360              STRH     r0,[r4,#0x1a]
;;;827          return ERR_RST;
00008a  f06f000d          MVN      r0,#0xd
                  |L8.142|
;;;828        } else {
;;;829          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;830                                        seqno, pcb->rcv_nxt));
;;;831          LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;832                                  seqno, pcb->rcv_nxt));
;;;833          return ERR_OK;
;;;834        }
;;;835      }
;;;836    
;;;837      if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
;;;838        /* Cope with new connection attempt after remote end crashed */
;;;839        tcp_ack_now(pcb);
;;;840        return ERR_OK;
;;;841      }
;;;842    
;;;843      if ((pcb->flags & TF_RXCLOSED) == 0) {
;;;844        /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
;;;845        pcb->tmr = tcp_ticks;
;;;846      }
;;;847      pcb->keep_cnt_sent = 0;
;;;848      pcb->persist_probe = 0;
;;;849    
;;;850      tcp_parseopt(pcb);
;;;851    
;;;852      /* Do different things depending on the TCP state. */
;;;853      switch (pcb->state) {
;;;854        case SYN_SENT:
;;;855          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
;;;856                                        pcb->snd_nxt, lwip_ntohl(pcb->unacked->tcphdr->seqno)));
;;;857          /* received SYN ACK with expected sequence number? */
;;;858          if ((flags & TCP_ACK) && (flags & TCP_SYN)
;;;859              && (ackno == pcb->lastack + 1)) {
;;;860            pcb->rcv_nxt = seqno + 1;
;;;861            pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;862            pcb->lastack = ackno;
;;;863            pcb->snd_wnd = tcphdr->wnd;
;;;864            pcb->snd_wnd_max = pcb->snd_wnd;
;;;865            pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
;;;866            pcb->state = ESTABLISHED;
;;;867    
;;;868    #if TCP_CALCULATE_EFF_SEND_MSS
;;;869            pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
;;;870    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;871    
;;;872            pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
;;;873            LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
;;;874                                         " ssthresh %"TCPWNDSIZE_F"\n",
;;;875                                         pcb->cwnd, pcb->ssthresh));
;;;876            LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
;;;877            --pcb->snd_queuelen;
;;;878            LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
;;;879            rseg = pcb->unacked;
;;;880            if (rseg == NULL) {
;;;881              /* might happen if tcp_output fails in tcp_rexmit_rto()
;;;882                 in which case the segment is on the unsent list */
;;;883              rseg = pcb->unsent;
;;;884              LWIP_ASSERT("no segment to free", rseg != NULL);
;;;885              pcb->unsent = rseg->next;
;;;886            } else {
;;;887              pcb->unacked = rseg->next;
;;;888            }
;;;889            tcp_seg_free(rseg);
;;;890    
;;;891            /* If there's nothing left to acknowledge, stop the retransmit
;;;892               timer, otherwise reset it to start again */
;;;893            if (pcb->unacked == NULL) {
;;;894              pcb->rtime = -1;
;;;895            } else {
;;;896              pcb->rtime = 0;
;;;897              pcb->nrtx = 0;
;;;898            }
;;;899    
;;;900            /* Call the user specified function to call when successfully
;;;901             * connected. */
;;;902            TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
;;;903            if (err == ERR_ABRT) {
;;;904              return ERR_ABRT;
;;;905            }
;;;906            tcp_ack_now(pcb);
;;;907          }
;;;908          /* received ACK? possibly a half-open connection */
;;;909          else if (flags & TCP_ACK) {
;;;910            /* send a RST to bring the other side in a non-synchronized state. */
;;;911            tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
;;;912                    ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;913            /* Resend SYN immediately (don't wait for rto timeout) to establish
;;;914              connection faster, but do not send more SYNs than we otherwise would
;;;915              have, or we might get caught in a loop on loopback interfaces. */
;;;916            if (pcb->nrtx < TCP_SYNMAXRTX) {
;;;917              pcb->rtime = 0;
;;;918              tcp_rexmit_rto(pcb);
;;;919            }
;;;920          }
;;;921          break;
;;;922        case SYN_RCVD:
;;;923          if (flags & TCP_ACK) {
;;;924            /* expected ACK number? */
;;;925            if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
;;;926              pcb->state = ESTABLISHED;
;;;927              LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;928    #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
;;;929              if (pcb->listener == NULL) {
;;;930                /* listen pcb might be closed by now */
;;;931                err = ERR_VAL;
;;;932              } else
;;;933    #endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
;;;934              {
;;;935    #if LWIP_CALLBACK_API
;;;936                LWIP_ASSERT("pcb->listener->accept != NULL", pcb->listener->accept != NULL);
;;;937    #endif
;;;938                tcp_backlog_accepted(pcb);
;;;939                /* Call the accept function. */
;;;940                TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
;;;941              }
;;;942              if (err != ERR_OK) {
;;;943                /* If the accept function returns with an error, we abort
;;;944                 * the connection. */
;;;945                /* Already aborted? */
;;;946                if (err != ERR_ABRT) {
;;;947                  tcp_abort(pcb);
;;;948                }
;;;949                return ERR_ABRT;
;;;950              }
;;;951              /* If there was any data contained within this ACK,
;;;952               * we'd better pass it on to the application as well. */
;;;953              tcp_receive(pcb);
;;;954    
;;;955              /* Prevent ACK for SYN to generate a sent event */
;;;956              if (recv_acked != 0) {
;;;957                recv_acked--;
;;;958              }
;;;959    
;;;960              pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
;;;961              LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
;;;962                                           " ssthresh %"TCPWNDSIZE_F"\n",
;;;963                                           pcb->cwnd, pcb->ssthresh));
;;;964    
;;;965              if (recv_flags & TF_GOT_FIN) {
;;;966                tcp_ack_now(pcb);
;;;967                pcb->state = CLOSE_WAIT;
;;;968              }
;;;969            } else {
;;;970              /* incorrect ACK number, send RST */
;;;971              tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
;;;972                      ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;973            }
;;;974          } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
;;;975            /* Looks like another copy of the SYN - retransmit our SYN-ACK */
;;;976            tcp_rexmit(pcb);
;;;977          }
;;;978          break;
;;;979        case CLOSE_WAIT:
;;;980        /* FALLTHROUGH */
;;;981        case ESTABLISHED:
;;;982          tcp_receive(pcb);
;;;983          if (recv_flags & TF_GOT_FIN) { /* passive close */
;;;984            tcp_ack_now(pcb);
;;;985            pcb->state = CLOSE_WAIT;
;;;986          }
;;;987          break;
;;;988        case FIN_WAIT_1:
;;;989          tcp_receive(pcb);
;;;990          if (recv_flags & TF_GOT_FIN) {
;;;991            if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
;;;992                pcb->unsent == NULL) {
;;;993              LWIP_DEBUGF(TCP_DEBUG,
;;;994                          ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;995              tcp_ack_now(pcb);
;;;996              tcp_pcb_purge(pcb);
;;;997              TCP_RMV_ACTIVE(pcb);
;;;998              pcb->state = TIME_WAIT;
;;;999              TCP_REG(&tcp_tw_pcbs, pcb);
;;;1000           } else {
;;;1001             tcp_ack_now(pcb);
;;;1002             pcb->state = CLOSING;
;;;1003           }
;;;1004         } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
;;;1005                    pcb->unsent == NULL) {
;;;1006           pcb->state = FIN_WAIT_2;
;;;1007         }
;;;1008         break;
;;;1009       case FIN_WAIT_2:
;;;1010         tcp_receive(pcb);
;;;1011         if (recv_flags & TF_GOT_FIN) {
;;;1012           LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;1013           tcp_ack_now(pcb);
;;;1014           tcp_pcb_purge(pcb);
;;;1015           TCP_RMV_ACTIVE(pcb);
;;;1016           pcb->state = TIME_WAIT;
;;;1017           TCP_REG(&tcp_tw_pcbs, pcb);
;;;1018         }
;;;1019         break;
;;;1020       case CLOSING:
;;;1021         tcp_receive(pcb);
;;;1022         if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
;;;1023           LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;1024           tcp_pcb_purge(pcb);
;;;1025           TCP_RMV_ACTIVE(pcb);
;;;1026           pcb->state = TIME_WAIT;
;;;1027           TCP_REG(&tcp_tw_pcbs, pcb);
;;;1028         }
;;;1029         break;
;;;1030       case LAST_ACK:
;;;1031         tcp_receive(pcb);
;;;1032         if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
;;;1033           LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;1034           /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
;;;1035           recv_flags |= TF_CLOSED;
;;;1036         }
;;;1037         break;
;;;1038       default:
;;;1039         break;
;;;1040     }
;;;1041     return ERR_OK;
;;;1042   }
00008e  b004              ADD      sp,sp,#0x10
000090  e8bd9ff0          POP      {r4-r12,pc}
                  |L8.148|
000094  2000              MOVS     r0,#0                 ;833
000096  e7fa              B        |L8.142|
                  |L8.152|
000098  0780              LSLS     r0,r0,#30             ;837
00009a  d50a              BPL      |L8.178|
00009c  7d20              LDRB     r0,[r4,#0x14]         ;837
00009e  2802              CMP      r0,#2                 ;837
0000a0  d007              BEQ      |L8.178|
0000a2  2803              CMP      r0,#3                 ;837
0000a4  d005              BEQ      |L8.178|
0000a6  8b60              LDRH     r0,[r4,#0x1a]         ;839
0000a8  f0400002          ORR      r0,r0,#2              ;839
0000ac  8360              STRH     r0,[r4,#0x1a]         ;839
0000ae  2000              MOVS     r0,#0                 ;840
0000b0  e7ed              B        |L8.142|
                  |L8.178|
0000b2  7ea0              LDRB     r0,[r4,#0x1a]         ;843
0000b4  06c0              LSLS     r0,r0,#27             ;843
0000b6  d402              BMI      |L8.190|
0000b8  48e2              LDR      r0,|L8.1092|
0000ba  6800              LDR      r0,[r0,#0]            ;845  ; tcp_ticks
0000bc  6220              STR      r0,[r4,#0x20]         ;845
                  |L8.190|
0000be  f04f0a00          MOV      r10,#0                ;847
0000c2  f884a09b          STRB     r10,[r4,#0x9b]        ;847
0000c6  f884a09a          STRB     r10,[r4,#0x9a]        ;848
0000ca  4620              MOV      r0,r4                 ;850
0000cc  f7fffffe          BL       tcp_parseopt
0000d0  4bdd              LDR      r3,|L8.1096|
0000d2  7d21              LDRB     r1,[r4,#0x14]         ;853
0000d4  f1030010          ADD      r0,r3,#0x10           ;911
0000d8  1e89              SUBS     r1,r1,#2              ;853
0000da  2701              MOVS     r7,#1                 ;805
0000dc  2204              MOVS     r2,#4                 ;866
0000de  3314              ADDS     r3,r3,#0x14           ;911
0000e0  f8df8368          LDR      r8,|L8.1100|
0000e4  4eda              LDR      r6,|L8.1104|
0000e6  4ddb              LDR      r5,|L8.1108|
0000e8  f04f090a          MOV      r9,#0xa               ;998
0000ec  2908              CMP      r1,#8                 ;853
0000ee  d269              BCS      |L8.452|
0000f0  e8dff001          TBB      [pc,r1]               ;853
0000f4  0499f6f5          DCB      0x04,0x99,0xf6,0xf5
0000f8  f4f6f3f2          DCB      0xf4,0xf6,0xf3,0xf2
0000fc  f89b1000          LDRB     r1,[r11,#0]           ;858  ; flags
000100  06cd              LSLS     r5,r1,#27             ;858
000102  d574              BPL      |L8.494|
000104  078d              LSLS     r5,r1,#30             ;858
000106  d572              BPL      |L8.494|
000108  6c66              LDR      r6,[r4,#0x44]         ;859
00010a  f8db5018          LDR      r5,[r11,#0x18]        ;859  ; ackno
00010e  1c76              ADDS     r6,r6,#1              ;859
000110  42ae              CMP      r6,r5                 ;859
000112  d16c              BNE      |L8.494|
000114  f8db0014          LDR      r0,[r11,#0x14]        ;860  ; seqno
000118  4601              MOV      r1,r0                 ;860
00011a  1c40              ADDS     r0,r0,#1              ;860
00011c  6260              STR      r0,[r4,#0x24]         ;860
00011e  62e0              STR      r0,[r4,#0x2c]         ;861
000120  6465              STR      r5,[r4,#0x44]         ;862
000122  f8db000c          LDR      r0,[r11,#0xc]         ;863  ; tcphdr
000126  89c0              LDRH     r0,[r0,#0xe]          ;863
000128  f8a40060          STRH     r0,[r4,#0x60]         ;863
00012c  f8a40062          STRH     r0,[r4,#0x62]         ;864
000130  1e49              SUBS     r1,r1,#1              ;865
000132  6561              STR      r1,[r4,#0x54]         ;865
000134  7522              STRB     r2,[r4,#0x14]         ;866
000136  1d20              ADDS     r0,r4,#4              ;869
000138  f7fffffe          BL       ip4_route
00013c  4601              MOV      r1,r0                 ;869
00013e  8e60              LDRH     r0,[r4,#0x32]         ;869
000140  1d22              ADDS     r2,r4,#4              ;869
000142  f7fffffe          BL       tcp_eff_send_mss_netif
000146  8660              STRH     r0,[r4,#0x32]         ;869
000148  f241111c          MOV      r1,#0x111c            ;872
00014c  ebb10f40          CMP      r1,r0,LSL #1          ;872
000150  d201              BCS      |L8.342|
000152  0042              LSLS     r2,r0,#1              ;872
000154  e000              B        |L8.344|
                  |L8.342|
000156  460a              MOV      r2,r1                 ;872
                  |L8.344|
000158  ebb20f80          CMP      r2,r0,LSL #2          ;872
00015c  d901              BLS      |L8.354|
00015e  0081              LSLS     r1,r0,#2              ;872
000160  e003              B        |L8.362|
                  |L8.354|
000162  ebb10f40          CMP      r1,r0,LSL #1          ;872
000166  d200              BCS      |L8.362|
000168  0041              LSLS     r1,r0,#1              ;872
                  |L8.362|
00016a  f8a41048          STRH     r1,[r4,#0x48]         ;872
00016e  f8b40066          LDRH     r0,[r4,#0x66]         ;876
000172  b930              CBNZ     r0,|L8.386|
000174  a38c              ADR      r3,|L8.936|
000176  f44f725b          MOV      r2,#0x36c             ;876
00017a  a1b7              ADR      r1,|L8.1112|
00017c  a09e              ADR      r0,|L8.1016|
00017e  f7fffffe          BL       __2printf
                  |L8.386|
000182  f8b40066          LDRH     r0,[r4,#0x66]         ;877
000186  1e40              SUBS     r0,r0,#1              ;877
000188  f8a40066          STRH     r0,[r4,#0x66]         ;877
00018c  6f25              LDR      r5,[r4,#0x70]         ;879
00018e  b1d5              CBZ      r5,|L8.454|
000190  6828              LDR      r0,[r5,#0]            ;887
000192  6720              STR      r0,[r4,#0x70]         ;887
                  |L8.404|
000194  4628              MOV      r0,r5                 ;889
000196  f7fffffe          BL       tcp_seg_free
00019a  6f20              LDR      r0,[r4,#0x70]         ;893
00019c  b1f8              CBZ      r0,|L8.478|
00019e  f8a4a030          STRH     r10,[r4,#0x30]        ;896
0001a2  f884a042          STRB     r10,[r4,#0x42]        ;897
                  |L8.422|
0001a6  f8d43088          LDR      r3,[r4,#0x88]         ;902
0001aa  b123              CBZ      r3,|L8.438|
0001ac  2200              MOVS     r2,#0                 ;902
0001ae  4621              MOV      r1,r4                 ;902
0001b0  6920              LDR      r0,[r4,#0x10]         ;902
0001b2  4798              BLX      r3                    ;902
0001b4  9003              STR      r0,[sp,#0xc]          ;902
                  |L8.438|
0001b6  9803              LDR      r0,[sp,#0xc]          ;903
0001b8  300d              ADDS     r0,r0,#0xd            ;903
0001ba  d015              BEQ      |L8.488|
0001bc  8b60              LDRH     r0,[r4,#0x1a]         ;906
0001be  f0400002          ORR      r0,r0,#2              ;906
0001c2  8360              STRH     r0,[r4,#0x1a]         ;906
                  |L8.452|
0001c4  e1e1              B        |L8.1418|
                  |L8.454|
0001c6  6ee5              LDR      r5,[r4,#0x6c]         ;883
0001c8  b935              CBNZ     r5,|L8.472|
0001ca  a377              ADR      r3,|L8.936|
0001cc  f44f725d          MOV      r2,#0x374             ;884
0001d0  a1a7              ADR      r1,|L8.1136|
0001d2  a089              ADR      r0,|L8.1016|
0001d4  f7fffffe          BL       __2printf
                  |L8.472|
0001d8  6828              LDR      r0,[r5,#0]            ;885
0001da  66e0              STR      r0,[r4,#0x6c]         ;885
0001dc  e7da              B        |L8.404|
                  |L8.478|
0001de  f04f30ff          MOV      r0,#0xffffffff        ;894
0001e2  8620              STRH     r0,[r4,#0x30]         ;894
0001e4  e7df              B        |L8.422|
0001e6  e002              B        |L8.494|
                  |L8.488|
0001e8  f06f000c          MVN      r0,#0xc               ;904
0001ec  e74f              B        |L8.142|
                  |L8.494|
0001ee  06c9              LSLS     r1,r1,#27             ;909
0001f0  d5e8              BPL      |L8.452|
0001f2  f8db100c          LDR      r1,[r11,#0xc]         ;911  ; tcphdr
0001f6  880a              LDRH     r2,[r1,#0]            ;911
0001f8  8849              LDRH     r1,[r1,#2]            ;911
0001fa  e88d0007          STM      sp,{r0-r2}            ;911
0001fe  f8bb100a          LDRH     r1,[r11,#0xa]         ;911  ; tcplen
000202  f8db0014          LDR      r0,[r11,#0x14]        ;911  ; seqno
000206  1842              ADDS     r2,r0,r1              ;911
000208  4620              MOV      r0,r4                 ;911
00020a  f8db1018          LDR      r1,[r11,#0x18]        ;911  ; ackno
00020e  f7fffffe          BL       tcp_rst
000212  f8940042          LDRB     r0,[r4,#0x42]         ;916
000216  2806              CMP      r0,#6                 ;916
000218  d2d4              BCS      |L8.452|
00021a  f8a4a030          STRH     r10,[r4,#0x30]        ;917
00021e  4620              MOV      r0,r4                 ;918
000220  f7fffffe          BL       tcp_rexmit_rto
000224  e1b1              B        |L8.1418|
000226  f89b1000          LDRB     r1,[r11,#0]           ;923  ; flags
00022a  06cd              LSLS     r5,r1,#27             ;923
00022c  d568              BPL      |L8.768|
00022e  6c65              LDR      r5,[r4,#0x44]         ;925
000230  f8db1018          LDR      r1,[r11,#0x18]        ;925  ; ackno
000234  1b4d              SUBS     r5,r1,r5              ;925
000236  2d01              CMP      r5,#1                 ;925
000238  d453              BMI      |L8.738|
00023a  6d25              LDR      r5,[r4,#0x50]         ;925
00023c  1b4d              SUBS     r5,r1,r5              ;925
00023e  2d00              CMP      r5,#0                 ;925
000240  dc4f              BGT      |L8.738|
000242  7522              STRB     r2,[r4,#0x14]         ;926
000244  6fe0              LDR      r0,[r4,#0x7c]         ;929
000246  b110              CBZ      r0,|L8.590|
000248  6980              LDR      r0,[r0,#0x18]         ;936
00024a  b118              CBZ      r0,|L8.596|
00024c  e009              B        |L8.610|
                  |L8.590|
00024e  f06f0005          MVN      r0,#5                 ;931
000252  e010              B        |L8.630|
                  |L8.596|
000254  a354              ADR      r3,|L8.936|
000256  f44f726a          MOV      r2,#0x3a8             ;936
00025a  a18a              ADR      r1,|L8.1156|
00025c  a066              ADR      r0,|L8.1016|
00025e  f7fffffe          BL       __2printf
                  |L8.610|
000262  6fe0              LDR      r0,[r4,#0x7c]         ;940
000264  6983              LDR      r3,[r0,#0x18]         ;940
000266  b123              CBZ      r3,|L8.626|
000268  2200              MOVS     r2,#0                 ;940
00026a  4621              MOV      r1,r4                 ;940
00026c  6920              LDR      r0,[r4,#0x10]         ;940
00026e  4798              BLX      r3                    ;940
000270  e001              B        |L8.630|
                  |L8.626|
000272  f06f000f          MVN      r0,#0xf               ;940
                  |L8.630|
000276  b138              CBZ      r0,|L8.648|
000278  300d              ADDS     r0,r0,#0xd            ;946
00027a  d002              BEQ      |L8.642|
00027c  4620              MOV      r0,r4                 ;947
00027e  f7fffffe          BL       tcp_abort
                  |L8.642|
000282  f06f000c          MVN      r0,#0xc               ;949
000286  e702              B        |L8.142|
                  |L8.648|
000288  4620              MOV      r0,r4                 ;953
00028a  f7fffffe          BL       tcp_receive
00028e  f8bb0008          LDRH     r0,[r11,#8]           ;956  ; recv_acked
000292  b110              CBZ      r0,|L8.666|
000294  1e40              SUBS     r0,r0,#1              ;957
000296  f8ab0008          STRH     r0,[r11,#8]           ;957
                  |L8.666|
00029a  8e60              LDRH     r0,[r4,#0x32]         ;960
00029c  f241111c          MOV      r1,#0x111c            ;960
0002a0  ebb10f40          CMP      r1,r0,LSL #1          ;960
0002a4  d201              BCS      |L8.682|
0002a6  0042              LSLS     r2,r0,#1              ;960
0002a8  e000              B        |L8.684|
                  |L8.682|
0002aa  460a              MOV      r2,r1                 ;960
                  |L8.684|
0002ac  ebb20f80          CMP      r2,r0,LSL #2          ;960
0002b0  d901              BLS      |L8.694|
0002b2  0081              LSLS     r1,r0,#2              ;960
0002b4  e003              B        |L8.702|
                  |L8.694|
0002b6  ebb10f40          CMP      r1,r0,LSL #1          ;960
0002ba  d200              BCS      |L8.702|
0002bc  0041              LSLS     r1,r0,#1              ;960
                  |L8.702|
0002be  f8a41048          STRH     r1,[r4,#0x48]         ;960
0002c2  f89b0001          LDRB     r0,[r11,#1]           ;965  ; recv_flags
0002c6  0680              LSLS     r0,r0,#26             ;965
0002c8  d505              BPL      |L8.726|
0002ca  8b60              LDRH     r0,[r4,#0x1a]         ;966
0002cc  f0400002          ORR      r0,r0,#2              ;966
0002d0  8360              STRH     r0,[r4,#0x1a]         ;966
0002d2  2007              MOVS     r0,#7                 ;967
0002d4  7520              STRB     r0,[r4,#0x14]         ;967
                  |L8.726|
0002d6  e158              B        |L8.1418|
0002d8  e143              B        |L8.1378|
0002da  e118              B        |L8.1294|
0002dc  e0f0              B        |L8.1216|
0002de  e029              B        |L8.820|
0002e0  e01a              B        |L8.792|
                  |L8.738|
0002e2  f8db200c          LDR      r2,[r11,#0xc]         ;971  ; tcphdr
0002e6  8815              LDRH     r5,[r2,#0]            ;971
0002e8  8852              LDRH     r2,[r2,#2]            ;971
0002ea  e88d0025          STM      sp,{r0,r2,r5}         ;971
0002ee  f8bb200a          LDRH     r2,[r11,#0xa]         ;971  ; tcplen
0002f2  f8db0014          LDR      r0,[r11,#0x14]        ;971  ; seqno
0002f6  4402              ADD      r2,r2,r0              ;971
0002f8  4620              MOV      r0,r4                 ;971
0002fa  f7fffffe          BL       tcp_rst
0002fe  e144              B        |L8.1418|
                  |L8.768|
000300  0788              LSLS     r0,r1,#30             ;974
000302  d508              BPL      |L8.790|
000304  6a60              LDR      r0,[r4,#0x24]         ;974
000306  f8db1014          LDR      r1,[r11,#0x14]        ;974  ; seqno
00030a  1e40              SUBS     r0,r0,#1              ;974
00030c  4288              CMP      r0,r1                 ;974
00030e  d102              BNE      |L8.790|
000310  4620              MOV      r0,r4                 ;976
000312  f7fffffe          BL       tcp_rexmit
                  |L8.790|
000316  e138              B        |L8.1418|
                  |L8.792|
000318  4620              MOV      r0,r4                 ;982
00031a  f7fffffe          BL       tcp_receive
00031e  f89b0001          LDRB     r0,[r11,#1]           ;983  ; recv_flags
000322  0680              LSLS     r0,r0,#26             ;983
000324  d505              BPL      |L8.818|
000326  8b60              LDRH     r0,[r4,#0x1a]         ;984
000328  f0400002          ORR      r0,r0,#2              ;984
00032c  8360              STRH     r0,[r4,#0x1a]         ;984
00032e  2007              MOVS     r0,#7                 ;985
000330  7520              STRB     r0,[r4,#0x14]         ;985
                  |L8.818|
000332  e12a              B        |L8.1418|
                  |L8.820|
000334  4620              MOV      r0,r4                 ;989
000336  f7fffffe          BL       tcp_receive
00033a  f89b0001          LDRB     r0,[r11,#1]           ;990  ; recv_flags
00033e  0680              LSLS     r0,r0,#26             ;990
000340  d531              BPL      |L8.934|
000342  f89b0000          LDRB     r0,[r11,#0]           ;991  ; flags
000346  06c0              LSLS     r0,r0,#27             ;991
000348  d506              BPL      |L8.856|
00034a  6d20              LDR      r0,[r4,#0x50]         ;991
00034c  f8db1018          LDR      r1,[r11,#0x18]        ;991  ; ackno
000350  4288              CMP      r0,r1                 ;991
000352  d101              BNE      |L8.856|
000354  6ee0              LDR      r0,[r4,#0x6c]         ;992
000356  b130              CBZ      r0,|L8.870|
                  |L8.856|
000358  8b60              LDRH     r0,[r4,#0x1a]         ;1001
00035a  f0400002          ORR      r0,r0,#2              ;1001
00035e  8360              STRH     r0,[r4,#0x1a]         ;1001
000360  2008              MOVS     r0,#8                 ;1002
000362  7520              STRB     r0,[r4,#0x14]         ;1002
000364  e111              B        |L8.1418|
                  |L8.870|
000366  8b60              LDRH     r0,[r4,#0x1a]         ;995
000368  f0400002          ORR      r0,r0,#2              ;995
00036c  8360              STRH     r0,[r4,#0x1a]         ;995
00036e  4620              MOV      r0,r4                 ;996
000370  f7fffffe          BL       tcp_pcb_purge
000374  6828              LDR      r0,[r5,#0]            ;997  ; tcp_active_pcbs
000376  42a0              CMP      r0,r4                 ;997
000378  d109              BNE      |L8.910|
00037a  68c0              LDR      r0,[r0,#0xc]          ;997
00037c  6028              STR      r0,[r5,#0]            ;997  ; tcp_active_pcbs
00037e  e008              B        |L8.914|
                  |L8.896|
000380  68c1              LDR      r1,[r0,#0xc]          ;997
000382  42a1              CMP      r1,r4                 ;997
000384  d102              BNE      |L8.908|
000386  68e1              LDR      r1,[r4,#0xc]          ;997
000388  60c1              STR      r1,[r0,#0xc]          ;997
00038a  e002              B        |L8.914|
                  |L8.908|
00038c  4608              MOV      r0,r1                 ;997
                  |L8.910|
00038e  2800              CMP      r0,#0                 ;997
000390  d1f6              BNE      |L8.896|
                  |L8.914|
000392  f8887000          STRB     r7,[r8,#0]            ;997
000396  f8849014          STRB     r9,[r4,#0x14]         ;998
00039a  6830              LDR      r0,[r6,#0]            ;999  ; tcp_tw_pcbs
00039c  60e0              STR      r0,[r4,#0xc]          ;999
00039e  6034              STR      r4,[r6,#0]            ;999  ; tcp_tw_pcbs
0003a0  f7fffffe          BL       tcp_timer_needed
0003a4  e0f1              B        |L8.1418|
                  |L8.934|
0003a6  e07d              B        |L8.1188|
                  |L8.936|
0003a8  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_in.c"
0003ac  6964646c
0003b0  65776172
0003b4  65735c54
0003b8  68697264
0003bc  5f506172
0003c0  74795c4c
0003c4  7749505c
0003c8  7372635c
0003cc  636f7265
0003d0  5c746370
0003d4  5f696e2e
0003d8  63      
0003d9  00                DCB      0
0003da  00                DCB      0
0003db  00                DCB      0
                  |L8.988|
0003dc  7463705f          DCB      "tcp_process: invalid pcb",0
0003e0  70726f63
0003e4  6573733a
0003e8  20696e76
0003ec  616c6964
0003f0  20706362
0003f4  00      
0003f5  00                DCB      0
0003f6  00                DCB      0
0003f7  00                DCB      0
                  |L8.1016|
0003f8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0003fc  7274696f
000400  6e202225
000404  73222066
000408  61696c65
00040c  64206174
000410  206c696e
000414  65202564
000418  20696e20
00041c  25730a00
                  |L8.1056|
                          DCD      ||.data||
                  |L8.1060|
000424  7463705f          DCB      "tcp_input: pcb->state != CLOSED",0
000428  696e7075
00042c  743a2070
000430  63622d3e
000434  73746174
000438  6520213d
00043c  20434c4f
000440  53454400
                  |L8.1092|
                          DCD      tcp_ticks
                  |L8.1096|
                          DCD      ip_data
                  |L8.1100|
                          DCD      tcp_active_pcbs_changed
                  |L8.1104|
                          DCD      tcp_tw_pcbs
                  |L8.1108|
                          DCD      tcp_active_pcbs
                  |L8.1112|
000458  7063622d          DCB      "pcb->snd_queuelen > 0",0
00045c  3e736e64
000460  5f717565
000464  75656c65
000468  6e203e20
00046c  3000    
00046e  00                DCB      0
00046f  00                DCB      0
                  |L8.1136|
000470  6e6f2073          DCB      "no segment to free",0
000474  65676d65
000478  6e742074
00047c  6f206672
000480  656500  
000483  00                DCB      0
                  |L8.1156|
000484  7063622d          DCB      "pcb->listener->accept != NULL",0
000488  3e6c6973
00048c  74656e65
000490  722d3e61
000494  63636570
000498  7420213d
00049c  204e554c
0004a0  4c00    
0004a2  00                DCB      0
0004a3  00                DCB      0
                  |L8.1188|
0004a4  f89b0000          LDRB     r0,[r11,#0]           ;1004  ; flags
0004a8  06c0              LSLS     r0,r0,#27             ;1004
0004aa  d56e              BPL      |L8.1418|
0004ac  6d20              LDR      r0,[r4,#0x50]         ;1004
0004ae  f8db1018          LDR      r1,[r11,#0x18]        ;1004  ; ackno
0004b2  4288              CMP      r0,r1                 ;1004
0004b4  d169              BNE      |L8.1418|
0004b6  6ee0              LDR      r0,[r4,#0x6c]         ;1005
0004b8  bb40              CBNZ     r0,|L8.1292|
0004ba  2006              MOVS     r0,#6                 ;1006
0004bc  7520              STRB     r0,[r4,#0x14]         ;1006
0004be  e064              B        |L8.1418|
                  |L8.1216|
0004c0  4620              MOV      r0,r4                 ;1010
0004c2  f7fffffe          BL       tcp_receive
0004c6  f89b0001          LDRB     r0,[r11,#1]           ;1011  ; recv_flags
0004ca  0680              LSLS     r0,r0,#26             ;1011
0004cc  d55d              BPL      |L8.1418|
0004ce  8b60              LDRH     r0,[r4,#0x1a]         ;1013
0004d0  f0400002          ORR      r0,r0,#2              ;1013
0004d4  8360              STRH     r0,[r4,#0x1a]         ;1013
0004d6  4620              MOV      r0,r4                 ;1014
0004d8  f7fffffe          BL       tcp_pcb_purge
0004dc  6828              LDR      r0,[r5,#0]            ;1015  ; tcp_active_pcbs
0004de  42a0              CMP      r0,r4                 ;1015
0004e0  d109              BNE      |L8.1270|
0004e2  68c0              LDR      r0,[r0,#0xc]          ;1015
0004e4  6028              STR      r0,[r5,#0]            ;1015  ; tcp_active_pcbs
0004e6  e008              B        |L8.1274|
                  |L8.1256|
0004e8  68c1              LDR      r1,[r0,#0xc]          ;1015
0004ea  42a1              CMP      r1,r4                 ;1015
0004ec  d102              BNE      |L8.1268|
0004ee  68e1              LDR      r1,[r4,#0xc]          ;1015
0004f0  60c1              STR      r1,[r0,#0xc]          ;1015
0004f2  e002              B        |L8.1274|
                  |L8.1268|
0004f4  4608              MOV      r0,r1                 ;1015
                  |L8.1270|
0004f6  2800              CMP      r0,#0                 ;1015
0004f8  d1f6              BNE      |L8.1256|
                  |L8.1274|
0004fa  f8887000          STRB     r7,[r8,#0]            ;1015
0004fe  f8849014          STRB     r9,[r4,#0x14]         ;1016
000502  6830              LDR      r0,[r6,#0]            ;1017  ; tcp_tw_pcbs
000504  60e0              STR      r0,[r4,#0xc]          ;1017
000506  6034              STR      r4,[r6,#0]            ;1017  ; tcp_tw_pcbs
000508  f7fffffe          BL       tcp_timer_needed
                  |L8.1292|
00050c  e03d              B        |L8.1418|
                  |L8.1294|
00050e  4620              MOV      r0,r4                 ;1021
000510  f7fffffe          BL       tcp_receive
000514  f89b0000          LDRB     r0,[r11,#0]           ;1022  ; flags
000518  06c0              LSLS     r0,r0,#27             ;1022
00051a  d536              BPL      |L8.1418|
00051c  6d20              LDR      r0,[r4,#0x50]         ;1022
00051e  f8db1018          LDR      r1,[r11,#0x18]        ;1022  ; ackno
000522  4288              CMP      r0,r1                 ;1022
000524  d131              BNE      |L8.1418|
000526  6ee0              LDR      r0,[r4,#0x6c]         ;1022
000528  bb78              CBNZ     r0,|L8.1418|
00052a  4620              MOV      r0,r4                 ;1024
00052c  f7fffffe          BL       tcp_pcb_purge
000530  6828              LDR      r0,[r5,#0]            ;1025  ; tcp_active_pcbs
000532  42a0              CMP      r0,r4                 ;1025
000534  d109              BNE      |L8.1354|
000536  68c0              LDR      r0,[r0,#0xc]          ;1025
000538  6028              STR      r0,[r5,#0]            ;1025  ; tcp_active_pcbs
00053a  e008              B        |L8.1358|
                  |L8.1340|
00053c  68c1              LDR      r1,[r0,#0xc]          ;1025
00053e  42a1              CMP      r1,r4                 ;1025
000540  d102              BNE      |L8.1352|
000542  68e1              LDR      r1,[r4,#0xc]          ;1025
000544  60c1              STR      r1,[r0,#0xc]          ;1025
000546  e002              B        |L8.1358|
                  |L8.1352|
000548  4608              MOV      r0,r1                 ;1025
                  |L8.1354|
00054a  2800              CMP      r0,#0                 ;1025
00054c  d1f6              BNE      |L8.1340|
                  |L8.1358|
00054e  f8887000          STRB     r7,[r8,#0]            ;1025
000552  f8849014          STRB     r9,[r4,#0x14]         ;1026
000556  6830              LDR      r0,[r6,#0]            ;1027  ; tcp_tw_pcbs
000558  60e0              STR      r0,[r4,#0xc]          ;1027
00055a  6034              STR      r4,[r6,#0]            ;1027  ; tcp_tw_pcbs
00055c  f7fffffe          BL       tcp_timer_needed
000560  e013              B        |L8.1418|
                  |L8.1378|
000562  4620              MOV      r0,r4                 ;1031
000564  f7fffffe          BL       tcp_receive
000568  f89b0000          LDRB     r0,[r11,#0]           ;1032  ; flags
00056c  06c0              LSLS     r0,r0,#27             ;1032
00056e  d50c              BPL      |L8.1418|
000570  6d20              LDR      r0,[r4,#0x50]         ;1032
000572  f8db1018          LDR      r1,[r11,#0x18]        ;1032  ; ackno
000576  4288              CMP      r0,r1                 ;1032
000578  d107              BNE      |L8.1418|
00057a  6ee0              LDR      r0,[r4,#0x6c]         ;1032
00057c  b928              CBNZ     r0,|L8.1418|
00057e  f89b0001          LDRB     r0,[r11,#1]           ;1035  ; recv_flags
000582  f0400010          ORR      r0,r0,#0x10           ;1035
000586  f88b0001          STRB     r0,[r11,#1]           ;1035
                  |L8.1418|
00058a  2000              MOVS     r0,#0                 ;1041
00058c  e57f              B        |L8.142|
;;;1043   
                          ENDP


                          AREA ||i.tcp_receive||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_receive PROC
;;;1140   static void
;;;1141   tcp_receive(struct tcp_pcb *pcb)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1142   {
000004  4604              MOV      r4,r0
;;;1143     s16_t m;
;;;1144     u32_t right_wnd_edge;
;;;1145     int found_dupack = 0;
000006  2500              MOVS     r5,#0
;;;1146   
;;;1147     LWIP_ASSERT("tcp_receive: invalid pcb", pcb != NULL);
000008  2c00              CMP      r4,#0
00000a  d106              BNE      |L9.26|
00000c  a3e1              ADR      r3,|L9.916|
00000e  f240427b          MOV      r2,#0x47b
000012  a1ed              ADR      r1,|L9.968|
000014  a0f3              ADR      r0,|L9.996|
000016  f7fffffe          BL       __2printf
                  |L9.26|
;;;1148     LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
00001a  7d20              LDRB     r0,[r4,#0x14]
00001c  2804              CMP      r0,#4
00001e  d206              BCS      |L9.46|
000020  a3dc              ADR      r3,|L9.916|
000022  f240427c          MOV      r2,#0x47c
000026  a1f9              ADR      r1,|L9.1036|
000028  a0ee              ADR      r0,|L9.996|
00002a  f7fffffe          BL       __2printf
                  |L9.46|
;;;1149   
;;;1150     if (flags & TCP_ACK) {
00002e  4ffe              LDR      r7,|L9.1064|
;;;1151       right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
;;;1152   
;;;1153       /* Update window. */
;;;1154       if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
;;;1155           (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
;;;1156           (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
;;;1157         pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
;;;1158         /* keep track of the biggest window announced by the remote host to calculate
;;;1159            the maximum segment size */
;;;1160         if (pcb->snd_wnd_max < pcb->snd_wnd) {
;;;1161           pcb->snd_wnd_max = pcb->snd_wnd;
;;;1162         }
;;;1163         pcb->snd_wl1 = seqno;
;;;1164         pcb->snd_wl2 = ackno;
;;;1165         LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"TCPWNDSIZE_F"\n", pcb->snd_wnd));
;;;1166   #if TCP_WND_DEBUG
;;;1167       } else {
;;;1168         if (pcb->snd_wnd != (tcpwnd_size_t)SND_WND_SCALE(pcb, tcphdr->wnd)) {
;;;1169           LWIP_DEBUGF(TCP_WND_DEBUG,
;;;1170                       ("tcp_receive: no window update lastack %"U32_F" ackno %"
;;;1171                        U32_F" wl1 %"U32_F" seqno %"U32_F" wl2 %"U32_F"\n",
;;;1172                        pcb->lastack, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
;;;1173         }
;;;1174   #endif /* TCP_WND_DEBUG */
;;;1175       }
;;;1176   
;;;1177       /* (From Stevens TCP/IP Illustrated Vol II, p970.) Its only a
;;;1178        * duplicate ack if:
;;;1179        * 1) It doesn't ACK new data
;;;1180        * 2) length of received packet is zero (i.e. no payload)
;;;1181        * 3) the advertised window hasn't changed
;;;1182        * 4) There is outstanding unacknowledged data (retransmission timer running)
;;;1183        * 5) The ACK is == biggest ACK sequence number so far seen (snd_una)
;;;1184        *
;;;1185        * If it passes all five, should process as a dupack:
;;;1186        * a) dupacks < 3: do nothing
;;;1187        * b) dupacks == 3: fast retransmit
;;;1188        * c) dupacks > 3: increase cwnd
;;;1189        *
;;;1190        * If it only passes 1-3, should reset dupack counter (and add to
;;;1191        * stats, which we don't do in lwIP)
;;;1192        *
;;;1193        * If it only passes 1, should reset dupack counter
;;;1194        *
;;;1195        */
;;;1196   
;;;1197       /* Clause 1 */
;;;1198       if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
;;;1199         /* Clause 2 */
;;;1200         if (tcplen == 0) {
;;;1201           /* Clause 3 */
;;;1202           if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
;;;1203             /* Clause 4 */
;;;1204             if (pcb->rtime >= 0) {
;;;1205               /* Clause 5 */
;;;1206               if (pcb->lastack == ackno) {
;;;1207                 found_dupack = 1;
;;;1208                 if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
;;;1209                   ++pcb->dupacks;
;;;1210                 }
;;;1211                 if (pcb->dupacks > 3) {
;;;1212                   /* Inflate the congestion window */
;;;1213                   TCP_WND_INC(pcb->cwnd, pcb->mss);
000030  f64f79ff          MOV      r9,#0xffff
000034  f04f0600          MOV      r6,#0
000038  7838              LDRB     r0,[r7,#0]            ;1150  ; flags
00003a  06c0              LSLS     r0,r0,#27             ;1150
00003c  d57d              BPL      |L9.314|
00003e  f8b4c060          LDRH     r12,[r4,#0x60]        ;1151
000042  6da0              LDR      r0,[r4,#0x58]         ;1151
000044  eb0c0300          ADD      r3,r12,r0             ;1151
000048  6d62              LDR      r2,[r4,#0x54]         ;1154
00004a  6979              LDR      r1,[r7,#0x14]         ;1154  ; seqno
00004c  ebb20801          SUBS     r8,r2,r1              ;1154
000050  d40b              BMI      |L9.106|
000052  428a              CMP      r2,r1                 ;1155
000054  d102              BNE      |L9.92|
000056  69ba              LDR      r2,[r7,#0x18]         ;1155  ; ackno
000058  1a82              SUBS     r2,r0,r2              ;1155
00005a  d406              BMI      |L9.106|
                  |L9.92|
00005c  69ba              LDR      r2,[r7,#0x18]         ;1156  ; ackno
00005e  4290              CMP      r0,r2                 ;1156
000060  d110              BNE      |L9.132|
000062  68f8              LDR      r0,[r7,#0xc]          ;1156  ; tcphdr
000064  89c0              LDRH     r0,[r0,#0xe]          ;1156
000066  4560              CMP      r0,r12                ;1156
000068  d90c              BLS      |L9.132|
                  |L9.106|
00006a  68f8              LDR      r0,[r7,#0xc]          ;1157  ; tcphdr
00006c  89c0              LDRH     r0,[r0,#0xe]          ;1157
00006e  f8a40060          STRH     r0,[r4,#0x60]         ;1157
000072  f8b42062          LDRH     r2,[r4,#0x62]         ;1160
000076  4282              CMP      r2,r0                 ;1160
000078  d201              BCS      |L9.126|
00007a  f8a40062          STRH     r0,[r4,#0x62]         ;1161
                  |L9.126|
00007e  6561              STR      r1,[r4,#0x54]         ;1163
000080  69b8              LDR      r0,[r7,#0x18]         ;1164  ; ackno
000082  65a0              STR      r0,[r4,#0x58]         ;1164
                  |L9.132|
000084  6c62              LDR      r2,[r4,#0x44]         ;1198
000086  69b8              LDR      r0,[r7,#0x18]         ;1198  ; ackno
000088  1a81              SUBS     r1,r0,r2              ;1198
00008a  2900              CMP      r1,#0                 ;1198
00008c  dc30              BGT      |L9.240|
00008e  8979              LDRH     r1,[r7,#0xa]          ;1200  ; tcplen
000090  bb49              CBNZ     r1,|L9.230|
000092  f8b4c060          LDRH     r12,[r4,#0x60]        ;1202
000096  6da1              LDR      r1,[r4,#0x58]         ;1202
000098  4461              ADD      r1,r1,r12             ;1202
00009a  4299              CMP      r1,r3                 ;1202
00009c  d123              BNE      |L9.230|
00009e  f9b41030          LDRSH    r1,[r4,#0x30]         ;1204
0000a2  2900              CMP      r1,#0                 ;1204
0000a4  db1f              BLT      |L9.230|
0000a6  4282              CMP      r2,r0                 ;1206
0000a8  d11d              BNE      |L9.230|
0000aa  2501              MOVS     r5,#1                 ;1207
0000ac  f8940043          LDRB     r0,[r4,#0x43]         ;1208
0000b0  1c41              ADDS     r1,r0,#1              ;1208
0000b2  b2c9              UXTB     r1,r1                 ;1208
0000b4  4281              CMP      r1,r0                 ;1208
0000b6  d901              BLS      |L9.188|
0000b8  f8841043          STRB     r1,[r4,#0x43]         ;1209
                  |L9.188|
0000bc  f8942043          LDRB     r2,[r4,#0x43]         ;1211
0000c0  2a03              CMP      r2,#3                 ;1211
0000c2  d90b              BLS      |L9.220|
0000c4  f8b41048          LDRH     r1,[r4,#0x48]
0000c8  8e60              LDRH     r0,[r4,#0x32]
0000ca  4408              ADD      r0,r0,r1
0000cc  b280              UXTH     r0,r0
0000ce  4288              CMP      r0,r1
0000d0  d302              BCC      |L9.216|
0000d2  f8a40048          STRH     r0,[r4,#0x48]
0000d6  e001              B        |L9.220|
                  |L9.216|
0000d8  f8a49048          STRH     r9,[r4,#0x48]
                  |L9.220|
;;;1214                 }
;;;1215                 if (pcb->dupacks >= 3) {
0000dc  2a03              CMP      r2,#3
0000de  d302              BCC      |L9.230|
;;;1216                   /* Do fast retransmit (checked via TF_INFR, not via dupacks count) */
;;;1217                   tcp_rexmit_fast(pcb);
0000e0  4620              MOV      r0,r4
0000e2  f7fffffe          BL       tcp_rexmit_fast
                  |L9.230|
;;;1218                 }
;;;1219               }
;;;1220             }
;;;1221           }
;;;1222         }
;;;1223         /* If Clause (1) or more is true, but not a duplicate ack, reset
;;;1224          * count of consecutive duplicate acks */
;;;1225         if (!found_dupack) {
0000e6  2d00              CMP      r5,#0
0000e8  d101              BNE      |L9.238|
;;;1226           pcb->dupacks = 0;
0000ea  f8846043          STRB     r6,[r4,#0x43]
                  |L9.238|
0000ee  e09e              B        |L9.558|
                  |L9.240|
;;;1227         }
;;;1228       } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack + 1, pcb->snd_nxt)) {
0000f0  2901              CMP      r1,#1
0000f2  d471              BMI      |L9.472|
0000f4  6d22              LDR      r2,[r4,#0x50]
0000f6  1a82              SUBS     r2,r0,r2
0000f8  2a00              CMP      r2,#0
0000fa  dc6d              BGT      |L9.472|
;;;1229         /* We come here when the ACK acknowledges new data. */
;;;1230         tcpwnd_size_t acked;
;;;1231   
;;;1232         /* Reset the "IN Fast Retransmit" flag, since we are no longer
;;;1233            in fast retransmit. Also reset the congestion window to the
;;;1234            slow start threshold. */
;;;1235         if (pcb->flags & TF_INFR) {
0000fc  8b62              LDRH     r2,[r4,#0x1a]
0000fe  0753              LSLS     r3,r2,#29
000100  d508              BPL      |L9.276|
;;;1236           tcp_clear_flags(pcb, TF_INFR);
000102  f0220204          BIC      r2,r2,#4
000106  8362              STRH     r2,[r4,#0x1a]
;;;1237           pcb->cwnd = pcb->ssthresh;
000108  f8b4204a          LDRH     r2,[r4,#0x4a]
00010c  f8a42048          STRH     r2,[r4,#0x48]
;;;1238           pcb->bytes_acked = 0;
000110  f8a4606a          STRH     r6,[r4,#0x6a]
                  |L9.276|
;;;1239         }
;;;1240   
;;;1241         /* Reset the number of retransmissions. */
;;;1242         pcb->nrtx = 0;
000114  f8846042          STRB     r6,[r4,#0x42]
;;;1243   
;;;1244         /* Reset the retransmission time-out. */
;;;1245         pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
000118  8fe2              LDRH     r2,[r4,#0x3e]
00011a  f9b4303c          LDRSH    r3,[r4,#0x3c]
00011e  eb0202e3          ADD      r2,r2,r3,ASR #3
000122  f8a42040          STRH     r2,[r4,#0x40]
;;;1246   
;;;1247         /* Record how much data this ACK acks */
;;;1248         acked = (tcpwnd_size_t)(ackno - pcb->lastack);
000126  b289              UXTH     r1,r1
;;;1249   
;;;1250         /* Reset the fast retransmit variables. */
;;;1251         pcb->dupacks = 0;
000128  f8846043          STRB     r6,[r4,#0x43]
;;;1252         pcb->lastack = ackno;
00012c  6460              STR      r0,[r4,#0x44]
;;;1253   
;;;1254         /* Update the congestion control variables (cwnd and
;;;1255            ssthresh). */
;;;1256         if (pcb->state >= ESTABLISHED) {
00012e  7d20              LDRB     r0,[r4,#0x14]
000130  2804              CMP      r0,#4
000132  d339              BCC      |L9.424|
;;;1257           if (pcb->cwnd < pcb->ssthresh) {
000134  f8b40048          LDRH     r0,[r4,#0x48]
000138  e000              B        |L9.316|
                  |L9.314|
00013a  e098              B        |L9.622|
                  |L9.316|
00013c  f8b4204a          LDRH     r2,[r4,#0x4a]
000140  4290              CMP      r0,r2
000142  d215              BCS      |L9.368|
;;;1258             tcpwnd_size_t increase;
;;;1259             /* limit to 1 SMSS segment during period following RTO */
;;;1260             u8_t num_seg = (pcb->flags & TF_RTO) ? 1 : 2;
000144  8b62              LDRH     r2,[r4,#0x1a]
000146  0512              LSLS     r2,r2,#20
000148  d501              BPL      |L9.334|
00014a  2201              MOVS     r2,#1
00014c  e000              B        |L9.336|
                  |L9.334|
00014e  2202              MOVS     r2,#2
                  |L9.336|
;;;1261             /* RFC 3465, section 2.2 Slow Start */
;;;1262             increase = LWIP_MIN(acked, (tcpwnd_size_t)(num_seg * pcb->mss));
000150  8e63              LDRH     r3,[r4,#0x32]
000152  4353              MULS     r3,r2,r3
000154  b29a              UXTH     r2,r3
000156  428a              CMP      r2,r1
000158  d800              BHI      |L9.348|
00015a  4611              MOV      r1,r2
                  |L9.348|
;;;1263             TCP_WND_INC(pcb->cwnd, increase);
00015c  4401              ADD      r1,r1,r0
00015e  b289              UXTH     r1,r1
000160  4281              CMP      r1,r0
000162  d302              BCC      |L9.362|
000164  f8a41048          STRH     r1,[r4,#0x48]
000168  e01e              B        |L9.424|
                  |L9.362|
00016a  f8a49048          STRH     r9,[r4,#0x48]
00016e  e01b              B        |L9.424|
                  |L9.368|
;;;1264             LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd));
;;;1265           } else {
;;;1266             /* RFC 3465, section 2.1 Congestion Avoidance */
;;;1267             TCP_WND_INC(pcb->bytes_acked, acked);
000170  f8b4206a          LDRH     r2,[r4,#0x6a]
000174  4411              ADD      r1,r1,r2
000176  b289              UXTH     r1,r1
000178  4291              CMP      r1,r2
00017a  d302              BCC      |L9.386|
00017c  f8a4106a          STRH     r1,[r4,#0x6a]
000180  e001              B        |L9.390|
                  |L9.386|
000182  f8a4906a          STRH     r9,[r4,#0x6a]
                  |L9.390|
;;;1268             if (pcb->bytes_acked >= pcb->cwnd) {
000186  f8b4106a          LDRH     r1,[r4,#0x6a]
00018a  4281              CMP      r1,r0
00018c  d30c              BCC      |L9.424|
;;;1269               pcb->bytes_acked = (tcpwnd_size_t)(pcb->bytes_acked - pcb->cwnd);
00018e  1a09              SUBS     r1,r1,r0
000190  f8a4106a          STRH     r1,[r4,#0x6a]
;;;1270               TCP_WND_INC(pcb->cwnd, pcb->mss);
000194  8e61              LDRH     r1,[r4,#0x32]
000196  4401              ADD      r1,r1,r0
000198  b289              UXTH     r1,r1
00019a  4281              CMP      r1,r0
00019c  d302              BCC      |L9.420|
00019e  f8a41048          STRH     r1,[r4,#0x48]
0001a2  e001              B        |L9.424|
                  |L9.420|
0001a4  f8a49048          STRH     r9,[r4,#0x48]
                  |L9.424|
;;;1271             }
;;;1272             LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd));
;;;1273           }
;;;1274         }
;;;1275         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %"U32_F", unacked->seqno %"U32_F":%"U32_F"\n",
;;;1276                                       ackno,
;;;1277                                       pcb->unacked != NULL ?
;;;1278                                       lwip_ntohl(pcb->unacked->tcphdr->seqno) : 0,
;;;1279                                       pcb->unacked != NULL ?
;;;1280                                       lwip_ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked) : 0));
;;;1281   
;;;1282         /* Remove segment from the unacknowledged list if the incoming
;;;1283            ACK acknowledges them. */
;;;1284         pcb->unacked = tcp_free_acked_segments(pcb, pcb->unacked, "unacked", pcb->unsent);
0001a8  e9d4311b          LDRD     r3,r1,[r4,#0x6c]
0001ac  a29f              ADR      r2,|L9.1068|
0001ae  4620              MOV      r0,r4
0001b0  f7fffffe          BL       tcp_free_acked_segments
0001b4  6720              STR      r0,[r4,#0x70]
;;;1285         /* We go through the ->unsent list to see if any of the segments
;;;1286            on the list are acknowledged by the ACK. This may seem
;;;1287            strange since an "unsent" segment shouldn't be acked. The
;;;1288            rationale is that lwIP puts all outstanding segments on the
;;;1289            ->unsent list after a retransmission, so these segments may
;;;1290            in fact have been sent once. */
;;;1291         pcb->unsent = tcp_free_acked_segments(pcb, pcb->unsent, "unsent", pcb->unacked);
0001b6  4603              MOV      r3,r0
0001b8  a29e              ADR      r2,|L9.1076|
0001ba  4620              MOV      r0,r4
0001bc  6ee1              LDR      r1,[r4,#0x6c]
0001be  f7fffffe          BL       tcp_free_acked_segments
0001c2  66e0              STR      r0,[r4,#0x6c]
;;;1292   
;;;1293         /* If there's nothing left to acknowledge, stop the retransmit
;;;1294            timer, otherwise reset it to start again */
;;;1295         if (pcb->unacked == NULL) {
0001c4  6f21              LDR      r1,[r4,#0x70]
0001c6  b119              CBZ      r1,|L9.464|
;;;1296           pcb->rtime = -1;
;;;1297         } else {
;;;1298           pcb->rtime = 0;
0001c8  8626              STRH     r6,[r4,#0x30]
                  |L9.458|
;;;1299         }
;;;1300   
;;;1301         pcb->polltmr = 0;
0001ca  7726              STRB     r6,[r4,#0x1c]
;;;1302   
;;;1303   #if TCP_OVERSIZE
;;;1304         if (pcb->unsent == NULL) {
0001cc  b128              CBZ      r0,|L9.474|
0001ce  e006              B        |L9.478|
                  |L9.464|
0001d0  f04f32ff          MOV      r2,#0xffffffff        ;1296
0001d4  8622              STRH     r2,[r4,#0x30]         ;1296
0001d6  e7f8              B        |L9.458|
                  |L9.472|
0001d8  e026              B        |L9.552|
                  |L9.474|
;;;1305           pcb->unsent_oversize = 0;
0001da  f8a46068          STRH     r6,[r4,#0x68]
                  |L9.478|
;;;1306         }
;;;1307   #endif /* TCP_OVERSIZE */
;;;1308   
;;;1309   #if LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS
;;;1310         if (ip_current_is_v6()) {
;;;1311           /* Inform neighbor reachability of forward progress. */
;;;1312           nd6_reachability_hint(ip6_current_src_addr());
;;;1313         }
;;;1314   #endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/
;;;1315   
;;;1316         pcb->snd_buf = (tcpwnd_size_t)(pcb->snd_buf + recv_acked);
0001de  f8b42064          LDRH     r2,[r4,#0x64]
0001e2  893b              LDRH     r3,[r7,#8]  ; recv_acked
0001e4  441a              ADD      r2,r2,r3
0001e6  f8a42064          STRH     r2,[r4,#0x64]
;;;1317         /* check if this ACK ends our retransmission of in-flight data */
;;;1318         if (pcb->flags & TF_RTO) {
0001ea  8b62              LDRH     r2,[r4,#0x1a]
0001ec  0512              LSLS     r2,r2,#20
0001ee  d51e              BPL      |L9.558|
;;;1319           /* RTO is done if
;;;1320               1) both queues are empty or
;;;1321               2) unacked is empty and unsent head contains data not part of RTO or
;;;1322               3) unacked head contains data not part of RTO */
;;;1323           if (pcb->unacked == NULL) {
0001f0  b161              CBZ      r1,|L9.524|
;;;1324             if ((pcb->unsent == NULL) ||
;;;1325                 (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unsent->tcphdr->seqno)))) {
;;;1326               tcp_clear_flags(pcb, TF_RTO);
;;;1327             }
;;;1328           } else if (TCP_SEQ_LEQ(pcb->rto_end, lwip_ntohl(pcb->unacked->tcphdr->seqno))) {
0001f2  68c8              LDR      r0,[r1,#0xc]
0001f4  6840              LDR      r0,[r0,#4]
0001f6  f7fffffe          BL       lwip_htonl
0001fa  6ce1              LDR      r1,[r4,#0x4c]
0001fc  1a08              SUBS     r0,r1,r0
0001fe  2800              CMP      r0,#0
000200  dc15              BGT      |L9.558|
;;;1329             tcp_clear_flags(pcb, TF_RTO);
000202  8b60              LDRH     r0,[r4,#0x1a]
000204  f4206000          BIC      r0,r0,#0x800
000208  8360              STRH     r0,[r4,#0x1a]
00020a  e010              B        |L9.558|
                  |L9.524|
00020c  b138              CBZ      r0,|L9.542|
00020e  68c0              LDR      r0,[r0,#0xc]          ;1325
000210  6840              LDR      r0,[r0,#4]            ;1325
000212  f7fffffe          BL       lwip_htonl
000216  6ce1              LDR      r1,[r4,#0x4c]         ;1325
000218  1a08              SUBS     r0,r1,r0              ;1325
00021a  2800              CMP      r0,#0                 ;1325
00021c  dc07              BGT      |L9.558|
                  |L9.542|
00021e  8b60              LDRH     r0,[r4,#0x1a]         ;1326
000220  f4206000          BIC      r0,r0,#0x800          ;1326
000224  8360              STRH     r0,[r4,#0x1a]         ;1326
000226  e002              B        |L9.558|
                  |L9.552|
;;;1330           }
;;;1331         }
;;;1332         /* End of ACK for new data processing. */
;;;1333       } else {
;;;1334         /* Out of sequence ACK, didn't really ack anything */
;;;1335         tcp_send_empty_ack(pcb);
000228  4620              MOV      r0,r4
00022a  f7fffffe          BL       tcp_send_empty_ack
                  |L9.558|
;;;1336       }
;;;1337   
;;;1338       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %"U32_F" rtseq %"U32_F" ackno %"U32_F"\n",
;;;1339                                   pcb->rttest, pcb->rtseq, ackno));
;;;1340   
;;;1341       /* RTT estimation calculations. This is done by checking if the
;;;1342          incoming segment acknowledges the segment we use to take a
;;;1343          round-trip time measurement. */
;;;1344       if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
00022e  6b60              LDR      r0,[r4,#0x34]
000230  b1e8              CBZ      r0,|L9.622|
000232  6ba1              LDR      r1,[r4,#0x38]
000234  69ba              LDR      r2,[r7,#0x18]  ; ackno
000236  1a89              SUBS     r1,r1,r2
000238  d519              BPL      |L9.622|
;;;1345         /* diff between this shouldn't exceed 32K since this are tcp timer ticks
;;;1346            and a round-trip shouldn't be that long... */
;;;1347         m = (s16_t)(tcp_ticks - pcb->rttest);
00023a  4980              LDR      r1,|L9.1084|
00023c  8809              LDRH     r1,[r1,#0]  ; tcp_ticks
00023e  1a08              SUBS     r0,r1,r0
;;;1348   
;;;1349         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
;;;1350                                     m, (u16_t)(m * TCP_SLOW_INTERVAL)));
;;;1351   
;;;1352         /* This is taken directly from VJs original code in his paper */
;;;1353         m = (s16_t)(m - (pcb->sa >> 3));
000240  f9b4103c          LDRSH    r1,[r4,#0x3c]
000244  eba000e1          SUB      r0,r0,r1,ASR #3
000248  b200              SXTH     r0,r0
;;;1354         pcb->sa = (s16_t)(pcb->sa + m);
00024a  4401              ADD      r1,r1,r0
00024c  b209              SXTH     r1,r1
00024e  87a1              STRH     r1,[r4,#0x3c]
;;;1355         if (m < 0) {
000250  2800              CMP      r0,#0
000252  da01              BGE      |L9.600|
;;;1356           m = (s16_t) - m;
000254  4240              RSBS     r0,r0,#0
000256  b200              SXTH     r0,r0
                  |L9.600|
;;;1357         }
;;;1358         m = (s16_t)(m - (pcb->sv >> 2));
000258  f9b4203e          LDRSH    r2,[r4,#0x3e]
00025c  eba000a2          SUB      r0,r0,r2,ASR #2
;;;1359         pcb->sv = (s16_t)(pcb->sv + m);
000260  4410              ADD      r0,r0,r2
000262  87e0              STRH     r0,[r4,#0x3e]
;;;1360         pcb->rto = (s16_t)((pcb->sa >> 3) + pcb->sv);
000264  eb0000e1          ADD      r0,r0,r1,ASR #3
000268  f8a40040          STRH     r0,[r4,#0x40]
;;;1361   
;;;1362         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
;;;1363                                     pcb->rto, (u16_t)(pcb->rto * TCP_SLOW_INTERVAL)));
;;;1364   
;;;1365         pcb->rttest = 0;
00026c  6366              STR      r6,[r4,#0x34]
                  |L9.622|
;;;1366       }
;;;1367     }
;;;1368   
;;;1369     /* If the incoming segment contains data, we must process it
;;;1370        further unless the pcb already received a FIN.
;;;1371        (RFC 793, chapter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
;;;1372        LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
;;;1373     if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
00026e  897a              LDRH     r2,[r7,#0xa]  ; tcplen
000270  2a00              CMP      r2,#0
000272  d07d              BEQ      |L9.880|
000274  7d20              LDRB     r0,[r4,#0x14]
000276  2807              CMP      r0,#7
000278  d27a              BCS      |L9.880|
;;;1374       /* This code basically does three things:
;;;1375   
;;;1376       +) If the incoming segment contains data that is the next
;;;1377       in-sequence data, this data is passed to the application. This
;;;1378       might involve trimming the first edge of the data. The rcv_nxt
;;;1379       variable and the advertised window are adjusted.
;;;1380   
;;;1381       +) If the incoming segment has data that is above the next
;;;1382       sequence number expected (->rcv_nxt), the segment is placed on
;;;1383       the ->ooseq queue. This is done by finding the appropriate
;;;1384       place in the ->ooseq queue (which is ordered by sequence
;;;1385       number) and trim the segment in both ends if needed. An
;;;1386       immediate ACK is sent to indicate that we received an
;;;1387       out-of-sequence segment.
;;;1388   
;;;1389       +) Finally, we check if the first segment on the ->ooseq queue
;;;1390       now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
;;;1391       rcv_nxt > ooseq->seqno, we must trim the first edge of the
;;;1392       segment on ->ooseq before we adjust rcv_nxt. The data in the
;;;1393       segments that are now on sequence are chained onto the
;;;1394       incoming segment so that we only need to call the application
;;;1395       once.
;;;1396       */
;;;1397   
;;;1398       /* First, we check if we must trim the first edge. We have to do
;;;1399          this if the sequence number of the incoming segment is less
;;;1400          than rcv_nxt, and the sequence number plus the length of the
;;;1401          segment is larger than rcv_nxt. */
;;;1402       /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
;;;1403             if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
;;;1404       if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
00027a  6a60              LDR      r0,[r4,#0x24]
00027c  6979              LDR      r1,[r7,#0x14]  ; seqno
;;;1405         /* Trimming the first edge is done by pushing the payload
;;;1406            pointer in the pbuf downwards. This is somewhat tricky since
;;;1407            we do not want to discard the full contents of the pbuf up to
;;;1408            the new starting point of the data since we have to keep the
;;;1409            TCP header which is present in the first pbuf in the chain.
;;;1410   
;;;1411            What is done is really quite a nasty hack: the first pbuf in
;;;1412            the pbuf chain is pointed to by inseg.p. Since we need to be
;;;1413            able to deallocate the whole pbuf, we cannot change this
;;;1414            inseg.p pointer to point to any of the later pbufs in the
;;;1415            chain. Instead, we point the ->payload pointer in the first
;;;1416            pbuf to data in one of the later pbufs. We also set the
;;;1417            inseg.data pointer to point to the right place. This way, the
;;;1418            ->p pointer will still point to the first pbuf, but the
;;;1419            ->p->payload pointer will point to data in another pbuf.
;;;1420   
;;;1421            After we are done with adjusting the pbuf pointers we must
;;;1422            adjust the ->data pointer in the seg and the segment
;;;1423            length.*/
;;;1424   
;;;1425         struct pbuf *p = inseg.p;
00027e  f8df81c0          LDR      r8,|L9.1088|
000282  eba00a01          SUB      r10,r0,r1             ;1404
000286  f1ba0f01          CMP      r10,#1                ;1404
00028a  d446              BMI      |L9.794|
00028c  440a              ADD      r2,r2,r1              ;1404
00028e  1a82              SUBS     r2,r0,r2              ;1404
000290  1c52              ADDS     r2,r2,#1              ;1404
000292  2a00              CMP      r2,#0                 ;1404
000294  dc41              BGT      |L9.794|
000296  f8d85004          LDR      r5,[r8,#4]  ; inseg
;;;1426         u32_t off32 = pcb->rcv_nxt - seqno;
;;;1427         u16_t new_tot_len, off;
;;;1428         LWIP_ASSERT("inseg.p != NULL", inseg.p);
00029a  b935              CBNZ     r5,|L9.682|
00029c  a33d              ADR      r3,|L9.916|
00029e  f2405294          MOV      r2,#0x594
0002a2  a168              ADR      r1,|L9.1092|
0002a4  a04f              ADR      r0,|L9.996|
0002a6  f7fffffe          BL       __2printf
                  |L9.682|
;;;1429         LWIP_ASSERT("insane offset!", (off32 < 0xffff));
0002aa  45ca              CMP      r10,r9
0002ac  d306              BCC      |L9.700|
0002ae  a339              ADR      r3,|L9.916|
0002b0  f2405295          MOV      r2,#0x595
0002b4  a167              ADR      r1,|L9.1108|
0002b6  a04b              ADR      r0,|L9.996|
0002b8  f7fffffe          BL       __2printf
                  |L9.700|
;;;1430         off = (u16_t)off32;
0002bc  fa1ff98a          UXTH     r9,r10
;;;1431         LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
0002c0  f8d80004          LDR      r0,[r8,#4]  ; inseg
0002c4  8900              LDRH     r0,[r0,#8]
0002c6  4548              CMP      r0,r9
0002c8  d206              BCS      |L9.728|
0002ca  a332              ADR      r3,|L9.916|
0002cc  f2405297          MOV      r2,#0x597
0002d0  a164              ADR      r1,|L9.1124|
0002d2  a044              ADR      r0,|L9.996|
0002d4  f7fffffe          BL       __2printf
                  |L9.728|
;;;1432         inseg.len -= off;
0002d8  f8b80008          LDRH     r0,[r8,#8]  ; inseg
0002dc  eba00009          SUB      r0,r0,r9
0002e0  f8a80008          STRH     r0,[r8,#8]
;;;1433         new_tot_len = (u16_t)(inseg.p->tot_len - off);
0002e4  f8d80004          LDR      r0,[r8,#4]  ; inseg
0002e8  8900              LDRH     r0,[r0,#8]
0002ea  eba00009          SUB      r0,r0,r9
0002ee  b281              UXTH     r1,r0
;;;1434         while (p->len < off) {
0002f0  e006              B        |L9.768|
                  |L9.754|
;;;1435           off -= p->len;
0002f2  eba90000          SUB      r0,r9,r0
0002f6  fa1ff980          UXTH     r9,r0
;;;1436           /* all pbufs up to and including this one have len==0, so tot_len is equal */
;;;1437           p->tot_len = new_tot_len;
0002fa  8129              STRH     r1,[r5,#8]
;;;1438           p->len = 0;
0002fc  816e              STRH     r6,[r5,#0xa]
;;;1439           p = p->next;
0002fe  682d              LDR      r5,[r5,#0]
                  |L9.768|
000300  8968              LDRH     r0,[r5,#0xa]          ;1434
000302  4548              CMP      r0,r9                 ;1434
000304  d3f5              BCC      |L9.754|
;;;1440         }
;;;1441         /* cannot fail... */
;;;1442         pbuf_remove_header(p, off);
000306  4649              MOV      r1,r9
000308  4628              MOV      r0,r5
00030a  f7fffffe          BL       pbuf_remove_header
;;;1443         inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
00030e  6a60              LDR      r0,[r4,#0x24]
000310  6178              STR      r0,[r7,#0x14]  ; seqno
000312  f8d8100c          LDR      r1,[r8,#0xc]  ; inseg
000316  6048              STR      r0,[r1,#4]
;;;1444       } else {
000318  e005              B        |L9.806|
                  |L9.794|
;;;1445         if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
00031a  1a08              SUBS     r0,r1,r0
00031c  d503              BPL      |L9.806|
;;;1446           /* the whole segment is < rcv_nxt */
;;;1447           /* must be a duplicate of a packet that has already been correctly handled */
;;;1448   
;;;1449           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
;;;1450           tcp_ack_now(pcb);
00031e  8b60              LDRH     r0,[r4,#0x1a]
000320  f0400002          ORR      r0,r0,#2
000324  8360              STRH     r0,[r4,#0x1a]
                  |L9.806|
;;;1451         }
;;;1452       }
;;;1453   
;;;1454       /* The sequence number must be within the window (above rcv_nxt
;;;1455          and below rcv_nxt + rcv_wnd) in order to be further
;;;1456          processed. */
;;;1457       if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
000326  6a61              LDR      r1,[r4,#0x24]
000328  6978              LDR      r0,[r7,#0x14]  ; seqno
00032a  1a42              SUBS     r2,r0,r1
00032c  d42e              BMI      |L9.908|
00032e  8d22              LDRH     r2,[r4,#0x28]
000330  440a              ADD      r2,r2,r1
000332  1a82              SUBS     r2,r0,r2
000334  1c52              ADDS     r2,r2,#1
000336  2a00              CMP      r2,#0
000338  dc28              BGT      |L9.908|
;;;1458                           pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
;;;1459         if (pcb->rcv_nxt == seqno) {
00033a  4281              CMP      r1,r0
00033c  d127              BNE      |L9.910|
;;;1460           /* The incoming segment is the next in sequence. We check if
;;;1461              we have to trim the end of the segment and update rcv_nxt
;;;1462              and pass the data to the application. */
;;;1463           tcplen = TCP_TCPLEN(&inseg);
00033e  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
000342  8980              LDRH     r0,[r0,#0xc]
000344  f7fffffe          BL       lwip_htons
000348  0780              LSLS     r0,r0,#30
00034a  d001              BEQ      |L9.848|
00034c  2001              MOVS     r0,#1
00034e  e000              B        |L9.850|
                  |L9.848|
000350  2000              MOVS     r0,#0
                  |L9.850|
000352  f8b81008          LDRH     r1,[r8,#8]  ; inseg
000356  4408              ADD      r0,r0,r1
000358  b280              UXTH     r0,r0
00035a  8178              STRH     r0,[r7,#0xa]
;;;1464   
;;;1465           if (tcplen > pcb->rcv_wnd) {
00035c  8d21              LDRH     r1,[r4,#0x28]
00035e  4281              CMP      r1,r0
000360  d216              BCS      |L9.912|
;;;1466             LWIP_DEBUGF(TCP_INPUT_DEBUG,
;;;1467                         ("tcp_receive: other end overran receive window"
;;;1468                          "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1469                          seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1470             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
000362  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
000366  8980              LDRH     r0,[r0,#0xc]
000368  f7fffffe          BL       lwip_htons
00036c  07c0              LSLS     r0,r0,#31
00036e  e000              B        |L9.882|
                  |L9.880|
000370  e29d              B        |L9.2222|
                  |L9.882|
000372  d00e              BEQ      |L9.914|
;;;1471               /* Must remove the FIN from the header as we're trimming
;;;1472                * that byte of sequence-space from the packet */
;;;1473               TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
000374  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
000378  8980              LDRH     r0,[r0,#0xc]
00037a  f7fffffe          BL       lwip_htons
00037e  f3c00044          UBFX     r0,r0,#1,#5
000382  0040              LSLS     r0,r0,#1
000384  f7fffffe          BL       lwip_htons
000388  4601              MOV      r1,r0
00038a  e073              B        |L9.1140|
                  |L9.908|
00038c  e28a              B        |L9.2212|
                  |L9.910|
00038e  e1c0              B        |L9.1810|
                  |L9.912|
000390  e0ab              B        |L9.1258|
                  |L9.914|
000392  e076              B        |L9.1154|
                  |L9.916|
000394  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_in.c"
000398  6964646c
00039c  65776172
0003a0  65735c54
0003a4  68697264
0003a8  5f506172
0003ac  74795c4c
0003b0  7749505c
0003b4  7372635c
0003b8  636f7265
0003bc  5c746370
0003c0  5f696e2e
0003c4  63      
0003c5  00                DCB      0
0003c6  00                DCB      0
0003c7  00                DCB      0
                  |L9.968|
0003c8  7463705f          DCB      "tcp_receive: invalid pcb",0
0003cc  72656365
0003d0  6976653a
0003d4  20696e76
0003d8  616c6964
0003dc  20706362
0003e0  00      
0003e1  00                DCB      0
0003e2  00                DCB      0
0003e3  00                DCB      0
                  |L9.996|
0003e4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0003e8  7274696f
0003ec  6e202225
0003f0  73222066
0003f4  61696c65
0003f8  64206174
0003fc  206c696e
000400  65202564
000404  20696e20
000408  25730a00
                  |L9.1036|
00040c  7463705f          DCB      "tcp_receive: wrong state",0
000410  72656365
000414  6976653a
000418  2077726f
00041c  6e672073
000420  74617465
000424  00      
000425  00                DCB      0
000426  00                DCB      0
000427  00                DCB      0
                  |L9.1064|
                          DCD      ||.data||
                  |L9.1068|
00042c  756e6163          DCB      "unacked",0
000430  6b656400
                  |L9.1076|
000434  756e7365          DCB      "unsent",0
000438  6e7400  
00043b  00                DCB      0
                  |L9.1084|
                          DCD      tcp_ticks
                  |L9.1088|
                          DCD      ||.bss||
                  |L9.1092|
000444  696e7365          DCB      "inseg.p != NULL",0
000448  672e7020
00044c  213d204e
000450  554c4c00
                  |L9.1108|
000454  696e7361          DCB      "insane offset!",0
000458  6e65206f
00045c  66667365
000460  742100  
000463  00                DCB      0
                  |L9.1124|
000464  70627566          DCB      "pbuf too short!",0
000468  20746f6f
00046c  2073686f
000470  72742100
                  |L9.1140|
000474  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
000478  8982              LDRH     r2,[r0,#0xc]
00047a  f422527c          BIC      r2,r2,#0x3f00
00047e  4311              ORRS     r1,r1,r2
000480  8181              STRH     r1,[r0,#0xc]
                  |L9.1154|
;;;1474             }
;;;1475             /* Adjust length of segment to fit in the window. */
;;;1476             TCPWND_CHECK16(pcb->rcv_wnd);
;;;1477             inseg.len = (u16_t)pcb->rcv_wnd;
000482  8d20              LDRH     r0,[r4,#0x28]
000484  f8a80008          STRH     r0,[r8,#8]
;;;1478             if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
000488  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
00048c  8980              LDRH     r0,[r0,#0xc]
00048e  f7fffffe          BL       lwip_htons
000492  0780              LSLS     r0,r0,#30
000494  d504              BPL      |L9.1184|
;;;1479               inseg.len -= 1;
000496  f8b80008          LDRH     r0,[r8,#8]  ; inseg
00049a  1e40              SUBS     r0,r0,#1
00049c  f8a80008          STRH     r0,[r8,#8]
                  |L9.1184|
;;;1480             }
;;;1481             pbuf_realloc(inseg.p, inseg.len);
0004a0  f8b81008          LDRH     r1,[r8,#8]  ; inseg
0004a4  f8d80004          LDR      r0,[r8,#4]  ; inseg
0004a8  f7fffffe          BL       pbuf_realloc
;;;1482             tcplen = TCP_TCPLEN(&inseg);
0004ac  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
0004b0  8980              LDRH     r0,[r0,#0xc]
0004b2  f7fffffe          BL       lwip_htons
0004b6  0780              LSLS     r0,r0,#30
0004b8  d001              BEQ      |L9.1214|
0004ba  2001              MOVS     r0,#1
0004bc  e000              B        |L9.1216|
                  |L9.1214|
0004be  2000              MOVS     r0,#0
                  |L9.1216|
0004c0  f8b81008          LDRH     r1,[r8,#8]  ; inseg
0004c4  4408              ADD      r0,r0,r1
0004c6  b280              UXTH     r0,r0
0004c8  8178              STRH     r0,[r7,#0xa]
;;;1483             LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
0004ca  8d22              LDRH     r2,[r4,#0x28]
0004cc  6a61              LDR      r1,[r4,#0x24]
0004ce  4411              ADD      r1,r1,r2
0004d0  697a              LDR      r2,[r7,#0x14]  ; seqno
0004d2  4410              ADD      r0,r0,r2
0004d4  4288              CMP      r0,r1
0004d6  d008              BEQ      |L9.1258|
0004d8  f2af1348          ADR      r3,|L9.916|
0004dc  f24052cb          MOV      r2,#0x5cb
0004e0  a1fb              ADR      r1,|L9.2256|
0004e2  f2af1000          ADR      r0,|L9.996|
0004e6  f7fffffe          BL       __2printf
                  |L9.1258|
;;;1484                         (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1485           }
;;;1486   #if TCP_QUEUE_OOSEQ
;;;1487           /* Received in-sequence data, adjust ooseq data if:
;;;1488              - FIN has been received or
;;;1489              - inseq overlaps with ooseq */
;;;1490           if (pcb->ooseq != NULL) {
0004ea  6f60              LDR      r0,[r4,#0x74]
0004ec  2800              CMP      r0,#0
0004ee  d07d              BEQ      |L9.1516|
;;;1491             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
0004f0  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
0004f4  8980              LDRH     r0,[r0,#0xc]
0004f6  f7fffffe          BL       lwip_htons
0004fa  07c0              LSLS     r0,r0,#31
0004fc  d104              BNE      |L9.1288|
0004fe  e007              B        |L9.1296|
                  |L9.1280|
;;;1492               LWIP_DEBUGF(TCP_INPUT_DEBUG,
;;;1493                           ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
;;;1494               /* Received in-order FIN means anything that was received
;;;1495                * out of order must now have been received in-order, so
;;;1496                * bin the ooseq queue */
;;;1497               while (pcb->ooseq != NULL) {
;;;1498                 struct tcp_seg *old_ooseq = pcb->ooseq;
;;;1499                 pcb->ooseq = pcb->ooseq->next;
000500  6801              LDR      r1,[r0,#0]
000502  6761              STR      r1,[r4,#0x74]
;;;1500                 tcp_seg_free(old_ooseq);
000504  f7fffffe          BL       tcp_seg_free
                  |L9.1288|
000508  6f60              LDR      r0,[r4,#0x74]         ;1497
00050a  2800              CMP      r0,#0                 ;1497
00050c  d1f8              BNE      |L9.1280|
00050e  e06d              B        |L9.1516|
                  |L9.1296|
;;;1501               }
;;;1502             } else {
;;;1503               struct tcp_seg *next = pcb->ooseq;
000510  6f65              LDR      r5,[r4,#0x74]
;;;1504               /* Remove all segments on ooseq that are covered by inseg already.
;;;1505                * FIN is copied from ooseq to inseg if present. */
;;;1506               while (next &&
000512  e022              B        |L9.1370|
                  |L9.1300|
;;;1507                      TCP_SEQ_GEQ(seqno + tcplen,
;;;1508                                  next->tcphdr->seqno + next->len)) {
;;;1509                 struct tcp_seg *tmp;
;;;1510                 /* inseg cannot have FIN here (already processed above) */
;;;1511                 if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
000514  8980              LDRH     r0,[r0,#0xc]
000516  f7fffffe          BL       lwip_htons
00051a  07c0              LSLS     r0,r0,#31
00051c  d019              BEQ      |L9.1362|
;;;1512                     (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
00051e  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
000522  8980              LDRH     r0,[r0,#0xc]
000524  f7fffffe          BL       lwip_htons
000528  0780              LSLS     r0,r0,#30
00052a  d412              BMI      |L9.1362|
;;;1513                   TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
00052c  2001              MOVS     r0,#1
00052e  f7fffffe          BL       lwip_htons
000532  f8d8100c          LDR      r1,[r8,#0xc]  ; inseg
000536  898a              LDRH     r2,[r1,#0xc]
000538  4310              ORRS     r0,r0,r2
00053a  8188              STRH     r0,[r1,#0xc]
;;;1514                   tcplen = TCP_TCPLEN(&inseg);
00053c  f7fffffe          BL       lwip_htons
000540  0780              LSLS     r0,r0,#30
000542  d001              BEQ      |L9.1352|
000544  2001              MOVS     r0,#1
000546  e000              B        |L9.1354|
                  |L9.1352|
000548  2000              MOVS     r0,#0
                  |L9.1354|
00054a  f8b81008          LDRH     r1,[r8,#8]  ; inseg
00054e  4408              ADD      r0,r0,r1
000550  8178              STRH     r0,[r7,#0xa]
                  |L9.1362|
;;;1515                 }
;;;1516                 tmp = next;
;;;1517                 next = next->next;
000552  4628              MOV      r0,r5
000554  682d              LDR      r5,[r5,#0]
;;;1518                 tcp_seg_free(tmp);
000556  f7fffffe          BL       tcp_seg_free
                  |L9.1370|
00055a  b145              CBZ      r5,|L9.1390|
00055c  68e8              LDR      r0,[r5,#0xc]          ;1507
00055e  892a              LDRH     r2,[r5,#8]            ;1507
000560  897b              LDRH     r3,[r7,#0xa]          ;1507  ; tcplen
000562  6841              LDR      r1,[r0,#4]            ;1507
000564  4411              ADD      r1,r1,r2              ;1507
000566  697a              LDR      r2,[r7,#0x14]         ;1507  ; seqno
000568  441a              ADD      r2,r2,r3              ;1507
00056a  1a51              SUBS     r1,r2,r1              ;1507
00056c  d5d2              BPL      |L9.1300|
                  |L9.1390|
;;;1519               }
;;;1520               /* Now trim right side of inseg if it overlaps with the first
;;;1521                * segment on ooseq */
;;;1522               if (next &&
00056e  b3b5              CBZ      r5,|L9.1502|
;;;1523                   TCP_SEQ_GT(seqno + tcplen,
000570  8979              LDRH     r1,[r7,#0xa]  ; tcplen
000572  6978              LDR      r0,[r7,#0x14]  ; seqno
000574  1842              ADDS     r2,r0,r1
000576  68e9              LDR      r1,[r5,#0xc]
000578  6849              LDR      r1,[r1,#4]
00057a  1a52              SUBS     r2,r2,r1
00057c  2a00              CMP      r2,#0
00057e  dd34              BLE      |L9.1514|
;;;1524                              next->tcphdr->seqno)) {
;;;1525                 /* inseg cannot have FIN here (already processed above) */
;;;1526                 inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
000580  1a08              SUBS     r0,r1,r0
000582  f8a80008          STRH     r0,[r8,#8]
;;;1527                 if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
000586  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
00058a  8980              LDRH     r0,[r0,#0xc]
00058c  f7fffffe          BL       lwip_htons
000590  0780              LSLS     r0,r0,#30
000592  d504              BPL      |L9.1438|
;;;1528                   inseg.len -= 1;
000594  f8b80008          LDRH     r0,[r8,#8]  ; inseg
000598  1e40              SUBS     r0,r0,#1
00059a  f8a80008          STRH     r0,[r8,#8]
                  |L9.1438|
;;;1529                 }
;;;1530                 pbuf_realloc(inseg.p, inseg.len);
00059e  f8b81008          LDRH     r1,[r8,#8]  ; inseg
0005a2  f8d80004          LDR      r0,[r8,#4]  ; inseg
0005a6  f7fffffe          BL       pbuf_realloc
;;;1531                 tcplen = TCP_TCPLEN(&inseg);
0005aa  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
0005ae  8980              LDRH     r0,[r0,#0xc]
0005b0  f7fffffe          BL       lwip_htons
0005b4  0780              LSLS     r0,r0,#30
0005b6  d001              BEQ      |L9.1468|
0005b8  2001              MOVS     r0,#1
0005ba  e000              B        |L9.1470|
                  |L9.1468|
0005bc  2000              MOVS     r0,#0
                  |L9.1470|
0005be  f8b81008          LDRH     r1,[r8,#8]  ; inseg
0005c2  4408              ADD      r0,r0,r1
0005c4  b280              UXTH     r0,r0
0005c6  8178              STRH     r0,[r7,#0xa]
;;;1532                 LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
0005c8  6979              LDR      r1,[r7,#0x14]  ; seqno
0005ca  4408              ADD      r0,r0,r1
0005cc  68e9              LDR      r1,[r5,#0xc]
0005ce  6849              LDR      r1,[r1,#4]
0005d0  4288              CMP      r0,r1
0005d2  d00a              BEQ      |L9.1514|
0005d4  f2af2344          ADR      r3,|L9.916|
0005d8  f24052fc          MOV      r2,#0x5fc
0005dc  e000              B        |L9.1504|
                  |L9.1502|
0005de  e004              B        |L9.1514|
                  |L9.1504|
0005e0  a1c9              ADR      r1,|L9.2312|
0005e2  f2af2000          ADR      r0,|L9.996|
0005e6  f7fffffe          BL       __2printf
                  |L9.1514|
;;;1533                             (seqno + tcplen) == next->tcphdr->seqno);
;;;1534               }
;;;1535               pcb->ooseq = next;
0005ea  6765              STR      r5,[r4,#0x74]
                  |L9.1516|
;;;1536             }
;;;1537           }
;;;1538   #endif /* TCP_QUEUE_OOSEQ */
;;;1539   
;;;1540           pcb->rcv_nxt = seqno + tcplen;
0005ec  8978              LDRH     r0,[r7,#0xa]  ; tcplen
0005ee  6979              LDR      r1,[r7,#0x14]  ; seqno
0005f0  4401              ADD      r1,r1,r0
0005f2  6261              STR      r1,[r4,#0x24]
;;;1541   
;;;1542           /* Update the receiver's (our) window. */
;;;1543           LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
0005f4  8d21              LDRH     r1,[r4,#0x28]
0005f6  4281              CMP      r1,r0
0005f8  d208              BCS      |L9.1548|
0005fa  f2af2368          ADR      r3,|L9.916|
0005fe  f2406207          MOV      r2,#0x607
000602  a1d0              ADR      r1,|L9.2372|
000604  f2af2024          ADR      r0,|L9.996|
000608  f7fffffe          BL       __2printf
                  |L9.1548|
;;;1544           pcb->rcv_wnd -= tcplen;
00060c  8d20              LDRH     r0,[r4,#0x28]
00060e  8979              LDRH     r1,[r7,#0xa]  ; tcplen
000610  1a40              SUBS     r0,r0,r1
000612  8520              STRH     r0,[r4,#0x28]
;;;1545   
;;;1546           tcp_update_rcv_ann_wnd(pcb);
000614  4620              MOV      r0,r4
000616  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1547   
;;;1548           /* If there is data in the segment, we make preparations to
;;;1549              pass this up to the application. The ->recv_data variable
;;;1550              is used for holding the pbuf that goes to the
;;;1551              application. The code for reassembling out-of-sequence data
;;;1552              chains its data on this pbuf as well.
;;;1553   
;;;1554              If the segment was a FIN, we set the TF_GOT_FIN flag that will
;;;1555              be used to indicate to the application that the remote side has
;;;1556              closed its end of the connection. */
;;;1557           if (inseg.p->tot_len > 0) {
00061a  f8d80004          LDR      r0,[r8,#4]  ; inseg
00061e  8901              LDRH     r1,[r0,#8]
000620  b111              CBZ      r1,|L9.1576|
;;;1558             recv_data = inseg.p;
000622  61f8              STR      r0,[r7,#0x1c]  ; recv_data
;;;1559             /* Since this pbuf now is the responsibility of the
;;;1560                application, we delete our reference to it so that we won't
;;;1561                (mistakingly) deallocate it. */
;;;1562             inseg.p = NULL;
000624  f8c86004          STR      r6,[r8,#4]  ; inseg
                  |L9.1576|
;;;1563           }
;;;1564           if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
000628  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
00062c  8980              LDRH     r0,[r0,#0xc]
00062e  f7fffffe          BL       lwip_htons
000632  07c0              LSLS     r0,r0,#31
000634  d058              BEQ      |L9.1768|
;;;1565             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
;;;1566             recv_flags |= TF_GOT_FIN;
000636  7878              LDRB     r0,[r7,#1]  ; recv_flags
000638  f0400020          ORR      r0,r0,#0x20
00063c  7078              STRB     r0,[r7,#1]
00063e  e053              B        |L9.1768|
                  |L9.1600|
;;;1567           }
;;;1568   
;;;1569   #if TCP_QUEUE_OOSEQ
;;;1570           /* We now check if we have segments on the ->ooseq queue that
;;;1571              are now in sequence. */
;;;1572           while (pcb->ooseq != NULL &&
;;;1573                  pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
;;;1574   
;;;1575             struct tcp_seg *cseg = pcb->ooseq;
;;;1576             seqno = pcb->ooseq->tcphdr->seqno;
000640  6179              STR      r1,[r7,#0x14]  ; seqno
;;;1577   
;;;1578             pcb->rcv_nxt += TCP_TCPLEN(cseg);
000642  8980              LDRH     r0,[r0,#0xc]
000644  f7fffffe          BL       lwip_htons
000648  0780              LSLS     r0,r0,#30
00064a  d001              BEQ      |L9.1616|
00064c  2001              MOVS     r0,#1
00064e  e000              B        |L9.1618|
                  |L9.1616|
000650  2000              MOVS     r0,#0
                  |L9.1618|
000652  892a              LDRH     r2,[r5,#8]
000654  6a61              LDR      r1,[r4,#0x24]
000656  4411              ADD      r1,r1,r2
000658  4408              ADD      r0,r0,r1
00065a  6260              STR      r0,[r4,#0x24]
;;;1579             LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
00065c  68e8              LDR      r0,[r5,#0xc]
00065e  8980              LDRH     r0,[r0,#0xc]
000660  f7fffffe          BL       lwip_htons
000664  0780              LSLS     r0,r0,#30
000666  d001              BEQ      |L9.1644|
000668  2001              MOVS     r0,#1
00066a  e000              B        |L9.1646|
                  |L9.1644|
00066c  2000              MOVS     r0,#0
                  |L9.1646|
00066e  8929              LDRH     r1,[r5,#8]
000670  4408              ADD      r0,r0,r1
000672  8d21              LDRH     r1,[r4,#0x28]
000674  4288              CMP      r0,r1
000676  d908              BLS      |L9.1674|
000678  f2af23e8          ADR      r3,|L9.916|
00067c  f240622b          MOV      r2,#0x62b
000680  a1b8              ADR      r1,|L9.2404|
000682  f2af20a0          ADR      r0,|L9.996|
000686  f7fffffe          BL       __2printf
                  |L9.1674|
;;;1580                         pcb->rcv_wnd >= TCP_TCPLEN(cseg));
;;;1581             pcb->rcv_wnd -= TCP_TCPLEN(cseg);
00068a  68e8              LDR      r0,[r5,#0xc]
00068c  8980              LDRH     r0,[r0,#0xc]
00068e  f7fffffe          BL       lwip_htons
000692  0780              LSLS     r0,r0,#30
000694  d001              BEQ      |L9.1690|
000696  2001              MOVS     r0,#1
000698  e000              B        |L9.1692|
                  |L9.1690|
00069a  2000              MOVS     r0,#0
                  |L9.1692|
00069c  8929              LDRH     r1,[r5,#8]
00069e  4408              ADD      r0,r0,r1
0006a0  8d21              LDRH     r1,[r4,#0x28]
0006a2  1a08              SUBS     r0,r1,r0
0006a4  8520              STRH     r0,[r4,#0x28]
;;;1582   
;;;1583             tcp_update_rcv_ann_wnd(pcb);
0006a6  4620              MOV      r0,r4
0006a8  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1584   
;;;1585             if (cseg->p->tot_len > 0) {
0006ac  6869              LDR      r1,[r5,#4]
0006ae  8908              LDRH     r0,[r1,#8]
0006b0  b130              CBZ      r0,|L9.1728|
;;;1586               /* Chain this pbuf onto the pbuf that we will pass to
;;;1587                  the application. */
;;;1588               /* With window scaling, this can overflow recv_data->tot_len, but
;;;1589                  that's not a problem since we explicitly fix that before passing
;;;1590                  recv_data to the application. */
;;;1591               if (recv_data) {
0006b2  69f8              LDR      r0,[r7,#0x1c]  ; recv_data
0006b4  b110              CBZ      r0,|L9.1724|
;;;1592                 pbuf_cat(recv_data, cseg->p);
0006b6  f7fffffe          BL       pbuf_cat
0006ba  e000              B        |L9.1726|
                  |L9.1724|
;;;1593               } else {
;;;1594                 recv_data = cseg->p;
0006bc  61f9              STR      r1,[r7,#0x1c]  ; recv_data
                  |L9.1726|
;;;1595               }
;;;1596               cseg->p = NULL;
0006be  606e              STR      r6,[r5,#4]
                  |L9.1728|
;;;1597             }
;;;1598             if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
0006c0  68e8              LDR      r0,[r5,#0xc]
0006c2  8980              LDRH     r0,[r0,#0xc]
0006c4  f7fffffe          BL       lwip_htons
0006c8  07c0              LSLS     r0,r0,#31
0006ca  d008              BEQ      |L9.1758|
;;;1599               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
;;;1600               recv_flags |= TF_GOT_FIN;
0006cc  7878              LDRB     r0,[r7,#1]  ; recv_flags
0006ce  f0400020          ORR      r0,r0,#0x20
0006d2  7078              STRB     r0,[r7,#1]
;;;1601               if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
0006d4  7d20              LDRB     r0,[r4,#0x14]
0006d6  2804              CMP      r0,#4
0006d8  d101              BNE      |L9.1758|
;;;1602                 pcb->state = CLOSE_WAIT;
0006da  2007              MOVS     r0,#7
0006dc  7520              STRB     r0,[r4,#0x14]
                  |L9.1758|
;;;1603               }
;;;1604             }
;;;1605   
;;;1606             pcb->ooseq = cseg->next;
0006de  6828              LDR      r0,[r5,#0]
0006e0  6760              STR      r0,[r4,#0x74]
;;;1607             tcp_seg_free(cseg);
0006e2  4628              MOV      r0,r5
0006e4  f7fffffe          BL       tcp_seg_free
                  |L9.1768|
0006e8  6f65              LDR      r5,[r4,#0x74]         ;1572
0006ea  b125              CBZ      r5,|L9.1782|
0006ec  68e8              LDR      r0,[r5,#0xc]          ;1573
0006ee  6a62              LDR      r2,[r4,#0x24]         ;1573
0006f0  6841              LDR      r1,[r0,#4]            ;1573
0006f2  4291              CMP      r1,r2                 ;1573
0006f4  d0a4              BEQ      |L9.1600|
                  |L9.1782|
;;;1608           }
;;;1609   #if LWIP_TCP_SACK_OUT
;;;1610           if (pcb->flags & TF_SACK) {
;;;1611             if (pcb->ooseq != NULL) {
;;;1612               /* Some segments may have been removed from ooseq, let's remove all SACKs that
;;;1613                  describe anything before the new beginning of that list. */
;;;1614               tcp_remove_sacks_lt(pcb, pcb->ooseq->tcphdr->seqno);
;;;1615             } else if (LWIP_TCP_SACK_VALID(pcb, 0)) {
;;;1616               /* ooseq has been cleared. Nothing to SACK */
;;;1617               memset(pcb->rcv_sacks, 0, sizeof(pcb->rcv_sacks));
;;;1618             }
;;;1619           }
;;;1620   #endif /* LWIP_TCP_SACK_OUT */
;;;1621   #endif /* TCP_QUEUE_OOSEQ */
;;;1622   
;;;1623   
;;;1624           /* Acknowledge the segment(s). */
;;;1625           tcp_ack(pcb);
0006f6  8b60              LDRH     r0,[r4,#0x1a]
0006f8  07c1              LSLS     r1,r0,#31
0006fa  d006              BEQ      |L9.1802|
0006fc  f0200001          BIC      r0,r0,#1
000700  f0400002          ORR      r0,r0,#2
000704  8360              STRH     r0,[r4,#0x1a]
                  |L9.1798|
;;;1626   
;;;1627   #if LWIP_TCP_SACK_OUT
;;;1628           if (LWIP_TCP_SACK_VALID(pcb, 0)) {
;;;1629             /* Normally the ACK for the data received could be piggy-backed on a data packet,
;;;1630                but lwIP currently does not support including SACKs in data packets. So we force
;;;1631                it to respond with an empty ACK packet (only if there is at least one SACK to be sent).
;;;1632                NOTE: tcp_send_empty_ack() on success clears the ACK flags (set by tcp_ack()) */
;;;1633             tcp_send_empty_ack(pcb);
;;;1634           }
;;;1635   #endif /* LWIP_TCP_SACK_OUT */
;;;1636   
;;;1637   #if LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS
;;;1638           if (ip_current_is_v6()) {
;;;1639             /* Inform neighbor reachability of forward progress. */
;;;1640             nd6_reachability_hint(ip6_current_src_addr());
;;;1641           }
;;;1642   #endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/
;;;1643   
;;;1644         } else {
;;;1645           /* We get here if the incoming segment is out-of-sequence. */
;;;1646   
;;;1647   #if TCP_QUEUE_OOSEQ
;;;1648           /* We queue the segment on the ->ooseq queue. */
;;;1649           if (pcb->ooseq == NULL) {
;;;1650             pcb->ooseq = tcp_seg_copy(&inseg);
;;;1651   #if LWIP_TCP_SACK_OUT
;;;1652             if (pcb->flags & TF_SACK) {
;;;1653               /* All the SACKs should be invalid, so we can simply store the most recent one: */
;;;1654               pcb->rcv_sacks[0].left = seqno;
;;;1655               pcb->rcv_sacks[0].right = seqno + inseg.len;
;;;1656             }
;;;1657   #endif /* LWIP_TCP_SACK_OUT */
;;;1658           } else {
;;;1659             /* If the queue is not empty, we walk through the queue and
;;;1660                try to find a place where the sequence number of the
;;;1661                incoming segment is between the sequence numbers of the
;;;1662                previous and the next segment on the ->ooseq queue. That is
;;;1663                the place where we put the incoming segment. If needed, we
;;;1664                trim the second edges of the previous and the incoming
;;;1665                segment so that it will fit into the sequence.
;;;1666   
;;;1667                If the incoming segment has the same sequence number as a
;;;1668                segment on the ->ooseq queue, we discard the segment that
;;;1669                contains less data. */
;;;1670   
;;;1671   #if LWIP_TCP_SACK_OUT
;;;1672             /* This is the left edge of the lowest possible SACK range.
;;;1673                It may start before the newly received segment (possibly adjusted below). */
;;;1674             u32_t sackbeg = TCP_SEQ_LT(seqno, pcb->ooseq->tcphdr->seqno) ? seqno : pcb->ooseq->tcphdr->seqno;
;;;1675   #endif /* LWIP_TCP_SACK_OUT */
;;;1676             struct tcp_seg *next, *prev = NULL;
;;;1677             for (next = pcb->ooseq; next != NULL; next = next->next) {
;;;1678               if (seqno == next->tcphdr->seqno) {
;;;1679                 /* The sequence number of the incoming segment is the
;;;1680                    same as the sequence number of the segment on
;;;1681                    ->ooseq. We check the lengths to see which one to
;;;1682                    discard. */
;;;1683                 if (inseg.len > next->len) {
;;;1684                   /* The incoming segment is larger than the old
;;;1685                      segment. We replace some segments with the new
;;;1686                      one. */
;;;1687                   struct tcp_seg *cseg = tcp_seg_copy(&inseg);
;;;1688                   if (cseg != NULL) {
;;;1689                     if (prev != NULL) {
;;;1690                       prev->next = cseg;
;;;1691                     } else {
;;;1692                       pcb->ooseq = cseg;
;;;1693                     }
;;;1694                     tcp_oos_insert_segment(cseg, next);
;;;1695                   }
;;;1696                   break;
;;;1697                 } else {
;;;1698                   /* Either the lengths are the same or the incoming
;;;1699                      segment was smaller than the old one; in either
;;;1700                      case, we ditch the incoming segment. */
;;;1701                   break;
;;;1702                 }
;;;1703               } else {
;;;1704                 if (prev == NULL) {
;;;1705                   if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
;;;1706                     /* The sequence number of the incoming segment is lower
;;;1707                        than the sequence number of the first segment on the
;;;1708                        queue. We put the incoming segment first on the
;;;1709                        queue. */
;;;1710                     struct tcp_seg *cseg = tcp_seg_copy(&inseg);
;;;1711                     if (cseg != NULL) {
;;;1712                       pcb->ooseq = cseg;
;;;1713                       tcp_oos_insert_segment(cseg, next);
;;;1714                     }
;;;1715                     break;
;;;1716                   }
;;;1717                 } else {
;;;1718                   /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
;;;1719                     TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
;;;1720                   if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno + 1, next->tcphdr->seqno - 1)) {
;;;1721                     /* The sequence number of the incoming segment is in
;;;1722                        between the sequence numbers of the previous and
;;;1723                        the next segment on ->ooseq. We trim trim the previous
;;;1724                        segment, delete next segments that included in received segment
;;;1725                        and trim received, if needed. */
;;;1726                     struct tcp_seg *cseg = tcp_seg_copy(&inseg);
;;;1727                     if (cseg != NULL) {
;;;1728                       if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
;;;1729                         /* We need to trim the prev segment. */
;;;1730                         prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
;;;1731                         pbuf_realloc(prev->p, prev->len);
;;;1732                       }
;;;1733                       prev->next = cseg;
;;;1734                       tcp_oos_insert_segment(cseg, next);
;;;1735                     }
;;;1736                     break;
;;;1737                   }
;;;1738                 }
;;;1739   
;;;1740   #if LWIP_TCP_SACK_OUT
;;;1741                 /* The new segment goes after the 'next' one. If there is a "hole" in sequence numbers
;;;1742                    between 'prev' and the beginning of 'next', we want to move sackbeg. */
;;;1743                 if (prev != NULL && prev->tcphdr->seqno + prev->len != next->tcphdr->seqno) {
;;;1744                   sackbeg = next->tcphdr->seqno;
;;;1745                 }
;;;1746   #endif /* LWIP_TCP_SACK_OUT */
;;;1747   
;;;1748                 /* We don't use 'prev' below, so let's set it to current 'next'.
;;;1749                    This way even if we break the loop below, 'prev' will be pointing
;;;1750                    at the segment right in front of the newly added one. */
;;;1751                 prev = next;
;;;1752   
;;;1753                 /* If the "next" segment is the last segment on the
;;;1754                    ooseq queue, we add the incoming segment to the end
;;;1755                    of the list. */
;;;1756                 if (next->next == NULL &&
;;;1757                     TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
;;;1758                   if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
;;;1759                     /* segment "next" already contains all data */
;;;1760                     break;
;;;1761                   }
;;;1762                   next->next = tcp_seg_copy(&inseg);
;;;1763                   if (next->next != NULL) {
;;;1764                     if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
;;;1765                       /* We need to trim the last segment. */
;;;1766                       next->len = (u16_t)(seqno - next->tcphdr->seqno);
;;;1767                       pbuf_realloc(next->p, next->len);
;;;1768                     }
;;;1769                     /* check if the remote side overruns our receive window */
;;;1770                     if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
;;;1771                       LWIP_DEBUGF(TCP_INPUT_DEBUG,
;;;1772                                   ("tcp_receive: other end overran receive window"
;;;1773                                    "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1774                                    seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1775                       if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
;;;1776                         /* Must remove the FIN from the header as we're trimming
;;;1777                          * that byte of sequence-space from the packet */
;;;1778                         TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
;;;1779                       }
;;;1780                       /* Adjust length of segment to fit in the window. */
;;;1781                       next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
;;;1782                       pbuf_realloc(next->next->p, next->next->len);
;;;1783                       tcplen = TCP_TCPLEN(next->next);
;;;1784                       LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
;;;1785                                   (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1786                     }
;;;1787                   }
;;;1788                   break;
;;;1789                 }
;;;1790               }
;;;1791             }
;;;1792   
;;;1793   #if LWIP_TCP_SACK_OUT
;;;1794             if (pcb->flags & TF_SACK) {
;;;1795               if (prev == NULL) {
;;;1796                 /* The new segment is at the beginning. sackbeg should already be set properly.
;;;1797                    We need to find the right edge. */
;;;1798                 next = pcb->ooseq;
;;;1799               } else if (prev->next != NULL) {
;;;1800                 /* The new segment was added after 'prev'. If there is a "hole" between 'prev' and 'prev->next',
;;;1801                    we need to move sackbeg. After that we should find the right edge. */
;;;1802                 next = prev->next;
;;;1803                 if (prev->tcphdr->seqno + prev->len != next->tcphdr->seqno) {
;;;1804                   sackbeg = next->tcphdr->seqno;
;;;1805                 }
;;;1806               } else {
;;;1807                 next = NULL;
;;;1808               }
;;;1809               if (next != NULL) {
;;;1810                 u32_t sackend = next->tcphdr->seqno;
;;;1811                 for ( ; (next != NULL) && (sackend == next->tcphdr->seqno); next = next->next) {
;;;1812                   sackend += next->len;
;;;1813                 }
;;;1814                 tcp_add_sack(pcb, sackbeg, sackend);
;;;1815               }
;;;1816             }
;;;1817   #endif /* LWIP_TCP_SACK_OUT */
;;;1818           }
;;;1819   #if defined(TCP_OOSEQ_BYTES_LIMIT) || defined(TCP_OOSEQ_PBUFS_LIMIT)
;;;1820           {
;;;1821             /* Check that the data on ooseq doesn't exceed one of the limits
;;;1822                and throw away everything above that limit. */
;;;1823   #ifdef TCP_OOSEQ_BYTES_LIMIT
;;;1824             const u32_t ooseq_max_blen = TCP_OOSEQ_BYTES_LIMIT(pcb);
;;;1825             u32_t ooseq_blen = 0;
;;;1826   #endif
;;;1827   #ifdef TCP_OOSEQ_PBUFS_LIMIT
;;;1828             const u16_t ooseq_max_qlen = TCP_OOSEQ_PBUFS_LIMIT(pcb);
;;;1829             u16_t ooseq_qlen = 0;
;;;1830   #endif
;;;1831             struct tcp_seg *next, *prev = NULL;
;;;1832             for (next = pcb->ooseq; next != NULL; prev = next, next = next->next) {
;;;1833               struct pbuf *p = next->p;
;;;1834               int stop_here = 0;
;;;1835   #ifdef TCP_OOSEQ_BYTES_LIMIT
;;;1836               ooseq_blen += p->tot_len;
;;;1837               if (ooseq_blen > ooseq_max_blen) {
;;;1838                 stop_here = 1;
;;;1839               }
;;;1840   #endif
;;;1841   #ifdef TCP_OOSEQ_PBUFS_LIMIT
;;;1842               ooseq_qlen += pbuf_clen(p);
;;;1843               if (ooseq_qlen > ooseq_max_qlen) {
;;;1844                 stop_here = 1;
;;;1845               }
;;;1846   #endif
;;;1847               if (stop_here) {
;;;1848   #if LWIP_TCP_SACK_OUT
;;;1849                 if (pcb->flags & TF_SACK) {
;;;1850                   /* Let's remove all SACKs from next's seqno up. */
;;;1851                   tcp_remove_sacks_gt(pcb, next->tcphdr->seqno);
;;;1852                 }
;;;1853   #endif /* LWIP_TCP_SACK_OUT */
;;;1854                 /* too much ooseq data, dump this and everything after it */
;;;1855                 tcp_segs_free(next);
;;;1856                 if (prev == NULL) {
;;;1857                   /* first ooseq segment is too much, dump the whole queue */
;;;1858                   pcb->ooseq = NULL;
;;;1859                 } else {
;;;1860                   /* just dump 'next' and everything after it */
;;;1861                   prev->next = NULL;
;;;1862                 }
;;;1863                 break;
;;;1864               }
;;;1865             }
;;;1866           }
;;;1867   #endif /* TCP_OOSEQ_BYTES_LIMIT || TCP_OOSEQ_PBUFS_LIMIT */
;;;1868   #endif /* TCP_QUEUE_OOSEQ */
;;;1869   
;;;1870           /* We send the ACK packet after we've (potentially) dealt with SACKs,
;;;1871              so they can be included in the acknowledgment. */
;;;1872           tcp_send_empty_ack(pcb);
;;;1873         }
;;;1874       } else {
;;;1875         /* The incoming segment is not within the window. */
;;;1876         tcp_send_empty_ack(pcb);
;;;1877       }
;;;1878     } else {
;;;1879       /* Segments with length 0 is taken care of here. Segments that
;;;1880          fall out of the window are ACKed. */
;;;1881       if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
;;;1882         tcp_ack_now(pcb);
;;;1883       }
;;;1884     }
;;;1885   }
000706  e8bd87f0          POP      {r4-r10,pc}
                  |L9.1802|
00070a  f0400001          ORR      r0,r0,#1              ;1625
00070e  8360              STRH     r0,[r4,#0x1a]         ;1625
                  |L9.1808|
000710  e7f9              B        |L9.1798|
                  |L9.1810|
000712  6f65              LDR      r5,[r4,#0x74]         ;1649
000714  b10d              CBZ      r5,|L9.1818|
000716  2600              MOVS     r6,#0                 ;1676
000718  e0bc              B        |L9.2196|
                  |L9.1818|
00071a  489c              LDR      r0,|L9.2444|
00071c  f7fffffe          BL       tcp_seg_copy
000720  6760              STR      r0,[r4,#0x74]         ;1650
000722  e0ba              B        |L9.2202|
                  |L9.1828|
000724  68e9              LDR      r1,[r5,#0xc]          ;1678
000726  6849              LDR      r1,[r1,#4]            ;1678
000728  4281              CMP      r1,r0                 ;1678
00072a  d111              BNE      |L9.1872|
00072c  f8b80008          LDRH     r0,[r8,#8]            ;1683  ; inseg
000730  8929              LDRH     r1,[r5,#8]            ;1683
000732  4288              CMP      r0,r1                 ;1683
000734  d90b              BLS      |L9.1870|
000736  4895              LDR      r0,|L9.2444|
000738  f7fffffe          BL       tcp_seg_copy
00073c  2800              CMP      r0,#0                 ;1688
00073e  d006              BEQ      |L9.1870|
000740  b10e              CBZ      r6,|L9.1862|
000742  6030              STR      r0,[r6,#0]            ;1690
000744  e000              B        |L9.1864|
                  |L9.1862|
000746  6760              STR      r0,[r4,#0x74]         ;1692
                  |L9.1864|
000748  4629              MOV      r1,r5                 ;1694
00074a  f7fffffe          BL       tcp_oos_insert_segment
                  |L9.1870|
00074e  e0a4              B        |L9.2202|
                  |L9.1872|
000750  b326              CBZ      r6,|L9.1948|
000752  68f2              LDR      r2,[r6,#0xc]          ;1720
000754  6852              LDR      r2,[r2,#4]            ;1720
000756  1a82              SUBS     r2,r0,r2              ;1720
000758  2a01              CMP      r2,#1                 ;1720
00075a  d42a              BMI      |L9.1970|
00075c  1a42              SUBS     r2,r0,r1              ;1720
00075e  1c52              ADDS     r2,r2,#1              ;1720
000760  2a00              CMP      r2,#0                 ;1720
000762  dc26              BGT      |L9.1970|
000764  4889              LDR      r0,|L9.2444|
000766  f7fffffe          BL       tcp_seg_copy
00076a  4680              MOV      r8,r0                 ;1726
00076c  ea5f0008          MOVS     r0,r8                 ;1727
000770  d013              BEQ      |L9.1946|
000772  68f0              LDR      r0,[r6,#0xc]          ;1728
000774  6841              LDR      r1,[r0,#4]            ;1728
000776  8930              LDRH     r0,[r6,#8]            ;1728
000778  180a              ADDS     r2,r1,r0              ;1728
00077a  6978              LDR      r0,[r7,#0x14]         ;1728  ; seqno
00077c  1a12              SUBS     r2,r2,r0              ;1728
00077e  2a00              CMP      r2,#0                 ;1728
000780  dd05              BLE      |L9.1934|
000782  1a40              SUBS     r0,r0,r1              ;1730
000784  b281              UXTH     r1,r0                 ;1730
000786  8131              STRH     r1,[r6,#8]            ;1730
000788  6870              LDR      r0,[r6,#4]            ;1731
00078a  f7fffffe          BL       pbuf_realloc
                  |L9.1934|
00078e  f8c68000          STR      r8,[r6,#0]            ;1733
000792  4629              MOV      r1,r5                 ;1734
000794  4640              MOV      r0,r8                 ;1734
000796  f7fffffe          BL       tcp_oos_insert_segment
                  |L9.1946|
00079a  e07e              B        |L9.2202|
                  |L9.1948|
00079c  1a42              SUBS     r2,r0,r1              ;1705
00079e  d508              BPL      |L9.1970|
0007a0  487a              LDR      r0,|L9.2444|
0007a2  f7fffffe          BL       tcp_seg_copy
0007a6  b3e0              CBZ      r0,|L9.2082|
0007a8  6760              STR      r0,[r4,#0x74]         ;1712
0007aa  4629              MOV      r1,r5                 ;1713
0007ac  f7fffffe          BL       tcp_oos_insert_segment
0007b0  e073              B        |L9.2202|
                  |L9.1970|
0007b2  462e              MOV      r6,r5                 ;1751
0007b4  682a              LDR      r2,[r5,#0]            ;1756
0007b6  bbaa              CBNZ     r2,|L9.2084|
0007b8  1a41              SUBS     r1,r0,r1              ;1757
0007ba  2900              CMP      r1,#0                 ;1757
0007bc  dd69              BLE      |L9.2194|
0007be  68e8              LDR      r0,[r5,#0xc]          ;1758
0007c0  8980              LDRH     r0,[r0,#0xc]          ;1758
0007c2  f7fffffe          BL       lwip_htons
0007c6  07c0              LSLS     r0,r0,#31             ;1758
0007c8  d167              BNE      |L9.2202|
0007ca  4870              LDR      r0,|L9.2444|
0007cc  f7fffffe          BL       tcp_seg_copy
0007d0  6028              STR      r0,[r5,#0]            ;1762
0007d2  b330              CBZ      r0,|L9.2082|
0007d4  68e8              LDR      r0,[r5,#0xc]          ;1764
0007d6  8929              LDRH     r1,[r5,#8]            ;1764
0007d8  6840              LDR      r0,[r0,#4]            ;1764
0007da  1842              ADDS     r2,r0,r1              ;1764
0007dc  6979              LDR      r1,[r7,#0x14]         ;1764  ; seqno
0007de  1a52              SUBS     r2,r2,r1              ;1764
0007e0  2a00              CMP      r2,#0                 ;1764
0007e2  dd05              BLE      |L9.2032|
0007e4  1a08              SUBS     r0,r1,r0              ;1766
0007e6  b281              UXTH     r1,r0                 ;1766
0007e8  8129              STRH     r1,[r5,#8]            ;1766
0007ea  6868              LDR      r0,[r5,#4]            ;1767
0007ec  f7fffffe          BL       pbuf_realloc
                  |L9.2032|
0007f0  8d21              LDRH     r1,[r4,#0x28]         ;1770
0007f2  6a60              LDR      r0,[r4,#0x24]         ;1770
0007f4  697a              LDR      r2,[r7,#0x14]         ;1770  ; seqno
0007f6  4408              ADD      r0,r0,r1              ;1770
0007f8  8979              LDRH     r1,[r7,#0xa]          ;1770  ; tcplen
0007fa  4411              ADD      r1,r1,r2              ;1770
0007fc  1a08              SUBS     r0,r1,r0              ;1770
0007fe  2800              CMP      r0,#0                 ;1770
000800  dd4b              BLE      |L9.2202|
000802  6828              LDR      r0,[r5,#0]            ;1775
000804  68c0              LDR      r0,[r0,#0xc]          ;1775
000806  8980              LDRH     r0,[r0,#0xc]          ;1775
000808  f7fffffe          BL       lwip_htons
00080c  07c0              LSLS     r0,r0,#31             ;1775
00080e  d014              BEQ      |L9.2106|
000810  6828              LDR      r0,[r5,#0]            ;1778
000812  68c0              LDR      r0,[r0,#0xc]          ;1778
000814  8980              LDRH     r0,[r0,#0xc]          ;1778
000816  f7fffffe          BL       lwip_htons
00081a  f3c00044          UBFX     r0,r0,#1,#5           ;1778
00081e  0040              LSLS     r0,r0,#1              ;1778
000820  e001              B        |L9.2086|
                  |L9.2082|
000822  e035              B        |L9.2192|
                  |L9.2084|
000824  e035              B        |L9.2194|
                  |L9.2086|
000826  f7fffffe          BL       lwip_htons
00082a  4601              MOV      r1,r0                 ;1778
00082c  6828              LDR      r0,[r5,#0]            ;1778
00082e  68c0              LDR      r0,[r0,#0xc]          ;1778
000830  8982              LDRH     r2,[r0,#0xc]          ;1778
000832  f422527c          BIC      r2,r2,#0x3f00         ;1778
000836  4311              ORRS     r1,r1,r2              ;1778
000838  8181              STRH     r1,[r0,#0xc]          ;1778
                  |L9.2106|
00083a  8ca0              LDRH     r0,[r4,#0x24]         ;1781
00083c  8d21              LDRH     r1,[r4,#0x28]         ;1781
00083e  4408              ADD      r0,r0,r1              ;1781
000840  8ab9              LDRH     r1,[r7,#0x14]         ;1781  ; seqno
000842  1a40              SUBS     r0,r0,r1              ;1781
000844  b281              UXTH     r1,r0                 ;1781
000846  6828              LDR      r0,[r5,#0]            ;1781
000848  8101              STRH     r1,[r0,#8]            ;1781
00084a  6828              LDR      r0,[r5,#0]            ;1782
00084c  6840              LDR      r0,[r0,#4]            ;1782
00084e  f7fffffe          BL       pbuf_realloc
000852  6828              LDR      r0,[r5,#0]            ;1783
000854  68c0              LDR      r0,[r0,#0xc]          ;1783
000856  8980              LDRH     r0,[r0,#0xc]          ;1783
000858  f7fffffe          BL       lwip_htons
00085c  0780              LSLS     r0,r0,#30             ;1783
00085e  d001              BEQ      |L9.2148|
000860  2001              MOVS     r0,#1                 ;1783
000862  e000              B        |L9.2150|
                  |L9.2148|
000864  2000              MOVS     r0,#0                 ;1783
                  |L9.2150|
000866  6829              LDR      r1,[r5,#0]            ;1783
000868  8909              LDRH     r1,[r1,#8]            ;1783
00086a  4408              ADD      r0,r0,r1              ;1783
00086c  b280              UXTH     r0,r0                 ;1783
00086e  8178              STRH     r0,[r7,#0xa]          ;1783
000870  8d22              LDRH     r2,[r4,#0x28]         ;1784
000872  6a61              LDR      r1,[r4,#0x24]         ;1784
000874  4411              ADD      r1,r1,r2              ;1784
000876  697a              LDR      r2,[r7,#0x14]         ;1784  ; seqno
000878  4410              ADD      r0,r0,r2              ;1784
00087a  4288              CMP      r0,r1                 ;1784
00087c  d00d              BEQ      |L9.2202|
00087e  f2af43ec          ADR      r3,|L9.916|
000882  f44f62df          MOV      r2,#0x6f8             ;1784
000886  a112              ADR      r1,|L9.2256|
000888  f2af40a8          ADR      r0,|L9.996|
00088c  f7fffffe          BL       __2printf
                  |L9.2192|
000890  e003              B        |L9.2202|
                  |L9.2194|
000892  4615              MOV      r5,r2                 ;1677
                  |L9.2196|
000894  2d00              CMP      r5,#0                 ;1677
000896  f47faf45          BNE      |L9.1828|
                  |L9.2202|
00089a  4620              MOV      r0,r4                 ;1872
00089c  e8bd47f0          POP      {r4-r10,lr}           ;1872
0008a0  f7ffbffe          B.W      tcp_send_empty_ack
                  |L9.2212|
0008a4  4620              MOV      r0,r4                 ;1876
0008a6  e8bd47f0          POP      {r4-r10,lr}           ;1876
0008aa  f7ffbffe          B.W      tcp_send_empty_ack
                  |L9.2222|
0008ae  6a60              LDR      r0,[r4,#0x24]         ;1881
0008b0  6979              LDR      r1,[r7,#0x14]         ;1881  ; seqno
0008b2  1a0a              SUBS     r2,r1,r0              ;1881
0008b4  d406              BMI      |L9.2244|
0008b6  8d22              LDRH     r2,[r4,#0x28]         ;1881
0008b8  4410              ADD      r0,r0,r2              ;1881
0008ba  1a08              SUBS     r0,r1,r0              ;1881
0008bc  1c40              ADDS     r0,r0,#1              ;1881
0008be  2800              CMP      r0,#0                 ;1881
0008c0  f77faf26          BLE      |L9.1808|
                  |L9.2244|
0008c4  8b60              LDRH     r0,[r4,#0x1a]         ;1882
0008c6  f0400002          ORR      r0,r0,#2              ;1882
0008ca  8360              STRH     r0,[r4,#0x1a]         ;1882
0008cc  e71b              B        |L9.1798|
0008ce  0000              DCW      0x0000
                  |L9.2256|
0008d0  7463705f          DCB      "tcp_receive: segment not trimmed correctly to rcv_wnd\n"
0008d4  72656365
0008d8  6976653a
0008dc  20736567
0008e0  6d656e74
0008e4  206e6f74
0008e8  20747269
0008ec  6d6d6564
0008f0  20636f72
0008f4  72656374
0008f8  6c792074
0008fc  6f207263
000900  765f776e
000904  640a    
000906  00                DCB      0
000907  00                DCB      0
                  |L9.2312|
000908  7463705f          DCB      "tcp_receive: segment not trimmed correctly to ooseq que"
00090c  72656365
000910  6976653a
000914  20736567
000918  6d656e74
00091c  206e6f74
000920  20747269
000924  6d6d6564
000928  20636f72
00092c  72656374
000930  6c792074
000934  6f206f6f
000938  73657120
00093c  717565  
00093f  75650a00          DCB      "ue\n",0
000943  00                DCB      0
                  |L9.2372|
000944  7463705f          DCB      "tcp_receive: tcplen > rcv_wnd\n",0
000948  72656365
00094c  6976653a
000950  20746370
000954  6c656e20
000958  3e207263
00095c  765f776e
000960  640a00  
000963  00                DCB      0
                  |L9.2404|
000964  7463705f          DCB      "tcp_receive: ooseq tcplen > rcv_wnd\n",0
000968  72656365
00096c  6976653a
000970  206f6f73
000974  65712074
000978  63706c65
00097c  6e203e20
000980  7263765f
000984  776e640a
000988  00      
000989  00                DCB      0
00098a  00                DCB      0
00098b  00                DCB      0
                  |L9.2444|
                          DCD      ||.bss||
                          ENDP


                          AREA ||i.tcp_timewait_input||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  tcp_timewait_input PROC
;;;738    static void
;;;739    tcp_timewait_input(struct tcp_pcb *pcb)
000000  b53e              PUSH     {r1-r5,lr}
;;;740    {
000002  4604              MOV      r4,r0
;;;741      /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
;;;742      /* RFC 793 3.9 Event Processing - Segment Arrives:
;;;743       * - first check sequence number - we skip that one in TIME_WAIT (always
;;;744       *   acceptable since we only send ACKs)
;;;745       * - second check the RST bit (... return) */
;;;746      if (flags & TCP_RST) {
000004  4d1c              LDR      r5,|L10.120|
000006  7828              LDRB     r0,[r5,#0]  ; flags
000008  0740              LSLS     r0,r0,#29
00000a  d422              BMI      |L10.82|
;;;747        return;
;;;748      }
;;;749    
;;;750      LWIP_ASSERT("tcp_timewait_input: invalid pcb", pcb != NULL);
00000c  2c00              CMP      r4,#0
00000e  d106              BNE      |L10.30|
000010  a31a              ADR      r3,|L10.124|
000012  f24022ee          MOV      r2,#0x2ee
000016  a126              ADR      r1,|L10.176|
000018  a02d              ADR      r0,|L10.208|
00001a  f7fffffe          BL       __2printf
                  |L10.30|
;;;751    
;;;752      /* - fourth, check the SYN bit, */
;;;753      if (flags & TCP_SYN) {
00001e  7828              LDRB     r0,[r5,#0]  ; flags
000020  0781              LSLS     r1,r0,#30
000022  d517              BPL      |L10.84|
;;;754        /* If an incoming segment is not acceptable, an acknowledgment
;;;755           should be sent in reply */
;;;756        if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
000024  6a61              LDR      r1,[r4,#0x24]
000026  6968              LDR      r0,[r5,#0x14]  ; seqno
000028  1a42              SUBS     r2,r0,r1
00002a  d418              BMI      |L10.94|
00002c  8d22              LDRH     r2,[r4,#0x28]
00002e  4411              ADD      r1,r1,r2
000030  1a41              SUBS     r1,r0,r1
000032  2900              CMP      r1,#0
000034  dc13              BGT      |L10.94|
;;;757          /* If the SYN is in the window it is an error, send a reset */
;;;758          tcp_rst(pcb, ackno, seqno + tcplen, ip_current_dest_addr(),
000036  68e9              LDR      r1,[r5,#0xc]  ; tcphdr
000038  4b2f              LDR      r3,|L10.248|
00003a  880a              LDRH     r2,[r1,#0]
00003c  8849              LDRH     r1,[r1,#2]
00003e  9202              STR      r2,[sp,#8]
000040  e9cd3100          STRD     r3,r1,[sp,#0]
000044  8969              LDRH     r1,[r5,#0xa]  ; tcplen
000046  1d1b              ADDS     r3,r3,#4
000048  1842              ADDS     r2,r0,r1
00004a  4620              MOV      r0,r4
00004c  69a9              LDR      r1,[r5,#0x18]  ; ackno
00004e  f7fffffe          BL       tcp_rst
                  |L10.82|
;;;759                  ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;760          return;
;;;761        }
;;;762      } else if (flags & TCP_FIN) {
;;;763        /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
;;;764             Restart the 2 MSL time-wait timeout.*/
;;;765        pcb->tmr = tcp_ticks;
;;;766      }
;;;767    
;;;768      if ((tcplen > 0)) {
;;;769        /* Acknowledge data, FIN or out-of-window SYN */
;;;770        tcp_ack_now(pcb);
;;;771        tcp_output(pcb);
;;;772      }
;;;773      return;
;;;774    }
000052  bd3e              POP      {r1-r5,pc}
                  |L10.84|
000054  07c0              LSLS     r0,r0,#31             ;762
000056  d002              BEQ      |L10.94|
000058  4828              LDR      r0,|L10.252|
00005a  6800              LDR      r0,[r0,#0]            ;765  ; tcp_ticks
00005c  6220              STR      r0,[r4,#0x20]         ;765
                  |L10.94|
00005e  8968              LDRH     r0,[r5,#0xa]          ;768  ; tcplen
000060  2800              CMP      r0,#0                 ;768
000062  d0f6              BEQ      |L10.82|
000064  8b60              LDRH     r0,[r4,#0x1a]         ;770
000066  f0400002          ORR      r0,r0,#2              ;770
00006a  8360              STRH     r0,[r4,#0x1a]         ;770
00006c  4620              MOV      r0,r4                 ;771
00006e  e8bd403e          POP      {r1-r5,lr}            ;771
000072  f7ffbffe          B.W      tcp_output
;;;775    
                          ENDP

000076  0000              DCW      0x0000
                  |L10.120|
                          DCD      ||.data||
                  |L10.124|
00007c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_in.c"
000080  6964646c
000084  65776172
000088  65735c54
00008c  68697264
000090  5f506172
000094  74795c4c
000098  7749505c
00009c  7372635c
0000a0  636f7265
0000a4  5c746370
0000a8  5f696e2e
0000ac  63      
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L10.176|
0000b0  7463705f          DCB      "tcp_timewait_input: invalid pcb",0
0000b4  74696d65
0000b8  77616974
0000bc  5f696e70
0000c0  75743a20
0000c4  696e7661
0000c8  6c696420
0000cc  70636200
                  |L10.208|
0000d0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000d4  7274696f
0000d8  6e202225
0000dc  73222066
0000e0  61696c65
0000e4  64206174
0000e8  206c696e
0000ec  65202564
0000f0  20696e20
0000f4  25730a00
                  |L10.248|
                          DCD      ip_data+0x10
                  |L10.252|
                          DCD      tcp_ticks

                          AREA ||i.tcp_trigger_input_pcb_close||, CODE, READONLY, ALIGN=2

                  tcp_trigger_input_pcb_close PROC
;;;2028   void
;;;2029   tcp_trigger_input_pcb_close(void)
000000  4802              LDR      r0,|L11.12|
;;;2030   {
;;;2031     recv_flags |= TF_CLOSED;
000002  7841              LDRB     r1,[r0,#1]  ; recv_flags
000004  f0410110          ORR      r1,r1,#0x10
000008  7041              STRB     r1,[r0,#1]
;;;2032   }
00000a  4770              BX       lr
;;;2033   
                          ENDP

                  |L11.12|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  inseg
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  flags
000000  00                DCB      0x00
                  recv_flags
000001  00                DCB      0x00
                  tcphdr_optlen
000002  0000              DCB      0x00,0x00
                  tcphdr_opt1len
000004  0000              DCB      0x00,0x00
                  tcp_optidx
000006  0000              DCB      0x00,0x00
                  recv_acked
000008  0000              DCB      0x00,0x00
                  tcplen
00000a  0000              DCB      0x00,0x00
                  tcphdr
                          DCD      0x00000000
                  tcphdr_opt2
                          DCD      0x00000000
                  seqno
                          DCD      0x00000000
                  ackno
                          DCD      0x00000000
                  recv_data
                          DCD      0x00000000
                  tcp_input_pcb
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_in.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_tcp_in_c_1a988eec____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_tcp_in_c_1a988eec____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_tcp_in_c_1a988eec____REVSH|
#line 478
|__asm___8_tcp_in_c_1a988eec____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_tcp_in_c_1a988eec____RRX|
#line 665
|__asm___8_tcp_in_c_1a988eec____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
