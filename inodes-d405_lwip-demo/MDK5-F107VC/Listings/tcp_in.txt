; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\tcp_in.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\tcp_in.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\system\arch -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Inc -I..\Middlewares\Third_Party\LwIP\src\include -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\tcp_in.crf ..\Middlewares\Third_Party\LwIP\src\core\tcp_in.c]
                          THUMB

                          AREA ||i.tcp_getoptbyte||, CODE, READONLY, ALIGN=2

                  tcp_getoptbyte PROC
;;;1708   static u8_t
;;;1709   tcp_getoptbyte(void)
000000  b510              PUSH     {r4,lr}
;;;1710   {
;;;1711     if ((tcphdr_opt2 == NULL) || (tcp_optidx < tcphdr_opt1len)) {
000002  4c0a              LDR      r4,|L1.44|
000004  4620              MOV      r0,r4
000006  6922              LDR      r2,[r4,#0x10]  ; tcphdr_opt2
000008  88c0              LDRH     r0,[r0,#6]
;;;1712       u8_t* opts = (u8_t *)tcphdr + TCP_HLEN;
;;;1713       return opts[tcp_optidx++];
00000a  1c41              ADDS     r1,r0,#1
00000c  b289              UXTH     r1,r1
00000e  2a00              CMP      r2,#0                 ;1711
000010  d002              BEQ      |L1.24|
000012  88a3              LDRH     r3,[r4,#4]            ;1711  ; tcphdr_opt1len
000014  4298              CMP      r0,r3                 ;1711
000016  d204              BCS      |L1.34|
                  |L1.24|
000018  68e2              LDR      r2,[r4,#0xc]          ;1712  ; tcphdr
00001a  3214              ADDS     r2,r2,#0x14           ;1712
00001c  80e1              STRH     r1,[r4,#6]
00001e  5c10              LDRB     r0,[r2,r0]
;;;1714     } else {
;;;1715       u8_t idx = (u8_t)(tcp_optidx++ - tcphdr_opt1len);
;;;1716       return tcphdr_opt2[idx];
;;;1717     }
;;;1718   }
000020  bd10              POP      {r4,pc}
                  |L1.34|
000022  1ac0              SUBS     r0,r0,r3              ;1715
000024  80e1              STRH     r1,[r4,#6]            ;1715
000026  b2c0              UXTB     r0,r0                 ;1715
000028  5c10              LDRB     r0,[r2,r0]            ;1716
00002a  bd10              POP      {r4,pc}
;;;1719   
                          ENDP

                  |L1.44|
                          DCD      ||.data||

                          AREA ||i.tcp_input||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_input PROC
;;;103    void
;;;104    tcp_input(struct pbuf *p, struct netif *inp)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;105    {
000004  4605              MOV      r5,r0
;;;106      struct tcp_pcb *pcb, *prev;
;;;107      struct tcp_pcb_listen *lpcb;
;;;108    #if SO_REUSE
;;;109      struct tcp_pcb *lpcb_prev = NULL;
;;;110      struct tcp_pcb_listen *lpcb_any = NULL;
;;;111    #endif /* SO_REUSE */
;;;112      u8_t hdrlen_bytes;
;;;113      err_t err;
;;;114    
;;;115      LWIP_UNUSED_ARG(inp);
;;;116    
;;;117      PERF_START;
;;;118    
;;;119      TCP_STATS_INC(tcp.recv);
;;;120      MIB2_STATS_INC(mib2.tcpinsegs);
;;;121    
;;;122      tcphdr = (struct tcp_hdr *)p->payload;
000006  4ef7              LDR      r6,|L2.996|
000008  6868              LDR      r0,[r5,#4]
00000a  60f0              STR      r0,[r6,#0xc]  ; tcphdr
;;;123    
;;;124    #if TCP_INPUT_DEBUG
;;;125      tcp_debug_print(tcphdr);
;;;126    #endif
;;;127    
;;;128      /* Check that TCP header fits in payload */
;;;129      if (p->len < TCP_HLEN) {
00000c  8968              LDRH     r0,[r5,#0xa]
00000e  2814              CMP      r0,#0x14
                  |L2.16|
000010  d37e              BCC      |L2.272|
;;;130        /* drop short packets */
;;;131        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
;;;132        TCP_STATS_INC(tcp.lenerr);
;;;133        goto dropped;
;;;134      }
;;;135    
;;;136      /* Don't even process incoming broadcasts/multicasts. */
;;;137      if (ip_addr_isbroadcast(ip_current_dest_addr(), ip_current_netif()) ||
000012  f8df83d4          LDR      r8,|L2.1000|
000016  f8d81000          LDR      r1,[r8,#0]  ; ip_data
00001a  f8d80014          LDR      r0,[r8,#0x14]  ; ip_data
00001e  f7fffffe          BL       ip4_addr_isbroadcast_u32
000022  2800              CMP      r0,#0
000024  d174              BNE      |L2.272|
;;;138          ip_addr_ismulticast(ip_current_dest_addr())) {
000026  f8980014          LDRB     r0,[r8,#0x14]  ; ip_data
00002a  f3c01003          UBFX     r0,r0,#4,#4
00002e  280e              CMP      r0,#0xe
000030  d06e              BEQ      |L2.272|
;;;139        TCP_STATS_INC(tcp.proterr);
;;;140        goto dropped;
;;;141      }
;;;142    
;;;143    #if CHECKSUM_CHECK_TCP
;;;144      IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_TCP) {
;;;145        /* Verify TCP checksum. */
;;;146        u16_t chksum = ip_chksum_pseudo(p, IP_PROTO_TCP, p->tot_len,
;;;147                                   ip_current_src_addr(), ip_current_dest_addr());
;;;148        if (chksum != 0) {
;;;149            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packet discarded due to failing checksum 0x%04"X16_F"\n",
;;;150              chksum));
;;;151          tcp_debug_print(tcphdr);
;;;152          TCP_STATS_INC(tcp.chkerr);
;;;153          goto dropped;
;;;154        }
;;;155      }
;;;156    #endif /* CHECKSUM_CHECK_TCP */
;;;157    
;;;158      /* sanity-check header length */
;;;159      hdrlen_bytes = TCPH_HDRLEN(tcphdr) * 4;
000032  68f0              LDR      r0,[r6,#0xc]  ; tcphdr
000034  8980              LDRH     r0,[r0,#0xc]
000036  f7fffffe          BL       lwip_htons
00003a  0b00              LSRS     r0,r0,#12
00003c  0080              LSLS     r0,r0,#2
;;;160      if ((hdrlen_bytes < TCP_HLEN) || (hdrlen_bytes > p->tot_len)) {
00003e  2814              CMP      r0,#0x14
000040  d3e6              BCC      |L2.16|
000042  8929              LDRH     r1,[r5,#8]
000044  4281              CMP      r1,r0
000046  d3e3              BCC      |L2.16|
;;;161        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: invalid header length (%"U16_F")\n", (u16_t)hdrlen_bytes));
;;;162        TCP_STATS_INC(tcp.lenerr);
;;;163        goto dropped;
;;;164      }
;;;165    
;;;166      /* Move the payload pointer in the pbuf so that it points to the
;;;167         TCP data instead of the TCP header. */
;;;168      tcphdr_optlen = hdrlen_bytes - TCP_HLEN;
000048  f1a00114          SUB      r1,r0,#0x14
00004c  b289              UXTH     r1,r1
00004e  8071              STRH     r1,[r6,#2]
;;;169      tcphdr_opt2 = NULL;
000050  2700              MOVS     r7,#0
000052  6137              STR      r7,[r6,#0x10]  ; tcphdr_opt2
;;;170      if (p->len >= hdrlen_bytes) {
000054  896a              LDRH     r2,[r5,#0xa]
000056  4282              CMP      r2,r0
000058  d305              BCC      |L2.102|
;;;171        /* all options are in the first pbuf */
;;;172        tcphdr_opt1len = tcphdr_optlen;
00005a  80b1              STRH     r1,[r6,#4]
;;;173        pbuf_header(p, -(s16_t)hdrlen_bytes); /* cannot fail */
00005c  4241              RSBS     r1,r0,#0
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       pbuf_header
000064  e036              B        |L2.212|
                  |L2.102|
;;;174      } else {
;;;175        u16_t opt2len;
;;;176        /* TCP header fits into first pbuf, options don't - data is in the next pbuf */
;;;177        /* there must be a next pbuf, due to hdrlen_bytes sanity check above */
;;;178        LWIP_ASSERT("p->next != NULL", p->next != NULL);
000066  6828              LDR      r0,[r5,#0]
000068  b928              CBNZ     r0,|L2.118|
00006a  a3e0              ADR      r3,|L2.1004|
00006c  22b2              MOVS     r2,#0xb2
00006e  a1ec              ADR      r1,|L2.1056|
000070  a0ef              ADR      r0,|L2.1072|
000072  f7fffffe          BL       __2printf
                  |L2.118|
;;;179    
;;;180        /* advance over the TCP header (cannot fail) */
;;;181        pbuf_header(p, -TCP_HLEN);
000076  f06f0113          MVN      r1,#0x13
00007a  4628              MOV      r0,r5
00007c  f7fffffe          BL       pbuf_header
;;;182    
;;;183        /* determine how long the first and second parts of the options are */
;;;184        tcphdr_opt1len = p->len;
000080  8968              LDRH     r0,[r5,#0xa]
000082  80b0              STRH     r0,[r6,#4]
;;;185        opt2len = tcphdr_optlen - tcphdr_opt1len;
000084  8871              LDRH     r1,[r6,#2]  ; tcphdr_optlen
000086  1a09              SUBS     r1,r1,r0
000088  b28c              UXTH     r4,r1
;;;186    
;;;187        /* options continue in the next pbuf: set p to zero length and hide the
;;;188            options in the next pbuf (adjusting p->tot_len) */
;;;189        pbuf_header(p, -(s16_t)tcphdr_opt1len);
00008a  4240              RSBS     r0,r0,#0
00008c  b201              SXTH     r1,r0
00008e  4628              MOV      r0,r5
000090  f7fffffe          BL       pbuf_header
;;;190    
;;;191        /* check that the options fit in the second pbuf */
;;;192        if (opt2len > p->next->len) {
000094  6828              LDR      r0,[r5,#0]
000096  8941              LDRH     r1,[r0,#0xa]
000098  42a1              CMP      r1,r4
00009a  d3b9              BCC      |L2.16|
;;;193          /* drop short packets */
;;;194          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: options overflow second pbuf (%"U16_F" bytes)\n", p->next->len));
;;;195          TCP_STATS_INC(tcp.lenerr);
;;;196          goto dropped;
;;;197        }
;;;198    
;;;199        /* remember the pointer to the second part of the options */
;;;200        tcphdr_opt2 = (u8_t*)p->next->payload;
00009c  6841              LDR      r1,[r0,#4]
00009e  6131              STR      r1,[r6,#0x10]  ; tcphdr_opt2
;;;201    
;;;202        /* advance p->next to point after the options, and manually
;;;203            adjust p->tot_len to keep it consistent with the changed p->next */
;;;204        pbuf_header(p->next, -(s16_t)opt2len);
0000a0  4261              RSBS     r1,r4,#0
0000a2  b209              SXTH     r1,r1
0000a4  f7fffffe          BL       pbuf_header
;;;205        p->tot_len -= opt2len;
0000a8  8928              LDRH     r0,[r5,#8]
0000aa  1b00              SUBS     r0,r0,r4
0000ac  8128              STRH     r0,[r5,#8]
;;;206    
;;;207        LWIP_ASSERT("p->len == 0", p->len == 0);
0000ae  8968              LDRH     r0,[r5,#0xa]
0000b0  b128              CBZ      r0,|L2.190|
0000b2  a3ce              ADR      r3,|L2.1004|
0000b4  22cf              MOVS     r2,#0xcf
0000b6  a1e8              ADR      r1,|L2.1112|
0000b8  a0dd              ADR      r0,|L2.1072|
0000ba  f7fffffe          BL       __2printf
                  |L2.190|
;;;208        LWIP_ASSERT("p->tot_len == p->next->tot_len", p->tot_len == p->next->tot_len);
0000be  6829              LDR      r1,[r5,#0]
0000c0  8928              LDRH     r0,[r5,#8]
0000c2  8909              LDRH     r1,[r1,#8]
0000c4  4288              CMP      r0,r1
0000c6  d005              BEQ      |L2.212|
0000c8  a3c8              ADR      r3,|L2.1004|
0000ca  22d0              MOVS     r2,#0xd0
0000cc  a1e5              ADR      r1,|L2.1124|
0000ce  a0d8              ADR      r0,|L2.1072|
0000d0  f7fffffe          BL       __2printf
                  |L2.212|
;;;209      }
;;;210    
;;;211      /* Convert fields in TCP header to host byte order. */
;;;212      tcphdr->src = lwip_ntohs(tcphdr->src);
0000d4  68f0              LDR      r0,[r6,#0xc]  ; tcphdr
0000d6  8800              LDRH     r0,[r0,#0]
0000d8  f7fffffe          BL       lwip_htons
0000dc  4601              MOV      r1,r0
0000de  68f0              LDR      r0,[r6,#0xc]  ; tcphdr
0000e0  8001              STRH     r1,[r0,#0]
;;;213      tcphdr->dest = lwip_ntohs(tcphdr->dest);
0000e2  8840              LDRH     r0,[r0,#2]
0000e4  f7fffffe          BL       lwip_htons
0000e8  4601              MOV      r1,r0
0000ea  68f0              LDR      r0,[r6,#0xc]  ; tcphdr
0000ec  8041              STRH     r1,[r0,#2]
;;;214      seqno = tcphdr->seqno = lwip_ntohl(tcphdr->seqno);
0000ee  6840              LDR      r0,[r0,#4]
0000f0  f7fffffe          BL       lwip_htonl
0000f4  68f1              LDR      r1,[r6,#0xc]  ; tcphdr
0000f6  6048              STR      r0,[r1,#4]
0000f8  6170              STR      r0,[r6,#0x14]  ; seqno
;;;215      ackno = tcphdr->ackno = lwip_ntohl(tcphdr->ackno);
0000fa  6888              LDR      r0,[r1,#8]
0000fc  f7fffffe          BL       lwip_htonl
000100  4601              MOV      r1,r0
000102  68f0              LDR      r0,[r6,#0xc]  ; tcphdr
000104  6081              STR      r1,[r0,#8]
000106  61b1              STR      r1,[r6,#0x18]  ; ackno
;;;216      tcphdr->wnd = lwip_ntohs(tcphdr->wnd);
000108  89c0              LDRH     r0,[r0,#0xe]
00010a  f7fffffe          BL       lwip_htons
00010e  e000              B        |L2.274|
                  |L2.272|
000110  e268              B        |L2.1508|
                  |L2.274|
000112  4601              MOV      r1,r0
000114  68f0              LDR      r0,[r6,#0xc]  ; tcphdr
000116  81c1              STRH     r1,[r0,#0xe]
;;;217    
;;;218      flags = TCPH_FLAGS(tcphdr);
000118  8980              LDRH     r0,[r0,#0xc]
00011a  f7fffffe          BL       lwip_htons
00011e  f000003f          AND      r0,r0,#0x3f
000122  7030              STRB     r0,[r6,#0]
;;;219      tcplen = p->tot_len + ((flags & (TCP_FIN | TCP_SYN)) ? 1 : 0);
000124  8929              LDRH     r1,[r5,#8]
000126  0780              LSLS     r0,r0,#30
000128  d001              BEQ      |L2.302|
00012a  2001              MOVS     r0,#1
00012c  e000              B        |L2.304|
                  |L2.302|
00012e  2000              MOVS     r0,#0
                  |L2.304|
000130  4408              ADD      r0,r0,r1
000132  8170              STRH     r0,[r6,#0xa]
;;;220    
;;;221      /* Demultiplex an incoming segment. First, we check if it is destined
;;;222         for an active connection. */
;;;223      prev = NULL;
000134  f04f0900          MOV      r9,#0
;;;224    
;;;225      for (pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
000138  f8dfa348          LDR      r10,|L2.1156|
00013c  f8da4000          LDR      r4,[r10,#0]  ; tcp_active_pcbs
000140  e04c              B        |L2.476|
                  |L2.322|
;;;226        LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
000142  7d20              LDRB     r0,[r4,#0x14]
000144  b928              CBNZ     r0,|L2.338|
000146  a3a9              ADR      r3,|L2.1004|
000148  22e2              MOVS     r2,#0xe2
00014a  a1cf              ADR      r1,|L2.1160|
00014c  a0b8              ADR      r0,|L2.1072|
00014e  f7fffffe          BL       __2printf
                  |L2.338|
;;;227        LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
000152  7d20              LDRB     r0,[r4,#0x14]
000154  280a              CMP      r0,#0xa
000156  d105              BNE      |L2.356|
000158  a3a4              ADR      r3,|L2.1004|
00015a  22e3              MOVS     r2,#0xe3
00015c  a1d4              ADR      r1,|L2.1200|
00015e  a0b4              ADR      r0,|L2.1072|
000160  f7fffffe          BL       __2printf
                  |L2.356|
;;;228        LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
000164  7d20              LDRB     r0,[r4,#0x14]
000166  2801              CMP      r0,#1
000168  d105              BNE      |L2.374|
00016a  a3a0              ADR      r3,|L2.1004|
00016c  22e4              MOVS     r2,#0xe4
00016e  a1db              ADR      r1,|L2.1244|
000170  a0af              ADR      r0,|L2.1072|
000172  f7fffffe          BL       __2printf
                  |L2.374|
;;;229        if (pcb->remote_port == tcphdr->src &&
000176  68f0              LDR      r0,[r6,#0xc]  ; tcphdr
000178  8b21              LDRH     r1,[r4,#0x18]
00017a  8802              LDRH     r2,[r0,#0]
00017c  4291              CMP      r1,r2
00017e  d12b              BNE      |L2.472|
;;;230            pcb->local_port == tcphdr->dest &&
000180  8ae1              LDRH     r1,[r4,#0x16]
000182  8840              LDRH     r0,[r0,#2]
000184  4281              CMP      r1,r0
000186  d127              BNE      |L2.472|
;;;231            ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
000188  6860              LDR      r0,[r4,#4]
00018a  f8d81010          LDR      r1,[r8,#0x10]  ; ip_data
00018e  4288              CMP      r0,r1
000190  d122              BNE      |L2.472|
;;;232            ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
000192  6820              LDR      r0,[r4,#0]
000194  f8d81014          LDR      r1,[r8,#0x14]  ; ip_data
000198  4288              CMP      r0,r1
00019a  d11d              BNE      |L2.472|
;;;233          /* Move this PCB to the front of the list so that subsequent
;;;234             lookups will be faster (we exploit locality in TCP segment
;;;235             arrivals). */
;;;236          LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
00019c  68e0              LDR      r0,[r4,#0xc]
00019e  42a0              CMP      r0,r4
0001a0  d105              BNE      |L2.430|
0001a2  a392              ADR      r3,|L2.1004|
0001a4  22ec              MOVS     r2,#0xec
0001a6  a1d7              ADR      r1,|L2.1284|
0001a8  a0a1              ADR      r0,|L2.1072|
0001aa  f7fffffe          BL       __2printf
                  |L2.430|
;;;237          if (prev != NULL) {
0001ae  f1b90f00          CMP      r9,#0
0001b2  d007              BEQ      |L2.452|
;;;238            prev->next = pcb->next;
0001b4  68e0              LDR      r0,[r4,#0xc]
0001b6  f8c9000c          STR      r0,[r9,#0xc]
;;;239            pcb->next = tcp_active_pcbs;
0001ba  f8da0000          LDR      r0,[r10,#0]  ; tcp_active_pcbs
0001be  60e0              STR      r0,[r4,#0xc]
;;;240            tcp_active_pcbs = pcb;
0001c0  f8ca4000          STR      r4,[r10,#0]  ; tcp_active_pcbs
                  |L2.452|
;;;241          } else {
;;;242            TCP_STATS_INC(tcp.cachehit);
;;;243          }
;;;244          LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
0001c4  68e0              LDR      r0,[r4,#0xc]
0001c6  42a0              CMP      r0,r4
0001c8  d10a              BNE      |L2.480|
0001ca  a388              ADR      r3,|L2.1004|
0001cc  22f4              MOVS     r2,#0xf4
0001ce  a1d8              ADR      r1,|L2.1328|
0001d0  a097              ADR      r0,|L2.1072|
0001d2  f7fffffe          BL       __2printf
0001d6  e003              B        |L2.480|
                  |L2.472|
;;;245          break;
;;;246        }
;;;247        prev = pcb;
0001d8  46a1              MOV      r9,r4
0001da  68e4              LDR      r4,[r4,#0xc]          ;225
                  |L2.476|
0001dc  2c00              CMP      r4,#0                 ;225
0001de  d1b0              BNE      |L2.322|
                  |L2.480|
;;;248      }
;;;249    
;;;250      if (pcb == NULL) {
0001e0  2c00              CMP      r4,#0
0001e2  d150              BNE      |L2.646|
;;;251        /* If it did not go to an active connection, we check the connections
;;;252           in the TIME-WAIT state. */
;;;253        for (pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
0001e4  48dd              LDR      r0,|L2.1372|
0001e6  6804              LDR      r4,[r0,#0]  ; tcp_tw_pcbs
0001e8  e024              B        |L2.564|
                  |L2.490|
;;;254          LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
0001ea  7d20              LDRB     r0,[r4,#0x14]
0001ec  280a              CMP      r0,#0xa
0001ee  d005              BEQ      |L2.508|
0001f0  a37e              ADR      r3,|L2.1004|
0001f2  22fe              MOVS     r2,#0xfe
0001f4  a1da              ADR      r1,|L2.1376|
0001f6  a08e              ADR      r0,|L2.1072|
0001f8  f7fffffe          BL       __2printf
                  |L2.508|
;;;255          if (pcb->remote_port == tcphdr->src &&
0001fc  68f0              LDR      r0,[r6,#0xc]  ; tcphdr
0001fe  8b21              LDRH     r1,[r4,#0x18]
000200  8802              LDRH     r2,[r0,#0]
000202  4291              CMP      r1,r2
000204  d115              BNE      |L2.562|
;;;256              pcb->local_port == tcphdr->dest &&
000206  8ae1              LDRH     r1,[r4,#0x16]
000208  8840              LDRH     r0,[r0,#2]
00020a  4281              CMP      r1,r0
00020c  d111              BNE      |L2.562|
;;;257              ip_addr_cmp(&pcb->remote_ip, ip_current_src_addr()) &&
00020e  6860              LDR      r0,[r4,#4]
000210  f8d81010          LDR      r1,[r8,#0x10]  ; ip_data
000214  4288              CMP      r0,r1
000216  d10c              BNE      |L2.562|
;;;258              ip_addr_cmp(&pcb->local_ip, ip_current_dest_addr())) {
000218  6820              LDR      r0,[r4,#0]
00021a  f8d81014          LDR      r1,[r8,#0x14]  ; ip_data
00021e  4288              CMP      r0,r1
000220  d107              BNE      |L2.562|
;;;259            /* We don't really care enough to move this PCB to the front
;;;260               of the list since we are not very likely to receive that
;;;261               many segments for connections in TIME-WAIT. */
;;;262            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
;;;263            tcp_timewait_input(pcb);
000222  4620              MOV      r0,r4
000224  f7fffffe          BL       tcp_timewait_input
;;;264            pbuf_free(p);
000228  4628              MOV      r0,r5
00022a  e8bd47fc          POP      {r2-r10,lr}
00022e  f7ffbffe          B.W      pbuf_free
                  |L2.562|
000232  68e4              LDR      r4,[r4,#0xc]          ;253
                  |L2.564|
000234  2c00              CMP      r4,#0                 ;253
000236  d1d8              BNE      |L2.490|
;;;265            return;
;;;266          }
;;;267        }
;;;268    
;;;269        /* Finally, if we still did not get a match, we check all PCBs that
;;;270           are LISTENing for incoming connections. */
;;;271        prev = NULL;
000238  2200              MOVS     r2,#0
;;;272        for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
00023a  f8dfc354          LDR      r12,|L2.1424|
00023e  f8dc0000          LDR      r0,[r12,#0]  ; tcp_listen_pcbs
000242  4603              MOV      r3,r0
000244  f8d6900c          LDR      r9,[r6,#0xc]          ;137
000248  f8d88014          LDR      r8,[r8,#0x14]         ;137
00024c  e00b              B        |L2.614|
                  |L2.590|
;;;273          if (lpcb->local_port == tcphdr->dest) {
00024e  8ac1              LDRH     r1,[r0,#0x16]
000250  f8b9a002          LDRH     r10,[r9,#2]
000254  4551              CMP      r1,r10
000256  d104              BNE      |L2.610|
;;;274            if (IP_IS_ANY_TYPE_VAL(lpcb->local_ip)) {
;;;275              /* found an ANY TYPE (IPv4/IPv6) match */
;;;276    #if SO_REUSE
;;;277              lpcb_any = lpcb;
;;;278              lpcb_prev = prev;
;;;279    #else /* SO_REUSE */
;;;280              break;
;;;281    #endif /* SO_REUSE */
;;;282            } else if (IP_ADDR_PCB_VERSION_MATCH_EXACT(lpcb, ip_current_dest_addr())) {
;;;283              if (ip_addr_cmp(&lpcb->local_ip, ip_current_dest_addr())) {
000258  6801              LDR      r1,[r0,#0]
00025a  4541              CMP      r1,r8
00025c  d005              BEQ      |L2.618|
;;;284                /* found an exact match */
;;;285                break;
;;;286              } else if (ip_addr_isany(&lpcb->local_ip)) {
00025e  b120              CBZ      r0,|L2.618|
000260  b119              CBZ      r1,|L2.618|
                  |L2.610|
;;;287                /* found an ANY-match */
;;;288    #if SO_REUSE
;;;289                lpcb_any = lpcb;
;;;290                lpcb_prev = prev;
;;;291    #else /* SO_REUSE */
;;;292                break;
;;;293     #endif /* SO_REUSE */
;;;294              }
;;;295            }
;;;296          }
;;;297          prev = (struct tcp_pcb *)lpcb;
000262  4602              MOV      r2,r0
000264  68c0              LDR      r0,[r0,#0xc]          ;272
                  |L2.614|
000266  2800              CMP      r0,#0                 ;272
000268  d1f1              BNE      |L2.590|
                  |L2.618|
;;;298        }
;;;299    #if SO_REUSE
;;;300        /* first try specific local IP */
;;;301        if (lpcb == NULL) {
;;;302          /* only pass to ANY if no specific local IP has been found */
;;;303          lpcb = lpcb_any;
;;;304          prev = lpcb_prev;
;;;305        }
;;;306    #endif /* SO_REUSE */
;;;307        if (lpcb != NULL) {
00026a  b160              CBZ      r0,|L2.646|
;;;308          /* Move this PCB to the front of the list so that subsequent
;;;309             lookups will be faster (we exploit locality in TCP segment
;;;310             arrivals). */
;;;311          if (prev != NULL) {
00026c  b122              CBZ      r2,|L2.632|
;;;312            ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
00026e  68c1              LDR      r1,[r0,#0xc]
000270  60d1              STR      r1,[r2,#0xc]
;;;313                  /* our successor is the remainder of the listening list */
;;;314            lpcb->next = tcp_listen_pcbs.listen_pcbs;
000272  60c3              STR      r3,[r0,#0xc]
;;;315                  /* put this listening pcb at the head of the listening list */
;;;316            tcp_listen_pcbs.listen_pcbs = lpcb;
000274  f8cc0000          STR      r0,[r12,#0]  ; tcp_listen_pcbs
                  |L2.632|
;;;317          } else {
;;;318            TCP_STATS_INC(tcp.cachehit);
;;;319          }
;;;320    
;;;321          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
;;;322          tcp_listen_input(lpcb);
000278  f7fffffe          BL       tcp_listen_input
;;;323          pbuf_free(p);
00027c  4628              MOV      r0,r5
00027e  e8bd47fc          POP      {r2-r10,lr}
000282  f7ffbffe          B.W      pbuf_free
                  |L2.646|
;;;324          return;
;;;325        }
;;;326      }
;;;327    
;;;328    #if TCP_INPUT_DEBUG
;;;329      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("+-+-+-+-+-+-+-+-+-+-+-+-+-+- tcp_input: flags "));
;;;330      tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
;;;331      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
;;;332    #endif /* TCP_INPUT_DEBUG */
;;;333    
;;;334    
;;;335      if (pcb != NULL) {
000286  2c00              CMP      r4,#0
000288  d07e              BEQ      |L2.904|
;;;336        /* The incoming segment belongs to a connection. */
;;;337    #if TCP_INPUT_DEBUG
;;;338        tcp_debug_print_state(pcb->state);
;;;339    #endif /* TCP_INPUT_DEBUG */
;;;340    
;;;341        /* Set up a tcp_seg structure. */
;;;342        inseg.next = NULL;
00028a  f8df8308          LDR      r8,|L2.1428|
00028e  f8c87000          STR      r7,[r8,#0]  ; inseg
;;;343        inseg.len = p->tot_len;
000292  8928              LDRH     r0,[r5,#8]
000294  f8a80008          STRH     r0,[r8,#8]
;;;344        inseg.p = p;
000298  f8c85004          STR      r5,[r8,#4]  ; inseg
;;;345        inseg.tcphdr = tcphdr;
00029c  68f0              LDR      r0,[r6,#0xc]  ; tcphdr
00029e  f8c8000c          STR      r0,[r8,#0xc]  ; inseg
;;;346    
;;;347        recv_data = NULL;
0002a2  61f7              STR      r7,[r6,#0x1c]  ; recv_data
;;;348        recv_flags = 0;
0002a4  7077              STRB     r7,[r6,#1]
;;;349        recv_acked = 0;
0002a6  8137              STRH     r7,[r6,#8]
;;;350    
;;;351        if (flags & TCP_PSH) {
0002a8  7830              LDRB     r0,[r6,#0]  ; flags
0002aa  0700              LSLS     r0,r0,#28
0002ac  d503              BPL      |L2.694|
;;;352          p->flags |= PBUF_FLAG_PUSH;
0002ae  7b68              LDRB     r0,[r5,#0xd]
0002b0  f0400001          ORR      r0,r0,#1
0002b4  7368              STRB     r0,[r5,#0xd]
                  |L2.694|
;;;353        }
;;;354    
;;;355        /* If there is data which was previously "refused" by upper layer */
;;;356        if (pcb->refused_data != NULL) {
0002b6  6f60              LDR      r0,[r4,#0x74]
0002b8  b178              CBZ      r0,|L2.730|
;;;357          if ((tcp_process_refused_data(pcb) == ERR_ABRT) ||
0002ba  4620              MOV      r0,r4
0002bc  f7fffffe          BL       tcp_process_refused_data
0002c0  300d              ADDS     r0,r0,#0xd
0002c2  d003              BEQ      |L2.716|
;;;358            ((pcb->refused_data != NULL) && (tcplen > 0))) {
0002c4  6f60              LDR      r0,[r4,#0x74]
0002c6  b140              CBZ      r0,|L2.730|
0002c8  8970              LDRH     r0,[r6,#0xa]  ; tcplen
0002ca  b130              CBZ      r0,|L2.730|
                  |L2.716|
;;;359            /* pcb has been aborted or refused data is still refused and the new
;;;360               segment contains data */
;;;361            if (pcb->rcv_ann_wnd == 0) {
0002cc  8d60              LDRH     r0,[r4,#0x2a]
0002ce  2800              CMP      r0,#0
0002d0  d17c              BNE      |L2.972|
;;;362              /* this is a zero-window probe, we respond to it with current RCV.NXT
;;;363              and drop the data segment */
;;;364              tcp_send_empty_ack(pcb);
0002d2  4620              MOV      r0,r4
0002d4  f7fffffe          BL       tcp_send_empty_ack
0002d8  e078              B        |L2.972|
                  |L2.730|
;;;365            }
;;;366            TCP_STATS_INC(tcp.drop);
;;;367            MIB2_STATS_INC(mib2.tcpinerrs);
;;;368            goto aborted;
;;;369          }
;;;370        }
;;;371        tcp_input_pcb = pcb;
0002da  6234              STR      r4,[r6,#0x20]  ; tcp_input_pcb
;;;372        err = tcp_process(pcb);
0002dc  4620              MOV      r0,r4
0002de  f7fffffe          BL       tcp_process
;;;373        /* A return value of ERR_ABRT means that tcp_abort() was called
;;;374           and that the pcb has been freed. If so, we don't do anything. */
;;;375        if (err != ERR_ABRT) {
0002e2  300d              ADDS     r0,r0,#0xd
0002e4  d072              BEQ      |L2.972|
;;;376          if (recv_flags & TF_RESET) {
0002e6  7870              LDRB     r0,[r6,#1]  ; recv_flags
0002e8  0700              LSLS     r0,r0,#28
0002ea  d50f              BPL      |L2.780|
;;;377            /* TF_RESET means that the connection was reset by the other
;;;378               end. We then call the error callback to inform the
;;;379               application that the connection is dead before we
;;;380               deallocate the PCB. */
;;;381            TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_RST);
0002ec  f8d4208c          LDR      r2,[r4,#0x8c]
0002f0  b11a              CBZ      r2,|L2.762|
0002f2  f06f010d          MVN      r1,#0xd
0002f6  6920              LDR      r0,[r4,#0x10]
0002f8  4790              BLX      r2
                  |L2.762|
;;;382            tcp_pcb_remove(&tcp_active_pcbs, pcb);
0002fa  4621              MOV      r1,r4
0002fc  4861              LDR      r0,|L2.1156|
0002fe  f7fffffe          BL       tcp_pcb_remove
;;;383            memp_free(MEMP_TCP_PCB, pcb);
000302  4621              MOV      r1,r4
000304  2001              MOVS     r0,#1
000306  f7fffffe          BL       memp_free
00030a  e05f              B        |L2.972|
                  |L2.780|
;;;384          } else {
;;;385            err = ERR_OK;
00030c  2000              MOVS     r0,#0
;;;386            /* If the application has registered a "sent" function to be
;;;387               called when new send buffer space is available, we call it
;;;388               now. */
;;;389            if (recv_acked > 0) {
00030e  8932              LDRH     r2,[r6,#8]  ; recv_acked
000310  b13a              CBZ      r2,|L2.802|
;;;390              u16_t acked16;
;;;391    #if LWIP_WND_SCALE
;;;392              /* recv_acked is u32_t but the sent callback only takes a u16_t,
;;;393                 so we might have to call it multiple times. */
;;;394              u32_t acked = recv_acked;
;;;395              while (acked > 0) {
;;;396                acked16 = (u16_t)LWIP_MIN(acked, 0xffffu);
;;;397                acked -= acked16;
;;;398    #else
;;;399              {
;;;400                acked16 = recv_acked;
;;;401    #endif
;;;402                TCP_EVENT_SENT(pcb, (u16_t)acked16, err);
000312  6fe3              LDR      r3,[r4,#0x7c]
000314  b113              CBZ      r3,|L2.796|
000316  4621              MOV      r1,r4
000318  6920              LDR      r0,[r4,#0x10]
00031a  4798              BLX      r3
                  |L2.796|
;;;403                if (err == ERR_ABRT) {
00031c  300d              ADDS     r0,r0,#0xd
00031e  d055              BEQ      |L2.972|
;;;404                  goto aborted;
;;;405                }
;;;406              }
;;;407              recv_acked = 0;
000320  8137              STRH     r7,[r6,#8]
                  |L2.802|
;;;408            }
;;;409            if (tcp_input_delayed_close(pcb)) {
000322  4620              MOV      r0,r4
000324  f7fffffe          BL       tcp_input_delayed_close
000328  2800              CMP      r0,#0
00032a  d14f              BNE      |L2.972|
;;;410              goto aborted;
;;;411            }
;;;412    #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;413            while (recv_data != NULL) {
;;;414              struct pbuf *rest = NULL;
;;;415              pbuf_split_64k(recv_data, &rest);
;;;416    #else /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;417            if (recv_data != NULL) {
00032c  69f0              LDR      r0,[r6,#0x1c]  ; recv_data
00032e  b338              CBZ      r0,|L2.896|
;;;418    #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;419    
;;;420              LWIP_ASSERT("pcb->refused_data == NULL", pcb->refused_data == NULL);
000330  6f60              LDR      r0,[r4,#0x74]
000332  b130              CBZ      r0,|L2.834|
000334  a32d              ADR      r3,|L2.1004|
000336  f44f72d2          MOV      r2,#0x1a4
00033a  a197              ADR      r1,|L2.1432|
00033c  a03c              ADR      r0,|L2.1072|
00033e  f7fffffe          BL       __2printf
                  |L2.834|
;;;421              if (pcb->flags & TF_RXCLOSED) {
000342  7ea0              LDRB     r0,[r4,#0x1a]
000344  06c0              LSLS     r0,r0,#27
000346  d506              BPL      |L2.854|
;;;422                /* received data although already closed -> abort (send RST) to
;;;423                   notify the remote host that not all data has been processed */
;;;424                pbuf_free(recv_data);
000348  69f0              LDR      r0,[r6,#0x1c]  ; recv_data
00034a  f7fffffe          BL       pbuf_free
;;;425    #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;426                if (rest != NULL) {
;;;427                  pbuf_free(rest);
;;;428                }
;;;429    #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;430                tcp_abort(pcb);
00034e  4620              MOV      r0,r4
000350  f7fffffe          BL       tcp_abort
;;;431                goto aborted;
000354  e03a              B        |L2.972|
                  |L2.854|
;;;432              }
;;;433    
;;;434              /* Notify application that data has been received. */
;;;435              TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
000356  f8d45080          LDR      r5,[r4,#0x80]
00035a  b12d              CBZ      r5,|L2.872|
00035c  2300              MOVS     r3,#0
00035e  6920              LDR      r0,[r4,#0x10]
000360  4621              MOV      r1,r4
000362  69f2              LDR      r2,[r6,#0x1c]  ; recv_data
000364  47a8              BLX      r5
000366  e005              B        |L2.884|
                  |L2.872|
000368  2300              MOVS     r3,#0
00036a  4621              MOV      r1,r4
00036c  4618              MOV      r0,r3
00036e  69f2              LDR      r2,[r6,#0x1c]  ; recv_data
000370  f7fffffe          BL       tcp_recv_null
                  |L2.884|
;;;436              if (err == ERR_ABRT) {
000374  f1100f0d          CMN      r0,#0xd
000378  d028              BEQ      |L2.972|
;;;437    #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;438                if (rest != NULL) {
;;;439                  pbuf_free(rest);
;;;440                }
;;;441    #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;442                goto aborted;
;;;443              }
;;;444    
;;;445              /* If the upper layer can't receive this data, store it */
;;;446              if (err != ERR_OK) {
00037a  b108              CBZ      r0,|L2.896|
;;;447    #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;448                if (rest != NULL) {
;;;449                  pbuf_cat(recv_data, rest);
;;;450                }
;;;451    #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;452                pcb->refused_data = recv_data;
00037c  69f0              LDR      r0,[r6,#0x1c]  ; recv_data
00037e  6760              STR      r0,[r4,#0x74]
                  |L2.896|
;;;453                LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: keep incoming packet, because pcb is \"full\"\n"));
;;;454    #if TCP_QUEUE_OOSEQ && LWIP_WND_SCALE
;;;455                break;
;;;456              } else {
;;;457                /* Upper layer received the data, go on with the rest if > 64K */
;;;458                recv_data = rest;
;;;459    #endif /* TCP_QUEUE_OOSEQ && LWIP_WND_SCALE */
;;;460              }
;;;461            }
;;;462    
;;;463            /* If a FIN segment was received, we call the callback
;;;464               function with a NULL buffer to indicate EOF. */
;;;465            if (recv_flags & TF_GOT_FIN) {
000380  7870              LDRB     r0,[r6,#1]  ; recv_flags
000382  0680              LSLS     r0,r0,#26
000384  d51a              BPL      |L2.956|
;;;466              if (pcb->refused_data != NULL) {
000386  e000              B        |L2.906|
                  |L2.904|
000388  e114              B        |L2.1460|
                  |L2.906|
00038a  6f60              LDR      r0,[r4,#0x74]
00038c  b120              CBZ      r0,|L2.920|
;;;467                /* Delay this if we have refused data. */
;;;468                pcb->refused_data->flags |= PBUF_FLAG_TCP_FIN;
00038e  7b41              LDRB     r1,[r0,#0xd]
000390  f0410120          ORR      r1,r1,#0x20
000394  7341              STRB     r1,[r0,#0xd]
000396  e011              B        |L2.956|
                  |L2.920|
;;;469              } else {
;;;470                /* correct rcv_wnd as the application won't call tcp_recved()
;;;471                   for the FIN's seqno */
;;;472                if (pcb->rcv_wnd != TCP_WND_MAX(pcb)) {
000398  8d20              LDRH     r0,[r4,#0x28]
00039a  f5b06f06          CMP      r0,#0x860
00039e  d001              BEQ      |L2.932|
;;;473                  pcb->rcv_wnd++;
0003a0  1c40              ADDS     r0,r0,#1
0003a2  8520              STRH     r0,[r4,#0x28]
                  |L2.932|
;;;474                }
;;;475                TCP_EVENT_CLOSED(pcb, err);
0003a4  f8d45080          LDR      r5,[r4,#0x80]
0003a8  b12d              CBZ      r5,|L2.950|
0003aa  2300              MOVS     r3,#0
0003ac  461a              MOV      r2,r3
0003ae  4621              MOV      r1,r4
0003b0  6920              LDR      r0,[r4,#0x10]
0003b2  47a8              BLX      r5
0003b4  e000              B        |L2.952|
                  |L2.950|
0003b6  2000              MOVS     r0,#0
                  |L2.952|
;;;476                if (err == ERR_ABRT) {
0003b8  300d              ADDS     r0,r0,#0xd
0003ba  d007              BEQ      |L2.972|
                  |L2.956|
;;;477                  goto aborted;
;;;478                }
;;;479              }
;;;480            }
;;;481    
;;;482            tcp_input_pcb = NULL;
0003bc  6237              STR      r7,[r6,#0x20]  ; tcp_input_pcb
;;;483            if (tcp_input_delayed_close(pcb)) {
0003be  4620              MOV      r0,r4
0003c0  f7fffffe          BL       tcp_input_delayed_close
0003c4  b910              CBNZ     r0,|L2.972|
;;;484              goto aborted;
;;;485            }
;;;486            /* Try to send something out. */
;;;487            tcp_output(pcb);
0003c6  4620              MOV      r0,r4
0003c8  f7fffffe          BL       tcp_output
                  |L2.972|
;;;488    #if TCP_INPUT_DEBUG
;;;489    #if TCP_DEBUG
;;;490            tcp_debug_print_state(pcb->state);
;;;491    #endif /* TCP_DEBUG */
;;;492    #endif /* TCP_INPUT_DEBUG */
;;;493          }
;;;494        }
;;;495        /* Jump target if pcb has been aborted in a callback (by calling tcp_abort()).
;;;496           Below this line, 'pcb' may not be dereferenced! */
;;;497    aborted:
;;;498        tcp_input_pcb = NULL;
0003cc  6237              STR      r7,[r6,#0x20]  ; tcp_input_pcb
;;;499        recv_data = NULL;
0003ce  61f7              STR      r7,[r6,#0x1c]  ; recv_data
;;;500    
;;;501        /* give up our reference to inseg.p */
;;;502        if (inseg.p != NULL)
0003d0  f8d80004          LDR      r0,[r8,#4]  ; inseg
0003d4  2800              CMP      r0,#0
0003d6  d003              BEQ      |L2.992|
;;;503        {
;;;504          pbuf_free(inseg.p);
0003d8  f7fffffe          BL       pbuf_free
;;;505          inseg.p = NULL;
0003dc  f8c87004          STR      r7,[r8,#4]  ; inseg
                  |L2.992|
;;;506        }
;;;507      } else {
;;;508    
;;;509        /* If no matching PCB was found, send a TCP RST (reset) to the
;;;510           sender. */
;;;511        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
;;;512        if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
;;;513          TCP_STATS_INC(tcp.proterr);
;;;514          TCP_STATS_INC(tcp.drop);
;;;515          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
;;;516            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;517        }
;;;518        pbuf_free(p);
;;;519      }
;;;520    
;;;521      LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
;;;522      PERF_STOP("tcp_input");
;;;523      return;
;;;524    dropped:
;;;525      TCP_STATS_INC(tcp.drop);
;;;526      MIB2_STATS_INC(mib2.tcpinerrs);
;;;527      pbuf_free(p);
;;;528    }
0003e0  e8bd87fc          POP      {r2-r10,pc}
                  |L2.996|
                          DCD      ||.data||
                  |L2.1000|
                          DCD      ip_data
                  |L2.1004|
0003ec  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_in.c"
0003f0  6964646c
0003f4  65776172
0003f8  65735c54
0003fc  68697264
000400  5f506172
000404  74795c4c
000408  7749505c
00040c  7372635c
000410  636f7265
000414  5c746370
000418  5f696e2e
00041c  63      
00041d  00                DCB      0
00041e  00                DCB      0
00041f  00                DCB      0
                  |L2.1056|
000420  702d3e6e          DCB      "p->next != NULL",0
000424  65787420
000428  213d204e
00042c  554c4c00
                  |L2.1072|
000430  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000434  7274696f
000438  6e202225
00043c  73222066
000440  61696c65
000444  64206174
000448  206c696e
00044c  65202564
000450  20696e20
000454  25730a00
                  |L2.1112|
000458  702d3e6c          DCB      "p->len == 0",0
00045c  656e203d
000460  3d203000
                  |L2.1124|
000464  702d3e74          DCB      "p->tot_len == p->next->tot_len",0
000468  6f745f6c
00046c  656e203d
000470  3d20702d
000474  3e6e6578
000478  742d3e74
00047c  6f745f6c
000480  656e00  
000483  00                DCB      0
                  |L2.1156|
                          DCD      tcp_active_pcbs
                  |L2.1160|
000488  7463705f          DCB      "tcp_input: active pcb->state != CLOSED",0
00048c  696e7075
000490  743a2061
000494  63746976
000498  65207063
00049c  622d3e73
0004a0  74617465
0004a4  20213d20
0004a8  434c4f53
0004ac  454400  
0004af  00                DCB      0
                  |L2.1200|
0004b0  7463705f          DCB      "tcp_input: active pcb->state != TIME-WAIT",0
0004b4  696e7075
0004b8  743a2061
0004bc  63746976
0004c0  65207063
0004c4  622d3e73
0004c8  74617465
0004cc  20213d20
0004d0  54494d45
0004d4  2d574149
0004d8  5400    
0004da  00                DCB      0
0004db  00                DCB      0
                  |L2.1244|
0004dc  7463705f          DCB      "tcp_input: active pcb->state != LISTEN",0
0004e0  696e7075
0004e4  743a2061
0004e8  63746976
0004ec  65207063
0004f0  622d3e73
0004f4  74617465
0004f8  20213d20
0004fc  4c495354
000500  454e00  
000503  00                DCB      0
                  |L2.1284|
000504  7463705f          DCB      "tcp_input: pcb->next != pcb (before cache)",0
000508  696e7075
00050c  743a2070
000510  63622d3e
000514  6e657874
000518  20213d20
00051c  70636220
000520  28626566
000524  6f726520
000528  63616368
00052c  652900  
00052f  00                DCB      0
                  |L2.1328|
000530  7463705f          DCB      "tcp_input: pcb->next != pcb (after cache)",0
000534  696e7075
000538  743a2070
00053c  63622d3e
000540  6e657874
000544  20213d20
000548  70636220
00054c  28616674
000550  65722063
000554  61636865
000558  2900    
00055a  00                DCB      0
00055b  00                DCB      0
                  |L2.1372|
                          DCD      tcp_tw_pcbs
                  |L2.1376|
000560  7463705f          DCB      "tcp_input: TIME-WAIT pcb->state == TIME-WAIT",0
000564  696e7075
000568  743a2054
00056c  494d452d
000570  57414954
000574  20706362
000578  2d3e7374
00057c  61746520
000580  3d3d2054
000584  494d452d
000588  57414954
00058c  00      
00058d  00                DCB      0
00058e  00                DCB      0
00058f  00                DCB      0
                  |L2.1424|
                          DCD      tcp_listen_pcbs
                  |L2.1428|
                          DCD      ||.bss||
                  |L2.1432|
000598  7063622d          DCB      "pcb->refused_data == NULL",0
00059c  3e726566
0005a0  75736564
0005a4  5f646174
0005a8  61203d3d
0005ac  204e554c
0005b0  4c00    
0005b2  00                DCB      0
0005b3  00                DCB      0
                  |L2.1460|
0005b4  68f0              LDR      r0,[r6,#0xc]          ;512  ; tcphdr
0005b6  8980              LDRH     r0,[r0,#0xc]          ;512
0005b8  f7fffffe          BL       lwip_htons
0005bc  0740              LSLS     r0,r0,#29             ;512
0005be  d40c              BMI      |L2.1498|
0005c0  68f0              LDR      r0,[r6,#0xc]          ;515  ; tcphdr
0005c2  4b0b              LDR      r3,|L2.1520|
0005c4  8801              LDRH     r1,[r0,#0]            ;515
0005c6  8840              LDRH     r0,[r0,#2]            ;515
0005c8  e9cd0100          STRD     r0,r1,[sp,#0]         ;515
0005cc  8971              LDRH     r1,[r6,#0xa]          ;515  ; tcplen
0005ce  6970              LDR      r0,[r6,#0x14]         ;515  ; seqno
0005d0  1d1a              ADDS     r2,r3,#4              ;515
0005d2  4401              ADD      r1,r1,r0              ;515
0005d4  69b0              LDR      r0,[r6,#0x18]         ;515  ; ackno
0005d6  f7fffffe          BL       tcp_rst
                  |L2.1498|
0005da  4628              MOV      r0,r5                 ;518
0005dc  e8bd47fc          POP      {r2-r10,lr}           ;518
0005e0  f7ffbffe          B.W      pbuf_free
                  |L2.1508|
0005e4  4628              MOV      r0,r5                 ;527
0005e6  e8bd47fc          POP      {r2-r10,lr}           ;527
0005ea  f7ffbffe          B.W      pbuf_free
;;;529    
                          ENDP

0005ee  0000              DCW      0x0000
                  |L2.1520|
                          DCD      ip_data+0x10

                          AREA ||i.tcp_input_delayed_close||, CODE, READONLY, ALIGN=2

                  tcp_input_delayed_close PROC
;;;535    static int
;;;536    tcp_input_delayed_close(struct tcp_pcb *pcb)
000000  b510              PUSH     {r4,lr}
;;;537    {
000002  4604              MOV      r4,r0
;;;538      if (recv_flags & TF_CLOSED) {
000004  480c              LDR      r0,|L3.56|
000006  7840              LDRB     r0,[r0,#1]  ; recv_flags
000008  06c0              LSLS     r0,r0,#27
00000a  d513              BPL      |L3.52|
;;;539        /* The connection has been closed and we will deallocate the
;;;540            PCB. */
;;;541        if (!(pcb->flags & TF_RXCLOSED)) {
00000c  7ea0              LDRB     r0,[r4,#0x1a]
00000e  06c0              LSLS     r0,r0,#27
000010  d406              BMI      |L3.32|
;;;542          /* Connection closed although the application has only shut down the
;;;543              tx side: call the PCB's err callback and indicate the closure to
;;;544              ensure the application doesn't continue using the PCB. */
;;;545          TCP_EVENT_ERR(pcb->state, pcb->errf, pcb->callback_arg, ERR_CLSD);
000012  f8d4208c          LDR      r2,[r4,#0x8c]
000016  b11a              CBZ      r2,|L3.32|
000018  f06f010e          MVN      r1,#0xe
00001c  6920              LDR      r0,[r4,#0x10]
00001e  4790              BLX      r2
                  |L3.32|
;;;546        }
;;;547        tcp_pcb_remove(&tcp_active_pcbs, pcb);
000020  4621              MOV      r1,r4
000022  4806              LDR      r0,|L3.60|
000024  f7fffffe          BL       tcp_pcb_remove
;;;548        memp_free(MEMP_TCP_PCB, pcb);
000028  4621              MOV      r1,r4
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       memp_free
;;;549        return 1;
000030  2001              MOVS     r0,#1
;;;550      }
;;;551      return 0;
;;;552    }
000032  bd10              POP      {r4,pc}
                  |L3.52|
000034  2000              MOVS     r0,#0                 ;551
000036  bd10              POP      {r4,pc}
;;;553    
                          ENDP

                  |L3.56|
                          DCD      ||.data||
                  |L3.60|
                          DCD      tcp_active_pcbs

                          AREA ||i.tcp_listen_input||, CODE, READONLY, ALIGN=2

                  tcp_listen_input PROC
;;;563    static void
;;;564    tcp_listen_input(struct tcp_pcb_listen *pcb)
000000  b57c              PUSH     {r2-r6,lr}
;;;565    {
000002  4605              MOV      r5,r0
;;;566      struct tcp_pcb *npcb;
;;;567      u32_t iss;
;;;568      err_t rc;
;;;569    
;;;570      if (flags & TCP_RST) {
000004  4e37              LDR      r6,|L4.228|
000006  7830              LDRB     r0,[r6,#0]  ; flags
000008  0741              LSLS     r1,r0,#29
00000a  d40e              BMI      |L4.42|
;;;571        /* An incoming RST should be ignored. Return. */
;;;572        return;
;;;573      }
;;;574    
;;;575      /* In the LISTEN state, we check for incoming SYN segments,
;;;576         creates a new PCB, and responds with a SYN|ACK. */
;;;577      if (flags & TCP_ACK) {
00000c  06c1              LSLS     r1,r0,#27
00000e  d50d              BPL      |L4.44|
;;;578        /* For incoming segments with the ACK flag set, respond with a
;;;579           RST. */
;;;580        LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
;;;581        tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
000010  68f0              LDR      r0,[r6,#0xc]  ; tcphdr
000012  4b35              LDR      r3,|L4.232|
000014  8801              LDRH     r1,[r0,#0]
000016  8840              LDRH     r0,[r0,#2]
000018  e9cd0100          STRD     r0,r1,[sp,#0]
00001c  8971              LDRH     r1,[r6,#0xa]  ; tcplen
00001e  6970              LDR      r0,[r6,#0x14]  ; seqno
000020  1d1a              ADDS     r2,r3,#4
000022  4401              ADD      r1,r1,r0
000024  69b0              LDR      r0,[r6,#0x18]  ; ackno
000026  f7fffffe          BL       tcp_rst
                  |L4.42|
;;;582          ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;583      } else if (flags & TCP_SYN) {
;;;584        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection request %"U16_F" -> %"U16_F".\n", tcphdr->src, tcphdr->dest));
;;;585    #if TCP_LISTEN_BACKLOG
;;;586        if (pcb->accepts_pending >= pcb->backlog) {
;;;587          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: listen backlog exceeded for port %"U16_F"\n", tcphdr->dest));
;;;588          return;
;;;589        }
;;;590    #endif /* TCP_LISTEN_BACKLOG */
;;;591        npcb = tcp_alloc(pcb->prio);
;;;592        /* If a new PCB could not be created (probably due to lack of memory),
;;;593           we don't do anything, but rely on the sender will retransmit the
;;;594           SYN at a time when we have more memory available. */
;;;595        if (npcb == NULL) {
;;;596          err_t err;
;;;597          LWIP_DEBUGF(TCP_DEBUG, ("tcp_listen_input: could not allocate PCB\n"));
;;;598          TCP_STATS_INC(tcp.memerr);
;;;599          TCP_EVENT_ACCEPT(pcb, NULL, pcb->callback_arg, ERR_MEM, err);
;;;600          LWIP_UNUSED_ARG(err); /* err not useful here */
;;;601          return;
;;;602        }
;;;603    #if TCP_LISTEN_BACKLOG
;;;604        pcb->accepts_pending++;
;;;605        npcb->flags |= TF_BACKLOGPEND;
;;;606    #endif /* TCP_LISTEN_BACKLOG */
;;;607        /* Set up the new PCB. */
;;;608        ip_addr_copy(npcb->local_ip, *ip_current_dest_addr());
;;;609        ip_addr_copy(npcb->remote_ip, *ip_current_src_addr());
;;;610        npcb->local_port = pcb->local_port;
;;;611        npcb->remote_port = tcphdr->src;
;;;612        npcb->state = SYN_RCVD;
;;;613        npcb->rcv_nxt = seqno + 1;
;;;614        npcb->rcv_ann_right_edge = npcb->rcv_nxt;
;;;615        iss = tcp_next_iss(npcb);
;;;616        npcb->snd_wl2 = iss;
;;;617        npcb->snd_nxt = iss;
;;;618        npcb->lastack = iss;
;;;619        npcb->snd_lbb = iss;
;;;620        npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
;;;621        npcb->callback_arg = pcb->callback_arg;
;;;622    #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
;;;623        npcb->listener = pcb;
;;;624    #endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
;;;625        /* inherit socket options */
;;;626        npcb->so_options = pcb->so_options & SOF_INHERITED;
;;;627        /* Register the new PCB so that we can begin receiving segments
;;;628           for it. */
;;;629        TCP_REG_ACTIVE(npcb);
;;;630    
;;;631        /* Parse any options in the SYN. */
;;;632        tcp_parseopt(npcb);
;;;633        npcb->snd_wnd = tcphdr->wnd;
;;;634        npcb->snd_wnd_max = npcb->snd_wnd;
;;;635    
;;;636    #if TCP_CALCULATE_EFF_SEND_MSS
;;;637        npcb->mss = tcp_eff_send_mss(npcb->mss, &npcb->local_ip, &npcb->remote_ip);
;;;638    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;639    
;;;640        MIB2_STATS_INC(mib2.tcppassiveopens);
;;;641    
;;;642        /* Send a SYN|ACK together with the MSS option. */
;;;643        rc = tcp_enqueue_flags(npcb, TCP_SYN | TCP_ACK);
;;;644        if (rc != ERR_OK) {
;;;645          tcp_abandon(npcb, 0);
;;;646          return;
;;;647        }
;;;648        tcp_output(npcb);
;;;649      }
;;;650      return;
;;;651    }
00002a  bd7c              POP      {r2-r6,pc}
                  |L4.44|
00002c  0780              LSLS     r0,r0,#30             ;583
00002e  d5fc              BPL      |L4.42|
000030  7d68              LDRB     r0,[r5,#0x15]         ;591
000032  f7fffffe          BL       tcp_alloc
000036  4604              MOV      r4,r0                 ;591
000038  0020              MOVS     r0,r4                 ;595
00003a  d043              BEQ      |L4.196|
00003c  482a              LDR      r0,|L4.232|
00003e  3810              SUBS     r0,r0,#0x10           ;608
000040  6941              LDR      r1,[r0,#0x14]         ;608  ; ip_data
000042  6021              STR      r1,[r4,#0]            ;608
000044  6900              LDR      r0,[r0,#0x10]         ;609  ; ip_data
000046  6060              STR      r0,[r4,#4]            ;609
000048  8ae8              LDRH     r0,[r5,#0x16]         ;610
00004a  82e0              STRH     r0,[r4,#0x16]         ;610
00004c  68f0              LDR      r0,[r6,#0xc]          ;611  ; tcphdr
00004e  8800              LDRH     r0,[r0,#0]            ;611
000050  8320              STRH     r0,[r4,#0x18]         ;611
000052  2003              MOVS     r0,#3                 ;612
000054  7520              STRB     r0,[r4,#0x14]         ;612
000056  6970              LDR      r0,[r6,#0x14]         ;613  ; seqno
000058  1c40              ADDS     r0,r0,#1              ;613
00005a  6260              STR      r0,[r4,#0x24]         ;613
00005c  62e0              STR      r0,[r4,#0x2c]         ;614
00005e  4620              MOV      r0,r4                 ;615
000060  f7fffffe          BL       tcp_next_iss
000064  6560              STR      r0,[r4,#0x54]         ;616
000066  64e0              STR      r0,[r4,#0x4c]         ;617
000068  6460              STR      r0,[r4,#0x44]         ;618
00006a  65a0              STR      r0,[r4,#0x58]         ;619
00006c  6970              LDR      r0,[r6,#0x14]         ;620  ; seqno
00006e  1e40              SUBS     r0,r0,#1              ;620
000070  6520              STR      r0,[r4,#0x50]         ;620
000072  6928              LDR      r0,[r5,#0x10]         ;621
000074  6120              STR      r0,[r4,#0x10]         ;621
000076  67a5              STR      r5,[r4,#0x78]         ;623
000078  7a28              LDRB     r0,[r5,#8]            ;626
00007a  f000000c          AND      r0,r0,#0xc            ;626
00007e  7220              STRB     r0,[r4,#8]            ;626
000080  481a              LDR      r0,|L4.236|
000082  6801              LDR      r1,[r0,#0]            ;629  ; tcp_active_pcbs
000084  60e1              STR      r1,[r4,#0xc]          ;629
000086  6004              STR      r4,[r0,#0]            ;629  ; tcp_active_pcbs
000088  f7fffffe          BL       tcp_timer_needed
00008c  4918              LDR      r1,|L4.240|
00008e  2001              MOVS     r0,#1                 ;629
000090  7008              STRB     r0,[r1,#0]            ;629
000092  4620              MOV      r0,r4                 ;632
000094  f7fffffe          BL       tcp_parseopt
000098  68f0              LDR      r0,[r6,#0xc]          ;633  ; tcphdr
00009a  89c0              LDRH     r0,[r0,#0xe]          ;633
00009c  f8a4005c          STRH     r0,[r4,#0x5c]         ;633
0000a0  f8a4005e          STRH     r0,[r4,#0x5e]         ;634
0000a4  8e60              LDRH     r0,[r4,#0x32]         ;637
0000a6  1d21              ADDS     r1,r4,#4              ;637
0000a8  f7fffffe          BL       tcp_eff_send_mss_impl
0000ac  8660              STRH     r0,[r4,#0x32]         ;637
0000ae  2112              MOVS     r1,#0x12              ;643
0000b0  4620              MOV      r0,r4                 ;643
0000b2  f7fffffe          BL       tcp_enqueue_flags
0000b6  b180              CBZ      r0,|L4.218|
0000b8  4620              MOV      r0,r4                 ;645
0000ba  e8bd407c          POP      {r2-r6,lr}            ;645
0000be  2100              MOVS     r1,#0                 ;645
0000c0  f7ffbffe          B.W      tcp_abandon
                  |L4.196|
0000c4  69ab              LDR      r3,[r5,#0x18]         ;599
0000c6  2b00              CMP      r3,#0                 ;599
0000c8  d0af              BEQ      |L4.42|
0000ca  6928              LDR      r0,[r5,#0x10]         ;599
0000cc  b002              ADD      sp,sp,#8              ;599
0000ce  f04f32ff          MOV      r2,#0xffffffff        ;599
0000d2  e8bd4070          POP      {r4-r6,lr}            ;599
0000d6  2100              MOVS     r1,#0                 ;599
0000d8  4718              BX       r3                    ;599
                  |L4.218|
0000da  4620              MOV      r0,r4                 ;648
0000dc  e8bd407c          POP      {r2-r6,lr}            ;648
0000e0  f7ffbffe          B.W      tcp_output
;;;652    
                          ENDP

                  |L4.228|
                          DCD      ||.data||
                  |L4.232|
                          DCD      ip_data+0x10
                  |L4.236|
                          DCD      tcp_active_pcbs
                  |L4.240|
                          DCD      tcp_active_pcbs_changed

                          AREA ||i.tcp_oos_insert_segment||, CODE, READONLY, ALIGN=2

                  tcp_oos_insert_segment PROC
;;;969    static void
;;;970    tcp_oos_insert_segment(struct tcp_seg *cseg, struct tcp_seg *next)
000000  b570              PUSH     {r4-r6,lr}
;;;971    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;972      struct tcp_seg *old_seg;
;;;973    
;;;974      if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
000006  68e8              LDR      r0,[r5,#0xc]
000008  8980              LDRH     r0,[r0,#0xc]
00000a  f7fffffe          BL       lwip_htons
00000e  07c0              LSLS     r0,r0,#31
000010  d004              BEQ      |L5.28|
;;;975        /* received segment overlaps all following segments */
;;;976        tcp_segs_free(next);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       tcp_segs_free
;;;977        next = NULL;
000018  2400              MOVS     r4,#0
00001a  e02b              B        |L5.116|
                  |L5.28|
;;;978      } else {
;;;979        /* delete some following segments
;;;980           oos queue may have segments with FIN flag */
;;;981        while (next &&
;;;982               TCP_SEQ_GEQ((seqno + cseg->len),
00001c  4e16              LDR      r6,|L5.120|
00001e  e010              B        |L5.66|
                  |L5.32|
;;;983                          (next->tcphdr->seqno + next->len))) {
;;;984          /* cseg with FIN already processed */
;;;985          if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
000020  8980              LDRH     r0,[r0,#0xc]
000022  f7fffffe          BL       lwip_htons
000026  07c0              LSLS     r0,r0,#31
000028  d007              BEQ      |L5.58|
;;;986            TCPH_SET_FLAG(cseg->tcphdr, TCP_FIN);
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       lwip_htons
000030  4601              MOV      r1,r0
000032  68e8              LDR      r0,[r5,#0xc]
000034  8982              LDRH     r2,[r0,#0xc]
000036  4311              ORRS     r1,r1,r2
000038  8181              STRH     r1,[r0,#0xc]
                  |L5.58|
;;;987          }
;;;988          old_seg = next;
;;;989          next = next->next;
00003a  4620              MOV      r0,r4
00003c  6824              LDR      r4,[r4,#0]
;;;990          tcp_seg_free(old_seg);
00003e  f7fffffe          BL       tcp_seg_free
                  |L5.66|
000042  b144              CBZ      r4,|L5.86|
000044  68e0              LDR      r0,[r4,#0xc]          ;982
000046  8922              LDRH     r2,[r4,#8]            ;982
000048  6973              LDR      r3,[r6,#0x14]         ;982  ; seqno
00004a  6841              LDR      r1,[r0,#4]            ;982
00004c  4411              ADD      r1,r1,r2              ;982
00004e  892a              LDRH     r2,[r5,#8]            ;982
000050  441a              ADD      r2,r2,r3              ;982
000052  1a51              SUBS     r1,r2,r1              ;982
000054  d5e4              BPL      |L5.32|
                  |L5.86|
;;;991        }
;;;992        if (next &&
000056  b16c              CBZ      r4,|L5.116|
;;;993            TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
000058  8928              LDRH     r0,[r5,#8]
00005a  6971              LDR      r1,[r6,#0x14]  ; seqno
00005c  1842              ADDS     r2,r0,r1
00005e  68e0              LDR      r0,[r4,#0xc]
000060  6840              LDR      r0,[r0,#4]
000062  1a12              SUBS     r2,r2,r0
000064  2a00              CMP      r2,#0
000066  dd05              BLE      |L5.116|
;;;994          /* We need to trim the incoming segment. */
;;;995          cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
000068  1a40              SUBS     r0,r0,r1
00006a  b281              UXTH     r1,r0
00006c  8129              STRH     r1,[r5,#8]
;;;996          pbuf_realloc(cseg->p, cseg->len);
00006e  6868              LDR      r0,[r5,#4]
000070  f7fffffe          BL       pbuf_realloc
                  |L5.116|
;;;997        }
;;;998      }
;;;999      cseg->next = next;
000074  602c              STR      r4,[r5,#0]
;;;1000   }
000076  bd70              POP      {r4-r6,pc}
;;;1001   #endif /* TCP_QUEUE_OOSEQ */
                          ENDP

                  |L5.120|
                          DCD      ||.data||

                          AREA ||i.tcp_parseopt||, CODE, READONLY, ALIGN=2

                  tcp_parseopt PROC
;;;1728   static void
;;;1729   tcp_parseopt(struct tcp_pcb *pcb)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1730   {
000004  4605              MOV      r5,r0
;;;1731     u8_t data;
;;;1732     u16_t mss;
;;;1733   #if LWIP_TCP_TIMESTAMPS
;;;1734     u32_t tsval;
;;;1735   #endif
;;;1736   
;;;1737     /* Parse the TCP MSS option, if present. */
;;;1738     if (tcphdr_optlen != 0) {
000006  4c1a              LDR      r4,|L6.112|
000008  8860              LDRH     r0,[r4,#2]  ; tcphdr_optlen
00000a  2800              CMP      r0,#0
00000c  d018              BEQ      |L6.64|
;;;1739       for (tcp_optidx = 0; tcp_optidx < tcphdr_optlen; ) {
00000e  2000              MOVS     r0,#0
000010  80e0              STRH     r0,[r4,#6]
;;;1740         u8_t opt = tcp_getoptbyte();
;;;1741         switch (opt) {
;;;1742         case LWIP_TCP_OPT_EOL:
;;;1743           /* End of options. */
;;;1744           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: EOL\n"));
;;;1745           return;
;;;1746         case LWIP_TCP_OPT_NOP:
;;;1747           /* NOP option. */
;;;1748           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: NOP\n"));
;;;1749           break;
;;;1750         case LWIP_TCP_OPT_MSS:
;;;1751           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: MSS\n"));
;;;1752           if (tcp_getoptbyte() != LWIP_TCP_OPT_LEN_MSS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_MSS) > tcphdr_optlen) {
;;;1753             /* Bad length */
;;;1754             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1755             return;
;;;1756           }
;;;1757           /* An MSS option with the right option length. */
;;;1758           mss = (tcp_getoptbyte() << 8);
;;;1759           mss |= tcp_getoptbyte();
;;;1760           /* Limit the mss to the configured TCP_MSS and prevent division by zero */
;;;1761           pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
000012  f44f7606          MOV      r6,#0x218
000016  e00f              B        |L6.56|
                  |L6.24|
000018  f7fffffe          BL       tcp_getoptbyte
00001c  2800              CMP      r0,#0                 ;1741
00001e  d00f              BEQ      |L6.64|
000020  2801              CMP      r0,#1                 ;1741
000022  d009              BEQ      |L6.56|
000024  2802              CMP      r0,#2                 ;1741
000026  d00d              BEQ      |L6.68|
;;;1762           break;
;;;1763   #if LWIP_WND_SCALE
;;;1764         case LWIP_TCP_OPT_WS:
;;;1765           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: WND_SCALE\n"));
;;;1766           if (tcp_getoptbyte() != LWIP_TCP_OPT_LEN_WS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_WS) > tcphdr_optlen) {
;;;1767             /* Bad length */
;;;1768             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1769             return;
;;;1770           }
;;;1771           /* An WND_SCALE option with the right option length. */
;;;1772           data = tcp_getoptbyte();
;;;1773           /* If syn was received with wnd scale option,
;;;1774              activate wnd scale opt, but only if this is not a retransmission */
;;;1775           if ((flags & TCP_SYN) && !(pcb->flags & TF_WND_SCALE)) {
;;;1776             pcb->snd_scale = data;
;;;1777             if (pcb->snd_scale > 14U) {
;;;1778               pcb->snd_scale = 14U;
;;;1779             }
;;;1780             pcb->rcv_scale = TCP_RCV_SCALE;
;;;1781             pcb->flags |= TF_WND_SCALE;
;;;1782             /* window scaling is enabled, we can use the full receive window */
;;;1783             LWIP_ASSERT("window not at default value", pcb->rcv_wnd == TCPWND_MIN16(TCP_WND));
;;;1784             LWIP_ASSERT("window not at default value", pcb->rcv_ann_wnd == TCPWND_MIN16(TCP_WND));
;;;1785             pcb->rcv_wnd = pcb->rcv_ann_wnd = TCP_WND;
;;;1786           }
;;;1787           break;
;;;1788   #endif
;;;1789   #if LWIP_TCP_TIMESTAMPS
;;;1790         case LWIP_TCP_OPT_TS:
;;;1791           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: TS\n"));
;;;1792           if (tcp_getoptbyte() != LWIP_TCP_OPT_LEN_TS || (tcp_optidx - 2 + LWIP_TCP_OPT_LEN_TS) > tcphdr_optlen) {
;;;1793             /* Bad length */
;;;1794             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1795             return;
;;;1796           }
;;;1797           /* TCP timestamp option with valid length */
;;;1798           tsval = tcp_getoptbyte();
;;;1799           tsval |= (tcp_getoptbyte() << 8);
;;;1800           tsval |= (tcp_getoptbyte() << 16);
;;;1801           tsval |= (tcp_getoptbyte() << 24);
;;;1802           if (flags & TCP_SYN) {
;;;1803             pcb->ts_recent = lwip_ntohl(tsval);
;;;1804             /* Enable sending timestamps in every segment now that we know
;;;1805                the remote host supports it. */
;;;1806             pcb->flags |= TF_TIMESTAMP;
;;;1807           } else if (TCP_SEQ_BETWEEN(pcb->ts_lastacksent, seqno, seqno+tcplen)) {
;;;1808             pcb->ts_recent = lwip_ntohl(tsval);
;;;1809           }
;;;1810           /* Advance to next option (6 bytes already read) */
;;;1811           tcp_optidx += LWIP_TCP_OPT_LEN_TS - 6;
;;;1812           break;
;;;1813   #endif
;;;1814         default:
;;;1815           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: other\n"));
;;;1816           data = tcp_getoptbyte();
000028  f7fffffe          BL       tcp_getoptbyte
;;;1817           if (data < 2) {
00002c  2802              CMP      r0,#2
00002e  d307              BCC      |L6.64|
;;;1818             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_parseopt: bad length\n"));
;;;1819             /* If the length field is zero, the options are malformed
;;;1820                and we don't process them further. */
;;;1821             return;
;;;1822           }
;;;1823           /* All other options have a length field, so that we easily
;;;1824              can skip past them. */
;;;1825           tcp_optidx += data - 2;
000030  88e1              LDRH     r1,[r4,#6]  ; tcp_optidx
000032  4408              ADD      r0,r0,r1
000034  1e80              SUBS     r0,r0,#2
000036  80e0              STRH     r0,[r4,#6]
                  |L6.56|
000038  88e0              LDRH     r0,[r4,#6]            ;1739  ; tcp_optidx
00003a  8861              LDRH     r1,[r4,#2]            ;1739  ; tcphdr_optlen
00003c  4288              CMP      r0,r1                 ;1739
00003e  d3eb              BCC      |L6.24|
                  |L6.64|
;;;1826         }
;;;1827       }
;;;1828     }
;;;1829   }
000040  e8bd81f0          POP      {r4-r8,pc}
                  |L6.68|
000044  f7fffffe          BL       tcp_getoptbyte
000048  2804              CMP      r0,#4                 ;1752
00004a  d1f9              BNE      |L6.64|
00004c  88e0              LDRH     r0,[r4,#6]            ;1752  ; tcp_optidx
00004e  8861              LDRH     r1,[r4,#2]            ;1752  ; tcphdr_optlen
000050  1c80              ADDS     r0,r0,#2              ;1752
000052  4288              CMP      r0,r1                 ;1752
000054  d8f4              BHI      |L6.64|
000056  f7fffffe          BL       tcp_getoptbyte
00005a  0207              LSLS     r7,r0,#8              ;1758
00005c  f7fffffe          BL       tcp_getoptbyte
000060  4338              ORRS     r0,r0,r7              ;1759
000062  42b0              CMP      r0,r6                 ;1761
000064  d800              BHI      |L6.104|
000066  b900              CBNZ     r0,|L6.106|
                  |L6.104|
000068  4630              MOV      r0,r6                 ;1761
                  |L6.106|
00006a  8668              STRH     r0,[r5,#0x32]         ;1761
00006c  e7e4              B        |L6.56|
;;;1830   
                          ENDP

00006e  0000              DCW      0x0000
                  |L6.112|
                          DCD      ||.data||

                          AREA ||i.tcp_process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_process PROC
;;;708    static err_t
;;;709    tcp_process(struct tcp_pcb *pcb)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;710    {
000004  4604              MOV      r4,r0
;;;711      struct tcp_seg *rseg;
;;;712      u8_t acceptable = 0;
000006  2000              MOVS     r0,#0
;;;713      err_t err;
;;;714    
;;;715      err = ERR_OK;
000008  2100              MOVS     r1,#0
00000a  9102              STR      r1,[sp,#8]
;;;716    
;;;717      /* Process incoming RST segments. */
;;;718      if (flags & TCP_RST) {
00000c  f8dfb3dc          LDR      r11,|L7.1004|
000010  f89b1000          LDRB     r1,[r11,#0]  ; flags
000014  074a              LSLS     r2,r1,#29
000016  d535              BPL      |L7.132|
;;;719        /* First, determine if the reset is acceptable. */
;;;720        if (pcb->state == SYN_SENT) {
000018  7d23              LDRB     r3,[r4,#0x14]
00001a  2b02              CMP      r3,#2
00001c  d006              BEQ      |L7.44|
;;;721          /* "In the SYN-SENT state (a RST received in response to an initial SYN),
;;;722              the RST is acceptable if the ACK field acknowledges the SYN." */
;;;723          if (ackno == pcb->snd_nxt) {
;;;724            acceptable = 1;
;;;725          }
;;;726        } else {
;;;727          /* "In all states except SYN-SENT, all reset (RST) segments are validated
;;;728              by checking their SEQ-fields." */
;;;729          if (seqno == pcb->rcv_nxt) {
00001e  6a61              LDR      r1,[r4,#0x24]
000020  f8db2014          LDR      r2,[r11,#0x14]  ; seqno
000024  4291              CMP      r1,r2
000026  d108              BNE      |L7.58|
;;;730            acceptable = 1;
000028  2001              MOVS     r0,#1
00002a  e011              B        |L7.80|
                  |L7.44|
00002c  6ce1              LDR      r1,[r4,#0x4c]         ;723
00002e  f8db2018          LDR      r2,[r11,#0x18]        ;723  ; ackno
000032  4291              CMP      r1,r2                 ;723
000034  d10c              BNE      |L7.80|
000036  2001              MOVS     r0,#1                 ;724
000038  e00a              B        |L7.80|
                  |L7.58|
;;;731          } else  if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
00003a  1a55              SUBS     r5,r2,r1
00003c  d408              BMI      |L7.80|
00003e  8d25              LDRH     r5,[r4,#0x28]
000040  4429              ADD      r1,r1,r5
000042  1a51              SUBS     r1,r2,r1
000044  2900              CMP      r1,#0
000046  dc03              BGT      |L7.80|
;;;732                                      pcb->rcv_nxt + pcb->rcv_wnd)) {
;;;733            /* If the sequence number is inside the window, we only send an ACK
;;;734               and wait for a re-send with matching sequence number.
;;;735               This violates RFC 793, but is required to protection against
;;;736               CVE-2004-0230 (RST spoofing attack). */
;;;737            tcp_ack_now(pcb);
000048  7ea1              LDRB     r1,[r4,#0x1a]
00004a  f0410102          ORR      r1,r1,#2
00004e  76a1              STRB     r1,[r4,#0x1a]
                  |L7.80|
;;;738          }
;;;739        }
;;;740    
;;;741        if (acceptable) {
000050  2800              CMP      r0,#0
000052  d015              BEQ      |L7.128|
;;;742          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
;;;743          LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
000054  b933              CBNZ     r3,|L7.100|
000056  a3e6              ADR      r3,|L7.1008|
000058  f24022e7          MOV      r2,#0x2e7
00005c  a1f1              ADR      r1,|L7.1060|
00005e  a0f9              ADR      r0,|L7.1092|
000060  f7fffffe          BL       __2printf
                  |L7.100|
;;;744          recv_flags |= TF_RESET;
000064  f89b0001          LDRB     r0,[r11,#1]  ; recv_flags
000068  f0400008          ORR      r0,r0,#8
00006c  f88b0001          STRB     r0,[r11,#1]
;;;745          pcb->flags &= ~TF_ACK_DELAY;
000070  7ea0              LDRB     r0,[r4,#0x1a]
000072  f0200001          BIC      r0,r0,#1
000076  76a0              STRB     r0,[r4,#0x1a]
;;;746          return ERR_RST;
000078  f06f000d          MVN      r0,#0xd
                  |L7.124|
;;;747        } else {
;;;748          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;749           seqno, pcb->rcv_nxt));
;;;750          LWIP_DEBUGF(TCP_DEBUG, ("tcp_process: unacceptable reset seqno %"U32_F" rcv_nxt %"U32_F"\n",
;;;751           seqno, pcb->rcv_nxt));
;;;752          return ERR_OK;
;;;753        }
;;;754      }
;;;755    
;;;756      if ((flags & TCP_SYN) && (pcb->state != SYN_SENT && pcb->state != SYN_RCVD)) {
;;;757        /* Cope with new connection attempt after remote end crashed */
;;;758        tcp_ack_now(pcb);
;;;759        return ERR_OK;
;;;760      }
;;;761    
;;;762      if ((pcb->flags & TF_RXCLOSED) == 0) {
;;;763        /* Update the PCB (in)activity timer unless rx is closed (see tcp_shutdown) */
;;;764        pcb->tmr = tcp_ticks;
;;;765      }
;;;766      pcb->keep_cnt_sent = 0;
;;;767    
;;;768      tcp_parseopt(pcb);
;;;769    
;;;770      /* Do different things depending on the TCP state. */
;;;771      switch (pcb->state) {
;;;772      case SYN_SENT:
;;;773        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
;;;774         pcb->snd_nxt, lwip_ntohl(pcb->unacked->tcphdr->seqno)));
;;;775        /* received SYN ACK with expected sequence number? */
;;;776        if ((flags & TCP_ACK) && (flags & TCP_SYN)
;;;777            && (ackno == pcb->lastack + 1)) {
;;;778          pcb->rcv_nxt = seqno + 1;
;;;779          pcb->rcv_ann_right_edge = pcb->rcv_nxt;
;;;780          pcb->lastack = ackno;
;;;781          pcb->snd_wnd = tcphdr->wnd;
;;;782          pcb->snd_wnd_max = pcb->snd_wnd;
;;;783          pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
;;;784          pcb->state = ESTABLISHED;
;;;785    
;;;786    #if TCP_CALCULATE_EFF_SEND_MSS
;;;787          pcb->mss = tcp_eff_send_mss(pcb->mss, &pcb->local_ip, &pcb->remote_ip);
;;;788    #endif /* TCP_CALCULATE_EFF_SEND_MSS */
;;;789    
;;;790          pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
;;;791          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SENT): cwnd %"TCPWNDSIZE_F
;;;792                                       " ssthresh %"TCPWNDSIZE_F"\n",
;;;793                                       pcb->cwnd, pcb->ssthresh));
;;;794          LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
;;;795          --pcb->snd_queuelen;
;;;796          LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"TCPWNDSIZE_F"\n", (tcpwnd_size_t)pcb->snd_queuelen));
;;;797          rseg = pcb->unacked;
;;;798          if (rseg == NULL) {
;;;799            /* might happen if tcp_output fails in tcp_rexmit_rto()
;;;800               in which case the segment is on the unsent list */
;;;801            rseg = pcb->unsent;
;;;802            LWIP_ASSERT("no segment to free", rseg != NULL);
;;;803            pcb->unsent = rseg->next;
;;;804          } else {
;;;805            pcb->unacked = rseg->next;
;;;806          }
;;;807          tcp_seg_free(rseg);
;;;808    
;;;809          /* If there's nothing left to acknowledge, stop the retransmit
;;;810             timer, otherwise reset it to start again */
;;;811          if (pcb->unacked == NULL) {
;;;812            pcb->rtime = -1;
;;;813          } else {
;;;814            pcb->rtime = 0;
;;;815            pcb->nrtx = 0;
;;;816          }
;;;817    
;;;818          /* Call the user specified function to call when successfully
;;;819           * connected. */
;;;820          TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
;;;821          if (err == ERR_ABRT) {
;;;822            return ERR_ABRT;
;;;823          }
;;;824          tcp_ack_now(pcb);
;;;825        }
;;;826        /* received ACK? possibly a half-open connection */
;;;827        else if (flags & TCP_ACK) {
;;;828          /* send a RST to bring the other side in a non-synchronized state. */
;;;829          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
;;;830            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;831          /* Resend SYN immediately (don't wait for rto timeout) to establish
;;;832            connection faster, but do not send more SYNs than we otherwise would
;;;833            have, or we might get caught in a loop on loopback interfaces. */
;;;834          if (pcb->nrtx < TCP_SYNMAXRTX) {
;;;835            pcb->rtime = 0;
;;;836            tcp_rexmit_rto(pcb);
;;;837          }
;;;838        }
;;;839        break;
;;;840      case SYN_RCVD:
;;;841        if (flags & TCP_ACK) {
;;;842          /* expected ACK number? */
;;;843          if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
;;;844            pcb->state = ESTABLISHED;
;;;845            LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;846    #if LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG
;;;847    #if LWIP_CALLBACK_API
;;;848            LWIP_ASSERT("pcb->listener->accept != NULL",
;;;849              (pcb->listener == NULL) || (pcb->listener->accept != NULL));
;;;850    #endif
;;;851            if (pcb->listener == NULL) {
;;;852              /* listen pcb might be closed by now */
;;;853              err = ERR_VAL;
;;;854            } else
;;;855    #endif /* LWIP_CALLBACK_API || TCP_LISTEN_BACKLOG */
;;;856            {
;;;857              tcp_backlog_accepted(pcb);
;;;858              /* Call the accept function. */
;;;859              TCP_EVENT_ACCEPT(pcb->listener, pcb, pcb->callback_arg, ERR_OK, err);
;;;860            }
;;;861            if (err != ERR_OK) {
;;;862              /* If the accept function returns with an error, we abort
;;;863               * the connection. */
;;;864              /* Already aborted? */
;;;865              if (err != ERR_ABRT) {
;;;866                tcp_abort(pcb);
;;;867              }
;;;868              return ERR_ABRT;
;;;869            }
;;;870            /* If there was any data contained within this ACK,
;;;871             * we'd better pass it on to the application as well. */
;;;872            tcp_receive(pcb);
;;;873    
;;;874            /* Prevent ACK for SYN to generate a sent event */
;;;875            if (recv_acked != 0) {
;;;876              recv_acked--;
;;;877            }
;;;878    
;;;879            pcb->cwnd = LWIP_TCP_CALC_INITIAL_CWND(pcb->mss);
;;;880            LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_process (SYN_RCVD): cwnd %"TCPWNDSIZE_F
;;;881                                         " ssthresh %"TCPWNDSIZE_F"\n",
;;;882                                         pcb->cwnd, pcb->ssthresh));
;;;883    
;;;884            if (recv_flags & TF_GOT_FIN) {
;;;885              tcp_ack_now(pcb);
;;;886              pcb->state = CLOSE_WAIT;
;;;887            }
;;;888          } else {
;;;889            /* incorrect ACK number, send RST */
;;;890            tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
;;;891              ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;892          }
;;;893        } else if ((flags & TCP_SYN) && (seqno == pcb->rcv_nxt - 1)) {
;;;894          /* Looks like another copy of the SYN - retransmit our SYN-ACK */
;;;895          tcp_rexmit(pcb);
;;;896        }
;;;897        break;
;;;898      case CLOSE_WAIT:
;;;899        /* FALLTHROUGH */
;;;900      case ESTABLISHED:
;;;901        tcp_receive(pcb);
;;;902        if (recv_flags & TF_GOT_FIN) { /* passive close */
;;;903          tcp_ack_now(pcb);
;;;904          pcb->state = CLOSE_WAIT;
;;;905        }
;;;906        break;
;;;907      case FIN_WAIT_1:
;;;908        tcp_receive(pcb);
;;;909        if (recv_flags & TF_GOT_FIN) {
;;;910          if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
;;;911              pcb->unsent == NULL) {
;;;912            LWIP_DEBUGF(TCP_DEBUG,
;;;913              ("TCP connection closed: FIN_WAIT_1 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;914            tcp_ack_now(pcb);
;;;915            tcp_pcb_purge(pcb);
;;;916            TCP_RMV_ACTIVE(pcb);
;;;917            pcb->state = TIME_WAIT;
;;;918            TCP_REG(&tcp_tw_pcbs, pcb);
;;;919          } else {
;;;920            tcp_ack_now(pcb);
;;;921            pcb->state = CLOSING;
;;;922          }
;;;923        } else if ((flags & TCP_ACK) && (ackno == pcb->snd_nxt) &&
;;;924                   pcb->unsent == NULL) {
;;;925          pcb->state = FIN_WAIT_2;
;;;926        }
;;;927        break;
;;;928      case FIN_WAIT_2:
;;;929        tcp_receive(pcb);
;;;930        if (recv_flags & TF_GOT_FIN) {
;;;931          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: FIN_WAIT_2 %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;932          tcp_ack_now(pcb);
;;;933          tcp_pcb_purge(pcb);
;;;934          TCP_RMV_ACTIVE(pcb);
;;;935          pcb->state = TIME_WAIT;
;;;936          TCP_REG(&tcp_tw_pcbs, pcb);
;;;937        }
;;;938        break;
;;;939      case CLOSING:
;;;940        tcp_receive(pcb);
;;;941        if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
;;;942          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: CLOSING %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;943          tcp_pcb_purge(pcb);
;;;944          TCP_RMV_ACTIVE(pcb);
;;;945          pcb->state = TIME_WAIT;
;;;946          TCP_REG(&tcp_tw_pcbs, pcb);
;;;947        }
;;;948        break;
;;;949      case LAST_ACK:
;;;950        tcp_receive(pcb);
;;;951        if ((flags & TCP_ACK) && ackno == pcb->snd_nxt && pcb->unsent == NULL) {
;;;952          LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed: LAST_ACK %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
;;;953          /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
;;;954          recv_flags |= TF_CLOSED;
;;;955        }
;;;956        break;
;;;957      default:
;;;958        break;
;;;959      }
;;;960      return ERR_OK;
;;;961    }
00007c  e8bd8ffe          POP      {r1-r11,pc}
                  |L7.128|
000080  2000              MOVS     r0,#0                 ;752
000082  e7fb              B        |L7.124|
                  |L7.132|
000084  0788              LSLS     r0,r1,#30             ;756
000086  d50a              BPL      |L7.158|
000088  7d20              LDRB     r0,[r4,#0x14]         ;756
00008a  2802              CMP      r0,#2                 ;756
00008c  d007              BEQ      |L7.158|
00008e  2803              CMP      r0,#3                 ;756
000090  d005              BEQ      |L7.158|
000092  7ea0              LDRB     r0,[r4,#0x1a]         ;758
000094  f0400002          ORR      r0,r0,#2              ;758
000098  76a0              STRB     r0,[r4,#0x1a]         ;758
00009a  2000              MOVS     r0,#0                 ;759
00009c  e7ee              B        |L7.124|
                  |L7.158|
00009e  7ea0              LDRB     r0,[r4,#0x1a]         ;762
0000a0  06c0              LSLS     r0,r0,#27             ;762
0000a2  d402              BMI      |L7.170|
0000a4  48f1              LDR      r0,|L7.1132|
0000a6  6800              LDR      r0,[r0,#0]            ;764  ; tcp_ticks
0000a8  6220              STR      r0,[r4,#0x20]         ;764
                  |L7.170|
0000aa  f04f0a00          MOV      r10,#0                ;766
0000ae  f884a096          STRB     r10,[r4,#0x96]        ;766
0000b2  4620              MOV      r0,r4                 ;768
0000b4  f7fffffe          BL       tcp_parseopt
0000b8  4aed              LDR      r2,|L7.1136|
0000ba  7d20              LDRB     r0,[r4,#0x14]         ;771
0000bc  f1020310          ADD      r3,r2,#0x10           ;829
0000c0  1e80              SUBS     r0,r0,#2              ;771
0000c2  2701              MOVS     r7,#1                 ;724
0000c4  2104              MOVS     r1,#4                 ;784
0000c6  3214              ADDS     r2,r2,#0x14           ;829
0000c8  f8df83a8          LDR      r8,|L7.1140|
0000cc  4eea              LDR      r6,|L7.1144|
0000ce  4deb              LDR      r5,|L7.1148|
0000d0  f04f090a          MOV      r9,#0xa               ;917
0000d4  2808              CMP      r0,#8                 ;771
0000d6  d265              BCS      |L7.420|
0000d8  e8dff000          TBB      [pc,r0]               ;771
0000dc  0494f1f0          DCB      0x04,0x94,0xf1,0xf0
0000e0  eff1eeed          DCB      0xef,0xf1,0xee,0xed
0000e4  f89b0000          LDRB     r0,[r11,#0]           ;776  ; flags
0000e8  06c5              LSLS     r5,r0,#27             ;776
0000ea  d570              BPL      |L7.462|
0000ec  0785              LSLS     r5,r0,#30             ;776
0000ee  d56e              BPL      |L7.462|
0000f0  6c66              LDR      r6,[r4,#0x44]         ;777
0000f2  f8db5018          LDR      r5,[r11,#0x18]        ;777  ; ackno
0000f6  1c76              ADDS     r6,r6,#1              ;777
0000f8  42ae              CMP      r6,r5                 ;777
0000fa  d168              BNE      |L7.462|
0000fc  f8db0014          LDR      r0,[r11,#0x14]        ;778  ; seqno
000100  4602              MOV      r2,r0                 ;778
000102  1c40              ADDS     r0,r0,#1              ;778
000104  6260              STR      r0,[r4,#0x24]         ;778
000106  62e0              STR      r0,[r4,#0x2c]         ;779
000108  6465              STR      r5,[r4,#0x44]         ;780
00010a  f8db000c          LDR      r0,[r11,#0xc]         ;781  ; tcphdr
00010e  89c0              LDRH     r0,[r0,#0xe]          ;781
000110  f8a4005c          STRH     r0,[r4,#0x5c]         ;781
000114  f8a4005e          STRH     r0,[r4,#0x5e]         ;782
000118  1e52              SUBS     r2,r2,#1              ;783
00011a  6522              STR      r2,[r4,#0x50]         ;783
00011c  7521              STRB     r1,[r4,#0x14]         ;784
00011e  8e60              LDRH     r0,[r4,#0x32]         ;787
000120  1d21              ADDS     r1,r4,#4              ;787
000122  f7fffffe          BL       tcp_eff_send_mss_impl
000126  8660              STRH     r0,[r4,#0x32]         ;787
000128  f241111c          MOV      r1,#0x111c            ;790
00012c  ebb10f40          CMP      r1,r0,LSL #1          ;790
000130  d201              BCS      |L7.310|
000132  0042              LSLS     r2,r0,#1              ;790
000134  e000              B        |L7.312|
                  |L7.310|
000136  460a              MOV      r2,r1                 ;790
                  |L7.312|
000138  ebb20f80          CMP      r2,r0,LSL #2          ;790
00013c  d901              BLS      |L7.322|
00013e  0081              LSLS     r1,r0,#2              ;790
000140  e003              B        |L7.330|
                  |L7.322|
000142  ebb10f40          CMP      r1,r0,LSL #1          ;790
000146  d200              BCS      |L7.330|
000148  0041              LSLS     r1,r0,#1              ;790
                  |L7.330|
00014a  f8a41048          STRH     r1,[r4,#0x48]         ;790
00014e  f8b40062          LDRH     r0,[r4,#0x62]         ;794
000152  b930              CBNZ     r0,|L7.354|
000154  a3a6              ADR      r3,|L7.1008|
000156  f240321a          MOV      r2,#0x31a             ;794
00015a  a1c9              ADR      r1,|L7.1152|
00015c  a0b9              ADR      r0,|L7.1092|
00015e  f7fffffe          BL       __2printf
                  |L7.354|
000162  f8b40062          LDRH     r0,[r4,#0x62]         ;795
000166  1e40              SUBS     r0,r0,#1              ;795
000168  f8a40062          STRH     r0,[r4,#0x62]         ;795
00016c  6ee5              LDR      r5,[r4,#0x6c]         ;797
00016e  b1d5              CBZ      r5,|L7.422|
000170  6828              LDR      r0,[r5,#0]            ;805
000172  66e0              STR      r0,[r4,#0x6c]         ;805
                  |L7.372|
000174  4628              MOV      r0,r5                 ;807
000176  f7fffffe          BL       tcp_seg_free
00017a  6ee0              LDR      r0,[r4,#0x6c]         ;811
00017c  b1f8              CBZ      r0,|L7.446|
00017e  f8a4a030          STRH     r10,[r4,#0x30]        ;814
000182  f884a042          STRB     r10,[r4,#0x42]        ;815
                  |L7.390|
000186  f8d43084          LDR      r3,[r4,#0x84]         ;820
00018a  b123              CBZ      r3,|L7.406|
00018c  2200              MOVS     r2,#0                 ;820
00018e  4621              MOV      r1,r4                 ;820
000190  6920              LDR      r0,[r4,#0x10]         ;820
000192  4798              BLX      r3                    ;820
000194  9002              STR      r0,[sp,#8]            ;820
                  |L7.406|
000196  9802              LDR      r0,[sp,#8]            ;821
000198  300d              ADDS     r0,r0,#0xd            ;821
00019a  d014              BEQ      |L7.454|
00019c  7ea0              LDRB     r0,[r4,#0x1a]         ;824
00019e  f0400002          ORR      r0,r0,#2              ;824
0001a2  76a0              STRB     r0,[r4,#0x1a]         ;824
                  |L7.420|
0001a4  e1d0              B        |L7.1352|
                  |L7.422|
0001a6  6ea5              LDR      r5,[r4,#0x68]         ;801
0001a8  b935              CBNZ     r5,|L7.440|
0001aa  a391              ADR      r3,|L7.1008|
0001ac  f2403222          MOV      r2,#0x322             ;802
0001b0  a1b9              ADR      r1,|L7.1176|
0001b2  a0a4              ADR      r0,|L7.1092|
0001b4  f7fffffe          BL       __2printf
                  |L7.440|
0001b8  6828              LDR      r0,[r5,#0]            ;803
0001ba  66a0              STR      r0,[r4,#0x68]         ;803
0001bc  e7da              B        |L7.372|
                  |L7.446|
0001be  f04f30ff          MOV      r0,#0xffffffff        ;812
0001c2  8620              STRH     r0,[r4,#0x30]         ;812
0001c4  e7df              B        |L7.390|
                  |L7.454|
0001c6  f06f000c          MVN      r0,#0xc               ;822
0001ca  e757              B        |L7.124|
0001cc  e7ff              B        |L7.462|
                  |L7.462|
0001ce  06c0              LSLS     r0,r0,#27             ;827
0001d0  d5e8              BPL      |L7.420|
0001d2  f8db000c          LDR      r0,[r11,#0xc]         ;829  ; tcphdr
0001d6  8801              LDRH     r1,[r0,#0]            ;829
0001d8  8840              LDRH     r0,[r0,#2]            ;829
0001da  e9cd0100          STRD     r0,r1,[sp,#0]         ;829
0001de  f8bb100a          LDRH     r1,[r11,#0xa]         ;829  ; tcplen
0001e2  f8db0014          LDR      r0,[r11,#0x14]        ;829  ; seqno
0001e6  4401              ADD      r1,r1,r0              ;829
0001e8  f8db0018          LDR      r0,[r11,#0x18]        ;829  ; ackno
0001ec  f7fffffe          BL       tcp_rst
0001f0  f8940042          LDRB     r0,[r4,#0x42]         ;834
0001f4  2806              CMP      r0,#6                 ;834
0001f6  d2d5              BCS      |L7.420|
0001f8  f8a4a030          STRH     r10,[r4,#0x30]        ;835
0001fc  4620              MOV      r0,r4                 ;836
0001fe  f7fffffe          BL       tcp_rexmit_rto
000202  e1a1              B        |L7.1352|
000204  f89b0000          LDRB     r0,[r11,#0]           ;841  ; flags
000208  06c5              LSLS     r5,r0,#27             ;841
00020a  d567              BPL      |L7.732|
00020c  6c65              LDR      r5,[r4,#0x44]         ;843
00020e  f8db0018          LDR      r0,[r11,#0x18]        ;843  ; ackno
000212  1b45              SUBS     r5,r0,r5              ;843
000214  2d01              CMP      r5,#1                 ;843
000216  d453              BMI      |L7.704|
000218  6ce5              LDR      r5,[r4,#0x4c]         ;843
00021a  1b45              SUBS     r5,r0,r5              ;843
00021c  2d00              CMP      r5,#0                 ;843
00021e  dc4f              BGT      |L7.704|
000220  7521              STRB     r1,[r4,#0x14]         ;844
000222  6fa0              LDR      r0,[r4,#0x78]         ;848
000224  b140              CBZ      r0,|L7.568|
000226  6980              LDR      r0,[r0,#0x18]         ;848
000228  b930              CBNZ     r0,|L7.568|
00022a  a371              ADR      r3,|L7.1008|
00022c  f44f7254          MOV      r2,#0x350             ;848
000230  a19e              ADR      r1,|L7.1196|
000232  a084              ADR      r0,|L7.1092|
000234  f7fffffe          BL       __2printf
                  |L7.568|
000238  6fa0              LDR      r0,[r4,#0x78]         ;851
00023a  b130              CBZ      r0,|L7.586|
00023c  6983              LDR      r3,[r0,#0x18]         ;859
00023e  b13b              CBZ      r3,|L7.592|
000240  2200              MOVS     r2,#0                 ;859
000242  4621              MOV      r1,r4                 ;859
000244  6920              LDR      r0,[r4,#0x10]         ;859
000246  4798              BLX      r3                    ;859
000248  e004              B        |L7.596|
                  |L7.586|
00024a  f06f0005          MVN      r0,#5                 ;853
00024e  e001              B        |L7.596|
                  |L7.592|
000250  f06f000f          MVN      r0,#0xf               ;859
                  |L7.596|
000254  b138              CBZ      r0,|L7.614|
000256  300d              ADDS     r0,r0,#0xd            ;865
000258  d002              BEQ      |L7.608|
00025a  4620              MOV      r0,r4                 ;866
00025c  f7fffffe          BL       tcp_abort
                  |L7.608|
000260  f06f000c          MVN      r0,#0xc               ;868
000264  e70a              B        |L7.124|
                  |L7.614|
000266  4620              MOV      r0,r4                 ;872
000268  f7fffffe          BL       tcp_receive
00026c  f8bb0008          LDRH     r0,[r11,#8]           ;875  ; recv_acked
000270  b110              CBZ      r0,|L7.632|
000272  1e40              SUBS     r0,r0,#1              ;876
000274  f8ab0008          STRH     r0,[r11,#8]           ;876
                  |L7.632|
000278  8e60              LDRH     r0,[r4,#0x32]         ;879
00027a  f241111c          MOV      r1,#0x111c            ;879
00027e  ebb10f40          CMP      r1,r0,LSL #1          ;879
000282  d201              BCS      |L7.648|
000284  0042              LSLS     r2,r0,#1              ;879
000286  e000              B        |L7.650|
                  |L7.648|
000288  460a              MOV      r2,r1                 ;879
                  |L7.650|
00028a  ebb20f80          CMP      r2,r0,LSL #2          ;879
00028e  d901              BLS      |L7.660|
000290  0081              LSLS     r1,r0,#2              ;879
000292  e003              B        |L7.668|
                  |L7.660|
000294  ebb10f40          CMP      r1,r0,LSL #1          ;879
000298  d200              BCS      |L7.668|
00029a  0041              LSLS     r1,r0,#1              ;879
                  |L7.668|
00029c  f8a41048          STRH     r1,[r4,#0x48]         ;879
0002a0  f89b0001          LDRB     r0,[r11,#1]           ;884  ; recv_flags
0002a4  0680              LSLS     r0,r0,#26             ;884
0002a6  d505              BPL      |L7.692|
0002a8  7ea0              LDRB     r0,[r4,#0x1a]         ;885
0002aa  f0400002          ORR      r0,r0,#2              ;885
0002ae  76a0              STRB     r0,[r4,#0x1a]         ;885
0002b0  2007              MOVS     r0,#7                 ;886
0002b2  7520              STRB     r0,[r4,#0x14]         ;886
                  |L7.692|
0002b4  e148              B        |L7.1352|
0002b6  e133              B        |L7.1312|
0002b8  e108              B        |L7.1228|
0002ba  e070              B        |L7.926|
0002bc  e028              B        |L7.784|
0002be  e019              B        |L7.756|
                  |L7.704|
0002c0  f8db100c          LDR      r1,[r11,#0xc]         ;890  ; tcphdr
0002c4  880c              LDRH     r4,[r1,#0]            ;890
0002c6  8849              LDRH     r1,[r1,#2]            ;890
0002c8  e9cd1400          STRD     r1,r4,[sp,#0]         ;890
0002cc  f8bb400a          LDRH     r4,[r11,#0xa]         ;890  ; tcplen
0002d0  f8db1014          LDR      r1,[r11,#0x14]        ;890  ; seqno
0002d4  4421              ADD      r1,r1,r4              ;890
0002d6  f7fffffe          BL       tcp_rst
0002da  e135              B        |L7.1352|
                  |L7.732|
0002dc  0780              LSLS     r0,r0,#30             ;893
0002de  d508              BPL      |L7.754|
0002e0  6a60              LDR      r0,[r4,#0x24]         ;893
0002e2  f8db1014          LDR      r1,[r11,#0x14]        ;893  ; seqno
0002e6  1e40              SUBS     r0,r0,#1              ;893
0002e8  4288              CMP      r0,r1                 ;893
0002ea  d102              BNE      |L7.754|
0002ec  4620              MOV      r0,r4                 ;895
0002ee  f7fffffe          BL       tcp_rexmit
                  |L7.754|
0002f2  e129              B        |L7.1352|
                  |L7.756|
0002f4  4620              MOV      r0,r4                 ;901
0002f6  f7fffffe          BL       tcp_receive
0002fa  f89b0001          LDRB     r0,[r11,#1]           ;902  ; recv_flags
0002fe  0680              LSLS     r0,r0,#26             ;902
000300  d505              BPL      |L7.782|
000302  7ea0              LDRB     r0,[r4,#0x1a]         ;903
000304  f0400002          ORR      r0,r0,#2              ;903
000308  76a0              STRB     r0,[r4,#0x1a]         ;903
00030a  2007              MOVS     r0,#7                 ;904
00030c  7520              STRB     r0,[r4,#0x14]         ;904
                  |L7.782|
00030e  e11b              B        |L7.1352|
                  |L7.784|
000310  4620              MOV      r0,r4                 ;908
000312  f7fffffe          BL       tcp_receive
000316  f89b0001          LDRB     r0,[r11,#1]           ;909  ; recv_flags
00031a  0680              LSLS     r0,r0,#26             ;909
00031c  d531              BPL      |L7.898|
00031e  f89b0000          LDRB     r0,[r11,#0]           ;910  ; flags
000322  06c0              LSLS     r0,r0,#27             ;910
000324  d506              BPL      |L7.820|
000326  6ce0              LDR      r0,[r4,#0x4c]         ;910
000328  f8db1018          LDR      r1,[r11,#0x18]        ;910  ; ackno
00032c  4288              CMP      r0,r1                 ;910
00032e  d101              BNE      |L7.820|
000330  6ea0              LDR      r0,[r4,#0x68]         ;911
000332  b130              CBZ      r0,|L7.834|
                  |L7.820|
000334  7ea0              LDRB     r0,[r4,#0x1a]         ;920
000336  f0400002          ORR      r0,r0,#2              ;920
00033a  76a0              STRB     r0,[r4,#0x1a]         ;920
00033c  2008              MOVS     r0,#8                 ;921
00033e  7520              STRB     r0,[r4,#0x14]         ;921
000340  e102              B        |L7.1352|
                  |L7.834|
000342  7ea0              LDRB     r0,[r4,#0x1a]         ;914
000344  f0400002          ORR      r0,r0,#2              ;914
000348  76a0              STRB     r0,[r4,#0x1a]         ;914
00034a  4620              MOV      r0,r4                 ;915
00034c  f7fffffe          BL       tcp_pcb_purge
000350  6828              LDR      r0,[r5,#0]            ;916  ; tcp_active_pcbs
000352  42a0              CMP      r0,r4                 ;916
000354  d109              BNE      |L7.874|
000356  68c0              LDR      r0,[r0,#0xc]          ;916
000358  6028              STR      r0,[r5,#0]            ;916  ; tcp_active_pcbs
00035a  e008              B        |L7.878|
                  |L7.860|
00035c  68c1              LDR      r1,[r0,#0xc]          ;916
00035e  42a1              CMP      r1,r4                 ;916
000360  d102              BNE      |L7.872|
000362  68e1              LDR      r1,[r4,#0xc]          ;916
000364  60c1              STR      r1,[r0,#0xc]          ;916
000366  e002              B        |L7.878|
                  |L7.872|
000368  4608              MOV      r0,r1                 ;916
                  |L7.874|
00036a  2800              CMP      r0,#0                 ;916
00036c  d1f6              BNE      |L7.860|
                  |L7.878|
00036e  f8887000          STRB     r7,[r8,#0]            ;916
000372  f8849014          STRB     r9,[r4,#0x14]         ;917
000376  6830              LDR      r0,[r6,#0]            ;918  ; tcp_tw_pcbs
000378  60e0              STR      r0,[r4,#0xc]          ;918
00037a  6034              STR      r4,[r6,#0]            ;918  ; tcp_tw_pcbs
00037c  f7fffffe          BL       tcp_timer_needed
000380  e0e2              B        |L7.1352|
                  |L7.898|
000382  f89b0000          LDRB     r0,[r11,#0]           ;923  ; flags
000386  06c0              LSLS     r0,r0,#27             ;923
000388  d52f              BPL      |L7.1002|
00038a  6ce0              LDR      r0,[r4,#0x4c]         ;923
00038c  f8db1018          LDR      r1,[r11,#0x18]        ;923  ; ackno
000390  4288              CMP      r0,r1                 ;923
000392  d12a              BNE      |L7.1002|
000394  6ea0              LDR      r0,[r4,#0x68]         ;924
000396  bb40              CBNZ     r0,|L7.1002|
000398  2006              MOVS     r0,#6                 ;925
00039a  7520              STRB     r0,[r4,#0x14]         ;925
00039c  e0d4              B        |L7.1352|
                  |L7.926|
00039e  4620              MOV      r0,r4                 ;929
0003a0  f7fffffe          BL       tcp_receive
0003a4  f89b0001          LDRB     r0,[r11,#1]           ;930  ; recv_flags
0003a8  0680              LSLS     r0,r0,#26             ;930
0003aa  d51e              BPL      |L7.1002|
0003ac  7ea0              LDRB     r0,[r4,#0x1a]         ;932
0003ae  f0400002          ORR      r0,r0,#2              ;932
0003b2  76a0              STRB     r0,[r4,#0x1a]         ;932
0003b4  4620              MOV      r0,r4                 ;933
0003b6  f7fffffe          BL       tcp_pcb_purge
0003ba  6828              LDR      r0,[r5,#0]            ;934  ; tcp_active_pcbs
0003bc  42a0              CMP      r0,r4                 ;934
0003be  d109              BNE      |L7.980|
0003c0  68c0              LDR      r0,[r0,#0xc]          ;934
0003c2  6028              STR      r0,[r5,#0]            ;934  ; tcp_active_pcbs
0003c4  e008              B        |L7.984|
                  |L7.966|
0003c6  68c1              LDR      r1,[r0,#0xc]          ;934
0003c8  42a1              CMP      r1,r4                 ;934
0003ca  d102              BNE      |L7.978|
0003cc  68e1              LDR      r1,[r4,#0xc]          ;934
0003ce  60c1              STR      r1,[r0,#0xc]          ;934
0003d0  e002              B        |L7.984|
                  |L7.978|
0003d2  4608              MOV      r0,r1                 ;934
                  |L7.980|
0003d4  2800              CMP      r0,#0                 ;934
0003d6  d1f6              BNE      |L7.966|
                  |L7.984|
0003d8  f8887000          STRB     r7,[r8,#0]            ;934
0003dc  f8849014          STRB     r9,[r4,#0x14]         ;935
0003e0  6830              LDR      r0,[r6,#0]            ;936  ; tcp_tw_pcbs
0003e2  60e0              STR      r0,[r4,#0xc]          ;936
0003e4  6034              STR      r4,[r6,#0]            ;936  ; tcp_tw_pcbs
0003e6  f7fffffe          BL       tcp_timer_needed
                  |L7.1002|
0003ea  e0ad              B        |L7.1352|
                  |L7.1004|
                          DCD      ||.data||
                  |L7.1008|
0003f0  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_in.c"
0003f4  6964646c
0003f8  65776172
0003fc  65735c54
000400  68697264
000404  5f506172
000408  74795c4c
00040c  7749505c
000410  7372635c
000414  636f7265
000418  5c746370
00041c  5f696e2e
000420  63      
000421  00                DCB      0
000422  00                DCB      0
000423  00                DCB      0
                  |L7.1060|
000424  7463705f          DCB      "tcp_input: pcb->state != CLOSED",0
000428  696e7075
00042c  743a2070
000430  63622d3e
000434  73746174
000438  6520213d
00043c  20434c4f
000440  53454400
                  |L7.1092|
000444  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000448  7274696f
00044c  6e202225
000450  73222066
000454  61696c65
000458  64206174
00045c  206c696e
000460  65202564
000464  20696e20
000468  25730a00
                  |L7.1132|
                          DCD      tcp_ticks
                  |L7.1136|
                          DCD      ip_data
                  |L7.1140|
                          DCD      tcp_active_pcbs_changed
                  |L7.1144|
                          DCD      tcp_tw_pcbs
                  |L7.1148|
                          DCD      tcp_active_pcbs
                  |L7.1152|
000480  7063622d          DCB      "pcb->snd_queuelen > 0",0
000484  3e736e64
000488  5f717565
00048c  75656c65
000490  6e203e20
000494  3000    
000496  00                DCB      0
000497  00                DCB      0
                  |L7.1176|
000498  6e6f2073          DCB      "no segment to free",0
00049c  65676d65
0004a0  6e742074
0004a4  6f206672
0004a8  656500  
0004ab  00                DCB      0
                  |L7.1196|
0004ac  7063622d          DCB      "pcb->listener->accept != NULL",0
0004b0  3e6c6973
0004b4  74656e65
0004b8  722d3e61
0004bc  63636570
0004c0  7420213d
0004c4  204e554c
0004c8  4c00    
0004ca  00                DCB      0
0004cb  00                DCB      0
                  |L7.1228|
0004cc  4620              MOV      r0,r4                 ;940
0004ce  f7fffffe          BL       tcp_receive
0004d2  f89b0000          LDRB     r0,[r11,#0]           ;941  ; flags
0004d6  06c0              LSLS     r0,r0,#27             ;941
0004d8  d536              BPL      |L7.1352|
0004da  6ce0              LDR      r0,[r4,#0x4c]         ;941
0004dc  f8db1018          LDR      r1,[r11,#0x18]        ;941  ; ackno
0004e0  4288              CMP      r0,r1                 ;941
0004e2  d131              BNE      |L7.1352|
0004e4  6ea0              LDR      r0,[r4,#0x68]         ;941
0004e6  bb78              CBNZ     r0,|L7.1352|
0004e8  4620              MOV      r0,r4                 ;943
0004ea  f7fffffe          BL       tcp_pcb_purge
0004ee  6828              LDR      r0,[r5,#0]            ;944  ; tcp_active_pcbs
0004f0  42a0              CMP      r0,r4                 ;944
0004f2  d109              BNE      |L7.1288|
0004f4  68c0              LDR      r0,[r0,#0xc]          ;944
0004f6  6028              STR      r0,[r5,#0]            ;944  ; tcp_active_pcbs
0004f8  e008              B        |L7.1292|
                  |L7.1274|
0004fa  68c1              LDR      r1,[r0,#0xc]          ;944
0004fc  42a1              CMP      r1,r4                 ;944
0004fe  d102              BNE      |L7.1286|
000500  68e1              LDR      r1,[r4,#0xc]          ;944
000502  60c1              STR      r1,[r0,#0xc]          ;944
000504  e002              B        |L7.1292|
                  |L7.1286|
000506  4608              MOV      r0,r1                 ;944
                  |L7.1288|
000508  2800              CMP      r0,#0                 ;944
00050a  d1f6              BNE      |L7.1274|
                  |L7.1292|
00050c  f8887000          STRB     r7,[r8,#0]            ;944
000510  f8849014          STRB     r9,[r4,#0x14]         ;945
000514  6830              LDR      r0,[r6,#0]            ;946  ; tcp_tw_pcbs
000516  60e0              STR      r0,[r4,#0xc]          ;946
000518  6034              STR      r4,[r6,#0]            ;946  ; tcp_tw_pcbs
00051a  f7fffffe          BL       tcp_timer_needed
00051e  e013              B        |L7.1352|
                  |L7.1312|
000520  4620              MOV      r0,r4                 ;950
000522  f7fffffe          BL       tcp_receive
000526  f89b0000          LDRB     r0,[r11,#0]           ;951  ; flags
00052a  06c0              LSLS     r0,r0,#27             ;951
00052c  d50c              BPL      |L7.1352|
00052e  6ce0              LDR      r0,[r4,#0x4c]         ;951
000530  f8db1018          LDR      r1,[r11,#0x18]        ;951  ; ackno
000534  4288              CMP      r0,r1                 ;951
000536  d107              BNE      |L7.1352|
000538  6ea0              LDR      r0,[r4,#0x68]         ;951
00053a  b928              CBNZ     r0,|L7.1352|
00053c  f89b0001          LDRB     r0,[r11,#1]           ;954  ; recv_flags
000540  f0400010          ORR      r0,r0,#0x10           ;954
000544  f88b0001          STRB     r0,[r11,#1]           ;954
                  |L7.1352|
000548  2000              MOVS     r0,#0                 ;960
00054a  e597              B        |L7.124|
;;;962    
                          ENDP


                          AREA ||i.tcp_receive||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  tcp_receive PROC
;;;1015   static void
;;;1016   tcp_receive(struct tcp_pcb *pcb)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1017   {
000004  4604              MOV      r4,r0
;;;1018     struct tcp_seg *next;
;;;1019   #if TCP_QUEUE_OOSEQ
;;;1020     struct tcp_seg *prev, *cseg;
;;;1021   #endif /* TCP_QUEUE_OOSEQ */
;;;1022     s32_t off;
;;;1023     s16_t m;
;;;1024     u32_t right_wnd_edge;
;;;1025     u16_t new_tot_len;
;;;1026     int found_dupack = 0;
000006  2500              MOVS     r5,#0
;;;1027   #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;1028     u32_t ooseq_blen;
;;;1029     u16_t ooseq_qlen;
;;;1030   #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;1031   
;;;1032     LWIP_ASSERT("tcp_receive: wrong state", pcb->state >= ESTABLISHED);
000008  7d20              LDRB     r0,[r4,#0x14]
00000a  2804              CMP      r0,#4
00000c  d206              BCS      |L8.28|
00000e  a3e3              ADR      r3,|L8.924|
000010  f44f6281          MOV      r2,#0x408
000014  a1ee              ADR      r1,|L8.976|
000016  a0f5              ADR      r0,|L8.1004|
000018  f7fffffe          BL       __2printf
                  |L8.28|
;;;1033   
;;;1034     if (flags & TCP_ACK) {
00001c  4ffd              LDR      r7,|L8.1044|
00001e  f04f0900          MOV      r9,#0
000022  7838              LDRB     r0,[r7,#0]  ; flags
000024  06c0              LSLS     r0,r0,#27
000026  d57d              BPL      |L8.292|
;;;1035       right_wnd_edge = pcb->snd_wnd + pcb->snd_wl2;
000028  f8b4305c          LDRH     r3,[r4,#0x5c]
00002c  6d60              LDR      r0,[r4,#0x54]
00002e  181e              ADDS     r6,r3,r0
;;;1036   
;;;1037       /* Update window. */
;;;1038       if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
000030  6d22              LDR      r2,[r4,#0x50]
000032  6979              LDR      r1,[r7,#0x14]  ; seqno
000034  ebb20c01          SUBS     r12,r2,r1
000038  d40b              BMI      |L8.82|
;;;1039          (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
00003a  428a              CMP      r2,r1
00003c  d102              BNE      |L8.68|
00003e  69ba              LDR      r2,[r7,#0x18]  ; ackno
000040  1a82              SUBS     r2,r0,r2
000042  d406              BMI      |L8.82|
                  |L8.68|
;;;1040          (pcb->snd_wl2 == ackno && (u32_t)SND_WND_SCALE(pcb, tcphdr->wnd) > pcb->snd_wnd)) {
000044  69ba              LDR      r2,[r7,#0x18]  ; ackno
000046  4290              CMP      r0,r2
000048  d116              BNE      |L8.120|
00004a  68f8              LDR      r0,[r7,#0xc]  ; tcphdr
00004c  89c0              LDRH     r0,[r0,#0xe]
00004e  4298              CMP      r0,r3
000050  d912              BLS      |L8.120|
                  |L8.82|
;;;1041         pcb->snd_wnd = SND_WND_SCALE(pcb, tcphdr->wnd);
000052  68f8              LDR      r0,[r7,#0xc]  ; tcphdr
000054  89c0              LDRH     r0,[r0,#0xe]
000056  f8a4005c          STRH     r0,[r4,#0x5c]
;;;1042         /* keep track of the biggest window announced by the remote host to calculate
;;;1043            the maximum segment size */
;;;1044         if (pcb->snd_wnd_max < pcb->snd_wnd) {
00005a  f8b4205e          LDRH     r2,[r4,#0x5e]
00005e  4282              CMP      r2,r0
000060  d201              BCS      |L8.102|
;;;1045           pcb->snd_wnd_max = pcb->snd_wnd;
000062  f8a4005e          STRH     r0,[r4,#0x5e]
                  |L8.102|
;;;1046         }
;;;1047         pcb->snd_wl1 = seqno;
000066  6521              STR      r1,[r4,#0x50]
;;;1048         pcb->snd_wl2 = ackno;
000068  69b9              LDR      r1,[r7,#0x18]  ; ackno
00006a  6561              STR      r1,[r4,#0x54]
;;;1049         if (pcb->snd_wnd == 0) {
00006c  b160              CBZ      r0,|L8.136|
;;;1050           if (pcb->persist_backoff == 0) {
;;;1051             /* start persist timer */
;;;1052             pcb->persist_cnt = 0;
;;;1053             pcb->persist_backoff = 1;
;;;1054           }
;;;1055         } else if (pcb->persist_backoff > 0) {
00006e  f8940095          LDRB     r0,[r4,#0x95]
000072  b108              CBZ      r0,|L8.120|
;;;1056           /* stop persist timer */
;;;1057             pcb->persist_backoff = 0;
000074  f8849095          STRB     r9,[r4,#0x95]
                  |L8.120|
;;;1058         }
;;;1059         LWIP_DEBUGF(TCP_WND_DEBUG, ("tcp_receive: window update %"TCPWNDSIZE_F"\n", pcb->snd_wnd));
;;;1060   #if TCP_WND_DEBUG
;;;1061       } else {
;;;1062         if (pcb->snd_wnd != (tcpwnd_size_t)SND_WND_SCALE(pcb, tcphdr->wnd)) {
;;;1063           LWIP_DEBUGF(TCP_WND_DEBUG,
;;;1064                       ("tcp_receive: no window update lastack %"U32_F" ackno %"
;;;1065                        U32_F" wl1 %"U32_F" seqno %"U32_F" wl2 %"U32_F"\n",
;;;1066                        pcb->lastack, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
;;;1067         }
;;;1068   #endif /* TCP_WND_DEBUG */
;;;1069       }
;;;1070   
;;;1071       /* (From Stevens TCP/IP Illustrated Vol II, p970.) Its only a
;;;1072        * duplicate ack if:
;;;1073        * 1) It doesn't ACK new data
;;;1074        * 2) length of received packet is zero (i.e. no payload)
;;;1075        * 3) the advertised window hasn't changed
;;;1076        * 4) There is outstanding unacknowledged data (retransmission timer running)
;;;1077        * 5) The ACK is == biggest ACK sequence number so far seen (snd_una)
;;;1078        *
;;;1079        * If it passes all five, should process as a dupack:
;;;1080        * a) dupacks < 3: do nothing
;;;1081        * b) dupacks == 3: fast retransmit
;;;1082        * c) dupacks > 3: increase cwnd
;;;1083        *
;;;1084        * If it only passes 1-3, should reset dupack counter (and add to
;;;1085        * stats, which we don't do in lwIP)
;;;1086        *
;;;1087        * If it only passes 1, should reset dupack counter
;;;1088        *
;;;1089        */
;;;1090   
;;;1091       /* Clause 1 */
;;;1092       if (TCP_SEQ_LEQ(ackno, pcb->lastack)) {
000078  6c62              LDR      r2,[r4,#0x44]
00007a  69b8              LDR      r0,[r7,#0x18]  ; ackno
00007c  1a81              SUBS     r1,r0,r2
00007e  2900              CMP      r1,#0
000080  dc38              BGT      |L8.244|
;;;1093         /* Clause 2 */
;;;1094         if (tcplen == 0) {
000082  8979              LDRH     r1,[r7,#0xa]  ; tcplen
000084  b151              CBZ      r1,|L8.156|
000086  e030              B        |L8.234|
                  |L8.136|
000088  f8940095          LDRB     r0,[r4,#0x95]         ;1050
00008c  2800              CMP      r0,#0                 ;1050
00008e  d1f3              BNE      |L8.120|
000090  f8849094          STRB     r9,[r4,#0x94]         ;1052
000094  2001              MOVS     r0,#1                 ;1053
000096  f8840095          STRB     r0,[r4,#0x95]         ;1053
00009a  e7ed              B        |L8.120|
                  |L8.156|
;;;1095           /* Clause 3 */
;;;1096           if (pcb->snd_wl2 + pcb->snd_wnd == right_wnd_edge) {
00009c  f8b4305c          LDRH     r3,[r4,#0x5c]
0000a0  6d61              LDR      r1,[r4,#0x54]
0000a2  4419              ADD      r1,r1,r3
0000a4  42b1              CMP      r1,r6
0000a6  d120              BNE      |L8.234|
;;;1097             /* Clause 4 */
;;;1098             if (pcb->rtime >= 0) {
0000a8  f9b41030          LDRSH    r1,[r4,#0x30]
0000ac  2900              CMP      r1,#0
0000ae  db1c              BLT      |L8.234|
;;;1099               /* Clause 5 */
;;;1100               if (pcb->lastack == ackno) {
0000b0  4282              CMP      r2,r0
0000b2  d11a              BNE      |L8.234|
;;;1101                 found_dupack = 1;
0000b4  2501              MOVS     r5,#1
;;;1102                 if ((u8_t)(pcb->dupacks + 1) > pcb->dupacks) {
0000b6  f8940043          LDRB     r0,[r4,#0x43]
0000ba  1c41              ADDS     r1,r0,#1
0000bc  b2c9              UXTB     r1,r1
0000be  4281              CMP      r1,r0
0000c0  d901              BLS      |L8.198|
;;;1103                   ++pcb->dupacks;
0000c2  f8841043          STRB     r1,[r4,#0x43]
                  |L8.198|
;;;1104                 }
;;;1105                 if (pcb->dupacks > 3) {
0000c6  f8940043          LDRB     r0,[r4,#0x43]
0000ca  2803              CMP      r0,#3
0000cc  d909              BLS      |L8.226|
;;;1106                   /* Inflate the congestion window, but not if it means that
;;;1107                      the value overflows. */
;;;1108                   if ((tcpwnd_size_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
0000ce  f8b41048          LDRH     r1,[r4,#0x48]
0000d2  8e60              LDRH     r0,[r4,#0x32]
0000d4  4408              ADD      r0,r0,r1
0000d6  b280              UXTH     r0,r0
0000d8  4288              CMP      r0,r1
0000da  d906              BLS      |L8.234|
;;;1109                     pcb->cwnd += pcb->mss;
0000dc  f8a40048          STRH     r0,[r4,#0x48]
0000e0  e003              B        |L8.234|
                  |L8.226|
;;;1110                   }
;;;1111                 } else if (pcb->dupacks == 3) {
0000e2  d102              BNE      |L8.234|
;;;1112                   /* Do fast retransmit */
;;;1113                   tcp_rexmit_fast(pcb);
0000e4  4620              MOV      r0,r4
0000e6  f7fffffe          BL       tcp_rexmit_fast
                  |L8.234|
;;;1114                 }
;;;1115               }
;;;1116             }
;;;1117           }
;;;1118         }
;;;1119         /* If Clause (1) or more is true, but not a duplicate ack, reset
;;;1120          * count of consecutive duplicate acks */
;;;1121         if (!found_dupack) {
0000ea  2d00              CMP      r5,#0
0000ec  d101              BNE      |L8.242|
;;;1122           pcb->dupacks = 0;
0000ee  f8849043          STRB     r9,[r4,#0x43]
                  |L8.242|
0000f2  e0bd              B        |L8.624|
                  |L8.244|
;;;1123         }
;;;1124       } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
0000f4  2901              CMP      r1,#1
0000f6  d473              BMI      |L8.480|
0000f8  6ce1              LDR      r1,[r4,#0x4c]
0000fa  1a41              SUBS     r1,r0,r1
0000fc  2900              CMP      r1,#0
0000fe  dc6f              BGT      |L8.480|
;;;1125         /* We come here when the ACK acknowledges new data. */
;;;1126   
;;;1127         /* Reset the "IN Fast Retransmit" flag, since we are no longer
;;;1128            in fast retransmit. Also reset the congestion window to the
;;;1129            slow start threshold. */
;;;1130         if (pcb->flags & TF_INFR) {
000100  7ea1              LDRB     r1,[r4,#0x1a]
000102  074a              LSLS     r2,r1,#29
000104  d506              BPL      |L8.276|
;;;1131           pcb->flags &= ~TF_INFR;
000106  f0210104          BIC      r1,r1,#4
00010a  76a1              STRB     r1,[r4,#0x1a]
;;;1132           pcb->cwnd = pcb->ssthresh;
00010c  f8b4104a          LDRH     r1,[r4,#0x4a]
000110  f8a41048          STRH     r1,[r4,#0x48]
                  |L8.276|
;;;1133         }
;;;1134   
;;;1135         /* Reset the number of retransmissions. */
;;;1136         pcb->nrtx = 0;
000114  f8849042          STRB     r9,[r4,#0x42]
;;;1137   
;;;1138         /* Reset the retransmission time-out. */
;;;1139         pcb->rto = (pcb->sa >> 3) + pcb->sv;
000118  8fe1              LDRH     r1,[r4,#0x3e]
00011a  f9b4203c          LDRSH    r2,[r4,#0x3c]
00011e  eb0101e2          ADD      r1,r1,r2,ASR #3
000122  e000              B        |L8.294|
                  |L8.292|
000124  e0e7              B        |L8.758|
                  |L8.294|
000126  f8a41040          STRH     r1,[r4,#0x40]
;;;1140   
;;;1141         /* Reset the fast retransmit variables. */
;;;1142         pcb->dupacks = 0;
00012a  f8849043          STRB     r9,[r4,#0x43]
;;;1143         pcb->lastack = ackno;
00012e  6460              STR      r0,[r4,#0x44]
;;;1144   
;;;1145         /* Update the congestion control variables (cwnd and
;;;1146            ssthresh). */
;;;1147         if (pcb->state >= ESTABLISHED) {
000130  7d20              LDRB     r0,[r4,#0x14]
000132  2804              CMP      r0,#4
000134  d344              BCC      |L8.448|
;;;1148           if (pcb->cwnd < pcb->ssthresh) {
000136  f8b40048          LDRH     r0,[r4,#0x48]
00013a  f8b4104a          LDRH     r1,[r4,#0x4a]
00013e  4288              CMP      r0,r1
000140  d207              BCS      |L8.338|
;;;1149             if ((tcpwnd_size_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
000142  8e61              LDRH     r1,[r4,#0x32]
000144  4401              ADD      r1,r1,r0
000146  b289              UXTH     r1,r1
000148  4281              CMP      r1,r0
00014a  d939              BLS      |L8.448|
;;;1150               pcb->cwnd += pcb->mss;
00014c  f8a41048          STRH     r1,[r4,#0x48]
000150  e036              B        |L8.448|
                  |L8.338|
;;;1151             }
;;;1152             LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd));
;;;1153           } else {
;;;1154             tcpwnd_size_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
000152  8e61              LDRH     r1,[r4,#0x32]
000154  4349              MULS     r1,r1,r1
000156  fb91f1f0          SDIV     r1,r1,r0
00015a  4401              ADD      r1,r1,r0
00015c  b289              UXTH     r1,r1
;;;1155             if (new_cwnd > pcb->cwnd) {
00015e  4288              CMP      r0,r1
000160  d22e              BCS      |L8.448|
;;;1156               pcb->cwnd = new_cwnd;
000162  f8a41048          STRH     r1,[r4,#0x48]
000166  e02b              B        |L8.448|
                  |L8.360|
;;;1157             }
;;;1158             LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: congestion avoidance cwnd %"TCPWNDSIZE_F"\n", pcb->cwnd));
;;;1159           }
;;;1160         }
;;;1161         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: ACK for %"U32_F", unacked->seqno %"U32_F":%"U32_F"\n",
;;;1162                                       ackno,
;;;1163                                       pcb->unacked != NULL?
;;;1164                                       lwip_ntohl(pcb->unacked->tcphdr->seqno): 0,
;;;1165                                       pcb->unacked != NULL?
;;;1166                                       lwip_ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));
;;;1167   
;;;1168         /* Remove segment from the unacknowledged list if the incoming
;;;1169            ACK acknowledges them. */
;;;1170         while (pcb->unacked != NULL &&
;;;1171                TCP_SEQ_LEQ(lwip_ntohl(pcb->unacked->tcphdr->seqno) +
;;;1172                            TCP_TCPLEN(pcb->unacked), ackno)) {
;;;1173           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
;;;1174                                         lwip_ntohl(pcb->unacked->tcphdr->seqno),
;;;1175                                         lwip_ntohl(pcb->unacked->tcphdr->seqno) +
;;;1176                                         TCP_TCPLEN(pcb->unacked)));
;;;1177   
;;;1178           next = pcb->unacked;
;;;1179           pcb->unacked = pcb->unacked->next;
000168  6828              LDR      r0,[r5,#0]
00016a  66e0              STR      r0,[r4,#0x6c]
;;;1180   
;;;1181           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ", (tcpwnd_size_t)pcb->snd_queuelen));
;;;1182           LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
00016c  6868              LDR      r0,[r5,#4]
00016e  f7fffffe          BL       pbuf_clen
000172  f8b41062          LDRH     r1,[r4,#0x62]
000176  4288              CMP      r0,r1
000178  d906              BLS      |L8.392|
00017a  a388              ADR      r3,|L8.924|
00017c  f240429e          MOV      r2,#0x49e
000180  a1a5              ADR      r1,|L8.1048|
000182  a09a              ADR      r0,|L8.1004|
000184  f7fffffe          BL       __2printf
                  |L8.392|
;;;1183   
;;;1184           pcb->snd_queuelen -= pbuf_clen(next->p);
000188  6868              LDR      r0,[r5,#4]
00018a  f7fffffe          BL       pbuf_clen
00018e  f8341f62          LDRH     r1,[r4,#0x62]!
000192  1a08              SUBS     r0,r1,r0
000194  8020              STRH     r0,[r4,#0]
;;;1185           recv_acked += next->len;
000196  8928              LDRH     r0,[r5,#8]
000198  8939              LDRH     r1,[r7,#8]  ; recv_acked
00019a  4408              ADD      r0,r0,r1
00019c  8138              STRH     r0,[r7,#8]
;;;1186           tcp_seg_free(next);
00019e  4628              MOV      r0,r5
0001a0  f7fffffe          BL       tcp_seg_free
;;;1187   
;;;1188           LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"TCPWNDSIZE_F" (after freeing unacked)\n", (tcpwnd_size_t)pcb->snd_queuelen));
;;;1189           if (pcb->snd_queuelen != 0) {
0001a4  f8340962          LDRH     r0,[r4],#-0x62
0001a8  b150              CBZ      r0,|L8.448|
;;;1190             LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
0001aa  6ee0              LDR      r0,[r4,#0x6c]
0001ac  b940              CBNZ     r0,|L8.448|
0001ae  6ea0              LDR      r0,[r4,#0x68]
0001b0  b930              CBNZ     r0,|L8.448|
0001b2  a37a              ADR      r3,|L8.924|
0001b4  f24042a6          MOV      r2,#0x4a6
0001b8  a1a1              ADR      r1,|L8.1088|
0001ba  a08c              ADR      r0,|L8.1004|
0001bc  f7fffffe          BL       __2printf
                  |L8.448|
0001c0  6ee0              LDR      r0,[r4,#0x6c]         ;1170
0001c2  b1b8              CBZ      r0,|L8.500|
0001c4  68c0              LDR      r0,[r0,#0xc]          ;1171
0001c6  6840              LDR      r0,[r0,#4]            ;1171
0001c8  f7fffffe          BL       lwip_htonl
0001cc  4605              MOV      r5,r0                 ;1171
0001ce  6ee0              LDR      r0,[r4,#0x6c]         ;1171
0001d0  68c0              LDR      r0,[r0,#0xc]          ;1171
0001d2  8980              LDRH     r0,[r0,#0xc]          ;1171
0001d4  f7fffffe          BL       lwip_htons
0001d8  0780              LSLS     r0,r0,#30             ;1171
0001da  d002              BEQ      |L8.482|
0001dc  2001              MOVS     r0,#1                 ;1171
0001de  e001              B        |L8.484|
                  |L8.480|
0001e0  e013              B        |L8.522|
                  |L8.482|
0001e2  2000              MOVS     r0,#0                 ;1171
                  |L8.484|
0001e4  4428              ADD      r0,r0,r5              ;1171
0001e6  6ee5              LDR      r5,[r4,#0x6c]         ;1171
0001e8  8929              LDRH     r1,[r5,#8]            ;1171
0001ea  4408              ADD      r0,r0,r1              ;1171
0001ec  69b9              LDR      r1,[r7,#0x18]         ;1171  ; ackno
0001ee  1a40              SUBS     r0,r0,r1              ;1171
0001f0  2800              CMP      r0,#0                 ;1171
0001f2  ddb9              BLE      |L8.360|
                  |L8.500|
;;;1191                         pcb->unsent != NULL);
;;;1192           }
;;;1193         }
;;;1194   
;;;1195         /* If there's nothing left to acknowledge, stop the retransmit
;;;1196            timer, otherwise reset it to start again */
;;;1197         if (pcb->unacked == NULL) {
0001f4  6ee0              LDR      r0,[r4,#0x6c]
0001f6  b120              CBZ      r0,|L8.514|
;;;1198           pcb->rtime = -1;
;;;1199         } else {
;;;1200           pcb->rtime = 0;
0001f8  f8a49030          STRH     r9,[r4,#0x30]
                  |L8.508|
;;;1201         }
;;;1202   
;;;1203         pcb->polltmr = 0;
0001fc  f884901b          STRB     r9,[r4,#0x1b]
000200  e036              B        |L8.624|
                  |L8.514|
000202  f04f30ff          MOV      r0,#0xffffffff        ;1198
000206  8620              STRH     r0,[r4,#0x30]         ;1198
000208  e7f8              B        |L8.508|
                  |L8.522|
;;;1204   
;;;1205   #if LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS
;;;1206         if (ip_current_is_v6()) {
;;;1207           /* Inform neighbor reachability of forward progress. */
;;;1208           nd6_reachability_hint(ip6_current_src_addr());
;;;1209         }
;;;1210   #endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/
;;;1211       } else {
;;;1212         /* Out of sequence ACK, didn't really ack anything */
;;;1213         tcp_send_empty_ack(pcb);
00020a  4620              MOV      r0,r4
00020c  f7fffffe          BL       tcp_send_empty_ack
000210  e02e              B        |L8.624|
                  |L8.530|
;;;1214       }
;;;1215   
;;;1216       /* We go through the ->unsent list to see if any of the segments
;;;1217          on the list are acknowledged by the ACK. This may seem
;;;1218          strange since an "unsent" segment shouldn't be acked. The
;;;1219          rationale is that lwIP puts all outstanding segments on the
;;;1220          ->unsent list after a retransmission, so these segments may
;;;1221          in fact have been sent once. */
;;;1222       while (pcb->unsent != NULL &&
;;;1223              TCP_SEQ_BETWEEN(ackno, lwip_ntohl(pcb->unsent->tcphdr->seqno) +
;;;1224                              TCP_TCPLEN(pcb->unsent), pcb->snd_nxt)) {
;;;1225         LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
;;;1226                                       lwip_ntohl(pcb->unsent->tcphdr->seqno), lwip_ntohl(pcb->unsent->tcphdr->seqno) +
;;;1227                                       TCP_TCPLEN(pcb->unsent)));
;;;1228   
;;;1229         next = pcb->unsent;
;;;1230         pcb->unsent = pcb->unsent->next;
000212  6828              LDR      r0,[r5,#0]
000214  66a0              STR      r0,[r4,#0x68]
;;;1231   #if TCP_OVERSIZE
;;;1232         if (pcb->unsent == NULL) {
000216  b908              CBNZ     r0,|L8.540|
;;;1233           pcb->unsent_oversize = 0;
000218  f8a49064          STRH     r9,[r4,#0x64]
                  |L8.540|
;;;1234         }
;;;1235   #endif /* TCP_OVERSIZE */
;;;1236         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"TCPWNDSIZE_F" ... ", (tcpwnd_size_t)pcb->snd_queuelen));
;;;1237         LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
00021c  6868              LDR      r0,[r5,#4]
00021e  f7fffffe          BL       pbuf_clen
000222  f8b41062          LDRH     r1,[r4,#0x62]
000226  4288              CMP      r0,r1
000228  d906              BLS      |L8.568|
00022a  a35c              ADR      r3,|L8.924|
00022c  f24042d5          MOV      r2,#0x4d5
000230  a179              ADR      r1,|L8.1048|
000232  a06e              ADR      r0,|L8.1004|
000234  f7fffffe          BL       __2printf
                  |L8.568|
;;;1238         /* Prevent ACK for FIN to generate a sent event */
;;;1239         pcb->snd_queuelen -= pbuf_clen(next->p);
000238  6868              LDR      r0,[r5,#4]
00023a  f7fffffe          BL       pbuf_clen
00023e  f8341f62          LDRH     r1,[r4,#0x62]!
000242  1a08              SUBS     r0,r1,r0
000244  8020              STRH     r0,[r4,#0]
;;;1240         recv_acked += next->len;
000246  8928              LDRH     r0,[r5,#8]
000248  8939              LDRH     r1,[r7,#8]  ; recv_acked
00024a  4408              ADD      r0,r0,r1
00024c  8138              STRH     r0,[r7,#8]
;;;1241         tcp_seg_free(next);
00024e  4628              MOV      r0,r5
000250  f7fffffe          BL       tcp_seg_free
;;;1242         LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"TCPWNDSIZE_F" (after freeing unsent)\n", (tcpwnd_size_t)pcb->snd_queuelen));
;;;1243         if (pcb->snd_queuelen != 0) {
000254  f8340962          LDRH     r0,[r4],#-0x62
000258  b150              CBZ      r0,|L8.624|
;;;1244           LWIP_ASSERT("tcp_receive: valid queue length",
00025a  6ee0              LDR      r0,[r4,#0x6c]
00025c  b940              CBNZ     r0,|L8.624|
00025e  6ea0              LDR      r0,[r4,#0x68]
000260  b930              CBNZ     r0,|L8.624|
000262  a34e              ADR      r3,|L8.924|
000264  f24042dc          MOV      r2,#0x4dc
000268  a175              ADR      r1,|L8.1088|
00026a  a060              ADR      r0,|L8.1004|
00026c  f7fffffe          BL       __2printf
                  |L8.624|
000270  6ea0              LDR      r0,[r4,#0x68]         ;1222
000272  b1c8              CBZ      r0,|L8.680|
000274  68c0              LDR      r0,[r0,#0xc]          ;1223
000276  6840              LDR      r0,[r0,#4]            ;1223
000278  f7fffffe          BL       lwip_htonl
00027c  4605              MOV      r5,r0                 ;1223
00027e  6ea0              LDR      r0,[r4,#0x68]         ;1223
000280  68c0              LDR      r0,[r0,#0xc]          ;1223
000282  8980              LDRH     r0,[r0,#0xc]          ;1223
000284  f7fffffe          BL       lwip_htons
000288  0780              LSLS     r0,r0,#30             ;1223
00028a  d001              BEQ      |L8.656|
00028c  2001              MOVS     r0,#1                 ;1223
00028e  e000              B        |L8.658|
                  |L8.656|
000290  2000              MOVS     r0,#0                 ;1223
                  |L8.658|
000292  4428              ADD      r0,r0,r5              ;1223
000294  6ea5              LDR      r5,[r4,#0x68]         ;1223
000296  8929              LDRH     r1,[r5,#8]            ;1223
000298  4401              ADD      r1,r1,r0              ;1223
00029a  69b8              LDR      r0,[r7,#0x18]         ;1223  ; ackno
00029c  1a41              SUBS     r1,r0,r1              ;1223
00029e  d403              BMI      |L8.680|
0002a0  6ce1              LDR      r1,[r4,#0x4c]         ;1223
0002a2  1a40              SUBS     r0,r0,r1              ;1223
0002a4  2800              CMP      r0,#0                 ;1223
0002a6  ddb4              BLE      |L8.530|
                  |L8.680|
;;;1245             pcb->unacked != NULL || pcb->unsent != NULL);
;;;1246         }
;;;1247       }
;;;1248       pcb->snd_buf += recv_acked;
0002a8  f8b40060          LDRH     r0,[r4,#0x60]
0002ac  8939              LDRH     r1,[r7,#8]  ; recv_acked
0002ae  4408              ADD      r0,r0,r1
0002b0  f8a40060          STRH     r0,[r4,#0x60]
;;;1249       /* End of ACK for new data processing. */
;;;1250   
;;;1251       LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: pcb->rttest %"U32_F" rtseq %"U32_F" ackno %"U32_F"\n",
;;;1252                                   pcb->rttest, pcb->rtseq, ackno));
;;;1253   
;;;1254       /* RTT estimation calculations. This is done by checking if the
;;;1255          incoming segment acknowledges the segment we use to take a
;;;1256          round-trip time measurement. */
;;;1257       if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
0002b4  6b60              LDR      r0,[r4,#0x34]
0002b6  b1f0              CBZ      r0,|L8.758|
0002b8  6ba1              LDR      r1,[r4,#0x38]
0002ba  69ba              LDR      r2,[r7,#0x18]  ; ackno
0002bc  1a89              SUBS     r1,r1,r2
0002be  d51a              BPL      |L8.758|
;;;1258         /* diff between this shouldn't exceed 32K since this are tcp timer ticks
;;;1259            and a round-trip shouldn't be that long... */
;;;1260         m = (s16_t)(tcp_ticks - pcb->rttest);
0002c0  4967              LDR      r1,|L8.1120|
0002c2  8809              LDRH     r1,[r1,#0]  ; tcp_ticks
0002c4  1a08              SUBS     r0,r1,r0
;;;1261   
;;;1262         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
;;;1263                                     m, (u16_t)(m * TCP_SLOW_INTERVAL)));
;;;1264   
;;;1265         /* This is taken directly from VJs original code in his paper */
;;;1266         m = m - (pcb->sa >> 3);
0002c6  f9b4103c          LDRSH    r1,[r4,#0x3c]
0002ca  eba000e1          SUB      r0,r0,r1,ASR #3
0002ce  b200              SXTH     r0,r0
;;;1267         pcb->sa += m;
0002d0  4401              ADD      r1,r1,r0
0002d2  b20a              SXTH     r2,r1
0002d4  87a2              STRH     r2,[r4,#0x3c]
;;;1268         if (m < 0) {
0002d6  2800              CMP      r0,#0
0002d8  da01              BGE      |L8.734|
;;;1269           m = -m;
0002da  4240              RSBS     r0,r0,#0
0002dc  b200              SXTH     r0,r0
                  |L8.734|
;;;1270         }
;;;1271         m = m - (pcb->sv >> 2);
0002de  f9b4103e          LDRSH    r1,[r4,#0x3e]
0002e2  eba000a1          SUB      r0,r0,r1,ASR #2
;;;1272         pcb->sv += m;
0002e6  4408              ADD      r0,r0,r1
0002e8  87e0              STRH     r0,[r4,#0x3e]
;;;1273         pcb->rto = (pcb->sa >> 3) + pcb->sv;
0002ea  eb0000e2          ADD      r0,r0,r2,ASR #3
0002ee  f8a40040          STRH     r0,[r4,#0x40]
;;;1274   
;;;1275         LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
;;;1276                                     pcb->rto, (u16_t)(pcb->rto * TCP_SLOW_INTERVAL)));
;;;1277   
;;;1278         pcb->rttest = 0;
0002f2  f8c49034          STR      r9,[r4,#0x34]
                  |L8.758|
;;;1279       }
;;;1280     }
;;;1281   
;;;1282     /* If the incoming segment contains data, we must process it
;;;1283        further unless the pcb already received a FIN.
;;;1284        (RFC 793, chapter 3.9, "SEGMENT ARRIVES" in states CLOSE-WAIT, CLOSING,
;;;1285        LAST-ACK and TIME-WAIT: "Ignore the segment text.") */
;;;1286     if ((tcplen > 0) && (pcb->state < CLOSE_WAIT)) {
0002f6  897a              LDRH     r2,[r7,#0xa]  ; tcplen
0002f8  2a00              CMP      r2,#0
0002fa  d04a              BEQ      |L8.914|
0002fc  7d20              LDRB     r0,[r4,#0x14]
0002fe  2807              CMP      r0,#7
000300  d247              BCS      |L8.914|
;;;1287       /* This code basically does three things:
;;;1288   
;;;1289       +) If the incoming segment contains data that is the next
;;;1290       in-sequence data, this data is passed to the application. This
;;;1291       might involve trimming the first edge of the data. The rcv_nxt
;;;1292       variable and the advertised window are adjusted.
;;;1293   
;;;1294       +) If the incoming segment has data that is above the next
;;;1295       sequence number expected (->rcv_nxt), the segment is placed on
;;;1296       the ->ooseq queue. This is done by finding the appropriate
;;;1297       place in the ->ooseq queue (which is ordered by sequence
;;;1298       number) and trim the segment in both ends if needed. An
;;;1299       immediate ACK is sent to indicate that we received an
;;;1300       out-of-sequence segment.
;;;1301   
;;;1302       +) Finally, we check if the first segment on the ->ooseq queue
;;;1303       now is in sequence (i.e., if rcv_nxt >= ooseq->seqno). If
;;;1304       rcv_nxt > ooseq->seqno, we must trim the first edge of the
;;;1305       segment on ->ooseq before we adjust rcv_nxt. The data in the
;;;1306       segments that are now on sequence are chained onto the
;;;1307       incoming segment so that we only need to call the application
;;;1308       once.
;;;1309       */
;;;1310   
;;;1311       /* First, we check if we must trim the first edge. We have to do
;;;1312          this if the sequence number of the incoming segment is less
;;;1313          than rcv_nxt, and the sequence number plus the length of the
;;;1314          segment is larger than rcv_nxt. */
;;;1315       /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
;;;1316             if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
;;;1317       if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)) {
000302  6a60              LDR      r0,[r4,#0x24]
000304  6979              LDR      r1,[r7,#0x14]  ; seqno
;;;1318         /* Trimming the first edge is done by pushing the payload
;;;1319            pointer in the pbuf downwards. This is somewhat tricky since
;;;1320            we do not want to discard the full contents of the pbuf up to
;;;1321            the new starting point of the data since we have to keep the
;;;1322            TCP header which is present in the first pbuf in the chain.
;;;1323   
;;;1324            What is done is really quite a nasty hack: the first pbuf in
;;;1325            the pbuf chain is pointed to by inseg.p. Since we need to be
;;;1326            able to deallocate the whole pbuf, we cannot change this
;;;1327            inseg.p pointer to point to any of the later pbufs in the
;;;1328            chain. Instead, we point the ->payload pointer in the first
;;;1329            pbuf to data in one of the later pbufs. We also set the
;;;1330            inseg.data pointer to point to the right place. This way, the
;;;1331            ->p pointer will still point to the first pbuf, but the
;;;1332            ->p->payload pointer will point to data in another pbuf.
;;;1333   
;;;1334            After we are done with adjusting the pbuf pointers we must
;;;1335            adjust the ->data pointer in the seg and the segment
;;;1336            length.*/
;;;1337   
;;;1338         struct pbuf *p = inseg.p;
000306  f8df815c          LDR      r8,|L8.1124|
00030a  1a45              SUBS     r5,r0,r1              ;1317
00030c  2d01              CMP      r5,#1                 ;1317
00030e  d442              BMI      |L8.918|
000310  440a              ADD      r2,r2,r1              ;1317
000312  1a82              SUBS     r2,r0,r2              ;1317
000314  1c52              ADDS     r2,r2,#1              ;1317
000316  2a00              CMP      r2,#0                 ;1317
000318  dc3d              BGT      |L8.918|
00031a  f8d86004          LDR      r6,[r8,#4]  ; inseg
;;;1339         off = pcb->rcv_nxt - seqno;
;;;1340         LWIP_ASSERT("inseg.p != NULL", inseg.p);
00031e  b936              CBNZ     r6,|L8.814|
000320  a31e              ADR      r3,|L8.924|
000322  f240523c          MOV      r2,#0x53c
000326  a150              ADR      r1,|L8.1128|
000328  a030              ADR      r0,|L8.1004|
00032a  f7fffffe          BL       __2printf
                  |L8.814|
;;;1341         LWIP_ASSERT("insane offset!", (off < 0x7fff));
00032e  f64770ff          MOV      r0,#0x7fff
000332  4285              CMP      r5,r0
000334  db06              BLT      |L8.836|
000336  a319              ADR      r3,|L8.924|
000338  f240523d          MOV      r2,#0x53d
00033c  a14e              ADR      r1,|L8.1144|
00033e  a02b              ADR      r0,|L8.1004|
000340  f7fffffe          BL       __2printf
                  |L8.836|
;;;1342         if (inseg.p->len < off) {
000344  f8d80004          LDR      r0,[r8,#4]  ; inseg
000348  8941              LDRH     r1,[r0,#0xa]
00034a  42a9              CMP      r1,r5
00034c  da24              BGE      |L8.920|
;;;1343           LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
00034e  8900              LDRH     r0,[r0,#8]
000350  42a8              CMP      r0,r5
000352  da06              BGE      |L8.866|
000354  a311              ADR      r3,|L8.924|
000356  f240523f          MOV      r2,#0x53f
00035a  a14b              ADR      r1,|L8.1160|
00035c  a023              ADR      r0,|L8.1004|
00035e  f7fffffe          BL       __2printf
                  |L8.866|
;;;1344           new_tot_len = (u16_t)(inseg.p->tot_len - off);
000362  f8d80004          LDR      r0,[r8,#4]  ; inseg
000366  8900              LDRH     r0,[r0,#8]
000368  1b40              SUBS     r0,r0,r5
00036a  b281              UXTH     r1,r0
;;;1345           while (p->len < off) {
00036c  e004              B        |L8.888|
                  |L8.878|
;;;1346             off -= p->len;
00036e  1a2d              SUBS     r5,r5,r0
;;;1347             /* KJM following line changed (with addition of new_tot_len var)
;;;1348                to fix bug #9076
;;;1349                inseg.p->tot_len -= p->len; */
;;;1350             p->tot_len = new_tot_len;
000370  8131              STRH     r1,[r6,#8]
;;;1351             p->len = 0;
000372  f8a6900a          STRH     r9,[r6,#0xa]
;;;1352             p = p->next;
000376  6836              LDR      r6,[r6,#0]
                  |L8.888|
000378  8970              LDRH     r0,[r6,#0xa]          ;1345
00037a  42a8              CMP      r0,r5                 ;1345
00037c  dbf7              BLT      |L8.878|
;;;1353           }
;;;1354           if (pbuf_header(p, (s16_t)-off)) {
00037e  4268              RSBS     r0,r5,#0
000380  b201              SXTH     r1,r0
000382  4630              MOV      r0,r6
000384  f7fffffe          BL       pbuf_header
000388  b120              CBZ      r0,|L8.916|
;;;1355             /* Do we need to cope with this failing?  Assert for now */
;;;1356             LWIP_ASSERT("pbuf_header failed", 0);
00038a  a304              ADR      r3,|L8.924|
00038c  f240524c          MOV      r2,#0x54c
000390  e082              B        |L8.1176|
                  |L8.914|
000392  e36a              B        |L8.2666|
                  |L8.916|
000394  e094              B        |L8.1216|
                  |L8.918|
000396  e0a0              B        |L8.1242|
                  |L8.920|
000398  e084              B        |L8.1188|
00039a  0000              DCW      0x0000
                  |L8.924|
00039c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_in.c"
0003a0  6964646c
0003a4  65776172
0003a8  65735c54
0003ac  68697264
0003b0  5f506172
0003b4  74795c4c
0003b8  7749505c
0003bc  7372635c
0003c0  636f7265
0003c4  5c746370
0003c8  5f696e2e
0003cc  63      
0003cd  00                DCB      0
0003ce  00                DCB      0
0003cf  00                DCB      0
                  |L8.976|
0003d0  7463705f          DCB      "tcp_receive: wrong state",0
0003d4  72656365
0003d8  6976653a
0003dc  2077726f
0003e0  6e672073
0003e4  74617465
0003e8  00      
0003e9  00                DCB      0
0003ea  00                DCB      0
0003eb  00                DCB      0
                  |L8.1004|
0003ec  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0003f0  7274696f
0003f4  6e202225
0003f8  73222066
0003fc  61696c65
000400  64206174
000404  206c696e
000408  65202564
00040c  20696e20
000410  25730a00
                  |L8.1044|
                          DCD      ||.data||
                  |L8.1048|
000418  7063622d          DCB      "pcb->snd_queuelen >= pbuf_clen(next->p)",0
00041c  3e736e64
000420  5f717565
000424  75656c65
000428  6e203e3d
00042c  20706275
000430  665f636c
000434  656e286e
000438  6578742d
00043c  3e702900
                  |L8.1088|
000440  7463705f          DCB      "tcp_receive: valid queue length",0
000444  72656365
000448  6976653a
00044c  2076616c
000450  69642071
000454  75657565
000458  206c656e
00045c  67746800
                  |L8.1120|
                          DCD      tcp_ticks
                  |L8.1124|
                          DCD      ||.bss||
                  |L8.1128|
000468  696e7365          DCB      "inseg.p != NULL",0
00046c  672e7020
000470  213d204e
000474  554c4c00
                  |L8.1144|
000478  696e7361          DCB      "insane offset!",0
00047c  6e65206f
000480  66667365
000484  742100  
000487  00                DCB      0
                  |L8.1160|
000488  70627566          DCB      "pbuf too short!",0
00048c  20746f6f
000490  2073686f
000494  72742100
                  |L8.1176|
000498  a1fe              ADR      r1,|L8.2196|
00049a  f2af00b0          ADR      r0,|L8.1004|
00049e  f7fffffe          BL       __2printf
0004a2  e00d              B        |L8.1216|
                  |L8.1188|
;;;1357           }
;;;1358         } else {
;;;1359           if (pbuf_header(inseg.p, (s16_t)-off)) {
0004a4  4269              RSBS     r1,r5,#0
0004a6  b209              SXTH     r1,r1
0004a8  f7fffffe          BL       pbuf_header
0004ac  b140              CBZ      r0,|L8.1216|
;;;1360             /* Do we need to cope with this failing?  Assert for now */
;;;1361             LWIP_ASSERT("pbuf_header failed", 0);
0004ae  f2af1314          ADR      r3,|L8.924|
0004b2  f2405251          MOV      r2,#0x551
0004b6  a1f7              ADR      r1,|L8.2196|
0004b8  f2af00d0          ADR      r0,|L8.1004|
0004bc  f7fffffe          BL       __2printf
                  |L8.1216|
;;;1362           }
;;;1363         }
;;;1364         inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
0004c0  8aba              LDRH     r2,[r7,#0x14]  ; seqno
0004c2  6a60              LDR      r0,[r4,#0x24]
0004c4  f8b81008          LDRH     r1,[r8,#8]  ; inseg
0004c8  1a82              SUBS     r2,r0,r2
0004ca  1a89              SUBS     r1,r1,r2
0004cc  f8a81008          STRH     r1,[r8,#8]
;;;1365         inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
0004d0  6178              STR      r0,[r7,#0x14]  ; seqno
0004d2  f8d8100c          LDR      r1,[r8,#0xc]  ; inseg
0004d6  6048              STR      r0,[r1,#4]
;;;1366       }
0004d8  e005              B        |L8.1254|
                  |L8.1242|
;;;1367       else {
;;;1368         if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)) {
0004da  1a08              SUBS     r0,r1,r0
0004dc  d503              BPL      |L8.1254|
;;;1369           /* the whole segment is < rcv_nxt */
;;;1370           /* must be a duplicate of a packet that has already been correctly handled */
;;;1371   
;;;1372           LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
;;;1373           tcp_ack_now(pcb);
0004de  7ea0              LDRB     r0,[r4,#0x1a]
0004e0  f0400002          ORR      r0,r0,#2
0004e4  76a0              STRB     r0,[r4,#0x1a]
                  |L8.1254|
;;;1374         }
;;;1375       }
;;;1376   
;;;1377       /* The sequence number must be within the window (above rcv_nxt
;;;1378          and below rcv_nxt + rcv_wnd) in order to be further
;;;1379          processed. */
;;;1380       if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt,
0004e6  6a60              LDR      r0,[r4,#0x24]
0004e8  6979              LDR      r1,[r7,#0x14]  ; seqno
0004ea  1a0a              SUBS     r2,r1,r0
0004ec  d471              BMI      |L8.1490|
0004ee  8d22              LDRH     r2,[r4,#0x28]
0004f0  4402              ADD      r2,r2,r0
0004f2  1a8a              SUBS     r2,r1,r2
0004f4  1c52              ADDS     r2,r2,#1
0004f6  2a00              CMP      r2,#0
0004f8  dc6b              BGT      |L8.1490|
;;;1381                           pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
;;;1382         if (pcb->rcv_nxt == seqno) {
0004fa  4288              CMP      r0,r1
0004fc  d16a              BNE      |L8.1492|
;;;1383           /* The incoming segment is the next in sequence. We check if
;;;1384              we have to trim the end of the segment and update rcv_nxt
;;;1385              and pass the data to the application. */
;;;1386           tcplen = TCP_TCPLEN(&inseg);
0004fe  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
000502  8980              LDRH     r0,[r0,#0xc]
000504  f7fffffe          BL       lwip_htons
000508  0780              LSLS     r0,r0,#30
00050a  d001              BEQ      |L8.1296|
00050c  2001              MOVS     r0,#1
00050e  e000              B        |L8.1298|
                  |L8.1296|
000510  2000              MOVS     r0,#0
                  |L8.1298|
000512  f8b81008          LDRH     r1,[r8,#8]  ; inseg
000516  4408              ADD      r0,r0,r1
000518  b280              UXTH     r0,r0
00051a  8178              STRH     r0,[r7,#0xa]
;;;1387   
;;;1388           if (tcplen > pcb->rcv_wnd) {
00051c  8d21              LDRH     r1,[r4,#0x28]
00051e  4281              CMP      r1,r0
000520  d24c              BCS      |L8.1468|
;;;1389             LWIP_DEBUGF(TCP_INPUT_DEBUG,
;;;1390                         ("tcp_receive: other end overran receive window"
;;;1391                          "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1392                          seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1393             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
000522  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
000526  8980              LDRH     r0,[r0,#0xc]
000528  f7fffffe          BL       lwip_htons
00052c  07c0              LSLS     r0,r0,#31
00052e  d011              BEQ      |L8.1364|
;;;1394               /* Must remove the FIN from the header as we're trimming
;;;1395                * that byte of sequence-space from the packet */
;;;1396               TCPH_FLAGS_SET(inseg.tcphdr, TCPH_FLAGS(inseg.tcphdr) & ~(unsigned int)TCP_FIN);
000530  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
000534  8980              LDRH     r0,[r0,#0xc]
000536  f7fffffe          BL       lwip_htons
00053a  f3c00044          UBFX     r0,r0,#1,#5
00053e  0040              LSLS     r0,r0,#1
000540  f7fffffe          BL       lwip_htons
000544  4601              MOV      r1,r0
000546  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
00054a  8982              LDRH     r2,[r0,#0xc]
00054c  f422527c          BIC      r2,r2,#0x3f00
000550  4311              ORRS     r1,r1,r2
000552  8181              STRH     r1,[r0,#0xc]
                  |L8.1364|
;;;1397             }
;;;1398             /* Adjust length of segment to fit in the window. */
;;;1399             TCPWND_CHECK16(pcb->rcv_wnd);
;;;1400             inseg.len = (u16_t)pcb->rcv_wnd;
000554  8d20              LDRH     r0,[r4,#0x28]
000556  f8a80008          STRH     r0,[r8,#8]
;;;1401             if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
00055a  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
00055e  8980              LDRH     r0,[r0,#0xc]
000560  f7fffffe          BL       lwip_htons
000564  0780              LSLS     r0,r0,#30
000566  d504              BPL      |L8.1394|
;;;1402               inseg.len -= 1;
000568  f8b80008          LDRH     r0,[r8,#8]  ; inseg
00056c  1e40              SUBS     r0,r0,#1
00056e  f8a80008          STRH     r0,[r8,#8]
                  |L8.1394|
;;;1403             }
;;;1404             pbuf_realloc(inseg.p, inseg.len);
000572  f8b81008          LDRH     r1,[r8,#8]  ; inseg
000576  f8d80004          LDR      r0,[r8,#4]  ; inseg
00057a  f7fffffe          BL       pbuf_realloc
;;;1405             tcplen = TCP_TCPLEN(&inseg);
00057e  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
000582  8980              LDRH     r0,[r0,#0xc]
000584  f7fffffe          BL       lwip_htons
000588  0780              LSLS     r0,r0,#30
00058a  d001              BEQ      |L8.1424|
00058c  2001              MOVS     r0,#1
00058e  e000              B        |L8.1426|
                  |L8.1424|
000590  2000              MOVS     r0,#0
                  |L8.1426|
000592  f8b81008          LDRH     r1,[r8,#8]  ; inseg
000596  4408              ADD      r0,r0,r1
000598  b280              UXTH     r0,r0
00059a  8178              STRH     r0,[r7,#0xa]
;;;1406             LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
00059c  8d22              LDRH     r2,[r4,#0x28]
00059e  6a61              LDR      r1,[r4,#0x24]
0005a0  4411              ADD      r1,r1,r2
0005a2  697a              LDR      r2,[r7,#0x14]  ; seqno
0005a4  4410              ADD      r0,r0,r2
0005a6  4288              CMP      r0,r1
0005a8  d008              BEQ      |L8.1468|
0005aa  f2af2310          ADR      r3,|L8.924|
0005ae  f240527e          MOV      r2,#0x57e
0005b2  a1bd              ADR      r1,|L8.2216|
0005b4  f2af10cc          ADR      r0,|L8.1004|
0005b8  f7fffffe          BL       __2printf
                  |L8.1468|
;;;1407                         (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1408           }
;;;1409   #if TCP_QUEUE_OOSEQ
;;;1410           /* Received in-sequence data, adjust ooseq data if:
;;;1411              - FIN has been received or
;;;1412              - inseq overlaps with ooseq */
;;;1413           if (pcb->ooseq != NULL) {
0005bc  6f20              LDR      r0,[r4,#0x70]
0005be  2800              CMP      r0,#0
0005c0  d07d              BEQ      |L8.1726|
;;;1414             if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
0005c2  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
0005c6  8980              LDRH     r0,[r0,#0xc]
0005c8  f7fffffe          BL       lwip_htons
0005cc  07c0              LSLS     r0,r0,#31
0005ce  d106              BNE      |L8.1502|
0005d0  e009              B        |L8.1510|
                  |L8.1490|
0005d2  e245              B        |L8.2656|
                  |L8.1492|
0005d4  e107              B        |L8.2022|
                  |L8.1494|
;;;1415               LWIP_DEBUGF(TCP_INPUT_DEBUG,
;;;1416                           ("tcp_receive: received in-order FIN, binning ooseq queue\n"));
;;;1417               /* Received in-order FIN means anything that was received
;;;1418                * out of order must now have been received in-order, so
;;;1419                * bin the ooseq queue */
;;;1420               while (pcb->ooseq != NULL) {
;;;1421                 struct tcp_seg *old_ooseq = pcb->ooseq;
;;;1422                 pcb->ooseq = pcb->ooseq->next;
0005d6  6801              LDR      r1,[r0,#0]
0005d8  6721              STR      r1,[r4,#0x70]
;;;1423                 tcp_seg_free(old_ooseq);
0005da  f7fffffe          BL       tcp_seg_free
                  |L8.1502|
0005de  6f20              LDR      r0,[r4,#0x70]         ;1420
0005e0  2800              CMP      r0,#0                 ;1420
0005e2  d1f8              BNE      |L8.1494|
0005e4  e06b              B        |L8.1726|
                  |L8.1510|
;;;1424               }
;;;1425             } else {
;;;1426               next = pcb->ooseq;
0005e6  6f25              LDR      r5,[r4,#0x70]
;;;1427               /* Remove all segments on ooseq that are covered by inseg already.
;;;1428                * FIN is copied from ooseq to inseg if present. */
;;;1429               while (next &&
0005e8  e022              B        |L8.1584|
                  |L8.1514|
;;;1430                      TCP_SEQ_GEQ(seqno + tcplen,
;;;1431                                  next->tcphdr->seqno + next->len)) {
;;;1432                 /* inseg cannot have FIN here (already processed above) */
;;;1433                 if ((TCPH_FLAGS(next->tcphdr) & TCP_FIN) != 0 &&
0005ea  8980              LDRH     r0,[r0,#0xc]
0005ec  f7fffffe          BL       lwip_htons
0005f0  07c0              LSLS     r0,r0,#31
0005f2  d019              BEQ      |L8.1576|
;;;1434                     (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) == 0) {
0005f4  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
0005f8  8980              LDRH     r0,[r0,#0xc]
0005fa  f7fffffe          BL       lwip_htons
0005fe  0780              LSLS     r0,r0,#30
000600  d412              BMI      |L8.1576|
;;;1435                   TCPH_SET_FLAG(inseg.tcphdr, TCP_FIN);
000602  2001              MOVS     r0,#1
000604  f7fffffe          BL       lwip_htons
000608  f8d8100c          LDR      r1,[r8,#0xc]  ; inseg
00060c  898a              LDRH     r2,[r1,#0xc]
00060e  4310              ORRS     r0,r0,r2
000610  8188              STRH     r0,[r1,#0xc]
;;;1436                   tcplen = TCP_TCPLEN(&inseg);
000612  f7fffffe          BL       lwip_htons
000616  0780              LSLS     r0,r0,#30
000618  d001              BEQ      |L8.1566|
00061a  2001              MOVS     r0,#1
00061c  e000              B        |L8.1568|
                  |L8.1566|
00061e  2000              MOVS     r0,#0
                  |L8.1568|
000620  f8b81008          LDRH     r1,[r8,#8]  ; inseg
000624  4408              ADD      r0,r0,r1
000626  8178              STRH     r0,[r7,#0xa]
                  |L8.1576|
;;;1437                 }
;;;1438                 prev = next;
;;;1439                 next = next->next;
000628  4628              MOV      r0,r5
00062a  682d              LDR      r5,[r5,#0]
;;;1440                 tcp_seg_free(prev);
00062c  f7fffffe          BL       tcp_seg_free
                  |L8.1584|
000630  b145              CBZ      r5,|L8.1604|
000632  68e8              LDR      r0,[r5,#0xc]          ;1430
000634  892a              LDRH     r2,[r5,#8]            ;1430
000636  897b              LDRH     r3,[r7,#0xa]          ;1430  ; tcplen
000638  6841              LDR      r1,[r0,#4]            ;1430
00063a  4411              ADD      r1,r1,r2              ;1430
00063c  697a              LDR      r2,[r7,#0x14]         ;1430  ; seqno
00063e  441a              ADD      r2,r2,r3              ;1430
000640  1a51              SUBS     r1,r2,r1              ;1430
000642  d5d2              BPL      |L8.1514|
                  |L8.1604|
;;;1441               }
;;;1442               /* Now trim right side of inseg if it overlaps with the first
;;;1443                * segment on ooseq */
;;;1444               if (next &&
000644  b3d5              CBZ      r5,|L8.1724|
;;;1445                   TCP_SEQ_GT(seqno + tcplen,
000646  8978              LDRH     r0,[r7,#0xa]  ; tcplen
000648  6979              LDR      r1,[r7,#0x14]  ; seqno
00064a  180a              ADDS     r2,r1,r0
00064c  68e8              LDR      r0,[r5,#0xc]
00064e  6840              LDR      r0,[r0,#4]
000650  1a12              SUBS     r2,r2,r0
000652  2a00              CMP      r2,#0
000654  dd32              BLE      |L8.1724|
;;;1446                              next->tcphdr->seqno)) {
;;;1447                 /* inseg cannot have FIN here (already processed above) */
;;;1448                 inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
000656  1a40              SUBS     r0,r0,r1
000658  f8a80008          STRH     r0,[r8,#8]
;;;1449                 if (TCPH_FLAGS(inseg.tcphdr) & TCP_SYN) {
00065c  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
000660  8980              LDRH     r0,[r0,#0xc]
000662  f7fffffe          BL       lwip_htons
000666  0780              LSLS     r0,r0,#30
000668  d504              BPL      |L8.1652|
;;;1450                   inseg.len -= 1;
00066a  f8b80008          LDRH     r0,[r8,#8]  ; inseg
00066e  1e40              SUBS     r0,r0,#1
000670  f8a80008          STRH     r0,[r8,#8]
                  |L8.1652|
;;;1451                 }
;;;1452                 pbuf_realloc(inseg.p, inseg.len);
000674  f8b81008          LDRH     r1,[r8,#8]  ; inseg
000678  f8d80004          LDR      r0,[r8,#4]  ; inseg
00067c  f7fffffe          BL       pbuf_realloc
;;;1453                 tcplen = TCP_TCPLEN(&inseg);
000680  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
000684  8980              LDRH     r0,[r0,#0xc]
000686  f7fffffe          BL       lwip_htons
00068a  0780              LSLS     r0,r0,#30
00068c  d001              BEQ      |L8.1682|
00068e  2001              MOVS     r0,#1
000690  e000              B        |L8.1684|
                  |L8.1682|
000692  2000              MOVS     r0,#0
                  |L8.1684|
000694  f8b81008          LDRH     r1,[r8,#8]  ; inseg
000698  4408              ADD      r0,r0,r1
00069a  b280              UXTH     r0,r0
00069c  8178              STRH     r0,[r7,#0xa]
;;;1454                 LWIP_ASSERT("tcp_receive: segment not trimmed correctly to ooseq queue\n",
00069e  6979              LDR      r1,[r7,#0x14]  ; seqno
0006a0  4408              ADD      r0,r0,r1
0006a2  68e9              LDR      r1,[r5,#0xc]
0006a4  6849              LDR      r1,[r1,#4]
0006a6  4288              CMP      r0,r1
0006a8  d008              BEQ      |L8.1724|
0006aa  f2af3310          ADR      r3,|L8.924|
0006ae  f24052ae          MOV      r2,#0x5ae
0006b2  a18b              ADR      r1,|L8.2272|
0006b4  f2af20cc          ADR      r0,|L8.1004|
0006b8  f7fffffe          BL       __2printf
                  |L8.1724|
;;;1455                             (seqno + tcplen) == next->tcphdr->seqno);
;;;1456               }
;;;1457               pcb->ooseq = next;
0006bc  6725              STR      r5,[r4,#0x70]
                  |L8.1726|
;;;1458             }
;;;1459           }
;;;1460   #endif /* TCP_QUEUE_OOSEQ */
;;;1461   
;;;1462           pcb->rcv_nxt = seqno + tcplen;
0006be  8978              LDRH     r0,[r7,#0xa]  ; tcplen
0006c0  6979              LDR      r1,[r7,#0x14]  ; seqno
0006c2  4401              ADD      r1,r1,r0
0006c4  6261              STR      r1,[r4,#0x24]
;;;1463   
;;;1464           /* Update the receiver's (our) window. */
;;;1465           LWIP_ASSERT("tcp_receive: tcplen > rcv_wnd\n", pcb->rcv_wnd >= tcplen);
0006c6  8d21              LDRH     r1,[r4,#0x28]
0006c8  4281              CMP      r1,r0
0006ca  d208              BCS      |L8.1758|
0006cc  f2af3334          ADR      r3,|L8.924|
0006d0  f24052b9          MOV      r2,#0x5b9
0006d4  a191              ADR      r1,|L8.2332|
0006d6  f2af20ec          ADR      r0,|L8.1004|
0006da  f7fffffe          BL       __2printf
                  |L8.1758|
;;;1466           pcb->rcv_wnd -= tcplen;
0006de  8d20              LDRH     r0,[r4,#0x28]
0006e0  8979              LDRH     r1,[r7,#0xa]  ; tcplen
0006e2  1a40              SUBS     r0,r0,r1
0006e4  8520              STRH     r0,[r4,#0x28]
;;;1467   
;;;1468           tcp_update_rcv_ann_wnd(pcb);
0006e6  4620              MOV      r0,r4
0006e8  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1469   
;;;1470           /* If there is data in the segment, we make preparations to
;;;1471              pass this up to the application. The ->recv_data variable
;;;1472              is used for holding the pbuf that goes to the
;;;1473              application. The code for reassembling out-of-sequence data
;;;1474              chains its data on this pbuf as well.
;;;1475   
;;;1476              If the segment was a FIN, we set the TF_GOT_FIN flag that will
;;;1477              be used to indicate to the application that the remote side has
;;;1478              closed its end of the connection. */
;;;1479           if (inseg.p->tot_len > 0) {
0006ec  f8d80004          LDR      r0,[r8,#4]  ; inseg
0006f0  8901              LDRH     r1,[r0,#8]
0006f2  b111              CBZ      r1,|L8.1786|
;;;1480             recv_data = inseg.p;
0006f4  61f8              STR      r0,[r7,#0x1c]  ; recv_data
;;;1481             /* Since this pbuf now is the responsibility of the
;;;1482                application, we delete our reference to it so that we won't
;;;1483                (mistakingly) deallocate it. */
;;;1484             inseg.p = NULL;
0006f6  f8c89004          STR      r9,[r8,#4]  ; inseg
                  |L8.1786|
;;;1485           }
;;;1486           if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
0006fa  f8d8000c          LDR      r0,[r8,#0xc]  ; inseg
0006fe  8980              LDRH     r0,[r0,#0xc]
000700  f7fffffe          BL       lwip_htons
000704  07c0              LSLS     r0,r0,#31
000706  d059              BEQ      |L8.1980|
;;;1487             LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
;;;1488             recv_flags |= TF_GOT_FIN;
000708  7878              LDRB     r0,[r7,#1]  ; recv_flags
00070a  f0400020          ORR      r0,r0,#0x20
00070e  7078              STRB     r0,[r7,#1]
000710  e054              B        |L8.1980|
                  |L8.1810|
;;;1489           }
;;;1490   
;;;1491   #if TCP_QUEUE_OOSEQ
;;;1492           /* We now check if we have segments on the ->ooseq queue that
;;;1493              are now in sequence. */
;;;1494           while (pcb->ooseq != NULL &&
;;;1495                  pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
;;;1496   
;;;1497             cseg = pcb->ooseq;
;;;1498             seqno = pcb->ooseq->tcphdr->seqno;
000712  6179              STR      r1,[r7,#0x14]  ; seqno
;;;1499   
;;;1500             pcb->rcv_nxt += TCP_TCPLEN(cseg);
000714  8980              LDRH     r0,[r0,#0xc]
000716  f7fffffe          BL       lwip_htons
00071a  0780              LSLS     r0,r0,#30
00071c  d001              BEQ      |L8.1826|
00071e  2001              MOVS     r0,#1
000720  e000              B        |L8.1828|
                  |L8.1826|
000722  2000              MOVS     r0,#0
                  |L8.1828|
000724  892a              LDRH     r2,[r5,#8]
000726  6a61              LDR      r1,[r4,#0x24]
000728  4411              ADD      r1,r1,r2
00072a  4408              ADD      r0,r0,r1
00072c  6260              STR      r0,[r4,#0x24]
;;;1501             LWIP_ASSERT("tcp_receive: ooseq tcplen > rcv_wnd\n",
00072e  68e8              LDR      r0,[r5,#0xc]
000730  8980              LDRH     r0,[r0,#0xc]
000732  f7fffffe          BL       lwip_htons
000736  0780              LSLS     r0,r0,#30
000738  d001              BEQ      |L8.1854|
00073a  2001              MOVS     r0,#1
00073c  e000              B        |L8.1856|
                  |L8.1854|
00073e  2000              MOVS     r0,#0
                  |L8.1856|
000740  8929              LDRH     r1,[r5,#8]
000742  4408              ADD      r0,r0,r1
000744  8d21              LDRH     r1,[r4,#0x28]
000746  4288              CMP      r0,r1
000748  d908              BLS      |L8.1884|
00074a  f2af33b0          ADR      r3,|L8.924|
00074e  f24052dd          MOV      r2,#0x5dd
000752  a17a              ADR      r1,|L8.2364|
000754  f2af306c          ADR      r0,|L8.1004|
000758  f7fffffe          BL       __2printf
                  |L8.1884|
;;;1502                         pcb->rcv_wnd >= TCP_TCPLEN(cseg));
;;;1503             pcb->rcv_wnd -= TCP_TCPLEN(cseg);
00075c  68e8              LDR      r0,[r5,#0xc]
00075e  8980              LDRH     r0,[r0,#0xc]
000760  f7fffffe          BL       lwip_htons
000764  0780              LSLS     r0,r0,#30
000766  d001              BEQ      |L8.1900|
000768  2001              MOVS     r0,#1
00076a  e000              B        |L8.1902|
                  |L8.1900|
00076c  2000              MOVS     r0,#0
                  |L8.1902|
00076e  8929              LDRH     r1,[r5,#8]
000770  4408              ADD      r0,r0,r1
000772  8d21              LDRH     r1,[r4,#0x28]
000774  1a08              SUBS     r0,r1,r0
000776  8520              STRH     r0,[r4,#0x28]
;;;1504   
;;;1505             tcp_update_rcv_ann_wnd(pcb);
000778  4620              MOV      r0,r4
00077a  f7fffffe          BL       tcp_update_rcv_ann_wnd
;;;1506   
;;;1507             if (cseg->p->tot_len > 0) {
00077e  6869              LDR      r1,[r5,#4]
000780  8908              LDRH     r0,[r1,#8]
000782  b138              CBZ      r0,|L8.1940|
;;;1508               /* Chain this pbuf onto the pbuf that we will pass to
;;;1509                  the application. */
;;;1510               /* With window scaling, this can overflow recv_data->tot_len, but
;;;1511                  that's not a problem since we explicitly fix that before passing
;;;1512                  recv_data to the application. */
;;;1513               if (recv_data) {
000784  69f8              LDR      r0,[r7,#0x1c]  ; recv_data
000786  b110              CBZ      r0,|L8.1934|
;;;1514                 pbuf_cat(recv_data, cseg->p);
000788  f7fffffe          BL       pbuf_cat
00078c  e000              B        |L8.1936|
                  |L8.1934|
;;;1515               } else {
;;;1516                 recv_data = cseg->p;
00078e  61f9              STR      r1,[r7,#0x1c]  ; recv_data
                  |L8.1936|
;;;1517               }
;;;1518               cseg->p = NULL;
000790  f8c59004          STR      r9,[r5,#4]
                  |L8.1940|
;;;1519             }
;;;1520             if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
000794  68e8              LDR      r0,[r5,#0xc]
000796  8980              LDRH     r0,[r0,#0xc]
000798  f7fffffe          BL       lwip_htons
00079c  07c0              LSLS     r0,r0,#31
00079e  d008              BEQ      |L8.1970|
;;;1521               LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
;;;1522               recv_flags |= TF_GOT_FIN;
0007a0  7878              LDRB     r0,[r7,#1]  ; recv_flags
0007a2  f0400020          ORR      r0,r0,#0x20
0007a6  7078              STRB     r0,[r7,#1]
;;;1523               if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
0007a8  7d20              LDRB     r0,[r4,#0x14]
0007aa  2804              CMP      r0,#4
0007ac  d101              BNE      |L8.1970|
;;;1524                 pcb->state = CLOSE_WAIT;
0007ae  2007              MOVS     r0,#7
0007b0  7520              STRB     r0,[r4,#0x14]
                  |L8.1970|
;;;1525               }
;;;1526             }
;;;1527   
;;;1528             pcb->ooseq = cseg->next;
0007b2  6828              LDR      r0,[r5,#0]
0007b4  6720              STR      r0,[r4,#0x70]
;;;1529             tcp_seg_free(cseg);
0007b6  4628              MOV      r0,r5
0007b8  f7fffffe          BL       tcp_seg_free
                  |L8.1980|
0007bc  6f25              LDR      r5,[r4,#0x70]         ;1494
0007be  b125              CBZ      r5,|L8.1994|
0007c0  68e8              LDR      r0,[r5,#0xc]          ;1495
0007c2  6a62              LDR      r2,[r4,#0x24]         ;1495
0007c4  6841              LDR      r1,[r0,#4]            ;1495
0007c6  4291              CMP      r1,r2                 ;1495
0007c8  d0a3              BEQ      |L8.1810|
                  |L8.1994|
;;;1530           }
;;;1531   #endif /* TCP_QUEUE_OOSEQ */
;;;1532   
;;;1533   
;;;1534           /* Acknowledge the segment(s). */
;;;1535           tcp_ack(pcb);
0007ca  7ea0              LDRB     r0,[r4,#0x1a]
0007cc  07c1              LSLS     r1,r0,#31
0007ce  d006              BEQ      |L8.2014|
0007d0  f0200001          BIC      r0,r0,#1
0007d4  f0400002          ORR      r0,r0,#2
0007d8  76a0              STRB     r0,[r4,#0x1a]
                  |L8.2010|
;;;1536   
;;;1537   #if LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS
;;;1538           if (ip_current_is_v6()) {
;;;1539             /* Inform neighbor reachability of forward progress. */
;;;1540             nd6_reachability_hint(ip6_current_src_addr());
;;;1541           }
;;;1542   #endif /* LWIP_IPV6 && LWIP_ND6_TCP_REACHABILITY_HINTS*/
;;;1543   
;;;1544         } else {
;;;1545           /* We get here if the incoming segment is out-of-sequence. */
;;;1546           tcp_send_empty_ack(pcb);
;;;1547   #if TCP_QUEUE_OOSEQ
;;;1548           /* We queue the segment on the ->ooseq queue. */
;;;1549           if (pcb->ooseq == NULL) {
;;;1550             pcb->ooseq = tcp_seg_copy(&inseg);
;;;1551           } else {
;;;1552             /* If the queue is not empty, we walk through the queue and
;;;1553                try to find a place where the sequence number of the
;;;1554                incoming segment is between the sequence numbers of the
;;;1555                previous and the next segment on the ->ooseq queue. That is
;;;1556                the place where we put the incoming segment. If needed, we
;;;1557                trim the second edges of the previous and the incoming
;;;1558                segment so that it will fit into the sequence.
;;;1559   
;;;1560                If the incoming segment has the same sequence number as a
;;;1561                segment on the ->ooseq queue, we discard the segment that
;;;1562                contains less data. */
;;;1563   
;;;1564             prev = NULL;
;;;1565             for (next = pcb->ooseq; next != NULL; next = next->next) {
;;;1566               if (seqno == next->tcphdr->seqno) {
;;;1567                 /* The sequence number of the incoming segment is the
;;;1568                    same as the sequence number of the segment on
;;;1569                    ->ooseq. We check the lengths to see which one to
;;;1570                    discard. */
;;;1571                 if (inseg.len > next->len) {
;;;1572                   /* The incoming segment is larger than the old
;;;1573                      segment. We replace some segments with the new
;;;1574                      one. */
;;;1575                   cseg = tcp_seg_copy(&inseg);
;;;1576                   if (cseg != NULL) {
;;;1577                     if (prev != NULL) {
;;;1578                       prev->next = cseg;
;;;1579                     } else {
;;;1580                       pcb->ooseq = cseg;
;;;1581                     }
;;;1582                     tcp_oos_insert_segment(cseg, next);
;;;1583                   }
;;;1584                   break;
;;;1585                 } else {
;;;1586                   /* Either the lengths are the same or the incoming
;;;1587                      segment was smaller than the old one; in either
;;;1588                      case, we ditch the incoming segment. */
;;;1589                   break;
;;;1590                 }
;;;1591               } else {
;;;1592                 if (prev == NULL) {
;;;1593                   if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
;;;1594                     /* The sequence number of the incoming segment is lower
;;;1595                        than the sequence number of the first segment on the
;;;1596                        queue. We put the incoming segment first on the
;;;1597                        queue. */
;;;1598                     cseg = tcp_seg_copy(&inseg);
;;;1599                     if (cseg != NULL) {
;;;1600                       pcb->ooseq = cseg;
;;;1601                       tcp_oos_insert_segment(cseg, next);
;;;1602                     }
;;;1603                     break;
;;;1604                   }
;;;1605                 } else {
;;;1606                   /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
;;;1607                     TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
;;;1608                   if (TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)) {
;;;1609                     /* The sequence number of the incoming segment is in
;;;1610                        between the sequence numbers of the previous and
;;;1611                        the next segment on ->ooseq. We trim trim the previous
;;;1612                        segment, delete next segments that included in received segment
;;;1613                        and trim received, if needed. */
;;;1614                     cseg = tcp_seg_copy(&inseg);
;;;1615                     if (cseg != NULL) {
;;;1616                       if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
;;;1617                         /* We need to trim the prev segment. */
;;;1618                         prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
;;;1619                         pbuf_realloc(prev->p, prev->len);
;;;1620                       }
;;;1621                       prev->next = cseg;
;;;1622                       tcp_oos_insert_segment(cseg, next);
;;;1623                     }
;;;1624                     break;
;;;1625                   }
;;;1626                 }
;;;1627                 /* If the "next" segment is the last segment on the
;;;1628                    ooseq queue, we add the incoming segment to the end
;;;1629                    of the list. */
;;;1630                 if (next->next == NULL &&
;;;1631                     TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
;;;1632                   if (TCPH_FLAGS(next->tcphdr) & TCP_FIN) {
;;;1633                     /* segment "next" already contains all data */
;;;1634                     break;
;;;1635                   }
;;;1636                   next->next = tcp_seg_copy(&inseg);
;;;1637                   if (next->next != NULL) {
;;;1638                     if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
;;;1639                       /* We need to trim the last segment. */
;;;1640                       next->len = (u16_t)(seqno - next->tcphdr->seqno);
;;;1641                       pbuf_realloc(next->p, next->len);
;;;1642                     }
;;;1643                     /* check if the remote side overruns our receive window */
;;;1644                     if (TCP_SEQ_GT((u32_t)tcplen + seqno, pcb->rcv_nxt + (u32_t)pcb->rcv_wnd)) {
;;;1645                       LWIP_DEBUGF(TCP_INPUT_DEBUG,
;;;1646                                   ("tcp_receive: other end overran receive window"
;;;1647                                    "seqno %"U32_F" len %"U16_F" right edge %"U32_F"\n",
;;;1648                                    seqno, tcplen, pcb->rcv_nxt + pcb->rcv_wnd));
;;;1649                       if (TCPH_FLAGS(next->next->tcphdr) & TCP_FIN) {
;;;1650                         /* Must remove the FIN from the header as we're trimming
;;;1651                          * that byte of sequence-space from the packet */
;;;1652                         TCPH_FLAGS_SET(next->next->tcphdr, TCPH_FLAGS(next->next->tcphdr) & ~TCP_FIN);
;;;1653                       }
;;;1654                       /* Adjust length of segment to fit in the window. */
;;;1655                       next->next->len = (u16_t)(pcb->rcv_nxt + pcb->rcv_wnd - seqno);
;;;1656                       pbuf_realloc(next->next->p, next->next->len);
;;;1657                       tcplen = TCP_TCPLEN(next->next);
;;;1658                       LWIP_ASSERT("tcp_receive: segment not trimmed correctly to rcv_wnd\n",
;;;1659                                   (seqno + tcplen) == (pcb->rcv_nxt + pcb->rcv_wnd));
;;;1660                     }
;;;1661                   }
;;;1662                   break;
;;;1663                 }
;;;1664               }
;;;1665               prev = next;
;;;1666             }
;;;1667           }
;;;1668   #if TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS
;;;1669           /* Check that the data on ooseq doesn't exceed one of the limits
;;;1670              and throw away everything above that limit. */
;;;1671           ooseq_blen = 0;
;;;1672           ooseq_qlen = 0;
;;;1673           prev = NULL;
;;;1674           for (next = pcb->ooseq; next != NULL; prev = next, next = next->next) {
;;;1675             struct pbuf *p = next->p;
;;;1676             ooseq_blen += p->tot_len;
;;;1677             ooseq_qlen += pbuf_clen(p);
;;;1678             if ((ooseq_blen > TCP_OOSEQ_MAX_BYTES) ||
;;;1679                 (ooseq_qlen > TCP_OOSEQ_MAX_PBUFS)) {
;;;1680                /* too much ooseq data, dump this and everything after it */
;;;1681                tcp_segs_free(next);
;;;1682                if (prev == NULL) {
;;;1683                  /* first ooseq segment is too much, dump the whole queue */
;;;1684                  pcb->ooseq = NULL;
;;;1685                } else {
;;;1686                  /* just dump 'next' and everything after it */
;;;1687                  prev->next = NULL;
;;;1688                }
;;;1689                break;
;;;1690             }
;;;1691           }
;;;1692   #endif /* TCP_OOSEQ_MAX_BYTES || TCP_OOSEQ_MAX_PBUFS */
;;;1693   #endif /* TCP_QUEUE_OOSEQ */
;;;1694         }
;;;1695       } else {
;;;1696         /* The incoming segment is not within the window. */
;;;1697         tcp_send_empty_ack(pcb);
;;;1698       }
;;;1699     } else {
;;;1700       /* Segments with length 0 is taken care of here. Segments that
;;;1701          fall out of the window are ACKed. */
;;;1702       if (!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd - 1)) {
;;;1703         tcp_ack_now(pcb);
;;;1704       }
;;;1705     }
;;;1706   }
0007da  e8bd87f0          POP      {r4-r10,pc}
                  |L8.2014|
0007de  f0400001          ORR      r0,r0,#1              ;1535
0007e2  76a0              STRB     r0,[r4,#0x1a]         ;1535
                  |L8.2020|
0007e4  e7f9              B        |L8.2010|
                  |L8.2022|
0007e6  4620              MOV      r0,r4                 ;1546
0007e8  f7fffffe          BL       tcp_send_empty_ack
0007ec  6f25              LDR      r5,[r4,#0x70]         ;1549
0007ee  b10d              CBZ      r5,|L8.2036|
0007f0  2600              MOVS     r6,#0                 ;1564
0007f2  e131              B        |L8.2648|
                  |L8.2036|
0007f4  485b              LDR      r0,|L8.2404|
0007f6  f7fffffe          BL       tcp_seg_copy
0007fa  6720              STR      r0,[r4,#0x70]         ;1550
0007fc  e7ed              B        |L8.2010|
                  |L8.2046|
0007fe  68e8              LDR      r0,[r5,#0xc]          ;1566
000800  6841              LDR      r1,[r0,#4]            ;1566
000802  6978              LDR      r0,[r7,#0x14]         ;1566  ; seqno
000804  4281              CMP      r1,r0                 ;1566
000806  d112              BNE      |L8.2094|
000808  f8b80008          LDRH     r0,[r8,#8]            ;1571  ; inseg
00080c  8929              LDRH     r1,[r5,#8]            ;1571
00080e  4288              CMP      r0,r1                 ;1571
000810  d9e3              BLS      |L8.2010|
000812  4854              LDR      r0,|L8.2404|
000814  f7fffffe          BL       tcp_seg_copy
000818  2800              CMP      r0,#0                 ;1576
00081a  d0de              BEQ      |L8.2010|
00081c  b10e              CBZ      r6,|L8.2082|
00081e  6030              STR      r0,[r6,#0]            ;1578
000820  e000              B        |L8.2084|
                  |L8.2082|
000822  6720              STR      r0,[r4,#0x70]         ;1580
                  |L8.2084|
000824  4629              MOV      r1,r5                 ;1582
000826  e8bd47f0          POP      {r4-r10,lr}           ;1582
00082a  f7ffbffe          B.W      tcp_oos_insert_segment
                  |L8.2094|
00082e  b31e              CBZ      r6,|L8.2168|
000830  68f2              LDR      r2,[r6,#0xc]          ;1608
000832  6852              LDR      r2,[r2,#4]            ;1608
000834  1a82              SUBS     r2,r0,r2              ;1608
000836  2a01              CMP      r2,#1                 ;1608
000838  d42a              BMI      |L8.2192|
00083a  1a42              SUBS     r2,r0,r1              ;1608
00083c  1c52              ADDS     r2,r2,#1              ;1608
00083e  2a00              CMP      r2,#0                 ;1608
000840  dc26              BGT      |L8.2192|
000842  4848              LDR      r0,|L8.2404|
000844  f7fffffe          BL       tcp_seg_copy
000848  4604              MOV      r4,r0                 ;1614
00084a  0020              MOVS     r0,r4                 ;1615
00084c  d0c5              BEQ      |L8.2010|
00084e  68f0              LDR      r0,[r6,#0xc]          ;1616
000850  8931              LDRH     r1,[r6,#8]            ;1616
000852  6840              LDR      r0,[r0,#4]            ;1616
000854  1842              ADDS     r2,r0,r1              ;1616
000856  6979              LDR      r1,[r7,#0x14]         ;1616  ; seqno
000858  1a52              SUBS     r2,r2,r1              ;1616
00085a  2a00              CMP      r2,#0                 ;1616
00085c  dd05              BLE      |L8.2154|
00085e  1a08              SUBS     r0,r1,r0              ;1618
000860  b281              UXTH     r1,r0                 ;1618
000862  8131              STRH     r1,[r6,#8]            ;1618
000864  6870              LDR      r0,[r6,#4]            ;1619
000866  f7fffffe          BL       pbuf_realloc
                  |L8.2154|
00086a  6034              STR      r4,[r6,#0]            ;1621
00086c  4629              MOV      r1,r5                 ;1622
00086e  4620              MOV      r0,r4                 ;1622
000870  e8bd47f0          POP      {r4-r10,lr}           ;1622
000874  f7ffbffe          B.W      tcp_oos_insert_segment
                  |L8.2168|
000878  1a42              SUBS     r2,r0,r1              ;1593
00087a  d577              BPL      |L8.2412|
00087c  4839              LDR      r0,|L8.2404|
00087e  f7fffffe          BL       tcp_seg_copy
000882  2800              CMP      r0,#0                 ;1599
000884  d0a9              BEQ      |L8.2010|
000886  6720              STR      r0,[r4,#0x70]         ;1600
000888  4629              MOV      r1,r5                 ;1601
00088a  e8bd47f0          POP      {r4-r10,lr}           ;1601
00088e  e06b              B        |L8.2408|
                  |L8.2192|
000890  e06c              B        |L8.2412|
000892  0000              DCW      0x0000
                  |L8.2196|
000894  70627566          DCB      "pbuf_header failed",0
000898  5f686561
00089c  64657220
0008a0  6661696c
0008a4  656400  
0008a7  00                DCB      0
                  |L8.2216|
0008a8  7463705f          DCB      "tcp_receive: segment not trimmed correctly to rcv_wnd\n"
0008ac  72656365
0008b0  6976653a
0008b4  20736567
0008b8  6d656e74
0008bc  206e6f74
0008c0  20747269
0008c4  6d6d6564
0008c8  20636f72
0008cc  72656374
0008d0  6c792074
0008d4  6f207263
0008d8  765f776e
0008dc  640a    
0008de  00                DCB      0
0008df  00                DCB      0
                  |L8.2272|
0008e0  7463705f          DCB      "tcp_receive: segment not trimmed correctly to ooseq que"
0008e4  72656365
0008e8  6976653a
0008ec  20736567
0008f0  6d656e74
0008f4  206e6f74
0008f8  20747269
0008fc  6d6d6564
000900  20636f72
000904  72656374
000908  6c792074
00090c  6f206f6f
000910  73657120
000914  717565  
000917  75650a00          DCB      "ue\n",0
00091b  00                DCB      0
                  |L8.2332|
00091c  7463705f          DCB      "tcp_receive: tcplen > rcv_wnd\n",0
000920  72656365
000924  6976653a
000928  20746370
00092c  6c656e20
000930  3e207263
000934  765f776e
000938  640a00  
00093b  00                DCB      0
                  |L8.2364|
00093c  7463705f          DCB      "tcp_receive: ooseq tcplen > rcv_wnd\n",0
000940  72656365
000944  6976653a
000948  206f6f73
00094c  65712074
000950  63706c65
000954  6e203e20
000958  7263765f
00095c  776e640a
000960  00      
000961  00                DCB      0
000962  00                DCB      0
000963  00                DCB      0
                  |L8.2404|
                          DCD      ||.bss||
                  |L8.2408|
000968  f7ffbffe          B.W      tcp_oos_insert_segment
                  |L8.2412|
00096c  682a              LDR      r2,[r5,#0]            ;1630
00096e  bbea              CBNZ     r2,|L8.2540|
000970  1a40              SUBS     r0,r0,r1              ;1631
000972  2800              CMP      r0,#0                 ;1631
000974  dd6e              BLE      |L8.2644|
000976  68e8              LDR      r0,[r5,#0xc]          ;1632
000978  8980              LDRH     r0,[r0,#0xc]          ;1632
00097a  f7fffffe          BL       lwip_htons
00097e  07c0              LSLS     r0,r0,#31             ;1632
000980  f47faf30          BNE      |L8.2020|
000984  4840              LDR      r0,|L8.2696|
000986  f7fffffe          BL       tcp_seg_copy
00098a  6028              STR      r0,[r5,#0]            ;1636
00098c  2800              CMP      r0,#0                 ;1637
                  |L8.2446|
00098e  f43faf29          BEQ      |L8.2020|
000992  68e8              LDR      r0,[r5,#0xc]          ;1638
000994  6841              LDR      r1,[r0,#4]            ;1638
000996  8928              LDRH     r0,[r5,#8]            ;1638
000998  180a              ADDS     r2,r1,r0              ;1638
00099a  6978              LDR      r0,[r7,#0x14]         ;1638  ; seqno
00099c  1a12              SUBS     r2,r2,r0              ;1638
00099e  2a00              CMP      r2,#0                 ;1638
0009a0  dd05              BLE      |L8.2478|
0009a2  1a40              SUBS     r0,r0,r1              ;1640
0009a4  b281              UXTH     r1,r0                 ;1640
0009a6  8129              STRH     r1,[r5,#8]            ;1640
0009a8  6868              LDR      r0,[r5,#4]            ;1641
0009aa  f7fffffe          BL       pbuf_realloc
                  |L8.2478|
0009ae  8d21              LDRH     r1,[r4,#0x28]         ;1644
0009b0  6a60              LDR      r0,[r4,#0x24]         ;1644
0009b2  697a              LDR      r2,[r7,#0x14]         ;1644  ; seqno
0009b4  4408              ADD      r0,r0,r1              ;1644
0009b6  8979              LDRH     r1,[r7,#0xa]          ;1644  ; tcplen
0009b8  4411              ADD      r1,r1,r2              ;1644
0009ba  1a08              SUBS     r0,r1,r0              ;1644
0009bc  2800              CMP      r0,#0                 ;1644
0009be  f77faf11          BLE      |L8.2020|
0009c2  6828              LDR      r0,[r5,#0]            ;1649
0009c4  68c0              LDR      r0,[r0,#0xc]          ;1649
0009c6  8980              LDRH     r0,[r0,#0xc]          ;1649
0009c8  f7fffffe          BL       lwip_htons
0009cc  07c0              LSLS     r0,r0,#31             ;1649
0009ce  d013              BEQ      |L8.2552|
0009d0  6828              LDR      r0,[r5,#0]            ;1652
0009d2  68c0              LDR      r0,[r0,#0xc]          ;1652
0009d4  8980              LDRH     r0,[r0,#0xc]          ;1652
0009d6  f7fffffe          BL       lwip_htons
0009da  f3c00044          UBFX     r0,r0,#1,#5           ;1652
0009de  0040              LSLS     r0,r0,#1              ;1652
0009e0  f7fffffe          BL       lwip_htons
0009e4  4601              MOV      r1,r0                 ;1652
0009e6  6828              LDR      r0,[r5,#0]            ;1652
0009e8  68c0              LDR      r0,[r0,#0xc]          ;1652
0009ea  e000              B        |L8.2542|
                  |L8.2540|
0009ec  e032              B        |L8.2644|
                  |L8.2542|
0009ee  8982              LDRH     r2,[r0,#0xc]          ;1652
0009f0  f422527c          BIC      r2,r2,#0x3f00         ;1652
0009f4  4311              ORRS     r1,r1,r2              ;1652
0009f6  8181              STRH     r1,[r0,#0xc]          ;1652
                  |L8.2552|
0009f8  8ca0              LDRH     r0,[r4,#0x24]         ;1655
0009fa  8d21              LDRH     r1,[r4,#0x28]         ;1655
0009fc  4408              ADD      r0,r0,r1              ;1655
0009fe  8ab9              LDRH     r1,[r7,#0x14]         ;1655  ; seqno
000a00  1a40              SUBS     r0,r0,r1              ;1655
000a02  b281              UXTH     r1,r0                 ;1655
000a04  6828              LDR      r0,[r5,#0]            ;1655
000a06  8101              STRH     r1,[r0,#8]            ;1655
000a08  6828              LDR      r0,[r5,#0]            ;1656
000a0a  6840              LDR      r0,[r0,#4]            ;1656
000a0c  f7fffffe          BL       pbuf_realloc
000a10  6828              LDR      r0,[r5,#0]            ;1657
000a12  68c0              LDR      r0,[r0,#0xc]          ;1657
000a14  8980              LDRH     r0,[r0,#0xc]          ;1657
000a16  f7fffffe          BL       lwip_htons
000a1a  0780              LSLS     r0,r0,#30             ;1657
000a1c  d001              BEQ      |L8.2594|
000a1e  2001              MOVS     r0,#1                 ;1657
000a20  e000              B        |L8.2596|
                  |L8.2594|
000a22  2000              MOVS     r0,#0                 ;1657
                  |L8.2596|
000a24  6829              LDR      r1,[r5,#0]            ;1657
000a26  8909              LDRH     r1,[r1,#8]            ;1657
000a28  4408              ADD      r0,r0,r1              ;1657
000a2a  b280              UXTH     r0,r0                 ;1657
000a2c  8178              STRH     r0,[r7,#0xa]          ;1657
000a2e  8d22              LDRH     r2,[r4,#0x28]         ;1658
000a30  6a61              LDR      r1,[r4,#0x24]         ;1658
000a32  4411              ADD      r1,r1,r2              ;1658
000a34  697a              LDR      r2,[r7,#0x14]         ;1658  ; seqno
000a36  4410              ADD      r0,r0,r2              ;1658
000a38  4288              CMP      r0,r1                 ;1658
000a3a  d0a8              BEQ      |L8.2446|
000a3c  f2af63a4          ADR      r3,|L8.924|
000a40  f240627a          MOV      r2,#0x67a             ;1658
000a44  f2af11a0          ADR      r1,|L8.2216|
000a48  f2af6060          ADR      r0,|L8.1004|
000a4c  e8bd47f0          POP      {r4-r10,lr}           ;1658
000a50  f7ffbffe          B.W      __2printf
                  |L8.2644|
000a54  462e              MOV      r6,r5                 ;1665
000a56  4615              MOV      r5,r2                 ;1565
                  |L8.2648|
000a58  2d00              CMP      r5,#0                 ;1565
000a5a  f47faed0          BNE      |L8.2046|
                  |L8.2654|
000a5e  e6bc              B        |L8.2010|
                  |L8.2656|
000a60  4620              MOV      r0,r4                 ;1697
000a62  e8bd47f0          POP      {r4-r10,lr}           ;1697
000a66  f7ffbffe          B.W      tcp_send_empty_ack
                  |L8.2666|
000a6a  6a60              LDR      r0,[r4,#0x24]         ;1702
000a6c  6979              LDR      r1,[r7,#0x14]         ;1702  ; seqno
000a6e  1a0a              SUBS     r2,r1,r0              ;1702
000a70  d405              BMI      |L8.2686|
000a72  8d22              LDRH     r2,[r4,#0x28]         ;1702
000a74  4410              ADD      r0,r0,r2              ;1702
000a76  1a08              SUBS     r0,r1,r0              ;1702
000a78  1c40              ADDS     r0,r0,#1              ;1702
000a7a  2800              CMP      r0,#0                 ;1702
000a7c  ddef              BLE      |L8.2654|
                  |L8.2686|
000a7e  7ea0              LDRB     r0,[r4,#0x1a]         ;1703
000a80  f0400002          ORR      r0,r0,#2              ;1703
000a84  76a0              STRB     r0,[r4,#0x1a]         ;1703
000a86  e6a8              B        |L8.2010|
;;;1707   
                          ENDP

                  |L8.2696|
                          DCD      ||.bss||

                          AREA ||i.tcp_timewait_input||, CODE, READONLY, ALIGN=2

                  tcp_timewait_input PROC
;;;662    static void
;;;663    tcp_timewait_input(struct tcp_pcb *pcb)
000000  b57c              PUSH     {r2-r6,lr}
;;;664    {
;;;665      /* RFC 1337: in TIME_WAIT, ignore RST and ACK FINs + any 'acceptable' segments */
;;;666      /* RFC 793 3.9 Event Processing - Segment Arrives:
;;;667       * - first check sequence number - we skip that one in TIME_WAIT (always
;;;668       *   acceptable since we only send ACKs)
;;;669       * - second check the RST bit (... return) */
;;;670      if (flags & TCP_RST) {
000002  4c16              LDR      r4,|L9.92|
000004  7822              LDRB     r2,[r4,#0]  ; flags
000006  0751              LSLS     r1,r2,#29
000008  d417              BMI      |L9.58|
00000a  4621              MOV      r1,r4
;;;671        return;
;;;672      }
;;;673      /* - fourth, check the SYN bit, */
;;;674      if (flags & TCP_SYN) {
00000c  0793              LSLS     r3,r2,#30
;;;675        /* If an incoming segment is not acceptable, an acknowledgment
;;;676           should be sent in reply */
;;;677        if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd)) {
;;;678          /* If the SYN is in the window it is an error, send a reset */
;;;679          tcp_rst(ackno, seqno + tcplen, ip_current_dest_addr(),
00000e  8949              LDRH     r1,[r1,#0xa]
000010  d514              BPL      |L9.60|
000012  6a43              LDR      r3,[r0,#0x24]         ;677
000014  6962              LDR      r2,[r4,#0x14]         ;677  ; seqno
000016  1ad5              SUBS     r5,r2,r3              ;677
000018  d415              BMI      |L9.70|
00001a  8d05              LDRH     r5,[r0,#0x28]         ;677
00001c  442b              ADD      r3,r3,r5              ;677
00001e  1ad3              SUBS     r3,r2,r3              ;677
000020  2b00              CMP      r3,#0                 ;677
000022  dc10              BGT      |L9.70|
000024  68e0              LDR      r0,[r4,#0xc]  ; tcphdr
000026  4411              ADD      r1,r1,r2
000028  8803              LDRH     r3,[r0,#0]
00002a  8840              LDRH     r0,[r0,#2]
00002c  e9cd0300          STRD     r0,r3,[sp,#0]
000030  4b0b              LDR      r3,|L9.96|
000032  69a0              LDR      r0,[r4,#0x18]  ; ackno
000034  1d1a              ADDS     r2,r3,#4
000036  f7fffffe          BL       tcp_rst
                  |L9.58|
;;;680            ip_current_src_addr(), tcphdr->dest, tcphdr->src);
;;;681          return;
;;;682        }
;;;683      } else if (flags & TCP_FIN) {
;;;684        /* - eighth, check the FIN bit: Remain in the TIME-WAIT state.
;;;685             Restart the 2 MSL time-wait timeout.*/
;;;686        pcb->tmr = tcp_ticks;
;;;687      }
;;;688    
;;;689      if ((tcplen > 0)) {
;;;690        /* Acknowledge data, FIN or out-of-window SYN */
;;;691        pcb->flags |= TF_ACK_NOW;
;;;692        tcp_output(pcb);
;;;693      }
;;;694      return;
;;;695    }
00003a  bd7c              POP      {r2-r6,pc}
                  |L9.60|
00003c  07d2              LSLS     r2,r2,#31             ;683
00003e  d002              BEQ      |L9.70|
000040  4a08              LDR      r2,|L9.100|
000042  6812              LDR      r2,[r2,#0]            ;686  ; tcp_ticks
000044  6202              STR      r2,[r0,#0x20]         ;686
                  |L9.70|
000046  2900              CMP      r1,#0                 ;689
000048  d0f7              BEQ      |L9.58|
00004a  7e81              LDRB     r1,[r0,#0x1a]         ;691
00004c  f0410102          ORR      r1,r1,#2              ;691
000050  7681              STRB     r1,[r0,#0x1a]         ;691
000052  e8bd407c          POP      {r2-r6,lr}            ;692
000056  f7ffbffe          B.W      tcp_output
;;;696    
                          ENDP

00005a  0000              DCW      0x0000
                  |L9.92|
                          DCD      ||.data||
                  |L9.96|
                          DCD      ip_data+0x10
                  |L9.100|
                          DCD      tcp_ticks

                          AREA ||i.tcp_trigger_input_pcb_close||, CODE, READONLY, ALIGN=2

                  tcp_trigger_input_pcb_close PROC
;;;1831   void
;;;1832   tcp_trigger_input_pcb_close(void)
000000  4802              LDR      r0,|L10.12|
;;;1833   {
;;;1834     recv_flags |= TF_CLOSED;
000002  7841              LDRB     r1,[r0,#1]  ; recv_flags
000004  f0410110          ORR      r1,r1,#0x10
000008  7041              STRB     r1,[r0,#1]
;;;1835   }
00000a  4770              BX       lr
;;;1836   
                          ENDP

                  |L10.12|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  inseg
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  flags
000000  00                DCB      0x00
                  recv_flags
000001  00                DCB      0x00
                  tcphdr_optlen
000002  0000              DCB      0x00,0x00
                  tcphdr_opt1len
000004  0000              DCB      0x00,0x00
                  tcp_optidx
000006  0000              DCB      0x00,0x00
                  recv_acked
000008  0000              DCB      0x00,0x00
                  tcplen
00000a  0000              DCB      0x00,0x00
                  tcphdr
                          DCD      0x00000000
                  tcphdr_opt2
                          DCD      0x00000000
                  seqno
                          DCD      0x00000000
                  ackno
                          DCD      0x00000000
                  recv_data
                          DCD      0x00000000
                  tcp_input_pcb
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\tcp_in.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_tcp_in_c_1a988eec____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___8_tcp_in_c_1a988eec____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_tcp_in_c_1a988eec____REVSH|
#line 478
|__asm___8_tcp_in_c_1a988eec____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___8_tcp_in_c_1a988eec____RRX|
#line 665
|__asm___8_tcp_in_c_1a988eec____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
