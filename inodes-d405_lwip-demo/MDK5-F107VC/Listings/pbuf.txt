; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\pbuf.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\pbuf.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\pbuf.crf ..\Middlewares\Third_Party\LwIP\src\core\pbuf.c]
                          THUMB

                          AREA ||i.pbuf_add_header||, CODE, READONLY, ALIGN=1

                  pbuf_add_header PROC
;;;550    u8_t
;;;551    pbuf_add_header(struct pbuf *p, size_t header_size_increment)
000000  2200              MOVS     r2,#0
;;;552    {
;;;553      return pbuf_add_header_impl(p, header_size_increment, 0);
000002  f7ffbffe          B.W      pbuf_add_header_impl
;;;554    }
;;;555    
                          ENDP


                          AREA ||i.pbuf_add_header_force||, CODE, READONLY, ALIGN=1

                  pbuf_add_header_force PROC
;;;560    u8_t
;;;561    pbuf_add_header_force(struct pbuf *p, size_t header_size_increment)
000000  2201              MOVS     r2,#1
;;;562    {
;;;563      return pbuf_add_header_impl(p, header_size_increment, 1);
000002  f7ffbffe          B.W      pbuf_add_header_impl
;;;564    }
;;;565    
                          ENDP


                          AREA ||i.pbuf_add_header_impl||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pbuf_add_header_impl PROC
;;;472    static u8_t
;;;473    pbuf_add_header_impl(struct pbuf *p, size_t header_size_increment, u8_t force)
000000  b570              PUSH     {r4-r6,lr}
;;;474    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;475      u16_t type_internal;
;;;476      void *payload;
;;;477      u16_t increment_magnitude;
;;;478    
;;;479      LWIP_ASSERT("p != NULL", p != NULL);
000008  2c00              CMP      r4,#0
00000a  d106              BNE      |L3.26|
00000c  a317              ADR      r3,|L3.108|
00000e  f24012df          MOV      r2,#0x1df
000012  a122              ADR      r1,|L3.156|
000014  a024              ADR      r0,|L3.168|
000016  f7fffffe          BL       __2printf
                  |L3.26|
;;;480      if ((p == NULL) || (header_size_increment > 0xFFFF)) {
00001a  b114              CBZ      r4,|L3.34|
00001c  f5b53f80          CMP      r5,#0x10000
000020  d301              BCC      |L3.38|
                  |L3.34|
;;;481        return 1;
000022  2001              MOVS     r0,#1
;;;482      }
;;;483      if (header_size_increment == 0) {
;;;484        return 0;
;;;485      }
;;;486    
;;;487      increment_magnitude = (u16_t)header_size_increment;
;;;488      /* Do not allow tot_len to wrap as a result. */
;;;489      if ((u16_t)(increment_magnitude + p->tot_len) < increment_magnitude) {
;;;490        return 1;
;;;491      }
;;;492    
;;;493      type_internal = p->type_internal;
;;;494    
;;;495      /* pbuf types containing payloads? */
;;;496      if (type_internal & PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS) {
;;;497        /* set new payload pointer */
;;;498        payload = (u8_t *)p->payload - header_size_increment;
;;;499        /* boundary check fails? */
;;;500        if ((u8_t *)payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
;;;501          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE,
;;;502                       ("pbuf_add_header: failed as %p < %p (not enough space for new header size)\n",
;;;503                        (void *)payload, (void *)((u8_t *)p + SIZEOF_STRUCT_PBUF)));
;;;504          /* bail out unsuccessfully */
;;;505          return 1;
;;;506        }
;;;507        /* pbuf types referring to external payloads? */
;;;508      } else {
;;;509        /* hide a header in the payload? */
;;;510        if (force) {
;;;511          payload = (u8_t *)p->payload - header_size_increment;
;;;512        } else {
;;;513          /* cannot expand payload to front (yet!)
;;;514           * bail out unsuccessfully */
;;;515          return 1;
;;;516        }
;;;517      }
;;;518      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_add_header: old %p new %p (%"U16_F")\n",
;;;519                  (void *)p->payload, (void *)payload, increment_magnitude));
;;;520    
;;;521      /* modify pbuf fields */
;;;522      p->payload = payload;
;;;523      p->len = (u16_t)(p->len + increment_magnitude);
;;;524      p->tot_len = (u16_t)(p->tot_len + increment_magnitude);
;;;525    
;;;526    
;;;527      return 0;
;;;528    }
000024  bd70              POP      {r4-r6,pc}
                  |L3.38|
000026  b13d              CBZ      r5,|L3.56|
000028  b2a8              UXTH     r0,r5                 ;487
00002a  8921              LDRH     r1,[r4,#8]            ;489
00002c  4401              ADD      r1,r1,r0              ;489
00002e  b28b              UXTH     r3,r1                 ;489
000030  4283              CMP      r3,r0                 ;489
000032  d203              BCS      |L3.60|
000034  2001              MOVS     r0,#1                 ;490
000036  bd70              POP      {r4-r6,pc}
                  |L3.56|
000038  2000              MOVS     r0,#0                 ;484
00003a  bd70              POP      {r4-r6,pc}
                  |L3.60|
00003c  7b21              LDRB     r1,[r4,#0xc]          ;493
00003e  0609              LSLS     r1,r1,#24             ;496
000040  d507              BPL      |L3.82|
000042  6861              LDR      r1,[r4,#4]            ;498
000044  1b49              SUBS     r1,r1,r5              ;498
000046  f1040210          ADD      r2,r4,#0x10           ;500
00004a  4291              CMP      r1,r2                 ;500
00004c  d204              BCS      |L3.88|
00004e  2001              MOVS     r0,#1                 ;505
000050  bd70              POP      {r4-r6,pc}
                  |L3.82|
000052  b146              CBZ      r6,|L3.102|
000054  6861              LDR      r1,[r4,#4]            ;511
000056  1b49              SUBS     r1,r1,r5              ;511
                  |L3.88|
000058  6061              STR      r1,[r4,#4]            ;522
00005a  8961              LDRH     r1,[r4,#0xa]          ;523
00005c  4408              ADD      r0,r0,r1              ;523
00005e  8160              STRH     r0,[r4,#0xa]          ;523
000060  8123              STRH     r3,[r4,#8]            ;524
000062  2000              MOVS     r0,#0                 ;527
000064  bd70              POP      {r4-r6,pc}
                  |L3.102|
000066  2001              MOVS     r0,#1                 ;515
000068  bd70              POP      {r4-r6,pc}
;;;529    
                          ENDP

00006a  0000              DCW      0x0000
                  |L3.108|
00006c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000070  6964646c
000074  65776172
000078  65735c54
00007c  68697264
000080  5f506172
000084  74795c4c
000088  7749505c
00008c  7372635c
000090  636f7265
000094  5c706275
000098  662e6300
                  |L3.156|
00009c  7020213d          DCB      "p != NULL",0
0000a0  204e554c
0000a4  4c00    
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L3.168|
0000a8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000ac  7274696f
0000b0  6e202225
0000b4  73222066
0000b8  61696c65
0000bc  64206174
0000c0  206c696e
0000c4  65202564
0000c8  20696e20
0000cc  25730a00

                          AREA ||i.pbuf_alloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_alloc PROC
;;;223    struct pbuf *
;;;224    pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;225    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
;;;226      struct pbuf *p;
;;;227      u16_t offset = (u16_t)layer;
;;;228      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));
;;;229    
;;;230      switch (type) {
00000a  f1b90f01          CMP      r9,#1
00000e  d012              BEQ      |L4.54|
000010  f1b90f41          CMP      r9,#0x41
000014  d00f              BEQ      |L4.54|
000016  f5b97fc1          CMP      r9,#0x182
00001a  d013              BEQ      |L4.68|
00001c  f5b97f20          CMP      r9,#0x280
000020  d059              BEQ      |L4.214|
;;;231        case PBUF_REF: /* fall through */
;;;232        case PBUF_ROM:
;;;233          p = pbuf_alloc_reference(NULL, length, type);
;;;234          break;
;;;235        case PBUF_POOL: {
;;;236          struct pbuf *q, *last;
;;;237          u16_t rem_len; /* remaining length */
;;;238          p = NULL;
;;;239          last = NULL;
;;;240          rem_len = length;
;;;241          do {
;;;242            u16_t qlen;
;;;243            q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;244            if (q == NULL) {
;;;245              PBUF_POOL_IS_EMPTY();
;;;246              /* free chain so far allocated */
;;;247              if (p) {
;;;248                pbuf_free(p);
;;;249              }
;;;250              /* bail out unsuccessfully */
;;;251              return NULL;
;;;252            }
;;;253            qlen = LWIP_MIN(rem_len, (u16_t)(PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)));
;;;254            pbuf_init_alloced_pbuf(q, LWIP_MEM_ALIGN((void *)((u8_t *)q + SIZEOF_STRUCT_PBUF + offset)),
;;;255                                   rem_len, qlen, type, 0);
;;;256            LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
;;;257                        ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
;;;258            LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
;;;259                        (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
;;;260            if (p == NULL) {
;;;261              /* allocated head of pbuf chain (into p) */
;;;262              p = q;
;;;263            } else {
;;;264              /* make previous pbuf point to this pbuf */
;;;265              last->next = q;
;;;266            }
;;;267            last = q;
;;;268            rem_len = (u16_t)(rem_len - qlen);
;;;269            offset = 0;
;;;270          } while (rem_len > 0);
;;;271          break;
;;;272        }
;;;273        case PBUF_RAM: {
;;;274          u16_t payload_len = (u16_t)(LWIP_MEM_ALIGN_SIZE(offset) + LWIP_MEM_ALIGN_SIZE(length));
;;;275          mem_size_t alloc_len = (mem_size_t)(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF) + payload_len);
;;;276    
;;;277          /* bug #50040: Check for integer overflow when calculating alloc_len */
;;;278          if ((payload_len < LWIP_MEM_ALIGN_SIZE(length)) ||
;;;279              (alloc_len < LWIP_MEM_ALIGN_SIZE(length))) {
;;;280            return NULL;
;;;281          }
;;;282    
;;;283          /* If pbuf is to be allocated in RAM, allocate memory for it. */
;;;284          p = (struct pbuf *)mem_malloc(alloc_len);
;;;285          if (p == NULL) {
;;;286            return NULL;
;;;287          }
;;;288          pbuf_init_alloced_pbuf(p, LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset)),
;;;289                                 length, length, type, 0);
;;;290          LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
;;;291                      ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;292          break;
;;;293        }
;;;294        default:
;;;295          LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
000022  a345              ADR      r3,|L4.312|
000024  f2401227          MOV      r2,#0x127
000028  a14f              ADR      r1,|L4.360|
00002a  a056              ADR      r0,|L4.388|
00002c  f7fffffe          BL       __2printf
;;;296          return NULL;
000030  2000              MOVS     r0,#0
                  |L4.50|
;;;297      }
;;;298      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
;;;299      return p;
;;;300    }
000032  e8bd9ffc          POP      {r2-r12,pc}
                  |L4.54|
000036  464a              MOV      r2,r9                 ;233
000038  4629              MOV      r1,r5                 ;233
00003a  2000              MOVS     r0,#0                 ;233
00003c  f7fffffe          BL       pbuf_alloc_reference
000040  4606              MOV      r6,r0                 ;233
000042  e075              B        |L4.304|
                  |L4.68|
000044  2600              MOVS     r6,#0                 ;238
000046  46b2              MOV      r10,r6                ;239
                  |L4.72|
000048  2008              MOVS     r0,#8                 ;243
00004a  f7fffffe          BL       memp_malloc
00004e  4604              MOV      r4,r0                 ;243
000050  0020              MOVS     r0,r4                 ;244
000052  d036              BEQ      |L4.194|
000054  f1070b03          ADD      r11,r7,#3             ;253
000058  f02b0003          BIC      r0,r11,#3             ;253
00005c  f5c07014          RSB      r0,r0,#0x250          ;253
000060  fa1ff880          UXTH     r8,r0                 ;253
000064  45a8              CMP      r8,r5                 ;253
000066  d900              BLS      |L4.106|
000068  46a8              MOV      r8,r5                 ;253
                  |L4.106|
00006a  2000              MOVS     r0,#0                 ;254
00006c  e9cd9000          STRD     r9,r0,[sp,#0]         ;254
000070  19e0              ADDS     r0,r4,r7              ;254
000072  3013              ADDS     r0,r0,#0x13           ;254
000074  f0200103          BIC      r1,r0,#3              ;254
000078  4643              MOV      r3,r8                 ;254
00007a  462a              MOV      r2,r5                 ;254
00007c  4620              MOV      r0,r4                 ;254
00007e  f7fffffe          BL       pbuf_init_alloced_pbuf
000082  7920              LDRB     r0,[r4,#4]            ;256
000084  0780              LSLS     r0,r0,#30             ;256
000086  d006              BEQ      |L4.150|
000088  a32b              ADR      r3,|L4.312|
00008a  f44f7280          MOV      r2,#0x100             ;256
00008e  a147              ADR      r1,|L4.428|
000090  a03c              ADR      r0,|L4.388|
000092  f7fffffe          BL       __2printf
                  |L4.150|
000096  2094              MOVS     r0,#0x94              ;258
000098  ebb00f9b          CMP      r0,r11,LSR #2         ;258
00009c  d106              BNE      |L4.172|
00009e  a326              ADR      r3,|L4.312|
0000a0  f44f7281          MOV      r2,#0x102             ;258
0000a4  a14d              ADR      r1,|L4.476|
0000a6  a037              ADR      r0,|L4.388|
0000a8  f7fffffe          BL       __2printf
                  |L4.172|
0000ac  b18e              CBZ      r6,|L4.210|
0000ae  f8ca4000          STR      r4,[r10,#0]           ;265
                  |L4.178|
0000b2  46a2              MOV      r10,r4                ;267
0000b4  eba50008          SUB      r0,r5,r8              ;268
0000b8  b285              UXTH     r5,r0                 ;268
0000ba  2700              MOVS     r7,#0                 ;269
0000bc  2d00              CMP      r5,#0                 ;270
0000be  d1c3              BNE      |L4.72|
0000c0  e036              B        |L4.304|
                  |L4.194|
0000c2  f7fffffe          BL       pbuf_pool_is_empty
0000c6  b116              CBZ      r6,|L4.206|
0000c8  4630              MOV      r0,r6                 ;248
0000ca  f7fffffe          BL       pbuf_free
                  |L4.206|
0000ce  2000              MOVS     r0,#0                 ;251
0000d0  e7af              B        |L4.50|
                  |L4.210|
0000d2  4626              MOV      r6,r4                 ;262
0000d4  e7ed              B        |L4.178|
                  |L4.214|
0000d6  1cf8              ADDS     r0,r7,#3              ;274
0000d8  f0200103          BIC      r1,r0,#3              ;274
0000dc  1ce8              ADDS     r0,r5,#3              ;274
0000de  f0200203          BIC      r2,r0,#3              ;274
0000e2  1888              ADDS     r0,r1,r2              ;274
0000e4  b280              UXTH     r0,r0                 ;274
0000e6  f1000110          ADD      r1,r0,#0x10           ;275
0000ea  b289              UXTH     r1,r1                 ;275
0000ec  4282              CMP      r2,r0                 ;278
0000ee  d801              BHI      |L4.244|
0000f0  428a              CMP      r2,r1                 ;279
0000f2  d901              BLS      |L4.248|
                  |L4.244|
0000f4  2000              MOVS     r0,#0                 ;280
0000f6  e79c              B        |L4.50|
                  |L4.248|
0000f8  4608              MOV      r0,r1                 ;284
0000fa  f7fffffe          BL       mem_malloc
0000fe  4606              MOV      r6,r0                 ;284
000100  0030              MOVS     r0,r6                 ;285
000102  d017              BEQ      |L4.308|
000104  2000              MOVS     r0,#0                 ;288
000106  e9cd9000          STRD     r9,r0,[sp,#0]         ;288
00010a  19f0              ADDS     r0,r6,r7              ;288
00010c  3013              ADDS     r0,r0,#0x13           ;288
00010e  f0200103          BIC      r1,r0,#3              ;288
000112  462b              MOV      r3,r5                 ;288
000114  462a              MOV      r2,r5                 ;288
000116  4630              MOV      r0,r6                 ;288
000118  f7fffffe          BL       pbuf_init_alloced_pbuf
00011c  7930              LDRB     r0,[r6,#4]            ;290
00011e  0780              LSLS     r0,r0,#30             ;290
000120  d006              BEQ      |L4.304|
000122  a305              ADR      r3,|L4.312|
000124  f44f7291          MOV      r2,#0x122             ;290
000128  a139              ADR      r1,|L4.528|
00012a  a016              ADR      r0,|L4.388|
00012c  f7fffffe          BL       __2printf
                  |L4.304|
000130  4630              MOV      r0,r6                 ;299
000132  e77e              B        |L4.50|
                  |L4.308|
000134  2000              MOVS     r0,#0                 ;286
000136  e77c              B        |L4.50|
;;;301    
                          ENDP

                  |L4.312|
000138  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
00013c  6964646c
000140  65776172
000144  65735c54
000148  68697264
00014c  5f506172
000150  74795c4c
000154  7749505c
000158  7372635c
00015c  636f7265
000160  5c706275
000164  662e6300
                  |L4.360|
000168  70627566          DCB      "pbuf_alloc: erroneous type",0
00016c  5f616c6c
000170  6f633a20
000174  6572726f
000178  6e656f75
00017c  73207479
000180  706500  
000183  00                DCB      0
                  |L4.388|
000184  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000188  7274696f
00018c  6e202225
000190  73222066
000194  61696c65
000198  64206174
00019c  206c696e
0001a0  65202564
0001a4  20696e20
0001a8  25730a00
                  |L4.428|
0001ac  70627566          DCB      "pbuf_alloc: pbuf q->payload properly aligned",0
0001b0  5f616c6c
0001b4  6f633a20
0001b8  70627566
0001bc  20712d3e
0001c0  7061796c
0001c4  6f616420
0001c8  70726f70
0001cc  65726c79
0001d0  20616c69
0001d4  676e6564
0001d8  00      
0001d9  00                DCB      0
0001da  00                DCB      0
0001db  00                DCB      0
                  |L4.476|
0001dc  50425546          DCB      "PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",0
0001e0  5f504f4f
0001e4  4c5f4255
0001e8  4653495a
0001ec  45206d75
0001f0  73742062
0001f4  65206269
0001f8  67676572
0001fc  20746861
000200  6e204d45
000204  4d5f414c
000208  49474e4d
00020c  454e5400
                  |L4.528|
000210  70627566          DCB      "pbuf_alloc: pbuf->payload properly aligned",0
000214  5f616c6c
000218  6f633a20
00021c  70627566
000220  2d3e7061
000224  796c6f61
000228  64207072
00022c  6f706572
000230  6c792061
000234  6c69676e
000238  656400  
00023b  00                DCB      0

                          AREA ||i.pbuf_alloc_reference||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pbuf_alloc_reference PROC
;;;326    struct pbuf *
;;;327    pbuf_alloc_reference(void *payload, u16_t length, pbuf_type type)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;328    {
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;329      struct pbuf *p;
;;;330      LWIP_ASSERT("invalid pbuf_type", (type == PBUF_REF) || (type == PBUF_ROM));
00000a  2c41              CMP      r4,#0x41
00000c  d008              BEQ      |L5.32|
00000e  2c01              CMP      r4,#1
000010  d006              BEQ      |L5.32|
000012  a30d              ADR      r3,|L5.72|
000014  f44f72a5          MOV      r2,#0x14a
000018  a117              ADR      r1,|L5.120|
00001a  a01c              ADR      r0,|L5.140|
00001c  f7fffffe          BL       __2printf
                  |L5.32|
;;;331      /* only allocate memory for the pbuf structure */
;;;332      p = (struct pbuf *)memp_malloc(MEMP_PBUF);
000020  2007              MOVS     r0,#7
000022  f7fffffe          BL       memp_malloc
000026  4605              MOV      r5,r0
;;;333      if (p == NULL) {
000028  b15d              CBZ      r5,|L5.66|
;;;334        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;335                    ("pbuf_alloc_reference: Could not allocate MEMP_PBUF for PBUF_%s.\n",
;;;336                     (type == PBUF_ROM) ? "ROM" : "REF"));
;;;337        return NULL;
;;;338      }
;;;339      pbuf_init_alloced_pbuf(p, payload, length, length, type, 0);
00002a  2000              MOVS     r0,#0
00002c  e9cd4000          STRD     r4,r0,[sp,#0]
000030  4633              MOV      r3,r6
000032  4632              MOV      r2,r6
000034  4639              MOV      r1,r7
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       pbuf_init_alloced_pbuf
;;;340      return p;
00003c  4628              MOV      r0,r5
                  |L5.62|
;;;341    }
00003e  e8bd81fc          POP      {r2-r8,pc}
                  |L5.66|
000042  2000              MOVS     r0,#0                 ;337
000044  e7fb              B        |L5.62|
;;;342    
                          ENDP

000046  0000              DCW      0x0000
                  |L5.72|
000048  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
00004c  6964646c
000050  65776172
000054  65735c54
000058  68697264
00005c  5f506172
000060  74795c4c
000064  7749505c
000068  7372635c
00006c  636f7265
000070  5c706275
000074  662e6300
                  |L5.120|
000078  696e7661          DCB      "invalid pbuf_type",0
00007c  6c696420
000080  70627566
000084  5f747970
000088  6500    
00008a  00                DCB      0
00008b  00                DCB      0
                  |L5.140|
00008c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000090  7274696f
000094  6e202225
000098  73222066
00009c  61696c65
0000a0  64206174
0000a4  206c696e
0000a8  65202564
0000ac  20696e20
0000b0  25730a00

                          AREA ||i.pbuf_alloced_custom||, CODE, READONLY, ALIGN=1

                  pbuf_alloced_custom PROC
;;;362    struct pbuf *
;;;363    pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
000000  b57c              PUSH     {r2-r6,lr}
;;;364                        void *payload_mem, u16_t payload_mem_len)
;;;365    {
000002  460d              MOV      r5,r1
000004  461c              MOV      r4,r3
000006  e9dd1306          LDRD     r1,r3,[sp,#0x18]
;;;366      u16_t offset = (u16_t)l;
;;;367      void *payload;
;;;368      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));
;;;369    
;;;370      if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
00000a  1cc0              ADDS     r0,r0,#3
00000c  f0200003          BIC      r0,r0,#3
000010  1946              ADDS     r6,r0,r5
000012  429e              CMP      r6,r3
000014  d901              BLS      |L6.26|
;;;371        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
;;;372        return NULL;
000016  2000              MOVS     r0,#0
;;;373      }
;;;374    
;;;375      if (payload_mem != NULL) {
;;;376        payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
;;;377      } else {
;;;378        payload = NULL;
;;;379      }
;;;380      pbuf_init_alloced_pbuf(&p->pbuf, payload, length, length, type, PBUF_FLAG_IS_CUSTOM);
;;;381      return &p->pbuf;
;;;382    }
000018  bd7c              POP      {r2-r6,pc}
                  |L6.26|
00001a  b109              CBZ      r1,|L6.32|
00001c  4401              ADD      r1,r1,r0              ;376
00001e  e000              B        |L6.34|
                  |L6.32|
000020  2100              MOVS     r1,#0                 ;378
                  |L6.34|
000022  2002              MOVS     r0,#2                 ;380
000024  e9cd2000          STRD     r2,r0,[sp,#0]         ;380
000028  462b              MOV      r3,r5                 ;380
00002a  462a              MOV      r2,r5                 ;380
00002c  4620              MOV      r0,r4                 ;380
00002e  f7fffffe          BL       pbuf_init_alloced_pbuf
000032  4620              MOV      r0,r4                 ;381
000034  bd7c              POP      {r2-r6,pc}
;;;383    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
                          ENDP


                          AREA ||i.pbuf_cat||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_cat PROC
;;;852    void
;;;853    pbuf_cat(struct pbuf *h, struct pbuf *t)
000000  b570              PUSH     {r4-r6,lr}
;;;854    {
000002  460d              MOV      r5,r1
;;;855      struct pbuf *p;
;;;856    
;;;857      LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
000004  2800              CMP      r0,#0
000006  d002              BEQ      |L7.14|
000008  b10d              CBZ      r5,|L7.14|
;;;858                 ((h != NULL) && (t != NULL)), return;);
;;;859    
;;;860      /* proceed to last pbuf of chain */
;;;861      for (p = h; p->next != NULL; p = p->next) {
00000a  4604              MOV      r4,r0
00000c  e00d              B        |L7.42|
                  |L7.14|
00000e  e8bd4070          POP      {r4-r6,lr}            ;857
000012  a314              ADR      r3,|L7.100|
000014  f2403259          MOV      r2,#0x359             ;857
000018  a11e              ADR      r1,|L7.148|
00001a  a02c              ADR      r0,|L7.204|
00001c  f7ffbffe          B.W      __2printf
                  |L7.32|
;;;862        /* add total length of second chain to all totals of first chain */
;;;863        p->tot_len = (u16_t)(p->tot_len + t->tot_len);
000020  8921              LDRH     r1,[r4,#8]
000022  892a              LDRH     r2,[r5,#8]
000024  4411              ADD      r1,r1,r2
000026  8121              STRH     r1,[r4,#8]
000028  4604              MOV      r4,r0                 ;861
                  |L7.42|
00002a  6820              LDR      r0,[r4,#0]            ;861
00002c  2800              CMP      r0,#0                 ;861
00002e  d1f7              BNE      |L7.32|
;;;864      }
;;;865      /* { p is last pbuf of first h chain, p->next == NULL } */
;;;866      LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
000030  8920              LDRH     r0,[r4,#8]
000032  8961              LDRH     r1,[r4,#0xa]
000034  4288              CMP      r0,r1
000036  d006              BEQ      |L7.70|
000038  a30a              ADR      r3,|L7.100|
00003a  f2403262          MOV      r2,#0x362
00003e  a12d              ADR      r1,|L7.244|
000040  a022              ADR      r0,|L7.204|
000042  f7fffffe          BL       __2printf
                  |L7.70|
;;;867      LWIP_ASSERT("p->next == NULL", p->next == NULL);
000046  6820              LDR      r0,[r4,#0]
000048  b130              CBZ      r0,|L7.88|
00004a  a306              ADR      r3,|L7.100|
00004c  f2403263          MOV      r2,#0x363
000050  a134              ADR      r1,|L7.292|
000052  a01e              ADR      r0,|L7.204|
000054  f7fffffe          BL       __2printf
                  |L7.88|
;;;868      /* add total length of second chain to last pbuf total of first chain */
;;;869      p->tot_len = (u16_t)(p->tot_len + t->tot_len);
000058  8920              LDRH     r0,[r4,#8]
00005a  8929              LDRH     r1,[r5,#8]
00005c  4408              ADD      r0,r0,r1
00005e  8120              STRH     r0,[r4,#8]
;;;870      /* chain last pbuf of head (p) with first of tail (t) */
;;;871      p->next = t;
000060  6025              STR      r5,[r4,#0]
;;;872      /* p->next now references t, but the caller will drop its reference to t,
;;;873       * so netto there is no change to the reference count of t.
;;;874       */
;;;875    }
000062  bd70              POP      {r4-r6,pc}
;;;876    
                          ENDP

                  |L7.100|
000064  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000068  6964646c
00006c  65776172
000070  65735c54
000074  68697264
000078  5f506172
00007c  74795c4c
000080  7749505c
000084  7372635c
000088  636f7265
00008c  5c706275
000090  662e6300
                  |L7.148|
000094  28682021          DCB      "(h != NULL) && (t != NULL) (programmer violates API)",0
000098  3d204e55
00009c  4c4c2920
0000a0  26262028
0000a4  7420213d
0000a8  204e554c
0000ac  4c292028
0000b0  70726f67
0000b4  72616d6d
0000b8  65722076
0000bc  696f6c61
0000c0  74657320
0000c4  41504929
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L7.204|
0000cc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000d0  7274696f
0000d4  6e202225
0000d8  73222066
0000dc  61696c65
0000e0  64206174
0000e4  206c696e
0000e8  65202564
0000ec  20696e20
0000f0  25730a00
                  |L7.244|
0000f4  702d3e74          DCB      "p->tot_len == p->len (of last pbuf in chain)",0
0000f8  6f745f6c
0000fc  656e203d
000100  3d20702d
000104  3e6c656e
000108  20286f66
00010c  206c6173
000110  74207062
000114  75662069
000118  6e206368
00011c  61696e29
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L7.292|
000124  702d3e6e          DCB      "p->next == NULL",0
000128  65787420
00012c  3d3d204e
000130  554c4c00

                          AREA ||i.pbuf_chain||, CODE, READONLY, ALIGN=1

                  pbuf_chain PROC
;;;894    void
;;;895    pbuf_chain(struct pbuf *h, struct pbuf *t)
000000  b510              PUSH     {r4,lr}
;;;896    {
000002  460c              MOV      r4,r1
;;;897      pbuf_cat(h, t);
000004  4621              MOV      r1,r4
000006  f7fffffe          BL       pbuf_cat
;;;898      /* t is now referenced by h */
;;;899      pbuf_ref(t);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      pbuf_ref
;;;900      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
;;;901    }
;;;902    
                          ENDP


                          AREA ||i.pbuf_clen||, CODE, READONLY, ALIGN=1

                  pbuf_clen PROC
;;;808    u16_t
;;;809    pbuf_clen(const struct pbuf *p)
000000  2100              MOVS     r1,#0
;;;810    {
000002  e002              B        |L9.10|
                  |L9.4|
;;;811      u16_t len;
;;;812    
;;;813      len = 0;
;;;814      while (p != NULL) {
;;;815        ++len;
000004  1c49              ADDS     r1,r1,#1
000006  b289              UXTH     r1,r1
;;;816        p = p->next;
000008  6800              LDR      r0,[r0,#0]
                  |L9.10|
00000a  2800              CMP      r0,#0                 ;814
00000c  d1fa              BNE      |L9.4|
;;;817      }
;;;818      return len;
00000e  4608              MOV      r0,r1
;;;819    }
000010  4770              BX       lr
;;;820    
                          ENDP


                          AREA ||i.pbuf_clone||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pbuf_clone PROC
;;;1305   struct pbuf *
;;;1306   pbuf_clone(pbuf_layer layer, pbuf_type type, struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;1307   {
000002  460b              MOV      r3,r1
000004  4615              MOV      r5,r2
;;;1308     struct pbuf *q;
;;;1309     err_t err;
;;;1310     q = pbuf_alloc(layer, p->tot_len, type);
000006  461a              MOV      r2,r3
000008  8929              LDRH     r1,[r5,#8]
00000a  f7fffffe          BL       pbuf_alloc
00000e  4604              MOV      r4,r0
;;;1311     if (q == NULL) {
000010  2c00              CMP      r4,#0
000012  d00d              BEQ      |L10.48|
;;;1312       return NULL;
;;;1313     }
;;;1314     err = pbuf_copy(q, p);
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       pbuf_copy
;;;1315     LWIP_UNUSED_ARG(err); /* in case of LWIP_NOASSERT */
;;;1316     LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
00001c  b130              CBZ      r0,|L10.44|
00001e  a305              ADR      r3,|L10.52|
000020  f2405224          MOV      r2,#0x524
000024  a10f              ADR      r1,|L10.100|
000026  a014              ADR      r0,|L10.120|
000028  f7fffffe          BL       __2printf
                  |L10.44|
;;;1317     return q;
00002c  4620              MOV      r0,r4
;;;1318   }
00002e  bd70              POP      {r4-r6,pc}
                  |L10.48|
000030  2000              MOVS     r0,#0                 ;1312
000032  bd70              POP      {r4-r6,pc}
;;;1319   
                          ENDP

                  |L10.52|
000034  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000038  6964646c
00003c  65776172
000040  65735c54
000044  68697264
000048  5f506172
00004c  74795c4c
000050  7749505c
000054  7372635c
000058  636f7265
00005c  5c706275
000060  662e6300
                  |L10.100|
000064  70627566          DCB      "pbuf_copy failed",0
000068  5f636f70
00006c  79206661
000070  696c6564
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L10.120|
000078  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00007c  7274696f
000080  6e202225
000084  73222066
000088  61696c65
00008c  64206174
000090  206c696e
000094  65202564
000098  20696e20
00009c  25730a00

                          AREA ||i.pbuf_coalesce||, CODE, READONLY, ALIGN=1

                  pbuf_coalesce PROC
;;;1277   struct pbuf *
;;;1278   pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
000000  b570              PUSH     {r4-r6,lr}
;;;1279   {
000002  4605              MOV      r5,r0
000004  460b              MOV      r3,r1
;;;1280     struct pbuf *q;
;;;1281     if (p->next == NULL) {
000006  6828              LDR      r0,[r5,#0]
000008  2800              CMP      r0,#0
00000a  d00c              BEQ      |L11.38|
;;;1282       return p;
;;;1283     }
;;;1284     q = pbuf_clone(layer, PBUF_RAM, p);
00000c  462a              MOV      r2,r5
00000e  f44f7120          MOV      r1,#0x280
000012  4618              MOV      r0,r3
000014  f7fffffe          BL       pbuf_clone
000018  4604              MOV      r4,r0
;;;1285     if (q == NULL) {
00001a  b134              CBZ      r4,|L11.42|
;;;1286       /* @todo: what do we do now? */
;;;1287       return p;
;;;1288     }
;;;1289     pbuf_free(p);
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       pbuf_free
;;;1290     return q;
000022  4620              MOV      r0,r4
;;;1291   }
000024  bd70              POP      {r4-r6,pc}
                  |L11.38|
000026  4628              MOV      r0,r5                 ;1282
000028  bd70              POP      {r4-r6,pc}
                  |L11.42|
00002a  4628              MOV      r0,r5                 ;1287
00002c  bd70              POP      {r4-r6,pc}
;;;1292   
                          ENDP


                          AREA ||i.pbuf_copy||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_copy PROC
;;;960    err_t
;;;961    pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;962    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;963      size_t offset_to = 0, offset_from = 0, len;
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
;;;964    
;;;965      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
;;;966                  (const void *)p_to, (const void *)p_from));
;;;967    
;;;968      /* is the target big enough to hold the source? */
;;;969      LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
00000c  f06f090f          MVN      r9,#0xf
000010  2d00              CMP      r5,#0
000012  d004              BEQ      |L12.30|
000014  b11c              CBZ      r4,|L12.30|
000016  8928              LDRH     r0,[r5,#8]
000018  8921              LDRH     r1,[r4,#8]
00001a  4288              CMP      r0,r1
00001c  d209              BCS      |L12.50|
                  |L12.30|
00001e  a335              ADR      r3,|L12.244|
000020  f24032c9          MOV      r2,#0x3c9
000024  a13f              ADR      r1,|L12.292|
000026  a04b              ADR      r0,|L12.340|
000028  f7fffffe          BL       __2printf
00002c  4648              MOV      r0,r9
                  |L12.46|
;;;970                 (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);
;;;971    
;;;972      /* iterate through pbuf chain */
;;;973      do {
;;;974        /* copy one part of the original chain */
;;;975        if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
;;;976          /* complete current p_from fits into current p_to */
;;;977          len = p_from->len - offset_from;
;;;978        } else {
;;;979          /* current p_from does not fit into current p_to */
;;;980          len = p_to->len - offset_to;
;;;981        }
;;;982        MEMCPY((u8_t *)p_to->payload + offset_to, (u8_t *)p_from->payload + offset_from, len);
;;;983        offset_to += len;
;;;984        offset_from += len;
;;;985        LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
;;;986        LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
;;;987        if (offset_from >= p_from->len) {
;;;988          /* on to next p_from (if any) */
;;;989          offset_from = 0;
;;;990          p_from = p_from->next;
;;;991        }
;;;992        if (offset_to == p_to->len) {
;;;993          /* on to next p_to (if any) */
;;;994          offset_to = 0;
;;;995          p_to = p_to->next;
;;;996          LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL), return ERR_ARG;);
;;;997        }
;;;998    
;;;999        if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
;;;1000         /* don't copy more than one packet! */
;;;1001         LWIP_ERROR("pbuf_copy() does not allow packet queues!",
;;;1002                    (p_from->next == NULL), return ERR_VAL;);
;;;1003       }
;;;1004       if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
;;;1005         /* don't copy more than one packet! */
;;;1006         LWIP_ERROR("pbuf_copy() does not allow packet queues!",
;;;1007                    (p_to->next == NULL), return ERR_VAL;);
;;;1008       }
;;;1009     } while (p_from);
;;;1010     LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
;;;1011     return ERR_OK;
;;;1012   }
00002e  e8bd87f0          POP      {r4-r10,pc}
                  |L12.50|
000032  f06f0a05          MVN      r10,#5                ;1001
                  |L12.54|
000036  8968              LDRH     r0,[r5,#0xa]          ;975
000038  8961              LDRH     r1,[r4,#0xa]          ;975
00003a  1b80              SUBS     r0,r0,r6              ;975
00003c  eba10807          SUB      r8,r1,r7              ;975
000040  4540              CMP      r0,r8                 ;975
000042  d200              BCS      |L12.70|
000044  4680              MOV      r8,r0                 ;980
                  |L12.70|
000046  6860              LDR      r0,[r4,#4]            ;982
000048  4642              MOV      r2,r8                 ;982
00004a  19c1              ADDS     r1,r0,r7              ;982
00004c  6868              LDR      r0,[r5,#4]            ;982
00004e  4430              ADD      r0,r0,r6              ;982
000050  f7fffffe          BL       __aeabi_memcpy
000054  4446              ADD      r6,r6,r8              ;983
000056  4447              ADD      r7,r7,r8              ;984
000058  8968              LDRH     r0,[r5,#0xa]          ;985
00005a  42b0              CMP      r0,r6                 ;985
00005c  d206              BCS      |L12.108|
00005e  a325              ADR      r3,|L12.244|
000060  f24032d9          MOV      r2,#0x3d9             ;985
000064  a145              ADR      r1,|L12.380|
000066  a03b              ADR      r0,|L12.340|
000068  f7fffffe          BL       __2printf
                  |L12.108|
00006c  8960              LDRH     r0,[r4,#0xa]          ;986
00006e  42b8              CMP      r0,r7                 ;986
000070  d206              BCS      |L12.128|
000072  a320              ADR      r3,|L12.244|
000074  f24032da          MOV      r2,#0x3da             ;986
000078  a146              ADR      r1,|L12.404|
00007a  a036              ADR      r0,|L12.340|
00007c  f7fffffe          BL       __2printf
                  |L12.128|
000080  8960              LDRH     r0,[r4,#0xa]          ;987
000082  42b8              CMP      r0,r7                 ;987
000084  d801              BHI      |L12.138|
000086  2700              MOVS     r7,#0                 ;989
000088  6824              LDR      r4,[r4,#0]            ;990
                  |L12.138|
00008a  8968              LDRH     r0,[r5,#0xa]          ;992
00008c  42b0              CMP      r0,r6                 ;992
00008e  d10c              BNE      |L12.170|
000090  2600              MOVS     r6,#0                 ;994
000092  682d              LDR      r5,[r5,#0]            ;995
000094  b94d              CBNZ     r5,|L12.170|
000096  b144              CBZ      r4,|L12.170|
000098  a316              ADR      r3,|L12.244|
00009a  f44f7279          MOV      r2,#0x3e4             ;996
00009e  a144              ADR      r1,|L12.432|
0000a0  a02c              ADR      r0,|L12.340|
0000a2  f7fffffe          BL       __2printf
0000a6  4648              MOV      r0,r9                 ;996
0000a8  e7c1              B        |L12.46|
                  |L12.170|
0000aa  2c00              CMP      r4,#0                 ;999
0000ac  d00e              BEQ      |L12.204|
0000ae  8960              LDRH     r0,[r4,#0xa]          ;999
0000b0  8921              LDRH     r1,[r4,#8]            ;999
0000b2  4288              CMP      r0,r1                 ;999
0000b4  d10a              BNE      |L12.204|
0000b6  6820              LDR      r0,[r4,#0]            ;1001
0000b8  b140              CBZ      r0,|L12.204|
0000ba  a30e              ADR      r3,|L12.244|
0000bc  f24032e9          MOV      r2,#0x3e9             ;1001
0000c0  a13f              ADR      r1,|L12.448|
0000c2  a024              ADR      r0,|L12.340|
0000c4  f7fffffe          BL       __2printf
0000c8  4650              MOV      r0,r10                ;1001
0000ca  e7b0              B        |L12.46|
                  |L12.204|
0000cc  b175              CBZ      r5,|L12.236|
0000ce  8968              LDRH     r0,[r5,#0xa]          ;1004
0000d0  8929              LDRH     r1,[r5,#8]            ;1004
0000d2  4288              CMP      r0,r1                 ;1004
0000d4  d10a              BNE      |L12.236|
0000d6  6828              LDR      r0,[r5,#0]            ;1006
0000d8  b140              CBZ      r0,|L12.236|
0000da  a306              ADR      r3,|L12.244|
0000dc  f24032ee          MOV      r2,#0x3ee             ;1006
0000e0  a137              ADR      r1,|L12.448|
0000e2  a01c              ADR      r0,|L12.340|
0000e4  f7fffffe          BL       __2printf
0000e8  4650              MOV      r0,r10                ;1006
0000ea  e7a0              B        |L12.46|
                  |L12.236|
0000ec  2c00              CMP      r4,#0                 ;1009
0000ee  d1a2              BNE      |L12.54|
0000f0  2000              MOVS     r0,#0                 ;1011
0000f2  e79c              B        |L12.46|
;;;1013   
                          ENDP

                  |L12.244|
0000f4  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
0000f8  6964646c
0000fc  65776172
000100  65735c54
000104  68697264
000108  5f506172
00010c  74795c4c
000110  7749505c
000114  7372635c
000118  636f7265
00011c  5c706275
000120  662e6300
                  |L12.292|
000124  70627566          DCB      "pbuf_copy: target not big enough to hold source",0
000128  5f636f70
00012c  793a2074
000130  61726765
000134  74206e6f
000138  74206269
00013c  6720656e
000140  6f756768
000144  20746f20
000148  686f6c64
00014c  20736f75
000150  72636500
                  |L12.340|
000154  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000158  7274696f
00015c  6e202225
000160  73222066
000164  61696c65
000168  64206174
00016c  206c696e
000170  65202564
000174  20696e20
000178  25730a00
                  |L12.380|
00017c  6f666673          DCB      "offset_to <= p_to->len",0
000180  65745f74
000184  6f203c3d
000188  20705f74
00018c  6f2d3e6c
000190  656e00  
000193  00                DCB      0
                  |L12.404|
000194  6f666673          DCB      "offset_from <= p_from->len",0
000198  65745f66
00019c  726f6d20
0001a0  3c3d2070
0001a4  5f66726f
0001a8  6d2d3e6c
0001ac  656e00  
0001af  00                DCB      0
                  |L12.432|
0001b0  705f746f          DCB      "p_to != NULL",0
0001b4  20213d20
0001b8  4e554c4c
0001bc  00      
0001bd  00                DCB      0
0001be  00                DCB      0
0001bf  00                DCB      0
                  |L12.448|
0001c0  70627566          DCB      "pbuf_copy() does not allow packet queues!",0
0001c4  5f636f70
0001c8  79282920
0001cc  646f6573
0001d0  206e6f74
0001d4  20616c6c
0001d8  6f772070
0001dc  61636b65
0001e0  74207175
0001e4  65756573
0001e8  2100    
0001ea  00                DCB      0
0001eb  00                DCB      0

                          AREA ||i.pbuf_copy_partial||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_copy_partial PROC
;;;1026   u16_t
;;;1027   pbuf_copy_partial(const struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1028   {
000004  4689              MOV      r9,r1
000006  4616              MOV      r6,r2
;;;1029     const struct pbuf *p;
;;;1030     u16_t left = 0;
000008  2700              MOVS     r7,#0
;;;1031     u16_t buf_copy_len;
;;;1032     u16_t copied_total = 0;
00000a  46b8              MOV      r8,r7
;;;1033   
;;;1034     LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
00000c  2800              CMP      r0,#0
00000e  d004              BEQ      |L13.26|
;;;1035     LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
000010  f1b90f00          CMP      r9,#0
000014  d00b              BEQ      |L13.46|
;;;1036   
;;;1037     /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;1038     for (p = buf; len != 0 && p != NULL; p = p->next) {
000016  4604              MOV      r4,r0
000018  e030              B        |L13.124|
                  |L13.26|
00001a  a31b              ADR      r3,|L13.136|
00001c  f240420a          MOV      r2,#0x40a             ;1034
000020  a125              ADR      r1,|L13.184|
000022  a02d              ADR      r0,|L13.216|
000024  f7fffffe          BL       __2printf
000028  2000              MOVS     r0,#0                 ;1034
                  |L13.42|
;;;1039       if ((offset != 0) && (offset >= p->len)) {
;;;1040         /* don't copy from this buffer -> on to the next */
;;;1041         offset = (u16_t)(offset - p->len);
;;;1042       } else {
;;;1043         /* copy from this buffer. maybe only partially. */
;;;1044         buf_copy_len = (u16_t)(p->len - offset);
;;;1045         if (buf_copy_len > len) {
;;;1046           buf_copy_len = len;
;;;1047         }
;;;1048         /* copy the necessary parts of the buffer */
;;;1049         MEMCPY(&((char *)dataptr)[left], &((char *)p->payload)[offset], buf_copy_len);
;;;1050         copied_total = (u16_t)(copied_total + buf_copy_len);
;;;1051         left = (u16_t)(left + buf_copy_len);
;;;1052         len = (u16_t)(len - buf_copy_len);
;;;1053         offset = 0;
;;;1054       }
;;;1055     }
;;;1056     return copied_total;
;;;1057   }
00002a  e8bd87f0          POP      {r4-r10,pc}
                  |L13.46|
00002e  a316              ADR      r3,|L13.136|
000030  f240420b          MOV      r2,#0x40b             ;1035
000034  a132              ADR      r1,|L13.256|
000036  a028              ADR      r0,|L13.216|
000038  f7fffffe          BL       __2printf
00003c  2000              MOVS     r0,#0                 ;1035
00003e  e7f4              B        |L13.42|
                  |L13.64|
000040  b12b              CBZ      r3,|L13.78|
000042  8960              LDRH     r0,[r4,#0xa]          ;1039
000044  4298              CMP      r0,r3                 ;1039
000046  d802              BHI      |L13.78|
000048  1a18              SUBS     r0,r3,r0              ;1041
00004a  b283              UXTH     r3,r0                 ;1041
00004c  e015              B        |L13.122|
                  |L13.78|
00004e  8960              LDRH     r0,[r4,#0xa]          ;1044
000050  1ac0              SUBS     r0,r0,r3              ;1044
000052  b285              UXTH     r5,r0                 ;1044
000054  42b5              CMP      r5,r6                 ;1045
000056  d900              BLS      |L13.90|
000058  4635              MOV      r5,r6                 ;1046
                  |L13.90|
00005a  6860              LDR      r0,[r4,#4]            ;1049
00005c  462a              MOV      r2,r5                 ;1049
00005e  18c1              ADDS     r1,r0,r3              ;1049
000060  eb090007          ADD      r0,r9,r7              ;1049
000064  f7fffffe          BL       __aeabi_memcpy
000068  eb080005          ADD      r0,r8,r5              ;1050
00006c  fa1ff880          UXTH     r8,r0                 ;1050
000070  1978              ADDS     r0,r7,r5              ;1051
000072  b287              UXTH     r7,r0                 ;1051
000074  1b70              SUBS     r0,r6,r5              ;1052
000076  b286              UXTH     r6,r0                 ;1052
000078  2300              MOVS     r3,#0                 ;1053
                  |L13.122|
00007a  6824              LDR      r4,[r4,#0]            ;1038
                  |L13.124|
00007c  b10e              CBZ      r6,|L13.130|
00007e  2c00              CMP      r4,#0                 ;1038
000080  d1de              BNE      |L13.64|
                  |L13.130|
000082  4640              MOV      r0,r8                 ;1056
000084  e7d1              B        |L13.42|
;;;1058   
                          ENDP

000086  0000              DCW      0x0000
                  |L13.136|
000088  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
00008c  6964646c
000090  65776172
000094  65735c54
000098  68697264
00009c  5f506172
0000a0  74795c4c
0000a4  7749505c
0000a8  7372635c
0000ac  636f7265
0000b0  5c706275
0000b4  662e6300
                  |L13.184|
0000b8  70627566          DCB      "pbuf_copy_partial: invalid buf",0
0000bc  5f636f70
0000c0  795f7061
0000c4  72746961
0000c8  6c3a2069
0000cc  6e76616c
0000d0  69642062
0000d4  756600  
0000d7  00                DCB      0
                  |L13.216|
0000d8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000dc  7274696f
0000e0  6e202225
0000e4  73222066
0000e8  61696c65
0000ec  64206174
0000f0  206c696e
0000f4  65202564
0000f8  20696e20
0000fc  25730a00
                  |L13.256|
000100  70627566          DCB      "pbuf_copy_partial: invalid dataptr",0
000104  5f636f70
000108  795f7061
00010c  72746961
000110  6c3a2069
000114  6e76616c
000118  69642064
00011c  61746170
000120  747200  
000123  00                DCB      0

                          AREA ||i.pbuf_dechain||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_dechain PROC
;;;911    struct pbuf *
;;;912    pbuf_dechain(struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;913    {
000002  4604              MOV      r4,r0
;;;914      struct pbuf *q;
;;;915      u8_t tail_gone = 1;
000004  2601              MOVS     r6,#1
;;;916      /* tail */
;;;917      q = p->next;
000006  6825              LDR      r5,[r4,#0]
;;;918      /* pbuf has successor in chain? */
;;;919      if (q != NULL) {
000008  2d00              CMP      r5,#0
00000a  d018              BEQ      |L14.62|
;;;920        /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;921        LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
00000c  8920              LDRH     r0,[r4,#8]
00000e  8961              LDRH     r1,[r4,#0xa]
000010  1a40              SUBS     r0,r0,r1
000012  8929              LDRH     r1,[r5,#8]
000014  4288              CMP      r0,r1
000016  d006              BEQ      |L14.38|
000018  a311              ADR      r3,|L14.96|
00001a  f2403299          MOV      r2,#0x399
00001e  a11c              ADR      r1,|L14.144|
000020  a024              ADR      r0,|L14.180|
000022  f7fffffe          BL       __2printf
                  |L14.38|
;;;922        /* enforce invariant if assertion is disabled */
;;;923        q->tot_len = (u16_t)(p->tot_len - p->len);
000026  8920              LDRH     r0,[r4,#8]
000028  8961              LDRH     r1,[r4,#0xa]
00002a  1a40              SUBS     r0,r0,r1
00002c  8128              STRH     r0,[r5,#8]
;;;924        /* decouple pbuf from remainder */
;;;925        p->next = NULL;
00002e  2000              MOVS     r0,#0
000030  6020              STR      r0,[r4,#0]
;;;926        /* total length of pbuf p is its own length only */
;;;927        p->tot_len = p->len;
000032  8960              LDRH     r0,[r4,#0xa]
000034  8120              STRH     r0,[r4,#8]
;;;928        /* q is no longer referenced by p, free it */
;;;929        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
;;;930        tail_gone = pbuf_free(q);
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       pbuf_free
00003c  4606              MOV      r6,r0
                  |L14.62|
;;;931        if (tail_gone > 0) {
;;;932          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE,
;;;933                      ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
;;;934        }
;;;935        /* return remaining tail or NULL if deallocated */
;;;936      }
;;;937      /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;938      LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
00003e  8920              LDRH     r0,[r4,#8]
000040  8961              LDRH     r1,[r4,#0xa]
000042  4288              CMP      r0,r1
000044  d006              BEQ      |L14.84|
000046  a306              ADR      r3,|L14.96|
000048  f24032aa          MOV      r2,#0x3aa
00004c  a123              ADR      r1,|L14.220|
00004e  a019              ADR      r0,|L14.180|
000050  f7fffffe          BL       __2printf
                  |L14.84|
;;;939      return ((tail_gone > 0) ? NULL : q);
000054  b10e              CBZ      r6,|L14.90|
000056  2000              MOVS     r0,#0
;;;940    }
000058  bd70              POP      {r4-r6,pc}
                  |L14.90|
00005a  4628              MOV      r0,r5                 ;939
00005c  bd70              POP      {r4-r6,pc}
;;;941    
                          ENDP

00005e  0000              DCW      0x0000
                  |L14.96|
000060  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000064  6964646c
000068  65776172
00006c  65735c54
000070  68697264
000074  5f506172
000078  74795c4c
00007c  7749505c
000080  7372635c
000084  636f7265
000088  5c706275
00008c  662e6300
                  |L14.144|
000090  702d3e74          DCB      "p->tot_len == p->len + q->tot_len",0
000094  6f745f6c
000098  656e203d
00009c  3d20702d
0000a0  3e6c656e
0000a4  202b2071
0000a8  2d3e746f
0000ac  745f6c65
0000b0  6e00    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L14.180|
0000b4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000b8  7274696f
0000bc  6e202225
0000c0  73222066
0000c4  61696c65
0000c8  64206174
0000cc  206c696e
0000d0  65202564
0000d4  20696e20
0000d8  25730a00
                  |L14.220|
0000dc  702d3e74          DCB      "p->tot_len == p->len",0
0000e0  6f745f6c
0000e4  656e203d
0000e8  3d20702d
0000ec  3e6c656e
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0

                          AREA ||i.pbuf_free||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_free PROC
;;;724    u8_t
;;;725    pbuf_free(struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;726    {
000002  4604              MOV      r4,r0
;;;727      u8_t alloc_src;
;;;728      struct pbuf *q;
;;;729      u8_t count;
;;;730    
;;;731      if (p == NULL) {
000004  2c00              CMP      r4,#0
000006  d001              BEQ      |L15.12|
;;;732        LWIP_ASSERT("p != NULL", p != NULL);
;;;733        /* if assertions are disabled, proceed with debug output */
;;;734        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;735                    ("pbuf_free(p == NULL) was called.\n"));
;;;736        return 0;
;;;737      }
;;;738      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));
;;;739    
;;;740      PERF_START;
;;;741    
;;;742      count = 0;
000008  2500              MOVS     r5,#0
;;;743      /* de-allocate all consecutive pbufs from the head of the chain that
;;;744       * obtain a zero reference count after decrementing*/
;;;745      while (p != NULL) {
00000a  e017              B        |L15.60|
                  |L15.12|
00000c  a326              ADR      r3,|L15.168|
00000e  f44f7237          MOV      r2,#0x2dc             ;732
000012  a131              ADR      r1,|L15.216|
000014  a033              ADR      r0,|L15.228|
000016  f7fffffe          BL       __2printf
00001a  2000              MOVS     r0,#0                 ;736
;;;746        LWIP_PBUF_REF_T ref;
;;;747        SYS_ARCH_DECL_PROTECT(old_level);
;;;748        /* Since decrementing ref cannot be guaranteed to be a single machine operation
;;;749         * we must protect it. We put the new ref into a local variable to prevent
;;;750         * further protection. */
;;;751        SYS_ARCH_PROTECT(old_level);
;;;752        /* all pbufs in a chain are referenced at least once */
;;;753        LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
;;;754        /* decrease reference count (number of pointers to pbuf) */
;;;755        ref = --(p->ref);
;;;756        SYS_ARCH_UNPROTECT(old_level);
;;;757        /* this pbuf is no longer referenced to? */
;;;758        if (ref == 0) {
;;;759          /* remember next pbuf in chain for next iteration */
;;;760          q = p->next;
;;;761          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
;;;762          alloc_src = pbuf_get_allocsrc(p);
;;;763    #if LWIP_SUPPORT_CUSTOM_PBUF
;;;764          /* is this a custom pbuf? */
;;;765          if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
;;;766            struct pbuf_custom *pc = (struct pbuf_custom *)p;
;;;767            LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
;;;768            pc->custom_free_function(p);
;;;769          } else
;;;770    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
;;;771          {
;;;772            /* is this a pbuf from the pool? */
;;;773            if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL) {
;;;774              memp_free(MEMP_PBUF_POOL, p);
;;;775              /* is this a ROM or RAM referencing pbuf? */
;;;776            } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF) {
;;;777              memp_free(MEMP_PBUF, p);
;;;778              /* type == PBUF_RAM */
;;;779            } else if (alloc_src == PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) {
;;;780              mem_free(p);
;;;781            } else {
;;;782              /* @todo: support freeing other types */
;;;783              LWIP_ASSERT("invalid pbuf type", 0);
;;;784            }
;;;785          }
;;;786          count++;
;;;787          /* proceed to next pbuf */
;;;788          p = q;
;;;789          /* p->ref > 0, this pbuf is still referenced to */
;;;790          /* (and so the remaining pbufs in chain as well) */
;;;791        } else {
;;;792          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, (u16_t)ref));
;;;793          /* stop walking through the chain */
;;;794          p = NULL;
;;;795        }
;;;796      }
;;;797      PERF_STOP("pbuf_free");
;;;798      /* return number of de-allocated pbufs */
;;;799      return count;
;;;800    }
00001c  bd70              POP      {r4-r6,pc}
                  |L15.30|
00001e  7ba0              LDRB     r0,[r4,#0xe]          ;753
000020  b930              CBNZ     r0,|L15.48|
000022  a321              ADR      r3,|L15.168|
000024  f24022f1          MOV      r2,#0x2f1             ;753
000028  a138              ADR      r1,|L15.268|
00002a  a02e              ADR      r0,|L15.228|
00002c  f7fffffe          BL       __2printf
                  |L15.48|
000030  7ba0              LDRB     r0,[r4,#0xe]          ;755
000032  1e40              SUBS     r0,r0,#1              ;755
000034  b2c0              UXTB     r0,r0                 ;755
000036  73a0              STRB     r0,[r4,#0xe]          ;755
000038  b120              CBZ      r0,|L15.68|
00003a  2400              MOVS     r4,#0                 ;794
                  |L15.60|
00003c  2c00              CMP      r4,#0                 ;745
00003e  d1ee              BNE      |L15.30|
000040  4628              MOV      r0,r5                 ;799
000042  bd70              POP      {r4-r6,pc}
                  |L15.68|
000044  6826              LDR      r6,[r4,#0]            ;760
000046  7b20              LDRB     r0,[r4,#0xc]          ;762
000048  f000000f          AND      r0,r0,#0xf            ;762
00004c  7b61              LDRB     r1,[r4,#0xd]          ;765
00004e  0789              LSLS     r1,r1,#30             ;765
000050  d50c              BPL      |L15.108|
000052  6920              LDR      r0,[r4,#0x10]         ;767
000054  b930              CBNZ     r0,|L15.100|
000056  a314              ADR      r3,|L15.168|
000058  f24022ff          MOV      r2,#0x2ff             ;767
00005c  a131              ADR      r1,|L15.292|
00005e  a021              ADR      r0,|L15.228|
000060  f7fffffe          BL       __2printf
                  |L15.100|
000064  6921              LDR      r1,[r4,#0x10]         ;768
000066  4620              MOV      r0,r4                 ;768
000068  4788              BLX      r1                    ;768
00006a  e00b              B        |L15.132|
                  |L15.108|
00006c  2802              CMP      r0,#2                 ;773
00006e  d00d              BEQ      |L15.140|
000070  2801              CMP      r0,#1                 ;776
000072  d010              BEQ      |L15.150|
000074  b1a0              CBZ      r0,|L15.160|
000076  a30c              ADR      r3,|L15.168|
000078  f240320f          MOV      r2,#0x30f             ;783
00007c  a132              ADR      r1,|L15.328|
00007e  a019              ADR      r0,|L15.228|
000080  f7fffffe          BL       __2printf
                  |L15.132|
000084  1c6d              ADDS     r5,r5,#1              ;786
000086  b2ed              UXTB     r5,r5                 ;786
000088  4634              MOV      r4,r6                 ;788
00008a  e7d7              B        |L15.60|
                  |L15.140|
00008c  4621              MOV      r1,r4                 ;774
00008e  2008              MOVS     r0,#8                 ;774
000090  f7fffffe          BL       memp_free
000094  e7f6              B        |L15.132|
                  |L15.150|
000096  4621              MOV      r1,r4                 ;777
000098  2007              MOVS     r0,#7                 ;777
00009a  f7fffffe          BL       memp_free
00009e  e7f1              B        |L15.132|
                  |L15.160|
0000a0  4620              MOV      r0,r4                 ;780
0000a2  f7fffffe          BL       mem_free
0000a6  e7ed              B        |L15.132|
;;;801    
                          ENDP

                  |L15.168|
0000a8  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
0000ac  6964646c
0000b0  65776172
0000b4  65735c54
0000b8  68697264
0000bc  5f506172
0000c0  74795c4c
0000c4  7749505c
0000c8  7372635c
0000cc  636f7265
0000d0  5c706275
0000d4  662e6300
                  |L15.216|
0000d8  7020213d          DCB      "p != NULL",0
0000dc  204e554c
0000e0  4c00    
0000e2  00                DCB      0
0000e3  00                DCB      0
                  |L15.228|
0000e4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000e8  7274696f
0000ec  6e202225
0000f0  73222066
0000f4  61696c65
0000f8  64206174
0000fc  206c696e
000100  65202564
000104  20696e20
000108  25730a00
                  |L15.268|
00010c  70627566          DCB      "pbuf_free: p->ref > 0",0
000110  5f667265
000114  653a2070
000118  2d3e7265
00011c  66203e20
000120  3000    
000122  00                DCB      0
000123  00                DCB      0
                  |L15.292|
000124  70632d3e          DCB      "pc->custom_free_function != NULL",0
000128  63757374
00012c  6f6d5f66
000130  7265655f
000134  66756e63
000138  74696f6e
00013c  20213d20
000140  4e554c4c
000144  00      
000145  00                DCB      0
000146  00                DCB      0
000147  00                DCB      0
                  |L15.328|
000148  696e7661          DCB      "invalid pbuf type",0
00014c  6c696420
000150  70627566
000154  20747970
000158  6500    
00015a  00                DCB      0
00015b  00                DCB      0

                          AREA ||i.pbuf_free_header||, CODE, READONLY, ALIGN=1

                  pbuf_free_header PROC
;;;670    struct pbuf *
;;;671    pbuf_free_header(struct pbuf *q, u16_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;672    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;673      struct pbuf *p = q;
;;;674      u16_t free_left = size;
;;;675      while (free_left && p) {
000006  2600              MOVS     r6,#0
000008  e00f              B        |L16.42|
                  |L16.10|
;;;676        if (free_left >= p->len) {
00000a  8961              LDRH     r1,[r4,#0xa]
00000c  42a9              CMP      r1,r5
00000e  d807              BHI      |L16.32|
;;;677          struct pbuf *f = p;
000010  4620              MOV      r0,r4
;;;678          free_left = (u16_t)(free_left - p->len);
000012  1a69              SUBS     r1,r5,r1
000014  b28d              UXTH     r5,r1
;;;679          p = p->next;
000016  6824              LDR      r4,[r4,#0]
;;;680          f->next = 0;
000018  6006              STR      r6,[r0,#0]
;;;681          pbuf_free(f);
00001a  f7fffffe          BL       pbuf_free
;;;682        } else {
00001e  e004              B        |L16.42|
                  |L16.32|
;;;683          pbuf_remove_header(p, free_left);
000020  4629              MOV      r1,r5
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       pbuf_remove_header
;;;684          free_left = 0;
000028  2500              MOVS     r5,#0
                  |L16.42|
00002a  b10d              CBZ      r5,|L16.48|
00002c  2c00              CMP      r4,#0                 ;675
00002e  d1ec              BNE      |L16.10|
                  |L16.48|
;;;685        }
;;;686      }
;;;687      return p;
000030  4620              MOV      r0,r4
;;;688    }
000032  bd70              POP      {r4-r6,pc}
;;;689    
                          ENDP


                          AREA ||i.pbuf_free_ooseq||, CODE, READONLY, ALIGN=2

                  pbuf_free_ooseq PROC
;;;127    void
;;;128    pbuf_free_ooseq(void)
000000  4906              LDR      r1,|L17.28|
;;;129    {
;;;130      struct tcp_pcb *pcb;
;;;131      SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);
000002  2000              MOVS     r0,#0
000004  7008              STRB     r0,[r1,#0]
;;;132    
;;;133      for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
000006  4806              LDR      r0,|L17.32|
000008  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
00000a  e004              B        |L17.22|
                  |L17.12|
;;;134        if (pcb->ooseq != NULL) {
00000c  6f41              LDR      r1,[r0,#0x74]
00000e  b109              CBZ      r1,|L17.20|
;;;135          /** Free the ooseq pbufs of one PCB only */
;;;136          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
;;;137          tcp_free_ooseq(pcb);
000010  f7ffbffe          B.W      tcp_free_ooseq
                  |L17.20|
000014  68c0              LDR      r0,[r0,#0xc]          ;133
                  |L17.22|
000016  2800              CMP      r0,#0                 ;133
000018  d1f8              BNE      |L17.12|
;;;138          return;
;;;139        }
;;;140      }
;;;141    }
00001a  4770              BX       lr
;;;142    
                          ENDP

                  |L17.28|
                          DCD      ||.data||
                  |L17.32|
                          DCD      tcp_active_pcbs

                          AREA ||i.pbuf_get_at||, CODE, READONLY, ALIGN=1

                  pbuf_get_at PROC
;;;1370   u8_t
;;;1371   pbuf_get_at(const struct pbuf *p, u16_t offset)
000000  b510              PUSH     {r4,lr}
;;;1372   {
;;;1373     int ret = pbuf_try_get_at(p, offset);
000002  f7fffffe          BL       pbuf_try_get_at
;;;1374     if (ret >= 0) {
000006  2800              CMP      r0,#0
000008  db01              BLT      |L18.14|
;;;1375       return (u8_t)ret;
00000a  b2c0              UXTB     r0,r0
;;;1376     }
;;;1377     return 0;
;;;1378   }
00000c  bd10              POP      {r4,pc}
                  |L18.14|
00000e  2000              MOVS     r0,#0                 ;1377
000010  bd10              POP      {r4,pc}
;;;1379   
                          ENDP


                          AREA ||i.pbuf_get_contiguous||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_get_contiguous PROC
;;;1073   void *
;;;1074   pbuf_get_contiguous(const struct pbuf *p, void *buffer, size_t bufsize, u16_t len, u16_t offset)
000000  b538              PUSH     {r3-r5,lr}
;;;1075   {
000002  460d              MOV      r5,r1
000004  9904              LDR      r1,[sp,#0x10]
000006  461c              MOV      r4,r3
;;;1076     const struct pbuf *q;
;;;1077     u16_t out_offset;
;;;1078   
;;;1079     LWIP_ERROR("pbuf_get_contiguous: invalid buf", (p != NULL), return NULL;);
000008  2800              CMP      r0,#0
00000a  d00c              BEQ      |L19.38|
;;;1080     LWIP_ERROR("pbuf_get_contiguous: invalid dataptr", (buffer != NULL), return NULL;);
00000c  2d00              CMP      r5,#0
00000e  d013              BEQ      |L19.56|
;;;1081     LWIP_ERROR("pbuf_get_contiguous: invalid dataptr", (bufsize >= len), return NULL;);
000010  42a2              CMP      r2,r4
000012  d21a              BCS      |L19.74|
000014  a319              ADR      r3,|L19.124|
000016  f2404239          MOV      r2,#0x439
00001a  a124              ADR      r1,|L19.172|
00001c  a02d              ADR      r0,|L19.212|
00001e  f7fffffe          BL       __2printf
000022  2000              MOVS     r0,#0
;;;1082   
;;;1083     q = pbuf_skip_const(p, offset, &out_offset);
;;;1084     if (q != NULL) {
;;;1085       if (q->len >= (out_offset + len)) {
;;;1086         /* all data in this pbuf, return zero-copy */
;;;1087         return (u8_t *)q->payload + out_offset;
;;;1088       }
;;;1089       /* need to copy */
;;;1090       if (pbuf_copy_partial(q, buffer, len, out_offset) != len) {
;;;1091         /* copying failed: pbuf is too short */
;;;1092         return NULL;
;;;1093       }
;;;1094       return buffer;
;;;1095     }
;;;1096     /* pbuf is too short (offset does not fit in) */
;;;1097     return NULL;
;;;1098   }
000024  bd38              POP      {r3-r5,pc}
                  |L19.38|
000026  a315              ADR      r3,|L19.124|
000028  f2404237          MOV      r2,#0x437             ;1079
00002c  a133              ADR      r1,|L19.252|
00002e  a029              ADR      r0,|L19.212|
000030  f7fffffe          BL       __2printf
000034  2000              MOVS     r0,#0                 ;1079
000036  bd38              POP      {r3-r5,pc}
                  |L19.56|
000038  a310              ADR      r3,|L19.124|
00003a  f44f6287          MOV      r2,#0x438             ;1080
00003e  a11b              ADR      r1,|L19.172|
000040  a024              ADR      r0,|L19.212|
000042  f7fffffe          BL       __2printf
000046  2000              MOVS     r0,#0                 ;1080
000048  bd38              POP      {r3-r5,pc}
                  |L19.74|
00004a  466a              MOV      r2,sp                 ;1083
00004c  f7fffffe          BL       pbuf_skip_const
000050  b190              CBZ      r0,|L19.120|
000052  f8bd3000          LDRH     r3,[sp,#0]            ;1085
000056  8941              LDRH     r1,[r0,#0xa]          ;1085
000058  191a              ADDS     r2,r3,r4              ;1085
00005a  4291              CMP      r1,r2                 ;1085
00005c  d302              BCC      |L19.100|
00005e  6840              LDR      r0,[r0,#4]            ;1087
000060  4418              ADD      r0,r0,r3              ;1087
000062  bd38              POP      {r3-r5,pc}
                  |L19.100|
000064  4622              MOV      r2,r4                 ;1090
000066  4629              MOV      r1,r5                 ;1090
000068  f7fffffe          BL       pbuf_copy_partial
00006c  42a0              CMP      r0,r4                 ;1090
00006e  d001              BEQ      |L19.116|
000070  2000              MOVS     r0,#0                 ;1092
000072  bd38              POP      {r3-r5,pc}
                  |L19.116|
000074  4628              MOV      r0,r5                 ;1094
000076  bd38              POP      {r3-r5,pc}
                  |L19.120|
000078  2000              MOVS     r0,#0                 ;1097
00007a  bd38              POP      {r3-r5,pc}
;;;1099   
                          ENDP

                  |L19.124|
00007c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000080  6964646c
000084  65776172
000088  65735c54
00008c  68697264
000090  5f506172
000094  74795c4c
000098  7749505c
00009c  7372635c
0000a0  636f7265
0000a4  5c706275
0000a8  662e6300
                  |L19.172|
0000ac  70627566          DCB      "pbuf_get_contiguous: invalid dataptr",0
0000b0  5f676574
0000b4  5f636f6e
0000b8  74696775
0000bc  6f75733a
0000c0  20696e76
0000c4  616c6964
0000c8  20646174
0000cc  61707472
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0
                  |L19.212|
0000d4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000d8  7274696f
0000dc  6e202225
0000e0  73222066
0000e4  61696c65
0000e8  64206174
0000ec  206c696e
0000f0  65202564
0000f4  20696e20
0000f8  25730a00
                  |L19.252|
0000fc  70627566          DCB      "pbuf_get_contiguous: invalid buf",0
000100  5f676574
000104  5f636f6e
000108  74696775
00010c  6f75733a
000110  20696e76
000114  616c6964
000118  20627566
00011c  00      
00011d  00                DCB      0
00011e  00                DCB      0
00011f  00                DCB      0

                          AREA ||i.pbuf_header||, CODE, READONLY, ALIGN=1

                  pbuf_header PROC
;;;645    u8_t
;;;646    pbuf_header(struct pbuf *p, s16_t header_size_increment)
000000  2200              MOVS     r2,#0
;;;647    {
;;;648      return pbuf_header_impl(p, header_size_increment, 0);
000002  f7ffbffe          B.W      pbuf_header_impl
;;;649    }
;;;650    
                          ENDP


                          AREA ||i.pbuf_header_force||, CODE, READONLY, ALIGN=1

                  pbuf_header_force PROC
;;;655    u8_t
;;;656    pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
000000  2201              MOVS     r2,#1
;;;657    {
;;;658      return pbuf_header_impl(p, header_size_increment, 1);
000002  f7ffbffe          B.W      pbuf_header_impl
;;;659    }
;;;660    
                          ENDP


                          AREA ||i.pbuf_header_impl||, CODE, READONLY, ALIGN=1

                  pbuf_header_impl PROC
;;;615    static u8_t
;;;616    pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
000000  2900              CMP      r1,#0
;;;617    {
000002  da02              BGE      |L22.10|
;;;618      if (header_size_increment < 0) {
;;;619        return pbuf_remove_header(p, (size_t) - header_size_increment);
000004  4249              RSBS     r1,r1,#0
000006  f7ffbffe          B.W      pbuf_remove_header
                  |L22.10|
;;;620      } else {
;;;621        return pbuf_add_header_impl(p, (size_t)header_size_increment, force);
00000a  f7ffbffe          B.W      pbuf_add_header_impl
;;;622      }
;;;623    }
;;;624    
                          ENDP


                          AREA ||i.pbuf_init_alloced_pbuf||, CODE, READONLY, ALIGN=1

                  pbuf_init_alloced_pbuf PROC
;;;178    static void
;;;179    pbuf_init_alloced_pbuf(struct pbuf *p, void *payload, u16_t tot_len, u16_t len, pbuf_type type, u8_t flags)
000000  b570              PUSH     {r4-r6,lr}
;;;180    {
000002  e9dd5604          LDRD     r5,r6,[sp,#0x10]
;;;181      p->next = NULL;
000006  2400              MOVS     r4,#0
000008  6004              STR      r4,[r0,#0]
;;;182      p->payload = payload;
00000a  6041              STR      r1,[r0,#4]
;;;183      p->tot_len = tot_len;
00000c  8102              STRH     r2,[r0,#8]
;;;184      p->len = len;
00000e  8143              STRH     r3,[r0,#0xa]
;;;185      p->type_internal = (u8_t)type;
000010  7305              STRB     r5,[r0,#0xc]
;;;186      p->flags = flags;
000012  7346              STRB     r6,[r0,#0xd]
;;;187      p->ref = 1;
000014  2101              MOVS     r1,#1
000016  7381              STRB     r1,[r0,#0xe]
;;;188      p->if_idx = NETIF_NO_INDEX;
000018  73c4              STRB     r4,[r0,#0xf]
;;;189    }
00001a  bd70              POP      {r4-r6,pc}
;;;190    
                          ENDP


                          AREA ||i.pbuf_memcmp||, CODE, READONLY, ALIGN=1

                  pbuf_memcmp PROC
;;;1433   u16_t
;;;1434   pbuf_memcmp(const struct pbuf *p, u16_t offset, const void *s2, u16_t n)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1435   {
000004  4690              MOV      r8,r2
000006  461f              MOV      r7,r3
;;;1436     u16_t start = offset;
000008  460d              MOV      r5,r1
;;;1437     const struct pbuf *q = p;
00000a  4606              MOV      r6,r0
;;;1438     u16_t i;
;;;1439   
;;;1440     /* pbuf long enough to perform check? */
;;;1441     if (p->tot_len < (offset + n)) {
00000c  8900              LDRH     r0,[r0,#8]
00000e  4439              ADD      r1,r1,r7
;;;1442       return 0xffff;
000010  f64f79ff          MOV      r9,#0xffff
000014  4288              CMP      r0,r1                 ;1441
000016  d205              BCS      |L24.36|
000018  4648              MOV      r0,r9
                  |L24.26|
;;;1443     }
;;;1444   
;;;1445     /* get the correct pbuf from chain. We know it succeeds because of p->tot_len check above. */
;;;1446     while ((q != NULL) && (q->len <= start)) {
;;;1447       start = (u16_t)(start - q->len);
;;;1448       q = q->next;
;;;1449     }
;;;1450   
;;;1451     /* return requested data if pbuf is OK */
;;;1452     for (i = 0; i < n; i++) {
;;;1453       /* We know pbuf_get_at() succeeds because of p->tot_len check above. */
;;;1454       u8_t a = pbuf_get_at(q, (u16_t)(start + i));
;;;1455       u8_t b = ((const u8_t *)s2)[i];
;;;1456       if (a != b) {
;;;1457         return (u16_t)LWIP_MIN(i + 1, 0xFFFF);
;;;1458       }
;;;1459     }
;;;1460     return 0;
;;;1461   }
00001a  e8bd87f0          POP      {r4-r10,pc}
                  |L24.30|
00001e  1a28              SUBS     r0,r5,r0              ;1447
000020  b285              UXTH     r5,r0                 ;1447
000022  6836              LDR      r6,[r6,#0]            ;1448
                  |L24.36|
000024  b116              CBZ      r6,|L24.44|
000026  8970              LDRH     r0,[r6,#0xa]          ;1446
000028  42a8              CMP      r0,r5                 ;1446
00002a  d9f8              BLS      |L24.30|
                  |L24.44|
00002c  2400              MOVS     r4,#0                 ;1452
00002e  e011              B        |L24.84|
                  |L24.48|
000030  1928              ADDS     r0,r5,r4              ;1454
000032  b281              UXTH     r1,r0                 ;1454
000034  4630              MOV      r0,r6                 ;1454
000036  f7fffffe          BL       pbuf_get_at
00003a  f8181004          LDRB     r1,[r8,r4]            ;1455
00003e  4288              CMP      r0,r1                 ;1456
000040  d006              BEQ      |L24.80|
000042  1c60              ADDS     r0,r4,#1              ;1457
000044  4548              CMP      r0,r9                 ;1457
000046  d200              BCS      |L24.74|
000048  4681              MOV      r9,r0                 ;1457
                  |L24.74|
00004a  fa1ff089          UXTH     r0,r9                 ;1457
00004e  e7e4              B        |L24.26|
                  |L24.80|
000050  1c64              ADDS     r4,r4,#1              ;1452
000052  b2a4              UXTH     r4,r4                 ;1452
                  |L24.84|
000054  42bc              CMP      r4,r7                 ;1452
000056  d3eb              BCC      |L24.48|
000058  2000              MOVS     r0,#0                 ;1460
00005a  e7de              B        |L24.26|
;;;1462   
                          ENDP


                          AREA ||i.pbuf_memfind||, CODE, READONLY, ALIGN=1

                  pbuf_memfind PROC
;;;1475   u16_t
;;;1476   pbuf_memfind(const struct pbuf *p, const void *mem, u16_t mem_len, u16_t start_offset)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1477   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;1478     u16_t i;
;;;1479     u16_t max_cmp_start = (u16_t)(p->tot_len - mem_len);
00000a  8938              LDRH     r0,[r7,#8]
00000c  1b81              SUBS     r1,r0,r6
00000e  b28d              UXTH     r5,r1
;;;1480     if (p->tot_len >= mem_len + start_offset) {
000010  18f1              ADDS     r1,r6,r3
000012  4288              CMP      r0,r1
000014  d30c              BCC      |L25.48|
;;;1481       for (i = start_offset; i <= max_cmp_start; i++) {
000016  461c              MOV      r4,r3
000018  e008              B        |L25.44|
                  |L25.26|
;;;1482         u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
00001a  4633              MOV      r3,r6
00001c  4642              MOV      r2,r8
00001e  4621              MOV      r1,r4
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       pbuf_memcmp
;;;1483         if (plus == 0) {
000026  b138              CBZ      r0,|L25.56|
000028  1c64              ADDS     r4,r4,#1              ;1481
00002a  b2a4              UXTH     r4,r4                 ;1481
                  |L25.44|
00002c  42ac              CMP      r4,r5                 ;1481
00002e  d9f4              BLS      |L25.26|
                  |L25.48|
;;;1484           return i;
;;;1485         }
;;;1486       }
;;;1487     }
;;;1488     return 0xFFFF;
000030  f64f70ff          MOV      r0,#0xffff
                  |L25.52|
;;;1489   }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L25.56|
000038  4620              MOV      r0,r4                 ;1484
00003a  e7fb              B        |L25.52|
;;;1490   
                          ENDP


                          AREA ||i.pbuf_pool_is_empty||, CODE, READONLY, ALIGN=2

                  pbuf_pool_is_empty PROC
;;;156    static void
;;;157    pbuf_pool_is_empty(void)
000000  4901              LDR      r1,|L26.8|
;;;158    {
;;;159    #ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
;;;160      SYS_ARCH_SET(pbuf_free_ooseq_pending, 1);
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;161    #else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;162      u8_t queued;
;;;163      SYS_ARCH_DECL_PROTECT(old_level);
;;;164      SYS_ARCH_PROTECT(old_level);
;;;165      queued = pbuf_free_ooseq_pending;
;;;166      pbuf_free_ooseq_pending = 1;
;;;167      SYS_ARCH_UNPROTECT(old_level);
;;;168    
;;;169      if (!queued) {
;;;170        /* queue a call to pbuf_free_ooseq if not already queued */
;;;171        PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
;;;172      }
;;;173    #endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;174    }
000006  4770              BX       lr
;;;175    #endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */
                          ENDP

                  |L26.8|
                          DCD      ||.data||

                          AREA ||i.pbuf_put_at||, CODE, READONLY, ALIGN=1

                  pbuf_put_at PROC
;;;1410   void
;;;1411   pbuf_put_at(struct pbuf *p, u16_t offset, u8_t data)
000000  b538              PUSH     {r3-r5,lr}
;;;1412   {
000002  4614              MOV      r4,r2
;;;1413     u16_t q_idx;
;;;1414     struct pbuf *q = pbuf_skip(p, offset, &q_idx);
000004  466a              MOV      r2,sp
000006  f7fffffe          BL       pbuf_skip
;;;1415   
;;;1416     /* write requested data if pbuf is OK */
;;;1417     if ((q != NULL) && (q->len > q_idx)) {
00000a  2800              CMP      r0,#0
00000c  d006              BEQ      |L27.28|
00000e  8943              LDRH     r3,[r0,#0xa]
000010  f8bd1000          LDRH     r1,[sp,#0]
000014  428b              CMP      r3,r1
000016  d901              BLS      |L27.28|
;;;1418       ((u8_t *)q->payload)[q_idx] = data;
000018  6840              LDR      r0,[r0,#4]
00001a  5444              STRB     r4,[r0,r1]
                  |L27.28|
;;;1419     }
;;;1420   }
00001c  bd38              POP      {r3-r5,pc}
;;;1421   
                          ENDP


                          AREA ||i.pbuf_realloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_realloc PROC
;;;401    void
;;;402    pbuf_realloc(struct pbuf *p, u16_t new_len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;403    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;404      struct pbuf *q;
;;;405      u16_t rem_len; /* remaining length */
;;;406      u16_t shrink;
;;;407    
;;;408      LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
000008  2c00              CMP      r4,#0
00000a  d106              BNE      |L28.26|
00000c  a320              ADR      r3,|L28.144|
00000e  f44f72cc          MOV      r2,#0x198
000012  a12b              ADR      r1,|L28.192|
000014  a030              ADR      r0,|L28.216|
000016  f7fffffe          BL       __2printf
                  |L28.26|
;;;409    
;;;410      /* desired length larger than current length? */
;;;411      if (new_len >= p->tot_len) {
00001a  8920              LDRH     r0,[r4,#8]
00001c  42a8              CMP      r0,r5
00001e  d935              BLS      |L28.140|
;;;412        /* enlarging not yet supported */
;;;413        return;
;;;414      }
;;;415    
;;;416      /* the pbuf chain grows by (new_len - p->tot_len) bytes
;;;417       * (which may be negative in case of shrinking) */
;;;418      shrink = (u16_t)(p->tot_len - new_len);
000020  1b40              SUBS     r0,r0,r5
000022  b286              UXTH     r6,r0
;;;419    
;;;420      /* first, step over any pbufs that should remain in the chain */
;;;421      rem_len = new_len;
;;;422      q = p;
;;;423      /* should this pbuf be kept? */
;;;424      while (rem_len > q->len) {
;;;425        /* decrease remaining length by pbuf length */
;;;426        rem_len = (u16_t)(rem_len - q->len);
;;;427        /* decrease total length indicator */
;;;428        q->tot_len = (u16_t)(q->tot_len - shrink);
;;;429        /* proceed to next pbuf in chain */
;;;430        q = q->next;
;;;431        LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
000024  f24017af          MOV      r7,#0x1af
000028  e00c              B        |L28.68|
                  |L28.42|
00002a  1a28              SUBS     r0,r5,r0              ;426
00002c  b285              UXTH     r5,r0                 ;426
00002e  8920              LDRH     r0,[r4,#8]            ;428
000030  1b80              SUBS     r0,r0,r6              ;428
000032  8120              STRH     r0,[r4,#8]            ;428
000034  6824              LDR      r4,[r4,#0]            ;430
000036  b92c              CBNZ     r4,|L28.68|
000038  a315              ADR      r3,|L28.144|
00003a  463a              MOV      r2,r7
00003c  a130              ADR      r1,|L28.256|
00003e  a026              ADR      r0,|L28.216|
000040  f7fffffe          BL       __2printf
                  |L28.68|
000044  8960              LDRH     r0,[r4,#0xa]          ;424
000046  42a8              CMP      r0,r5                 ;424
000048  d3ef              BCC      |L28.42|
;;;432      }
;;;433      /* we have now reached the new last pbuf (in q) */
;;;434      /* rem_len == desired length for pbuf q */
;;;435    
;;;436      /* shrink allocated memory for PBUF_RAM */
;;;437      /* (other types merely adjust their length fields */
;;;438      if (pbuf_match_allocsrc(q, PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP) && (rem_len != q->len)
00004a  7b20              LDRB     r0,[r4,#0xc]
00004c  0700              LSLS     r0,r0,#28
00004e  d115              BNE      |L28.124|
000050  8960              LDRH     r0,[r4,#0xa]
000052  42a8              CMP      r0,r5
000054  d012              BEQ      |L28.124|
;;;439    #if LWIP_SUPPORT_CUSTOM_PBUF
;;;440          && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
000056  7b60              LDRB     r0,[r4,#0xd]
000058  0780              LSLS     r0,r0,#30
00005a  d40f              BMI      |L28.124|
;;;441    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
;;;442         ) {
;;;443        /* reallocate and adjust the length of the pbuf that will be split */
;;;444        q = (struct pbuf *)mem_trim(q, (mem_size_t)(((u8_t *)q->payload - (u8_t *)q) + rem_len));
00005c  88a0              LDRH     r0,[r4,#4]
00005e  1b00              SUBS     r0,r0,r4
000060  4428              ADD      r0,r0,r5
000062  b281              UXTH     r1,r0
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       mem_trim
00006a  4604              MOV      r4,r0
;;;445        LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
00006c  b934              CBNZ     r4,|L28.124|
00006e  a308              ADR      r3,|L28.144|
000070  f24012bd          MOV      r2,#0x1bd
000074  a128              ADR      r1,|L28.280|
000076  a018              ADR      r0,|L28.216|
000078  f7fffffe          BL       __2printf
                  |L28.124|
;;;446      }
;;;447      /* adjust length fields for new last pbuf */
;;;448      q->len = rem_len;
00007c  8165              STRH     r5,[r4,#0xa]
;;;449      q->tot_len = q->len;
00007e  8125              STRH     r5,[r4,#8]
;;;450    
;;;451      /* any remaining pbufs in chain? */
;;;452      if (q->next != NULL) {
000080  6820              LDR      r0,[r4,#0]
000082  b108              CBZ      r0,|L28.136|
;;;453        /* free remaining pbufs in chain */
;;;454        pbuf_free(q->next);
000084  f7fffffe          BL       pbuf_free
                  |L28.136|
;;;455      }
;;;456      /* q is last packet in chain */
;;;457      q->next = NULL;
000088  2000              MOVS     r0,#0
00008a  6020              STR      r0,[r4,#0]
                  |L28.140|
;;;458    
;;;459    }
00008c  e8bd81f0          POP      {r4-r8,pc}
;;;460    
                          ENDP

                  |L28.144|
000090  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000094  6964646c
000098  65776172
00009c  65735c54
0000a0  68697264
0000a4  5f506172
0000a8  74795c4c
0000ac  7749505c
0000b0  7372635c
0000b4  636f7265
0000b8  5c706275
0000bc  662e6300
                  |L28.192|
0000c0  70627566          DCB      "pbuf_realloc: p != NULL",0
0000c4  5f726561
0000c8  6c6c6f63
0000cc  3a207020
0000d0  213d204e
0000d4  554c4c00
                  |L28.216|
0000d8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000dc  7274696f
0000e0  6e202225
0000e4  73222066
0000e8  61696c65
0000ec  64206174
0000f0  206c696e
0000f4  65202564
0000f8  20696e20
0000fc  25730a00
                  |L28.256|
000100  70627566          DCB      "pbuf_realloc: q != NULL",0
000104  5f726561
000108  6c6c6f63
00010c  3a207120
000110  213d204e
000114  554c4c00
                  |L28.280|
000118  6d656d5f          DCB      "mem_trim returned q == NULL",0
00011c  7472696d
000120  20726574
000124  75726e65
000128  64207120
00012c  3d3d204e
000130  554c4c00

                          AREA ||i.pbuf_ref||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pbuf_ref PROC
;;;828    void
;;;829    pbuf_ref(struct pbuf *p)
000000  2800              CMP      r0,#0
;;;830    {
000002  d00c              BEQ      |L29.30|
;;;831      /* pbuf given? */
;;;832      if (p != NULL) {
;;;833        SYS_ARCH_SET(p->ref, (LWIP_PBUF_REF_T)(p->ref + 1));
000004  7b81              LDRB     r1,[r0,#0xe]
000006  1c49              ADDS     r1,r1,#1
000008  b2c9              UXTB     r1,r1
00000a  7381              STRB     r1,[r0,#0xe]
;;;834        LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
00000c  2900              CMP      r1,#0
00000e  d106              BNE      |L29.30|
000010  a303              ADR      r3,|L29.32|
000012  f2403242          MOV      r2,#0x342
000016  a10e              ADR      r1,|L29.80|
000018  a012              ADR      r0,|L29.100|
00001a  f7ffbffe          B.W      __2printf
                  |L29.30|
;;;835      }
;;;836    }
00001e  4770              BX       lr
;;;837    
                          ENDP

                  |L29.32|
000020  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000024  6964646c
000028  65776172
00002c  65735c54
000030  68697264
000034  5f506172
000038  74795c4c
00003c  7749505c
000040  7372635c
000044  636f7265
000048  5c706275
00004c  662e6300
                  |L29.80|
000050  70627566          DCB      "pbuf ref overflow",0
000054  20726566
000058  206f7665
00005c  72666c6f
000060  7700    
000062  00                DCB      0
000063  00                DCB      0
                  |L29.100|
000064  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000068  7274696f
00006c  6e202225
000070  73222066
000074  61696c65
000078  64206174
00007c  206c696e
000080  65202564
000084  20696e20
000088  25730a00

                          AREA ||i.pbuf_remove_header||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_remove_header PROC
;;;581    u8_t
;;;582    pbuf_remove_header(struct pbuf *p, size_t header_size_decrement)
000000  b570              PUSH     {r4-r6,lr}
;;;583    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;584      void *payload;
;;;585      u16_t increment_magnitude;
;;;586    
;;;587      LWIP_ASSERT("p != NULL", p != NULL);
000006  2c00              CMP      r4,#0
000008  d106              BNE      |L30.24|
00000a  a314              ADR      r3,|L30.92|
00000c  f240224b          MOV      r2,#0x24b
000010  a11e              ADR      r1,|L30.140|
000012  a021              ADR      r0,|L30.152|
000014  f7fffffe          BL       __2printf
                  |L30.24|
;;;588      if ((p == NULL) || (header_size_decrement > 0xFFFF)) {
000018  b114              CBZ      r4,|L30.32|
00001a  f5b53f80          CMP      r5,#0x10000
00001e  d301              BCC      |L30.36|
                  |L30.32|
;;;589        return 1;
000020  2001              MOVS     r0,#1
;;;590      }
;;;591      if (header_size_decrement == 0) {
;;;592        return 0;
;;;593      }
;;;594    
;;;595      increment_magnitude = (u16_t)header_size_decrement;
;;;596      /* Check that we aren't going to move off the end of the pbuf */
;;;597      LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
;;;598    
;;;599      /* remember current payload pointer */
;;;600      payload = p->payload;
;;;601      LWIP_UNUSED_ARG(payload); /* only used in LWIP_DEBUGF below */
;;;602    
;;;603      /* increase payload pointer (guarded by length check above) */
;;;604      p->payload = (u8_t *)p->payload + header_size_decrement;
;;;605      /* modify pbuf length fields */
;;;606      p->len = (u16_t)(p->len - increment_magnitude);
;;;607      p->tot_len = (u16_t)(p->tot_len - increment_magnitude);
;;;608    
;;;609      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_remove_header: old %p new %p (%"U16_F")\n",
;;;610                  (void *)payload, (void *)p->payload, increment_magnitude));
;;;611    
;;;612      return 0;
;;;613    }
000022  bd70              POP      {r4-r6,pc}
                  |L30.36|
000024  2d00              CMP      r5,#0                 ;591
000026  d00c              BEQ      |L30.66|
000028  b2a8              UXTH     r0,r5                 ;595
00002a  8961              LDRH     r1,[r4,#0xa]          ;597
00002c  4281              CMP      r1,r0                 ;597
00002e  d20a              BCS      |L30.70|
000030  a30a              ADR      r3,|L30.92|
000032  f2402255          MOV      r2,#0x255             ;597
000036  a122              ADR      r1,|L30.192|
000038  a017              ADR      r0,|L30.152|
00003a  f7fffffe          BL       __2printf
00003e  2001              MOVS     r0,#1                 ;597
000040  bd70              POP      {r4-r6,pc}
                  |L30.66|
000042  2000              MOVS     r0,#0                 ;592
000044  bd70              POP      {r4-r6,pc}
                  |L30.70|
000046  6862              LDR      r2,[r4,#4]            ;600
000048  442a              ADD      r2,r2,r5              ;604
00004a  6062              STR      r2,[r4,#4]            ;604
00004c  1a09              SUBS     r1,r1,r0              ;606
00004e  8161              STRH     r1,[r4,#0xa]          ;606
000050  8921              LDRH     r1,[r4,#8]            ;607
000052  1a08              SUBS     r0,r1,r0              ;607
000054  8120              STRH     r0,[r4,#8]            ;607
000056  2000              MOVS     r0,#0                 ;612
000058  bd70              POP      {r4-r6,pc}
;;;614    
                          ENDP

00005a  0000              DCW      0x0000
                  |L30.92|
00005c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000060  6964646c
000064  65776172
000068  65735c54
00006c  68697264
000070  5f506172
000074  74795c4c
000078  7749505c
00007c  7372635c
000080  636f7265
000084  5c706275
000088  662e6300
                  |L30.140|
00008c  7020213d          DCB      "p != NULL",0
000090  204e554c
000094  4c00    
000096  00                DCB      0
000097  00                DCB      0
                  |L30.152|
000098  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00009c  7274696f
0000a0  6e202225
0000a4  73222066
0000a8  61696c65
0000ac  64206174
0000b0  206c696e
0000b4  65202564
0000b8  20696e20
0000bc  25730a00
                  |L30.192|
0000c0  696e6372          DCB      "increment_magnitude <= p->len",0
0000c4  656d656e
0000c8  745f6d61
0000cc  676e6974
0000d0  75646520
0000d4  3c3d2070
0000d8  2d3e6c65
0000dc  6e00    
0000de  00                DCB      0
0000df  00                DCB      0

                          AREA ||i.pbuf_skip||, CODE, READONLY, ALIGN=1

                  pbuf_skip PROC
;;;1177   struct pbuf *
;;;1178   pbuf_skip(struct pbuf *in, u16_t in_offset, u16_t *out_offset)
000000  f7ffbffe          B.W      pbuf_skip_const
;;;1179   {
;;;1180     const struct pbuf *out = pbuf_skip_const(in, in_offset, out_offset);
;;;1181     return LWIP_CONST_CAST(struct pbuf *, out);
;;;1182   }
;;;1183   
                          ENDP


                          AREA ||i.pbuf_skip_const||, CODE, READONLY, ALIGN=1

                  pbuf_skip_const PROC
;;;1151   static const struct pbuf *
;;;1152   pbuf_skip_const(const struct pbuf *in, u16_t in_offset, u16_t *out_offset)
000000  e002              B        |L32.8|
                  |L32.2|
;;;1153   {
;;;1154     u16_t offset_left = in_offset;
;;;1155     const struct pbuf *q = in;
;;;1156   
;;;1157     /* get the correct pbuf */
;;;1158     while ((q != NULL) && (q->len <= offset_left)) {
;;;1159       offset_left = (u16_t)(offset_left - q->len);
000002  1ac9              SUBS     r1,r1,r3
000004  b289              UXTH     r1,r1
;;;1160       q = q->next;
000006  6800              LDR      r0,[r0,#0]
                  |L32.8|
000008  b110              CBZ      r0,|L32.16|
00000a  8943              LDRH     r3,[r0,#0xa]          ;1158
00000c  428b              CMP      r3,r1                 ;1158
00000e  d9f8              BLS      |L32.2|
                  |L32.16|
;;;1161     }
;;;1162     if (out_offset != NULL) {
000010  2a00              CMP      r2,#0
000012  d000              BEQ      |L32.22|
;;;1163       *out_offset = offset_left;
000014  8011              STRH     r1,[r2,#0]
                  |L32.22|
;;;1164     }
;;;1165     return q;
;;;1166   }
000016  4770              BX       lr
;;;1167   
                          ENDP


                          AREA ||i.pbuf_strstr||, CODE, READONLY, ALIGN=1

                  pbuf_strstr PROC
;;;1502   u16_t
;;;1503   pbuf_strstr(const struct pbuf *p, const char *substr)
000000  b570              PUSH     {r4-r6,lr}
;;;1504   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;1505     size_t substr_len;
;;;1506     if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
000006  f64f75ff          MOV      r5,#0xffff
00000a  2c00              CMP      r4,#0
00000c  d004              BEQ      |L33.24|
00000e  7820              LDRB     r0,[r4,#0]
000010  b110              CBZ      r0,|L33.24|
000012  8930              LDRH     r0,[r6,#8]
000014  42a8              CMP      r0,r5
000016  d101              BNE      |L33.28|
                  |L33.24|
;;;1507       return 0xFFFF;
000018  4628              MOV      r0,r5
;;;1508     }
;;;1509     substr_len = strlen(substr);
;;;1510     if (substr_len >= 0xFFFF) {
;;;1511       return 0xFFFF;
;;;1512     }
;;;1513     return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
;;;1514   }
00001a  bd70              POP      {r4-r6,pc}
                  |L33.28|
00001c  4620              MOV      r0,r4                 ;1509
00001e  f7fffffe          BL       strlen
000022  42a8              CMP      r0,r5                 ;1510
000024  d301              BCC      |L33.42|
000026  4628              MOV      r0,r5                 ;1511
000028  bd70              POP      {r4-r6,pc}
                  |L33.42|
00002a  b282              UXTH     r2,r0                 ;1513
00002c  4621              MOV      r1,r4                 ;1513
00002e  4630              MOV      r0,r6                 ;1513
000030  e8bd4070          POP      {r4-r6,lr}            ;1513
000034  2300              MOVS     r3,#0                 ;1513
000036  f7ffbffe          B.W      pbuf_memfind
                          ENDP


                          AREA ||i.pbuf_take||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_take PROC
;;;1195   err_t
;;;1196   pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1197   {
000004  4689              MOV      r9,r1
000006  4690              MOV      r8,r2
;;;1198     struct pbuf *p;
;;;1199     size_t buf_copy_len;
;;;1200     size_t total_copy_len = len;
000008  4646              MOV      r6,r8
;;;1201     size_t copied_total = 0;
00000a  2700              MOVS     r7,#0
;;;1202   
;;;1203     LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
00000c  f06f040f          MVN      r4,#0xf
000010  2800              CMP      r0,#0
000012  d00f              BEQ      |L34.52|
;;;1204     LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
000014  f1b90f00          CMP      r9,#0
000018  d015              BEQ      |L34.70|
;;;1205     LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
00001a  8901              LDRH     r1,[r0,#8]
00001c  4541              CMP      r1,r8
00001e  d21b              BCS      |L34.88|
000020  a320              ADR      r3,|L34.164|
000022  f24042b5          MOV      r2,#0x4b5
000026  a12b              ADR      r1,|L34.212|
000028  a032              ADR      r0,|L34.244|
00002a  f7fffffe          BL       __2printf
00002e  1120              ASRS     r0,r4,#4
                  |L34.48|
;;;1206   
;;;1207     if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
;;;1208       return ERR_ARG;
;;;1209     }
;;;1210   
;;;1211     /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;1212     for (p = buf; total_copy_len != 0; p = p->next) {
;;;1213       LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
;;;1214       buf_copy_len = total_copy_len;
;;;1215       if (buf_copy_len > p->len) {
;;;1216         /* this pbuf cannot hold all remaining data */
;;;1217         buf_copy_len = p->len;
;;;1218       }
;;;1219       /* copy the necessary parts of the buffer */
;;;1220       MEMCPY(p->payload, &((const char *)dataptr)[copied_total], buf_copy_len);
;;;1221       total_copy_len -= buf_copy_len;
;;;1222       copied_total += buf_copy_len;
;;;1223     }
;;;1224     LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
;;;1225     return ERR_OK;
;;;1226   }
000030  e8bd87f0          POP      {r4-r10,pc}
                  |L34.52|
000034  a31b              ADR      r3,|L34.164|
000036  f24042b3          MOV      r2,#0x4b3             ;1203
00003a  a138              ADR      r1,|L34.284|
00003c  a02d              ADR      r0,|L34.244|
00003e  f7fffffe          BL       __2printf
000042  4620              MOV      r0,r4                 ;1203
000044  e7f4              B        |L34.48|
                  |L34.70|
000046  a317              ADR      r3,|L34.164|
000048  f24042b4          MOV      r2,#0x4b4             ;1204
00004c  a139              ADR      r1,|L34.308|
00004e  a029              ADR      r0,|L34.244|
000050  f7fffffe          BL       __2printf
000054  4620              MOV      r0,r4                 ;1204
000056  e7eb              B        |L34.48|
                  |L34.88|
000058  4604              MOV      r4,r0                 ;1212
00005a  e015              B        |L34.136|
                  |L34.92|
00005c  b934              CBNZ     r4,|L34.108|
00005e  a311              ADR      r3,|L34.164|
000060  f24042bd          MOV      r2,#0x4bd             ;1213
000064  a13a              ADR      r1,|L34.336|
000066  a023              ADR      r0,|L34.244|
000068  f7fffffe          BL       __2printf
                  |L34.108|
00006c  4635              MOV      r5,r6                 ;1214
00006e  8960              LDRH     r0,[r4,#0xa]          ;1215
000070  42a8              CMP      r0,r5                 ;1215
000072  d200              BCS      |L34.118|
000074  4605              MOV      r5,r0                 ;1217
                  |L34.118|
000076  eb090107          ADD      r1,r9,r7              ;1220
00007a  462a              MOV      r2,r5                 ;1220
00007c  6860              LDR      r0,[r4,#4]            ;1220
00007e  f7fffffe          BL       __aeabi_memcpy
000082  1b76              SUBS     r6,r6,r5              ;1221
000084  442f              ADD      r7,r7,r5              ;1222
000086  6824              LDR      r4,[r4,#0]            ;1212
                  |L34.136|
000088  2e00              CMP      r6,#0                 ;1212
00008a  d1e7              BNE      |L34.92|
00008c  4547              CMP      r7,r8                 ;1224
00008e  d006              BEQ      |L34.158|
000090  a304              ADR      r3,|L34.164|
000092  f44f6299          MOV      r2,#0x4c8             ;1224
000096  a134              ADR      r1,|L34.360|
000098  a016              ADR      r0,|L34.244|
00009a  f7fffffe          BL       __2printf
                  |L34.158|
00009e  2000              MOVS     r0,#0                 ;1225
0000a0  e7c6              B        |L34.48|
;;;1227   
                          ENDP

0000a2  0000              DCW      0x0000
                  |L34.164|
0000a4  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
0000a8  6964646c
0000ac  65776172
0000b0  65735c54
0000b4  68697264
0000b8  5f506172
0000bc  74795c4c
0000c0  7749505c
0000c4  7372635c
0000c8  636f7265
0000cc  5c706275
0000d0  662e6300
                  |L34.212|
0000d4  70627566          DCB      "pbuf_take: buf not large enough",0
0000d8  5f74616b
0000dc  653a2062
0000e0  7566206e
0000e4  6f74206c
0000e8  61726765
0000ec  20656e6f
0000f0  75676800
                  |L34.244|
0000f4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000f8  7274696f
0000fc  6e202225
000100  73222066
000104  61696c65
000108  64206174
00010c  206c696e
000110  65202564
000114  20696e20
000118  25730a00
                  |L34.284|
00011c  70627566          DCB      "pbuf_take: invalid buf",0
000120  5f74616b
000124  653a2069
000128  6e76616c
00012c  69642062
000130  756600  
000133  00                DCB      0
                  |L34.308|
000134  70627566          DCB      "pbuf_take: invalid dataptr",0
000138  5f74616b
00013c  653a2069
000140  6e76616c
000144  69642064
000148  61746170
00014c  747200  
00014f  00                DCB      0
                  |L34.336|
000150  70627566          DCB      "pbuf_take: invalid pbuf",0
000154  5f74616b
000158  653a2069
00015c  6e76616c
000160  69642070
000164  62756600
                  |L34.360|
000168  64696420          DCB      "did not copy all data",0
00016c  6e6f7420
000170  636f7079
000174  20616c6c
000178  20646174
00017c  6100    
00017e  00                DCB      0
00017f  00                DCB      0

                          AREA ||i.pbuf_take_at||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pbuf_take_at PROC
;;;1239   err_t
;;;1240   pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1241   {
000002  460e              MOV      r6,r1
000004  4615              MOV      r5,r2
000006  4619              MOV      r1,r3
;;;1242     u16_t target_offset;
;;;1243     struct pbuf *q = pbuf_skip(buf, offset, &target_offset);
000008  466a              MOV      r2,sp
00000a  f7fffffe          BL       pbuf_skip
00000e  4604              MOV      r4,r0
;;;1244   
;;;1245     /* return requested data if pbuf is OK */
;;;1246     if ((q != NULL) && (q->tot_len >= target_offset + len)) {
000010  0020              MOVS     r0,r4
000012  d028              BEQ      |L35.102|
000014  f8bd0000          LDRH     r0,[sp,#0]
000018  8921              LDRH     r1,[r4,#8]
00001a  1942              ADDS     r2,r0,r5
00001c  4291              CMP      r1,r2
00001e  d322              BCC      |L35.102|
;;;1247       u16_t remaining_len = len;
000020  462f              MOV      r7,r5
;;;1248       const u8_t *src_ptr = (const u8_t *)dataptr;
;;;1249       /* copy the part that goes into the first pbuf */
;;;1250       u16_t first_copy_len;
;;;1251       LWIP_ASSERT("check pbuf_skip result", target_offset < q->len);
000022  8961              LDRH     r1,[r4,#0xa]
000024  4281              CMP      r1,r0
000026  d806              BHI      |L35.54|
000028  a310              ADR      r3,|L35.108|
00002a  f24042e3          MOV      r2,#0x4e3
00002e  a11b              ADR      r1,|L35.156|
000030  a020              ADR      r0,|L35.180|
000032  f7fffffe          BL       __2printf
                  |L35.54|
;;;1252       first_copy_len = (u16_t)LWIP_MIN(q->len - target_offset, len);
000036  8961              LDRH     r1,[r4,#0xa]
000038  f8bd0000          LDRH     r0,[sp,#0]
00003c  1a09              SUBS     r1,r1,r0
00003e  42a9              CMP      r1,r5
000040  da00              BGE      |L35.68|
000042  460d              MOV      r5,r1
                  |L35.68|
000044  b2ad              UXTH     r5,r5
;;;1253       MEMCPY(((u8_t *)q->payload) + target_offset, dataptr, first_copy_len);
000046  6861              LDR      r1,[r4,#4]
000048  462a              MOV      r2,r5
00004a  4408              ADD      r0,r0,r1
00004c  4631              MOV      r1,r6
00004e  f7fffffe          BL       __aeabi_memcpy
;;;1254       remaining_len = (u16_t)(remaining_len - first_copy_len);
000052  1b78              SUBS     r0,r7,r5
000054  b282              UXTH     r2,r0
;;;1255       src_ptr += first_copy_len;
000056  1971              ADDS     r1,r6,r5
;;;1256       if (remaining_len > 0) {
000058  b11a              CBZ      r2,|L35.98|
;;;1257         return pbuf_take(q->next, src_ptr, remaining_len);
00005a  6820              LDR      r0,[r4,#0]
00005c  f7fffffe          BL       pbuf_take
;;;1258       }
;;;1259       return ERR_OK;
;;;1260     }
;;;1261     return ERR_MEM;
;;;1262   }
000060  bdf8              POP      {r3-r7,pc}
                  |L35.98|
000062  2000              MOVS     r0,#0                 ;1259
000064  bdf8              POP      {r3-r7,pc}
                  |L35.102|
000066  f04f30ff          MOV      r0,#0xffffffff        ;1261
00006a  bdf8              POP      {r3-r7,pc}
;;;1263   
                          ENDP

                  |L35.108|
00006c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000070  6964646c
000074  65776172
000078  65735c54
00007c  68697264
000080  5f506172
000084  74795c4c
000088  7749505c
00008c  7372635c
000090  636f7265
000094  5c706275
000098  662e6300
                  |L35.156|
00009c  63686563          DCB      "check pbuf_skip result",0
0000a0  6b207062
0000a4  75665f73
0000a8  6b697020
0000ac  72657375
0000b0  6c7400  
0000b3  00                DCB      0
                  |L35.180|
0000b4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000b8  7274696f
0000bc  6e202225
0000c0  73222066
0000c4  61696c65
0000c8  64206174
0000cc  206c696e
0000d0  65202564
0000d4  20696e20
0000d8  25730a00

                          AREA ||i.pbuf_try_get_at||, CODE, READONLY, ALIGN=1

                  pbuf_try_get_at PROC
;;;1388   int
;;;1389   pbuf_try_get_at(const struct pbuf *p, u16_t offset)
000000  b508              PUSH     {r3,lr}
;;;1390   {
;;;1391     u16_t q_idx;
;;;1392     const struct pbuf *q = pbuf_skip_const(p, offset, &q_idx);
000002  466a              MOV      r2,sp
000004  f7fffffe          BL       pbuf_skip_const
;;;1393   
;;;1394     /* return requested data if pbuf is OK */
;;;1395     if ((q != NULL) && (q->len > q_idx)) {
000008  b138              CBZ      r0,|L36.26|
00000a  8942              LDRH     r2,[r0,#0xa]
00000c  f8bd1000          LDRH     r1,[sp,#0]
000010  428a              CMP      r2,r1
000012  d902              BLS      |L36.26|
;;;1396       return ((u8_t *)q->payload)[q_idx];
000014  6840              LDR      r0,[r0,#4]
000016  5c40              LDRB     r0,[r0,r1]
;;;1397     }
;;;1398     return -1;
;;;1399   }
000018  bd08              POP      {r3,pc}
                  |L36.26|
00001a  f04f30ff          MOV      r0,#0xffffffff        ;1398
00001e  bd08              POP      {r3,pc}
;;;1400   
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  pbuf_free_ooseq_pending
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_pbuf_c_98275a01____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_pbuf_c_98275a01____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_pbuf_c_98275a01____REVSH|
#line 478
|__asm___6_pbuf_c_98275a01____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_pbuf_c_98275a01____RRX|
#line 665
|__asm___6_pbuf_c_98275a01____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
