; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\pbuf.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\pbuf.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\system\arch -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Inc -I..\Middlewares\Third_Party\LwIP\src\include -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\pbuf.crf ..\Middlewares\Third_Party\LwIP\src\core\pbuf.c]
                          THUMB

                          AREA ||i.pbuf_alloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_alloc PROC
;;;247    struct pbuf *
;;;248    pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;249    {
000004  460d              MOV      r5,r1
000006  4690              MOV      r8,r2
;;;250      struct pbuf *p, *q, *r;
;;;251      u16_t offset;
;;;252      s32_t rem_len; /* remaining length */
;;;253      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F")\n", length));
;;;254    
;;;255      /* determine header offset */
;;;256      switch (layer) {
000008  2805              CMP      r0,#5
00000a  d227              BCS      |L1.92|
00000c  e8dff000          TBB      [pc,r0]
000010  03050709          DCB      0x03,0x05,0x07,0x09
000014  0b00              DCB      0x0b,0x00
;;;257      case PBUF_TRANSPORT:
;;;258        /* add room for transport (often TCP) layer header */
;;;259        offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
000016  2636              MOVS     r6,#0x36
;;;260        break;
000018  e006              B        |L1.40|
;;;261      case PBUF_IP:
;;;262        /* add room for IP layer header */
;;;263        offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;
00001a  2622              MOVS     r6,#0x22
;;;264        break;
00001c  e004              B        |L1.40|
;;;265      case PBUF_LINK:
;;;266        /* add room for link layer header */
;;;267        offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
00001e  260e              MOVS     r6,#0xe
;;;268        break;
000020  e002              B        |L1.40|
;;;269      case PBUF_RAW_TX:
;;;270        /* add room for encapsulating link layer headers (e.g. 802.11) */
;;;271        offset = PBUF_LINK_ENCAPSULATION_HLEN;
000022  2600              MOVS     r6,#0
;;;272        break;
000024  e000              B        |L1.40|
;;;273      case PBUF_RAW:
;;;274        /* no offset (e.g. RX buffers or chain successors) */
;;;275        offset = 0;
000026  2600              MOVS     r6,#0
                  |L1.40|
000028  f04f0b01          MOV      r11,#1                ;249
00002c  f04f0a00          MOV      r10,#0                ;249
;;;276        break;
;;;277      default:
;;;278        LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
;;;279        return NULL;
;;;280      }
;;;281    
;;;282      switch (type) {
000030  f1b80f00          CMP      r8,#0
000034  d07e              BEQ      |L1.308|
000036  f1b80f01          CMP      r8,#1
                  |L1.58|
00003a  d07c              BEQ      |L1.310|
00003c  f1b80f02          CMP      r8,#2
000040  d0fb              BEQ      |L1.58|
000042  f1b80f03          CMP      r8,#3
000046  d012              BEQ      |L1.110|
;;;283      case PBUF_POOL:
;;;284        /* allocate head of pbuf chain into p */
;;;285        p = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;286        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
;;;287        if (p == NULL) {
;;;288          PBUF_POOL_IS_EMPTY();
;;;289          return NULL;
;;;290        }
;;;291        p->type = type;
;;;292        p->next = NULL;
;;;293    
;;;294        /* make the payload pointer point 'offset' bytes into pbuf data memory */
;;;295        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
;;;296        LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
;;;297                ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;298        /* the total length of the pbuf chain is the requested size */
;;;299        p->tot_len = length;
;;;300        /* set the length of the first pbuf in the chain */
;;;301        p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
;;;302        LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;303                    ((u8_t*)p->payload + p->len <=
;;;304                     (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;305        LWIP_ASSERT("PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",
;;;306          (PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset)) > 0 );
;;;307        /* set reference count (needed here in case we fail) */
;;;308        p->ref = 1;
;;;309    
;;;310        /* now allocate the tail of the pbuf chain */
;;;311    
;;;312        /* remember first pbuf for linkage in next iteration */
;;;313        r = p;
;;;314        /* remaining length to be allocated */
;;;315        rem_len = length - p->len;
;;;316        /* any remaining pbufs to be allocated? */
;;;317        while (rem_len > 0) {
;;;318          q = (struct pbuf *)memp_malloc(MEMP_PBUF_POOL);
;;;319          if (q == NULL) {
;;;320            PBUF_POOL_IS_EMPTY();
;;;321            /* free chain so far allocated */
;;;322            pbuf_free(p);
;;;323            /* bail out unsuccessfully */
;;;324            return NULL;
;;;325          }
;;;326          q->type = type;
;;;327          q->flags = 0;
;;;328          q->next = NULL;
;;;329          /* make previous pbuf point to this pbuf */
;;;330          r->next = q;
;;;331          /* set total length of this pbuf and next in chain */
;;;332          LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
;;;333          q->tot_len = (u16_t)rem_len;
;;;334          /* this pbuf length is pool size, unless smaller sized tail */
;;;335          q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
;;;336          q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
;;;337          LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
;;;338                  ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
;;;339          LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
;;;340                      ((u8_t*)p->payload + p->len <=
;;;341                       (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
;;;342          q->ref = 1;
;;;343          /* calculate remaining length to be allocated */
;;;344          rem_len -= q->len;
;;;345          /* remember this pbuf for linkage in next iteration */
;;;346          r = q;
;;;347        }
;;;348        /* end of chain */
;;;349        /*r->next = NULL;*/
;;;350    
;;;351        break;
;;;352      case PBUF_RAM:
;;;353        {
;;;354          mem_size_t alloc_len = LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length);
;;;355          
;;;356          /* bug #50040: Check for integer overflow when calculating alloc_len */
;;;357          if (alloc_len < LWIP_MEM_ALIGN_SIZE(length)) {
;;;358            return NULL;
;;;359          }
;;;360        
;;;361          /* If pbuf is to be allocated in RAM, allocate memory for it. */
;;;362          p = (struct pbuf*)mem_malloc(alloc_len);
;;;363        }
;;;364    
;;;365        if (p == NULL) {
;;;366          return NULL;
;;;367        }
;;;368        /* Set up internal structure of the pbuf. */
;;;369        p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
;;;370        p->len = p->tot_len = length;
;;;371        p->next = NULL;
;;;372        p->type = type;
;;;373    
;;;374        LWIP_ASSERT("pbuf_alloc: pbuf->payload properly aligned",
;;;375               ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
;;;376        break;
;;;377      /* pbuf references existing (non-volatile static constant) ROM payload? */
;;;378      case PBUF_ROM:
;;;379      /* pbuf references existing (externally allocated) RAM payload? */
;;;380      case PBUF_REF:
;;;381        /* only allocate memory for the pbuf structure */
;;;382        p = (struct pbuf *)memp_malloc(MEMP_PBUF);
;;;383        if (p == NULL) {
;;;384          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;385                      ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
;;;386                      (type == PBUF_ROM) ? "ROM" : "REF"));
;;;387          return NULL;
;;;388        }
;;;389        /* caller must set this field properly, afterwards */
;;;390        p->payload = NULL;
;;;391        p->len = p->tot_len = length;
;;;392        p->next = NULL;
;;;393        p->type = type;
;;;394        break;
;;;395      default:
;;;396        LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
000048  a370              ADR      r3,|L1.524|
00004a  f44f72c6          MOV      r2,#0x18c
00004e  a17b              ADR      r1,|L1.572|
000050  a081              ADR      r0,|L1.600|
000052  f7fffffe          BL       __2printf
;;;397        return NULL;
000056  2000              MOVS     r0,#0
                  |L1.88|
;;;398      }
;;;399      /* set reference count */
;;;400      p->ref = 1;
;;;401      /* set flags */
;;;402      p->flags = 0;
;;;403      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
;;;404      return p;
;;;405    }
000058  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.92|
00005c  a36b              ADR      r3,|L1.524|
00005e  f44f728b          MOV      r2,#0x116             ;278
000062  a187              ADR      r1,|L1.640|
000064  a07c              ADR      r0,|L1.600|
000066  f7fffffe          BL       __2printf
00006a  2000              MOVS     r0,#0                 ;279
00006c  e7f4              B        |L1.88|
                  |L1.110|
00006e  2008              MOVS     r0,#8                 ;285
000070  f7fffffe          BL       memp_malloc
000074  4604              MOV      r4,r0                 ;285
000076  0020              MOVS     r0,r4                 ;287
000078  d03a              BEQ      |L1.240|
00007a  f884800c          STRB     r8,[r4,#0xc]          ;291
00007e  f8c4a000          STR      r10,[r4,#0]           ;292
000082  19a0              ADDS     r0,r4,r6              ;295
000084  3013              ADDS     r0,r0,#0x13           ;295
000086  f0200003          BIC      r0,r0,#3              ;295
00008a  6060              STR      r0,[r4,#4]            ;295
00008c  0780              LSLS     r0,r0,#30             ;296
00008e  d006              BEQ      |L1.158|
000090  a35e              ADR      r3,|L1.524|
000092  f44f7294          MOV      r2,#0x128             ;296
000096  a181              ADR      r1,|L1.668|
000098  a06f              ADR      r0,|L1.600|
00009a  f7fffffe          BL       __2printf
                  |L1.158|
00009e  8125              STRH     r5,[r4,#8]            ;299
0000a0  1cf6              ADDS     r6,r6,#3              ;301
0000a2  f0260003          BIC      r0,r6,#3              ;301
0000a6  f5c07014          RSB      r0,r0,#0x250          ;301
0000aa  42a8              CMP      r0,r5                 ;301
0000ac  d900              BLS      |L1.176|
0000ae  4628              MOV      r0,r5                 ;301
                  |L1.176|
0000b0  b280              UXTH     r0,r0                 ;301
0000b2  8160              STRH     r0,[r4,#0xa]          ;301
0000b4  6861              LDR      r1,[r4,#4]            ;302
0000b6  f5047918          ADD      r9,r4,#0x260          ;302
0000ba  4408              ADD      r0,r0,r1              ;302
0000bc  4548              CMP      r0,r9                 ;302
0000be  d906              BLS      |L1.206|
0000c0  a352              ADR      r3,|L1.524|
0000c2  f44f7297          MOV      r2,#0x12e             ;302
0000c6  a181              ADR      r1,|L1.716|
0000c8  a063              ADR      r0,|L1.600|
0000ca  f7fffffe          BL       __2printf
                  |L1.206|
0000ce  2094              MOVS     r0,#0x94              ;305
0000d0  ebb00f96          CMP      r0,r6,LSR #2          ;305
0000d4  d106              BNE      |L1.228|
0000d6  a34d              ADR      r3,|L1.524|
0000d8  f2401231          MOV      r2,#0x131             ;305
0000dc  a188              ADR      r1,|L1.768|
0000de  a05e              ADR      r0,|L1.600|
0000e0  f7fffffe          BL       __2printf
                  |L1.228|
0000e4  f8a4b00e          STRH     r11,[r4,#0xe]         ;308
0000e8  4627              MOV      r7,r4                 ;313
0000ea  8960              LDRH     r0,[r4,#0xa]          ;315
0000ec  1a2e              SUBS     r6,r5,r0              ;315
0000ee  e043              B        |L1.376|
                  |L1.240|
0000f0  f7fffffe          BL       pbuf_pool_is_empty
0000f4  2000              MOVS     r0,#0                 ;289
0000f6  e7af              B        |L1.88|
                  |L1.248|
0000f8  2008              MOVS     r0,#8                 ;318
0000fa  f7fffffe          BL       memp_malloc
0000fe  4605              MOV      r5,r0                 ;318
000100  0028              MOVS     r0,r5                 ;319
000102  d03c              BEQ      |L1.382|
000104  f885800c          STRB     r8,[r5,#0xc]          ;326
000108  f885a00d          STRB     r10,[r5,#0xd]         ;327
00010c  f8c5a000          STR      r10,[r5,#0]           ;328
000110  603d              STR      r5,[r7,#0]            ;330
000112  f64f70ff          MOV      r0,#0xffff            ;332
000116  4286              CMP      r6,r0                 ;332
000118  db06              BLT      |L1.296|
00011a  a33c              ADR      r3,|L1.524|
00011c  f44f72a6          MOV      r2,#0x14c             ;332
000120  a184              ADR      r1,|L1.820|
000122  a04d              ADR      r0,|L1.600|
000124  f7fffffe          BL       __2printf
                  |L1.296|
000128  b2b0              UXTH     r0,r6                 ;333
00012a  8128              STRH     r0,[r5,#8]            ;333
00012c  f44f7114          MOV      r1,#0x250             ;335
000130  4288              CMP      r0,r1                 ;335
000132  e001              B        |L1.312|
                  |L1.308|
000134  e02a              B        |L1.396|
                  |L1.310|
000136  e052              B        |L1.478|
                  |L1.312|
000138  d300              BCC      |L1.316|
00013a  4608              MOV      r0,r1                 ;335
                  |L1.316|
00013c  8168              STRH     r0,[r5,#0xa]          ;335
00013e  f1050010          ADD      r0,r5,#0x10           ;336
000142  6068              STR      r0,[r5,#4]            ;336
000144  0780              LSLS     r0,r0,#30             ;337
000146  d006              BEQ      |L1.342|
000148  a330              ADR      r3,|L1.524|
00014a  f2401251          MOV      r2,#0x151             ;337
00014e  a17e              ADR      r1,|L1.840|
000150  a041              ADR      r0,|L1.600|
000152  f7fffffe          BL       __2printf
                  |L1.342|
000156  8961              LDRH     r1,[r4,#0xa]          ;339
000158  6860              LDR      r0,[r4,#4]            ;339
00015a  4408              ADD      r0,r0,r1              ;339
00015c  4548              CMP      r0,r9                 ;339
00015e  d906              BLS      |L1.366|
000160  a32a              ADR      r3,|L1.524|
000162  f2401253          MOV      r2,#0x153             ;339
000166  a159              ADR      r1,|L1.716|
000168  a03b              ADR      r0,|L1.600|
00016a  f7fffffe          BL       __2printf
                  |L1.366|
00016e  f8a5b00e          STRH     r11,[r5,#0xe]         ;342
000172  8968              LDRH     r0,[r5,#0xa]          ;344
000174  1a36              SUBS     r6,r6,r0              ;344
000176  462f              MOV      r7,r5                 ;346
                  |L1.376|
000178  2e00              CMP      r6,#0                 ;317
00017a  dcbd              BGT      |L1.248|
00017c  e03d              B        |L1.506|
                  |L1.382|
00017e  f7fffffe          BL       pbuf_pool_is_empty
000182  4620              MOV      r0,r4                 ;322
000184  f7fffffe          BL       pbuf_free
000188  2000              MOVS     r0,#0                 ;324
00018a  e765              B        |L1.88|
                  |L1.396|
00018c  f1060013          ADD      r0,r6,#0x13           ;354
000190  f0200203          BIC      r2,r0,#3              ;354
000194  1ce8              ADDS     r0,r5,#3              ;354
000196  f0200103          BIC      r1,r0,#3              ;354
00019a  1850              ADDS     r0,r2,r1              ;354
00019c  b280              UXTH     r0,r0                 ;354
00019e  4281              CMP      r1,r0                 ;357
0001a0  d901              BLS      |L1.422|
0001a2  2000              MOVS     r0,#0                 ;358
0001a4  e758              B        |L1.88|
                  |L1.422|
0001a6  f7fffffe          BL       mem_malloc
0001aa  4604              MOV      r4,r0                 ;362
0001ac  0020              MOVS     r0,r4                 ;365
0001ae  d014              BEQ      |L1.474|
0001b0  19a0              ADDS     r0,r4,r6              ;369
0001b2  3013              ADDS     r0,r0,#0x13           ;369
0001b4  f0200003          BIC      r0,r0,#3              ;369
0001b8  6060              STR      r0,[r4,#4]            ;369
0001ba  8125              STRH     r5,[r4,#8]            ;370
0001bc  8165              STRH     r5,[r4,#0xa]          ;370
0001be  f8c4a000          STR      r10,[r4,#0]           ;371
0001c2  f884a00c          STRB     r10,[r4,#0xc]         ;372
0001c6  0780              LSLS     r0,r0,#30             ;374
0001c8  d017              BEQ      |L1.506|
0001ca  a310              ADR      r3,|L1.524|
0001cc  f44f72bb          MOV      r2,#0x176             ;374
0001d0  a169              ADR      r1,|L1.888|
0001d2  a021              ADR      r0,|L1.600|
0001d4  f7fffffe          BL       __2printf
0001d8  e00f              B        |L1.506|
                  |L1.474|
0001da  2000              MOVS     r0,#0                 ;366
0001dc  e73c              B        |L1.88|
                  |L1.478|
0001de  2007              MOVS     r0,#7                 ;382
0001e0  f7fffffe          BL       memp_malloc
0001e4  4604              MOV      r4,r0                 ;382
0001e6  0020              MOVS     r0,r4                 ;383
0001e8  d00d              BEQ      |L1.518|
0001ea  f8c4a004          STR      r10,[r4,#4]           ;390
0001ee  8125              STRH     r5,[r4,#8]            ;391
0001f0  8165              STRH     r5,[r4,#0xa]          ;391
0001f2  f8c4a000          STR      r10,[r4,#0]           ;392
0001f6  f884800c          STRB     r8,[r4,#0xc]          ;393
                  |L1.506|
0001fa  f8a4b00e          STRH     r11,[r4,#0xe]         ;400
0001fe  f884a00d          STRB     r10,[r4,#0xd]         ;402
000202  4620              MOV      r0,r4                 ;404
000204  e728              B        |L1.88|
                  |L1.518|
000206  2000              MOVS     r0,#0                 ;387
000208  e726              B        |L1.88|
;;;406    
                          ENDP

00020a  0000              DCW      0x0000
                  |L1.524|
00020c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000210  6964646c
000214  65776172
000218  65735c54
00021c  68697264
000220  5f506172
000224  74795c4c
000228  7749505c
00022c  7372635c
000230  636f7265
000234  5c706275
000238  662e6300
                  |L1.572|
00023c  70627566          DCB      "pbuf_alloc: erroneous type",0
000240  5f616c6c
000244  6f633a20
000248  6572726f
00024c  6e656f75
000250  73207479
000254  706500  
000257  00                DCB      0
                  |L1.600|
000258  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00025c  7274696f
000260  6e202225
000264  73222066
000268  61696c65
00026c  64206174
000270  206c696e
000274  65202564
000278  20696e20
00027c  25730a00
                  |L1.640|
000280  70627566          DCB      "pbuf_alloc: bad pbuf layer",0
000284  5f616c6c
000288  6f633a20
00028c  62616420
000290  70627566
000294  206c6179
000298  657200  
00029b  00                DCB      0
                  |L1.668|
00029c  70627566          DCB      "pbuf_alloc: pbuf p->payload properly aligned",0
0002a0  5f616c6c
0002a4  6f633a20
0002a8  70627566
0002ac  20702d3e
0002b0  7061796c
0002b4  6f616420
0002b8  70726f70
0002bc  65726c79
0002c0  20616c69
0002c4  676e6564
0002c8  00      
0002c9  00                DCB      0
0002ca  00                DCB      0
0002cb  00                DCB      0
                  |L1.716|
0002cc  63686563          DCB      "check p->payload + p->len does not overflow pbuf",0
0002d0  6b20702d
0002d4  3e706179
0002d8  6c6f6164
0002dc  202b2070
0002e0  2d3e6c65
0002e4  6e20646f
0002e8  6573206e
0002ec  6f74206f
0002f0  76657266
0002f4  6c6f7720
0002f8  70627566
0002fc  00      
0002fd  00                DCB      0
0002fe  00                DCB      0
0002ff  00                DCB      0
                  |L1.768|
000300  50425546          DCB      "PBUF_POOL_BUFSIZE must be bigger than MEM_ALIGNMENT",0
000304  5f504f4f
000308  4c5f4255
00030c  4653495a
000310  45206d75
000314  73742062
000318  65206269
00031c  67676572
000320  20746861
000324  6e204d45
000328  4d5f414c
00032c  49474e4d
000330  454e5400
                  |L1.820|
000334  72656d5f          DCB      "rem_len < max_u16_t",0
000338  6c656e20
00033c  3c206d61
000340  785f7531
000344  365f7400
                  |L1.840|
000348  70627566          DCB      "pbuf_alloc: pbuf q->payload properly aligned",0
00034c  5f616c6c
000350  6f633a20
000354  70627566
000358  20712d3e
00035c  7061796c
000360  6f616420
000364  70726f70
000368  65726c79
00036c  20616c69
000370  676e6564
000374  00      
000375  00                DCB      0
000376  00                DCB      0
000377  00                DCB      0
                  |L1.888|
000378  70627566          DCB      "pbuf_alloc: pbuf->payload properly aligned",0
00037c  5f616c6c
000380  6f633a20
000384  70627566
000388  2d3e7061
00038c  796c6f61
000390  64207072
000394  6f706572
000398  6c792061
00039c  6c69676e
0003a0  656400  
0003a3  00                DCB      0

                          AREA ||i.pbuf_alloced_custom||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pbuf_alloced_custom PROC
;;;424    struct pbuf*
;;;425    pbuf_alloced_custom(pbuf_layer l, u16_t length, pbuf_type type, struct pbuf_custom *p,
000000  b570              PUSH     {r4-r6,lr}
;;;426                        void *payload_mem, u16_t payload_mem_len)
;;;427    {
000002  e9dd4604          LDRD     r4,r6,[sp,#0x10]
000006  4605              MOV      r5,r0
000008  4618              MOV      r0,r3
;;;428      u16_t offset;
;;;429      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_alloced_custom(length=%"U16_F")\n", length));
;;;430    
;;;431      /* determine header offset */
;;;432      switch (l) {
00000a  2d05              CMP      r5,#5
00000c  d215              BCS      |L2.58|
00000e  e8dff005          TBB      [pc,r5]
000012  0305              DCB      0x03,0x05
000014  07090b00          DCB      0x07,0x09,0x0b,0x00
;;;433      case PBUF_TRANSPORT:
;;;434        /* add room for transport (often TCP) layer header */
;;;435        offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN;
000018  2336              MOVS     r3,#0x36
;;;436        break;
00001a  e006              B        |L2.42|
;;;437      case PBUF_IP:
;;;438        /* add room for IP layer header */
;;;439        offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN;
00001c  2322              MOVS     r3,#0x22
;;;440        break;
00001e  e004              B        |L2.42|
;;;441      case PBUF_LINK:
;;;442        /* add room for link layer header */
;;;443        offset = PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN;
000020  230e              MOVS     r3,#0xe
;;;444        break;
000022  e002              B        |L2.42|
;;;445      case PBUF_RAW_TX:
;;;446        /* add room for encapsulating link layer headers (e.g. 802.11) */
;;;447        offset = PBUF_LINK_ENCAPSULATION_HLEN;
000024  2300              MOVS     r3,#0
;;;448        break;
000026  e000              B        |L2.42|
;;;449      case PBUF_RAW:
;;;450        offset = 0;
000028  2300              MOVS     r3,#0
                  |L2.42|
;;;451        break;
;;;452      default:
;;;453        LWIP_ASSERT("pbuf_alloced_custom: bad pbuf layer", 0);
;;;454        return NULL;
;;;455      }
;;;456    
;;;457      if (LWIP_MEM_ALIGN_SIZE(offset) + length > payload_mem_len) {
00002a  1cdb              ADDS     r3,r3,#3
00002c  f0230303          BIC      r3,r3,#3
000030  185d              ADDS     r5,r3,r1
000032  42b5              CMP      r5,r6
000034  d90a              BLS      |L2.76|
;;;458        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_WARNING, ("pbuf_alloced_custom(length=%"U16_F") buffer too short\n", length));
;;;459        return NULL;
000036  2000              MOVS     r0,#0
;;;460      }
;;;461    
;;;462      p->pbuf.next = NULL;
;;;463      if (payload_mem != NULL) {
;;;464        p->pbuf.payload = (u8_t *)payload_mem + LWIP_MEM_ALIGN_SIZE(offset);
;;;465      } else {
;;;466        p->pbuf.payload = NULL;
;;;467      }
;;;468      p->pbuf.flags = PBUF_FLAG_IS_CUSTOM;
;;;469      p->pbuf.len = p->pbuf.tot_len = length;
;;;470      p->pbuf.type = type;
;;;471      p->pbuf.ref = 1;
;;;472      return &p->pbuf;
;;;473    }
000038  bd70              POP      {r4-r6,pc}
                  |L2.58|
00003a  a30c              ADR      r3,|L2.108|
00003c  f24012c5          MOV      r2,#0x1c5             ;453
000040  a116              ADR      r1,|L2.156|
000042  a01f              ADR      r0,|L2.192|
000044  f7fffffe          BL       __2printf
000048  2000              MOVS     r0,#0                 ;454
00004a  bd70              POP      {r4-r6,pc}
                  |L2.76|
00004c  2500              MOVS     r5,#0                 ;462
00004e  6005              STR      r5,[r0,#0]            ;462
000050  b114              CBZ      r4,|L2.88|
000052  4423              ADD      r3,r3,r4              ;464
000054  6043              STR      r3,[r0,#4]            ;464
000056  e000              B        |L2.90|
                  |L2.88|
000058  6045              STR      r5,[r0,#4]            ;466
                  |L2.90|
00005a  2302              MOVS     r3,#2                 ;468
00005c  7343              STRB     r3,[r0,#0xd]          ;468
00005e  8101              STRH     r1,[r0,#8]            ;469
000060  8141              STRH     r1,[r0,#0xa]          ;469
000062  7302              STRB     r2,[r0,#0xc]          ;470
000064  2101              MOVS     r1,#1                 ;471
000066  81c1              STRH     r1,[r0,#0xe]          ;471
000068  bd70              POP      {r4-r6,pc}
;;;474    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
                          ENDP

00006a  0000              DCW      0x0000
                  |L2.108|
00006c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000070  6964646c
000074  65776172
000078  65735c54
00007c  68697264
000080  5f506172
000084  74795c4c
000088  7749505c
00008c  7372635c
000090  636f7265
000094  5c706275
000098  662e6300
                  |L2.156|
00009c  70627566          DCB      "pbuf_alloced_custom: bad pbuf layer",0
0000a0  5f616c6c
0000a4  6f636564
0000a8  5f637573
0000ac  746f6d3a
0000b0  20626164
0000b4  20706275
0000b8  66206c61
0000bc  79657200
                  |L2.192|
0000c0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000c4  7274696f
0000c8  6e202225
0000cc  73222066
0000d0  61696c65
0000d4  64206174
0000d8  206c696e
0000dc  65202564
0000e0  20696e20
0000e4  25730a00

                          AREA ||i.pbuf_cat||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_cat PROC
;;;839    void
;;;840    pbuf_cat(struct pbuf *h, struct pbuf *t)
000000  b570              PUSH     {r4-r6,lr}
;;;841    {
000002  460d              MOV      r5,r1
;;;842      struct pbuf *p;
;;;843    
;;;844      LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
000004  2800              CMP      r0,#0
000006  d002              BEQ      |L3.14|
000008  b10d              CBZ      r5,|L3.14|
;;;845                 ((h != NULL) && (t != NULL)), return;);
;;;846    
;;;847      /* proceed to last pbuf of chain */
;;;848      for (p = h; p->next != NULL; p = p->next) {
00000a  4604              MOV      r4,r0
00000c  e00d              B        |L3.42|
                  |L3.14|
00000e  e8bd4070          POP      {r4-r6,lr}            ;844
000012  a314              ADR      r3,|L3.100|
000014  f44f7253          MOV      r2,#0x34c             ;844
000018  a11e              ADR      r1,|L3.148|
00001a  a02c              ADR      r0,|L3.204|
00001c  f7ffbffe          B.W      __2printf
                  |L3.32|
;;;849        /* add total length of second chain to all totals of first chain */
;;;850        p->tot_len += t->tot_len;
000020  8921              LDRH     r1,[r4,#8]
000022  892a              LDRH     r2,[r5,#8]
000024  4411              ADD      r1,r1,r2
000026  8121              STRH     r1,[r4,#8]
000028  4604              MOV      r4,r0                 ;848
                  |L3.42|
00002a  6820              LDR      r0,[r4,#0]            ;848
00002c  2800              CMP      r0,#0                 ;848
00002e  d1f7              BNE      |L3.32|
;;;851      }
;;;852      /* { p is last pbuf of first h chain, p->next == NULL } */
;;;853      LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
000030  8920              LDRH     r0,[r4,#8]
000032  8961              LDRH     r1,[r4,#0xa]
000034  4288              CMP      r0,r1
000036  d006              BEQ      |L3.70|
000038  a30a              ADR      r3,|L3.100|
00003a  f2403255          MOV      r2,#0x355
00003e  a12d              ADR      r1,|L3.244|
000040  a022              ADR      r0,|L3.204|
000042  f7fffffe          BL       __2printf
                  |L3.70|
;;;854      LWIP_ASSERT("p->next == NULL", p->next == NULL);
000046  6820              LDR      r0,[r4,#0]
000048  b130              CBZ      r0,|L3.88|
00004a  a306              ADR      r3,|L3.100|
00004c  f2403256          MOV      r2,#0x356
000050  a134              ADR      r1,|L3.292|
000052  a01e              ADR      r0,|L3.204|
000054  f7fffffe          BL       __2printf
                  |L3.88|
;;;855      /* add total length of second chain to last pbuf total of first chain */
;;;856      p->tot_len += t->tot_len;
000058  8920              LDRH     r0,[r4,#8]
00005a  8929              LDRH     r1,[r5,#8]
00005c  4408              ADD      r0,r0,r1
00005e  8120              STRH     r0,[r4,#8]
;;;857      /* chain last pbuf of head (p) with first of tail (t) */
;;;858      p->next = t;
000060  6025              STR      r5,[r4,#0]
;;;859      /* p->next now references t, but the caller will drop its reference to t,
;;;860       * so netto there is no change to the reference count of t.
;;;861       */
;;;862    }
000062  bd70              POP      {r4-r6,pc}
;;;863    
                          ENDP

                  |L3.100|
000064  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000068  6964646c
00006c  65776172
000070  65735c54
000074  68697264
000078  5f506172
00007c  74795c4c
000080  7749505c
000084  7372635c
000088  636f7265
00008c  5c706275
000090  662e6300
                  |L3.148|
000094  28682021          DCB      "(h != NULL) && (t != NULL) (programmer violates API)",0
000098  3d204e55
00009c  4c4c2920
0000a0  26262028
0000a4  7420213d
0000a8  204e554c
0000ac  4c292028
0000b0  70726f67
0000b4  72616d6d
0000b8  65722076
0000bc  696f6c61
0000c0  74657320
0000c4  41504929
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L3.204|
0000cc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000d0  7274696f
0000d4  6e202225
0000d8  73222066
0000dc  61696c65
0000e0  64206174
0000e4  206c696e
0000e8  65202564
0000ec  20696e20
0000f0  25730a00
                  |L3.244|
0000f4  702d3e74          DCB      "p->tot_len == p->len (of last pbuf in chain)",0
0000f8  6f745f6c
0000fc  656e203d
000100  3d20702d
000104  3e6c656e
000108  20286f66
00010c  206c6173
000110  74207062
000114  75662069
000118  6e206368
00011c  61696e29
000120  00      
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L3.292|
000124  702d3e6e          DCB      "p->next == NULL",0
000128  65787420
00012c  3d3d204e
000130  554c4c00

                          AREA ||i.pbuf_chain||, CODE, READONLY, ALIGN=1

                  pbuf_chain PROC
;;;881    void
;;;882    pbuf_chain(struct pbuf *h, struct pbuf *t)
000000  b510              PUSH     {r4,lr}
;;;883    {
000002  460c              MOV      r4,r1
;;;884      pbuf_cat(h, t);
000004  4621              MOV      r1,r4
000006  f7fffffe          BL       pbuf_cat
;;;885      /* t is now referenced by h */
;;;886      pbuf_ref(t);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      pbuf_ref
;;;887      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
;;;888    }
;;;889    
                          ENDP


                          AREA ||i.pbuf_clen||, CODE, READONLY, ALIGN=1

                  pbuf_clen PROC
;;;799    u16_t
;;;800    pbuf_clen(const struct pbuf *p)
000000  2100              MOVS     r1,#0
;;;801    {
000002  e002              B        |L5.10|
                  |L5.4|
;;;802      u16_t len;
;;;803    
;;;804      len = 0;
;;;805      while (p != NULL) {
;;;806        ++len;
000004  1c49              ADDS     r1,r1,#1
000006  b289              UXTH     r1,r1
;;;807        p = p->next;
000008  6800              LDR      r0,[r0,#0]
                  |L5.10|
00000a  2800              CMP      r0,#0                 ;805
00000c  d1fa              BNE      |L5.4|
;;;808      }
;;;809      return len;
00000e  4608              MOV      r0,r1
;;;810    }
000010  4770              BX       lr
;;;811    
                          ENDP


                          AREA ||i.pbuf_coalesce||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pbuf_coalesce PROC
;;;1228   struct pbuf*
;;;1229   pbuf_coalesce(struct pbuf *p, pbuf_layer layer)
000000  b570              PUSH     {r4-r6,lr}
;;;1230   {
000002  4604              MOV      r4,r0
000004  460b              MOV      r3,r1
;;;1231     struct pbuf *q;
;;;1232     err_t err;
;;;1233     if (p->next == NULL) {
000006  6820              LDR      r0,[r4,#0]
000008  2800              CMP      r0,#0
00000a  d018              BEQ      |L6.62|
;;;1234       return p;
;;;1235     }
;;;1236     q = pbuf_alloc(layer, p->tot_len, PBUF_RAM);
00000c  8921              LDRH     r1,[r4,#8]
00000e  2200              MOVS     r2,#0
000010  4618              MOV      r0,r3
000012  f7fffffe          BL       pbuf_alloc
000016  4605              MOV      r5,r0
;;;1237     if (q == NULL) {
000018  2d00              CMP      r5,#0
00001a  d012              BEQ      |L6.66|
;;;1238       /* @todo: what do we do now? */
;;;1239       return p;
;;;1240     }
;;;1241     err = pbuf_copy(q, p);
00001c  4621              MOV      r1,r4
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       pbuf_copy
;;;1242     LWIP_UNUSED_ARG(err); /* in case of LWIP_NOASSERT */
;;;1243     LWIP_ASSERT("pbuf_copy failed", err == ERR_OK);
000024  b130              CBZ      r0,|L6.52|
000026  a308              ADR      r3,|L6.72|
000028  f24042db          MOV      r2,#0x4db
00002c  a112              ADR      r1,|L6.120|
00002e  a017              ADR      r0,|L6.140|
000030  f7fffffe          BL       __2printf
                  |L6.52|
;;;1244     pbuf_free(p);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       pbuf_free
;;;1245     return q;
00003a  4628              MOV      r0,r5
;;;1246   }
00003c  bd70              POP      {r4-r6,pc}
                  |L6.62|
00003e  4620              MOV      r0,r4                 ;1234
000040  bd70              POP      {r4-r6,pc}
                  |L6.66|
000042  4620              MOV      r0,r4                 ;1239
000044  bd70              POP      {r4-r6,pc}
;;;1247   
                          ENDP

000046  0000              DCW      0x0000
                  |L6.72|
000048  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
00004c  6964646c
000050  65776172
000054  65735c54
000058  68697264
00005c  5f506172
000060  74795c4c
000064  7749505c
000068  7372635c
00006c  636f7265
000070  5c706275
000074  662e6300
                  |L6.120|
000078  70627566          DCB      "pbuf_copy failed",0
00007c  5f636f70
000080  79206661
000084  696c6564
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L6.140|
00008c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000090  7274696f
000094  6e202225
000098  73222066
00009c  61696c65
0000a0  64206174
0000a4  206c696e
0000a8  65202564
0000ac  20696e20
0000b0  25730a00

                          AREA ||i.pbuf_copy||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_copy PROC
;;;947    err_t
;;;948    pbuf_copy(struct pbuf *p_to, const struct pbuf *p_from)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;949    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;950      u16_t offset_to=0, offset_from=0, len;
000008  2600              MOVS     r6,#0
00000a  2700              MOVS     r7,#0
;;;951    
;;;952      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy(%p, %p)\n",
;;;953        (const void*)p_to, (const void*)p_from));
;;;954    
;;;955      /* is the target big enough to hold the source? */
;;;956      LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
00000c  f06f090f          MVN      r9,#0xf
000010  2d00              CMP      r5,#0
000012  d004              BEQ      |L7.30|
000014  b11c              CBZ      r4,|L7.30|
000016  8928              LDRH     r0,[r5,#8]
000018  8921              LDRH     r1,[r4,#8]
00001a  4288              CMP      r0,r1
00001c  d209              BCS      |L7.50|
                  |L7.30|
00001e  a339              ADR      r3,|L7.260|
000020  f44f726f          MOV      r2,#0x3bc
000024  a143              ADR      r1,|L7.308|
000026  a04f              ADR      r0,|L7.356|
000028  f7fffffe          BL       __2printf
00002c  4648              MOV      r0,r9
                  |L7.46|
;;;957                 (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);
;;;958    
;;;959      /* iterate through pbuf chain */
;;;960      do
;;;961      {
;;;962        /* copy one part of the original chain */
;;;963        if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
;;;964          /* complete current p_from fits into current p_to */
;;;965          len = p_from->len - offset_from;
;;;966        } else {
;;;967          /* current p_from does not fit into current p_to */
;;;968          len = p_to->len - offset_to;
;;;969        }
;;;970        MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
;;;971        offset_to += len;
;;;972        offset_from += len;
;;;973        LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
;;;974        LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
;;;975        if (offset_from >= p_from->len) {
;;;976          /* on to next p_from (if any) */
;;;977          offset_from = 0;
;;;978          p_from = p_from->next;
;;;979        }
;;;980        if (offset_to == p_to->len) {
;;;981          /* on to next p_to (if any) */
;;;982          offset_to = 0;
;;;983          p_to = p_to->next;
;;;984          LWIP_ERROR("p_to != NULL", (p_to != NULL) || (p_from == NULL) , return ERR_ARG;);
;;;985        }
;;;986    
;;;987        if ((p_from != NULL) && (p_from->len == p_from->tot_len)) {
;;;988          /* don't copy more than one packet! */
;;;989          LWIP_ERROR("pbuf_copy() does not allow packet queues!",
;;;990                     (p_from->next == NULL), return ERR_VAL;);
;;;991        }
;;;992        if ((p_to != NULL) && (p_to->len == p_to->tot_len)) {
;;;993          /* don't copy more than one packet! */
;;;994          LWIP_ERROR("pbuf_copy() does not allow packet queues!",
;;;995                      (p_to->next == NULL), return ERR_VAL;);
;;;996        }
;;;997      } while (p_from);
;;;998      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_copy: end of chain reached.\n"));
;;;999      return ERR_OK;
;;;1000   }
00002e  e8bd87f0          POP      {r4-r10,pc}
                  |L7.50|
000032  f06f0a05          MVN      r10,#5                ;989
                  |L7.54|
000036  8968              LDRH     r0,[r5,#0xa]          ;963
000038  8961              LDRH     r1,[r4,#0xa]          ;963
00003a  1b80              SUBS     r0,r0,r6              ;963
00003c  1bc9              SUBS     r1,r1,r7              ;963
00003e  4288              CMP      r0,r1                 ;963
000040  db02              BLT      |L7.72|
000042  fa1ff881          UXTH     r8,r1                 ;965
000046  e001              B        |L7.76|
                  |L7.72|
000048  fa1ff880          UXTH     r8,r0                 ;968
                  |L7.76|
00004c  6860              LDR      r0,[r4,#4]            ;970
00004e  4642              MOV      r2,r8                 ;970
000050  19c1              ADDS     r1,r0,r7              ;970
000052  6868              LDR      r0,[r5,#4]            ;970
000054  4430              ADD      r0,r0,r6              ;970
000056  f7fffffe          BL       __aeabi_memcpy
00005a  eb060008          ADD      r0,r6,r8              ;971
00005e  b286              UXTH     r6,r0                 ;971
000060  eb070008          ADD      r0,r7,r8              ;972
000064  b287              UXTH     r7,r0                 ;972
000066  8968              LDRH     r0,[r5,#0xa]          ;973
000068  42b0              CMP      r0,r6                 ;973
00006a  d206              BCS      |L7.122|
00006c  a325              ADR      r3,|L7.260|
00006e  f24032cd          MOV      r2,#0x3cd             ;973
000072  a146              ADR      r1,|L7.396|
000074  a03b              ADR      r0,|L7.356|
000076  f7fffffe          BL       __2printf
                  |L7.122|
00007a  8960              LDRH     r0,[r4,#0xa]          ;974
00007c  42b8              CMP      r0,r7                 ;974
00007e  d206              BCS      |L7.142|
000080  a320              ADR      r3,|L7.260|
000082  f24032ce          MOV      r2,#0x3ce             ;974
000086  a147              ADR      r1,|L7.420|
000088  a036              ADR      r0,|L7.356|
00008a  f7fffffe          BL       __2printf
                  |L7.142|
00008e  8960              LDRH     r0,[r4,#0xa]          ;975
000090  42b8              CMP      r0,r7                 ;975
000092  d801              BHI      |L7.152|
000094  2700              MOVS     r7,#0                 ;977
000096  6824              LDR      r4,[r4,#0]            ;978
                  |L7.152|
000098  8968              LDRH     r0,[r5,#0xa]          ;980
00009a  42b0              CMP      r0,r6                 ;980
00009c  d10c              BNE      |L7.184|
00009e  2600              MOVS     r6,#0                 ;982
0000a0  682d              LDR      r5,[r5,#0]            ;983
0000a2  b94d              CBNZ     r5,|L7.184|
0000a4  b144              CBZ      r4,|L7.184|
0000a6  a317              ADR      r3,|L7.260|
0000a8  f44f7276          MOV      r2,#0x3d8             ;984
0000ac  a144              ADR      r1,|L7.448|
0000ae  a02d              ADR      r0,|L7.356|
0000b0  f7fffffe          BL       __2printf
0000b4  4648              MOV      r0,r9                 ;984
0000b6  e7ba              B        |L7.46|
                  |L7.184|
0000b8  2c00              CMP      r4,#0                 ;987
0000ba  d00e              BEQ      |L7.218|
0000bc  8960              LDRH     r0,[r4,#0xa]          ;987
0000be  8921              LDRH     r1,[r4,#8]            ;987
0000c0  4288              CMP      r0,r1                 ;987
0000c2  d10a              BNE      |L7.218|
0000c4  6820              LDR      r0,[r4,#0]            ;989
0000c6  b140              CBZ      r0,|L7.218|
0000c8  a30e              ADR      r3,|L7.260|
0000ca  f24032dd          MOV      r2,#0x3dd             ;989
0000ce  a140              ADR      r1,|L7.464|
0000d0  a024              ADR      r0,|L7.356|
0000d2  f7fffffe          BL       __2printf
0000d6  4650              MOV      r0,r10                ;989
0000d8  e7a9              B        |L7.46|
                  |L7.218|
0000da  b175              CBZ      r5,|L7.250|
0000dc  8968              LDRH     r0,[r5,#0xa]          ;992
0000de  8929              LDRH     r1,[r5,#8]            ;992
0000e0  4288              CMP      r0,r1                 ;992
0000e2  d10a              BNE      |L7.250|
0000e4  6828              LDR      r0,[r5,#0]            ;994
0000e6  b140              CBZ      r0,|L7.250|
0000e8  a306              ADR      r3,|L7.260|
0000ea  f24032e2          MOV      r2,#0x3e2             ;994
0000ee  a138              ADR      r1,|L7.464|
0000f0  a01c              ADR      r0,|L7.356|
0000f2  f7fffffe          BL       __2printf
0000f6  4650              MOV      r0,r10                ;994
0000f8  e799              B        |L7.46|
                  |L7.250|
0000fa  2c00              CMP      r4,#0                 ;997
0000fc  d19b              BNE      |L7.54|
0000fe  2000              MOVS     r0,#0                 ;999
000100  e795              B        |L7.46|
;;;1001   
                          ENDP

000102  0000              DCW      0x0000
                  |L7.260|
000104  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000108  6964646c
00010c  65776172
000110  65735c54
000114  68697264
000118  5f506172
00011c  74795c4c
000120  7749505c
000124  7372635c
000128  636f7265
00012c  5c706275
000130  662e6300
                  |L7.308|
000134  70627566          DCB      "pbuf_copy: target not big enough to hold source",0
000138  5f636f70
00013c  793a2074
000140  61726765
000144  74206e6f
000148  74206269
00014c  6720656e
000150  6f756768
000154  20746f20
000158  686f6c64
00015c  20736f75
000160  72636500
                  |L7.356|
000164  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000168  7274696f
00016c  6e202225
000170  73222066
000174  61696c65
000178  64206174
00017c  206c696e
000180  65202564
000184  20696e20
000188  25730a00
                  |L7.396|
00018c  6f666673          DCB      "offset_to <= p_to->len",0
000190  65745f74
000194  6f203c3d
000198  20705f74
00019c  6f2d3e6c
0001a0  656e00  
0001a3  00                DCB      0
                  |L7.420|
0001a4  6f666673          DCB      "offset_from <= p_from->len",0
0001a8  65745f66
0001ac  726f6d20
0001b0  3c3d2070
0001b4  5f66726f
0001b8  6d2d3e6c
0001bc  656e00  
0001bf  00                DCB      0
                  |L7.448|
0001c0  705f746f          DCB      "p_to != NULL",0
0001c4  20213d20
0001c8  4e554c4c
0001cc  00      
0001cd  00                DCB      0
0001ce  00                DCB      0
0001cf  00                DCB      0
                  |L7.464|
0001d0  70627566          DCB      "pbuf_copy() does not allow packet queues!",0
0001d4  5f636f70
0001d8  79282920
0001dc  646f6573
0001e0  206e6f74
0001e4  20616c6c
0001e8  6f772070
0001ec  61636b65
0001f0  74207175
0001f4  65756573
0001f8  2100    
0001fa  00                DCB      0
0001fb  00                DCB      0

                          AREA ||i.pbuf_copy_partial||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_copy_partial PROC
;;;1014   u16_t
;;;1015   pbuf_copy_partial(const struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1016   {
000004  4689              MOV      r9,r1
000006  4616              MOV      r6,r2
;;;1017     const struct pbuf *p;
;;;1018     u16_t left;
;;;1019     u16_t buf_copy_len;
;;;1020     u16_t copied_total = 0;
000008  f04f0800          MOV      r8,#0
;;;1021   
;;;1022     LWIP_ERROR("pbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
00000c  2800              CMP      r0,#0
00000e  d005              BEQ      |L8.28|
;;;1023     LWIP_ERROR("pbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
000010  f1b90f00          CMP      r9,#0
000014  d00c              BEQ      |L8.48|
;;;1024   
;;;1025     left = 0;
000016  2700              MOVS     r7,#0
;;;1026   
;;;1027     if ((buf == NULL) || (dataptr == NULL)) {
;;;1028       return 0;
;;;1029     }
;;;1030   
;;;1031     /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;1032     for (p = buf; len != 0 && p != NULL; p = p->next) {
000018  4604              MOV      r4,r0
00001a  e030              B        |L8.126|
                  |L8.28|
00001c  a31a              ADR      r3,|L8.136|
00001e  f24032fe          MOV      r2,#0x3fe             ;1022
000022  a125              ADR      r1,|L8.184|
000024  a02c              ADR      r0,|L8.216|
000026  f7fffffe          BL       __2printf
00002a  2000              MOVS     r0,#0                 ;1022
                  |L8.44|
;;;1033       if ((offset != 0) && (offset >= p->len)) {
;;;1034         /* don't copy from this buffer -> on to the next */
;;;1035         offset -= p->len;
;;;1036       } else {
;;;1037         /* copy from this buffer. maybe only partially. */
;;;1038         buf_copy_len = p->len - offset;
;;;1039         if (buf_copy_len > len) {
;;;1040           buf_copy_len = len;
;;;1041         }
;;;1042         /* copy the necessary parts of the buffer */
;;;1043         MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
;;;1044         copied_total += buf_copy_len;
;;;1045         left += buf_copy_len;
;;;1046         len -= buf_copy_len;
;;;1047         offset = 0;
;;;1048       }
;;;1049     }
;;;1050     return copied_total;
;;;1051   }
00002c  e8bd87f0          POP      {r4-r10,pc}
                  |L8.48|
000030  a315              ADR      r3,|L8.136|
000032  f24032ff          MOV      r2,#0x3ff             ;1023
000036  a132              ADR      r1,|L8.256|
000038  a027              ADR      r0,|L8.216|
00003a  f7fffffe          BL       __2printf
00003e  2000              MOVS     r0,#0                 ;1023
000040  e7f4              B        |L8.44|
                  |L8.66|
000042  b12b              CBZ      r3,|L8.80|
000044  8960              LDRH     r0,[r4,#0xa]          ;1033
000046  4298              CMP      r0,r3                 ;1033
000048  d802              BHI      |L8.80|
00004a  1a18              SUBS     r0,r3,r0              ;1035
00004c  b283              UXTH     r3,r0                 ;1035
00004e  e015              B        |L8.124|
                  |L8.80|
000050  8960              LDRH     r0,[r4,#0xa]          ;1038
000052  1ac0              SUBS     r0,r0,r3              ;1038
000054  b285              UXTH     r5,r0                 ;1038
000056  42b5              CMP      r5,r6                 ;1039
000058  d900              BLS      |L8.92|
00005a  4635              MOV      r5,r6                 ;1040
                  |L8.92|
00005c  6860              LDR      r0,[r4,#4]            ;1043
00005e  462a              MOV      r2,r5                 ;1043
000060  18c1              ADDS     r1,r0,r3              ;1043
000062  eb090007          ADD      r0,r9,r7              ;1043
000066  f7fffffe          BL       __aeabi_memcpy
00006a  eb080005          ADD      r0,r8,r5              ;1044
00006e  fa1ff880          UXTH     r8,r0                 ;1044
000072  1978              ADDS     r0,r7,r5              ;1045
000074  b287              UXTH     r7,r0                 ;1045
000076  1b70              SUBS     r0,r6,r5              ;1046
000078  b286              UXTH     r6,r0                 ;1046
00007a  2300              MOVS     r3,#0                 ;1047
                  |L8.124|
00007c  6824              LDR      r4,[r4,#0]            ;1032
                  |L8.126|
00007e  b10e              CBZ      r6,|L8.132|
000080  2c00              CMP      r4,#0                 ;1032
000082  d1de              BNE      |L8.66|
                  |L8.132|
000084  4640              MOV      r0,r8                 ;1050
000086  e7d1              B        |L8.44|
;;;1052   
                          ENDP

                  |L8.136|
000088  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
00008c  6964646c
000090  65776172
000094  65735c54
000098  68697264
00009c  5f506172
0000a0  74795c4c
0000a4  7749505c
0000a8  7372635c
0000ac  636f7265
0000b0  5c706275
0000b4  662e6300
                  |L8.184|
0000b8  70627566          DCB      "pbuf_copy_partial: invalid buf",0
0000bc  5f636f70
0000c0  795f7061
0000c4  72746961
0000c8  6c3a2069
0000cc  6e76616c
0000d0  69642062
0000d4  756600  
0000d7  00                DCB      0
                  |L8.216|
0000d8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000dc  7274696f
0000e0  6e202225
0000e4  73222066
0000e8  61696c65
0000ec  64206174
0000f0  206c696e
0000f4  65202564
0000f8  20696e20
0000fc  25730a00
                  |L8.256|
000100  70627566          DCB      "pbuf_copy_partial: invalid dataptr",0
000104  5f636f70
000108  795f7061
00010c  72746961
000110  6c3a2069
000114  6e76616c
000118  69642064
00011c  61746170
000120  747200  
000123  00                DCB      0

                          AREA ||i.pbuf_dechain||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_dechain PROC
;;;898    struct pbuf *
;;;899    pbuf_dechain(struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;900    {
000002  4604              MOV      r4,r0
;;;901      struct pbuf *q;
;;;902      u8_t tail_gone = 1;
000004  2601              MOVS     r6,#1
;;;903      /* tail */
;;;904      q = p->next;
000006  6825              LDR      r5,[r4,#0]
;;;905      /* pbuf has successor in chain? */
;;;906      if (q != NULL) {
000008  2d00              CMP      r5,#0
00000a  d018              BEQ      |L9.62|
;;;907        /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;908        LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
00000c  8920              LDRH     r0,[r4,#8]
00000e  8961              LDRH     r1,[r4,#0xa]
000010  1a40              SUBS     r0,r0,r1
000012  8929              LDRH     r1,[r5,#8]
000014  4288              CMP      r0,r1
000016  d006              BEQ      |L9.38|
000018  a311              ADR      r3,|L9.96|
00001a  f44f7263          MOV      r2,#0x38c
00001e  a11c              ADR      r1,|L9.144|
000020  a024              ADR      r0,|L9.180|
000022  f7fffffe          BL       __2printf
                  |L9.38|
;;;909        /* enforce invariant if assertion is disabled */
;;;910        q->tot_len = p->tot_len - p->len;
000026  8920              LDRH     r0,[r4,#8]
000028  8961              LDRH     r1,[r4,#0xa]
00002a  1a40              SUBS     r0,r0,r1
00002c  8128              STRH     r0,[r5,#8]
;;;911        /* decouple pbuf from remainder */
;;;912        p->next = NULL;
00002e  2000              MOVS     r0,#0
000030  6020              STR      r0,[r4,#0]
;;;913        /* total length of pbuf p is its own length only */
;;;914        p->tot_len = p->len;
000032  8960              LDRH     r0,[r4,#0xa]
000034  8120              STRH     r0,[r4,#8]
;;;915        /* q is no longer referenced by p, free it */
;;;916        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
;;;917        tail_gone = pbuf_free(q);
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       pbuf_free
00003c  4606              MOV      r6,r0
                  |L9.62|
;;;918        if (tail_gone > 0) {
;;;919          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE,
;;;920                      ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
;;;921        }
;;;922        /* return remaining tail or NULL if deallocated */
;;;923      }
;;;924      /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
;;;925      LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
00003e  8920              LDRH     r0,[r4,#8]
000040  8961              LDRH     r1,[r4,#0xa]
000042  4288              CMP      r0,r1
000044  d006              BEQ      |L9.84|
000046  a306              ADR      r3,|L9.96|
000048  f240329d          MOV      r2,#0x39d
00004c  a123              ADR      r1,|L9.220|
00004e  a019              ADR      r0,|L9.180|
000050  f7fffffe          BL       __2printf
                  |L9.84|
;;;926      return ((tail_gone > 0) ? NULL : q);
000054  b10e              CBZ      r6,|L9.90|
000056  2000              MOVS     r0,#0
;;;927    }
000058  bd70              POP      {r4-r6,pc}
                  |L9.90|
00005a  4628              MOV      r0,r5                 ;926
00005c  bd70              POP      {r4-r6,pc}
;;;928    
                          ENDP

00005e  0000              DCW      0x0000
                  |L9.96|
000060  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000064  6964646c
000068  65776172
00006c  65735c54
000070  68697264
000074  5f506172
000078  74795c4c
00007c  7749505c
000080  7372635c
000084  636f7265
000088  5c706275
00008c  662e6300
                  |L9.144|
000090  702d3e74          DCB      "p->tot_len == p->len + q->tot_len",0
000094  6f745f6c
000098  656e203d
00009c  3d20702d
0000a0  3e6c656e
0000a4  202b2071
0000a8  2d3e746f
0000ac  745f6c65
0000b0  6e00    
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L9.180|
0000b4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000b8  7274696f
0000bc  6e202225
0000c0  73222066
0000c4  61696c65
0000c8  64206174
0000cc  206c696e
0000d0  65202564
0000d4  20696e20
0000d8  25730a00
                  |L9.220|
0000dc  702d3e74          DCB      "p->tot_len == p->len",0
0000e0  6f745f6c
0000e4  656e203d
0000e8  3d20702d
0000ec  3e6c656e
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0

                          AREA ||i.pbuf_free||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_free PROC
;;;714    u8_t
;;;715    pbuf_free(struct pbuf *p)
000000  b570              PUSH     {r4-r6,lr}
;;;716    {
000002  4604              MOV      r4,r0
;;;717      u16_t type;
;;;718      struct pbuf *q;
;;;719      u8_t count;
;;;720    
;;;721      if (p == NULL) {
000004  2c00              CMP      r4,#0
000006  d011              BEQ      |L10.44|
;;;722        LWIP_ASSERT("p != NULL", p != NULL);
;;;723        /* if assertions are disabled, proceed with debug output */
;;;724        LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
;;;725          ("pbuf_free(p == NULL) was called.\n"));
;;;726        return 0;
;;;727      }
;;;728      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free(%p)\n", (void *)p));
;;;729    
;;;730      PERF_START;
;;;731    
;;;732      LWIP_ASSERT("pbuf_free: sane type",
000008  7b20              LDRB     r0,[r4,#0xc]
00000a  2800              CMP      r0,#0
00000c  d00c              BEQ      |L10.40|
00000e  2801              CMP      r0,#1
000010  d00a              BEQ      |L10.40|
000012  2802              CMP      r0,#2
000014  d008              BEQ      |L10.40|
000016  2803              CMP      r0,#3
000018  d006              BEQ      |L10.40|
00001a  a327              ADR      r3,|L10.184|
00001c  f44f7237          MOV      r2,#0x2dc
000020  a131              ADR      r1,|L10.232|
000022  a037              ADR      r0,|L10.256|
000024  f7fffffe          BL       __2printf
                  |L10.40|
;;;733        p->type == PBUF_RAM || p->type == PBUF_ROM ||
;;;734        p->type == PBUF_REF || p->type == PBUF_POOL);
;;;735    
;;;736      count = 0;
000028  2500              MOVS     r5,#0
;;;737      /* de-allocate all consecutive pbufs from the head of the chain that
;;;738       * obtain a zero reference count after decrementing*/
;;;739      while (p != NULL) {
00002a  e017              B        |L10.92|
                  |L10.44|
00002c  a322              ADR      r3,|L10.184|
00002e  f24022d2          MOV      r2,#0x2d2             ;722
000032  a13d              ADR      r1,|L10.296|
000034  a032              ADR      r0,|L10.256|
000036  f7fffffe          BL       __2printf
00003a  2000              MOVS     r0,#0                 ;726
;;;740        u16_t ref;
;;;741        SYS_ARCH_DECL_PROTECT(old_level);
;;;742        /* Since decrementing ref cannot be guaranteed to be a single machine operation
;;;743         * we must protect it. We put the new ref into a local variable to prevent
;;;744         * further protection. */
;;;745        SYS_ARCH_PROTECT(old_level);
;;;746        /* all pbufs in a chain are referenced at least once */
;;;747        LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
;;;748        /* decrease reference count (number of pointers to pbuf) */
;;;749        ref = --(p->ref);
;;;750        SYS_ARCH_UNPROTECT(old_level);
;;;751        /* this pbuf is no longer referenced to? */
;;;752        if (ref == 0) {
;;;753          /* remember next pbuf in chain for next iteration */
;;;754          q = p->next;
;;;755          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: deallocating %p\n", (void *)p));
;;;756          type = p->type;
;;;757    #if LWIP_SUPPORT_CUSTOM_PBUF
;;;758          /* is this a custom pbuf? */
;;;759          if ((p->flags & PBUF_FLAG_IS_CUSTOM) != 0) {
;;;760            struct pbuf_custom *pc = (struct pbuf_custom*)p;
;;;761            LWIP_ASSERT("pc->custom_free_function != NULL", pc->custom_free_function != NULL);
;;;762            pc->custom_free_function(p);
;;;763          } else
;;;764    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
;;;765          {
;;;766            /* is this a pbuf from the pool? */
;;;767            if (type == PBUF_POOL) {
;;;768              memp_free(MEMP_PBUF_POOL, p);
;;;769            /* is this a ROM or RAM referencing pbuf? */
;;;770            } else if (type == PBUF_ROM || type == PBUF_REF) {
;;;771              memp_free(MEMP_PBUF, p);
;;;772            /* type == PBUF_RAM */
;;;773            } else {
;;;774              mem_free(p);
;;;775            }
;;;776          }
;;;777          count++;
;;;778          /* proceed to next pbuf */
;;;779          p = q;
;;;780        /* p->ref > 0, this pbuf is still referenced to */
;;;781        /* (and so the remaining pbufs in chain as well) */
;;;782        } else {
;;;783          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free: %p has ref %"U16_F", ending here.\n", (void *)p, ref));
;;;784          /* stop walking through the chain */
;;;785          p = NULL;
;;;786        }
;;;787      }
;;;788      PERF_STOP("pbuf_free");
;;;789      /* return number of de-allocated pbufs */
;;;790      return count;
;;;791    }
00003c  bd70              POP      {r4-r6,pc}
                  |L10.62|
00003e  89e0              LDRH     r0,[r4,#0xe]          ;747
000040  b930              CBNZ     r0,|L10.80|
000042  a31d              ADR      r3,|L10.184|
000044  f24022eb          MOV      r2,#0x2eb             ;747
000048  a13a              ADR      r1,|L10.308|
00004a  a02d              ADR      r0,|L10.256|
00004c  f7fffffe          BL       __2printf
                  |L10.80|
000050  89e0              LDRH     r0,[r4,#0xe]          ;749
000052  1e40              SUBS     r0,r0,#1              ;749
000054  b280              UXTH     r0,r0                 ;749
000056  81e0              STRH     r0,[r4,#0xe]          ;749
000058  b120              CBZ      r0,|L10.100|
00005a  2400              MOVS     r4,#0                 ;785
                  |L10.92|
00005c  2c00              CMP      r4,#0                 ;739
00005e  d1ee              BNE      |L10.62|
000060  4628              MOV      r0,r5                 ;790
000062  bd70              POP      {r4-r6,pc}
                  |L10.100|
000064  6826              LDR      r6,[r4,#0]            ;754
000066  7b20              LDRB     r0,[r4,#0xc]          ;756
000068  7b61              LDRB     r1,[r4,#0xd]          ;759
00006a  0789              LSLS     r1,r1,#30             ;759
00006c  d50c              BPL      |L10.136|
00006e  6920              LDR      r0,[r4,#0x10]         ;761
000070  b930              CBNZ     r0,|L10.128|
000072  a311              ADR      r3,|L10.184|
000074  f24022f9          MOV      r2,#0x2f9             ;761
000078  a134              ADR      r1,|L10.332|
00007a  a021              ADR      r0,|L10.256|
00007c  f7fffffe          BL       __2printf
                  |L10.128|
000080  6921              LDR      r1,[r4,#0x10]         ;762
000082  4620              MOV      r0,r4                 ;762
000084  4788              BLX      r1                    ;762
000086  e008              B        |L10.154|
                  |L10.136|
000088  2803              CMP      r0,#3                 ;767
00008a  d00a              BEQ      |L10.162|
00008c  2801              CMP      r0,#1                 ;770
00008e  d00d              BEQ      |L10.172|
000090  2802              CMP      r0,#2                 ;770
000092  d00b              BEQ      |L10.172|
000094  4620              MOV      r0,r4                 ;774
000096  f7fffffe          BL       mem_free
                  |L10.154|
00009a  1c6d              ADDS     r5,r5,#1              ;777
00009c  b2ed              UXTB     r5,r5                 ;777
00009e  4634              MOV      r4,r6                 ;779
0000a0  e7dc              B        |L10.92|
                  |L10.162|
0000a2  4621              MOV      r1,r4                 ;768
0000a4  2008              MOVS     r0,#8                 ;768
0000a6  f7fffffe          BL       memp_free
0000aa  e7f6              B        |L10.154|
                  |L10.172|
0000ac  4621              MOV      r1,r4                 ;771
0000ae  2007              MOVS     r0,#7                 ;771
0000b0  f7fffffe          BL       memp_free
0000b4  e7f1              B        |L10.154|
;;;792    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L10.184|
0000b8  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
0000bc  6964646c
0000c0  65776172
0000c4  65735c54
0000c8  68697264
0000cc  5f506172
0000d0  74795c4c
0000d4  7749505c
0000d8  7372635c
0000dc  636f7265
0000e0  5c706275
0000e4  662e6300
                  |L10.232|
0000e8  70627566          DCB      "pbuf_free: sane type",0
0000ec  5f667265
0000f0  653a2073
0000f4  616e6520
0000f8  74797065
0000fc  00      
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L10.256|
000100  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000104  7274696f
000108  6e202225
00010c  73222066
000110  61696c65
000114  64206174
000118  206c696e
00011c  65202564
000120  20696e20
000124  25730a00
                  |L10.296|
000128  7020213d          DCB      "p != NULL",0
00012c  204e554c
000130  4c00    
000132  00                DCB      0
000133  00                DCB      0
                  |L10.308|
000134  70627566          DCB      "pbuf_free: p->ref > 0",0
000138  5f667265
00013c  653a2070
000140  2d3e7265
000144  66203e20
000148  3000    
00014a  00                DCB      0
00014b  00                DCB      0
                  |L10.332|
00014c  70632d3e          DCB      "pc->custom_free_function != NULL",0
000150  63757374
000154  6f6d5f66
000158  7265655f
00015c  66756e63
000160  74696f6e
000164  20213d20
000168  4e554c4c
00016c  00      
00016d  00                DCB      0
00016e  00                DCB      0
00016f  00                DCB      0

                          AREA ||i.pbuf_free_ooseq||, CODE, READONLY, ALIGN=2

                  pbuf_free_ooseq PROC
;;;164    void
;;;165    pbuf_free_ooseq(void)
000000  b570              PUSH     {r4-r6,lr}
;;;166    {
;;;167      struct tcp_pcb* pcb;
;;;168      SYS_ARCH_SET(pbuf_free_ooseq_pending, 0);
000002  4808              LDR      r0,|L11.36|
000004  2500              MOVS     r5,#0
000006  7005              STRB     r5,[r0,#0]
;;;169    
;;;170      for (pcb = tcp_active_pcbs; NULL != pcb; pcb = pcb->next) {
000008  4807              LDR      r0,|L11.40|
00000a  6804              LDR      r4,[r0,#0]  ; tcp_active_pcbs
00000c  e007              B        |L11.30|
                  |L11.14|
;;;171        if (NULL != pcb->ooseq) {
00000e  6f20              LDR      r0,[r4,#0x70]
000010  b120              CBZ      r0,|L11.28|
;;;172          /** Free the ooseq pbufs of one PCB only */
;;;173          LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_free_ooseq: freeing out-of-sequence pbufs\n"));
;;;174          tcp_segs_free(pcb->ooseq);
000012  6f20              LDR      r0,[r4,#0x70]
000014  f7fffffe          BL       tcp_segs_free
;;;175          pcb->ooseq = NULL;
000018  6725              STR      r5,[r4,#0x70]
;;;176          return;
;;;177        }
;;;178      }
;;;179    }
00001a  bd70              POP      {r4-r6,pc}
                  |L11.28|
00001c  68e4              LDR      r4,[r4,#0xc]          ;170
                  |L11.30|
00001e  2c00              CMP      r4,#0                 ;170
000020  d1f5              BNE      |L11.14|
000022  bd70              POP      {r4-r6,pc}
;;;180    
                          ENDP

                  |L11.36|
                          DCD      ||.data||
                  |L11.40|
                          DCD      tcp_active_pcbs

                          AREA ||i.pbuf_get_at||, CODE, READONLY, ALIGN=1

                  pbuf_get_at PROC
;;;1298   u8_t
;;;1299   pbuf_get_at(const struct pbuf* p, u16_t offset)
000000  b510              PUSH     {r4,lr}
;;;1300   {
;;;1301     int ret = pbuf_try_get_at(p, offset);
000002  f7fffffe          BL       pbuf_try_get_at
;;;1302     if (ret >= 0) {
000006  2800              CMP      r0,#0
000008  db01              BLT      |L12.14|
;;;1303       return (u8_t)ret;
00000a  b2c0              UXTB     r0,r0
;;;1304     }
;;;1305     return 0;
;;;1306   }
00000c  bd10              POP      {r4,pc}
                  |L12.14|
00000e  2000              MOVS     r0,#0                 ;1305
000010  bd10              POP      {r4,pc}
;;;1307   
                          ENDP


                          AREA ||i.pbuf_header||, CODE, READONLY, ALIGN=1

                  pbuf_header PROC
;;;664    u8_t
;;;665    pbuf_header(struct pbuf *p, s16_t header_size_increment)
000000  2200              MOVS     r2,#0
;;;666    {
;;;667       return pbuf_header_impl(p, header_size_increment, 0);
000002  f7ffbffe          B.W      pbuf_header_impl
;;;668    }
;;;669    
                          ENDP


                          AREA ||i.pbuf_header_force||, CODE, READONLY, ALIGN=1

                  pbuf_header_force PROC
;;;674    u8_t
;;;675    pbuf_header_force(struct pbuf *p, s16_t header_size_increment)
000000  2201              MOVS     r2,#1
;;;676    {
;;;677       return pbuf_header_impl(p, header_size_increment, 1);
000002  f7ffbffe          B.W      pbuf_header_impl
;;;678    }
;;;679    
                          ENDP


                          AREA ||i.pbuf_header_impl||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_header_impl PROC
;;;568    static u8_t
;;;569    pbuf_header_impl(struct pbuf *p, s16_t header_size_increment, u8_t force)
000000  b570              PUSH     {r4-r6,lr}
;;;570    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;571      u16_t type;
;;;572      void *payload;
;;;573      u16_t increment_magnitude;
;;;574    
;;;575      LWIP_ASSERT("p != NULL", p != NULL);
000008  2c00              CMP      r4,#0
00000a  d106              BNE      |L15.26|
00000c  a327              ADR      r3,|L15.172|
00000e  f240223f          MOV      r2,#0x23f
000012  a132              ADR      r1,|L15.220|
000014  a034              ADR      r0,|L15.232|
000016  f7fffffe          BL       __2printf
                  |L15.26|
;;;576      if ((header_size_increment == 0) || (p == NULL)) {
00001a  2d00              CMP      r5,#0
00001c  d011              BEQ      |L15.66|
00001e  2c00              CMP      r4,#0
000020  d00f              BEQ      |L15.66|
;;;577        return 0;
;;;578      }
;;;579    
;;;580      if (header_size_increment < 0) {
000022  2d00              CMP      r5,#0
000024  da0f              BGE      |L15.70|
;;;581        increment_magnitude = (u16_t)-header_size_increment;
000026  4268              RSBS     r0,r5,#0
000028  b283              UXTH     r3,r0
;;;582        /* Check that we aren't going to move off the end of the pbuf */
;;;583        LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
00002a  8960              LDRH     r0,[r4,#0xa]
00002c  4298              CMP      r0,r3
00002e  d20b              BCS      |L15.72|
000030  a31e              ADR      r3,|L15.172|
000032  f2402247          MOV      r2,#0x247
000036  a136              ADR      r1,|L15.272|
000038  a02b              ADR      r0,|L15.232|
00003a  f7fffffe          BL       __2printf
00003e  2001              MOVS     r0,#1
;;;584      } else {
;;;585        increment_magnitude = (u16_t)header_size_increment;
;;;586    #if 0
;;;587        /* Can't assert these as some callers speculatively call
;;;588             pbuf_header() to see if it's OK.  Will return 1 below instead. */
;;;589        /* Check that we've got the correct type of pbuf to work with */
;;;590        LWIP_ASSERT("p->type == PBUF_RAM || p->type == PBUF_POOL",
;;;591                    p->type == PBUF_RAM || p->type == PBUF_POOL);
;;;592        /* Check that we aren't going to move off the beginning of the pbuf */
;;;593        LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
;;;594                    (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
;;;595    #endif
;;;596      }
;;;597    
;;;598      type = p->type;
;;;599      /* remember current payload pointer */
;;;600      payload = p->payload;
;;;601    
;;;602      /* pbuf types containing payloads? */
;;;603      if (type == PBUF_RAM || type == PBUF_POOL) {
;;;604        /* set new payload pointer */
;;;605        p->payload = (u8_t *)p->payload - header_size_increment;
;;;606        /* boundary check fails? */
;;;607        if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
;;;608          LWIP_DEBUGF( PBUF_DEBUG | LWIP_DBG_TRACE,
;;;609            ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
;;;610            (void *)p->payload, (void *)((u8_t *)p + SIZEOF_STRUCT_PBUF)));
;;;611          /* restore old payload pointer */
;;;612          p->payload = payload;
;;;613          /* bail out unsuccessfully */
;;;614          return 1;
;;;615        }
;;;616      /* pbuf types referring to external payloads? */
;;;617      } else if (type == PBUF_REF || type == PBUF_ROM) {
;;;618        /* hide a header in the payload? */
;;;619        if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
;;;620          /* increase payload pointer */
;;;621          p->payload = (u8_t *)p->payload - header_size_increment;
;;;622        } else if ((header_size_increment > 0) && force) {
;;;623          p->payload = (u8_t *)p->payload - header_size_increment;
;;;624        } else {
;;;625          /* cannot expand payload to front (yet!)
;;;626           * bail out unsuccessfully */
;;;627          return 1;
;;;628        }
;;;629      } else {
;;;630        /* Unknown type */
;;;631        LWIP_ASSERT("bad pbuf type", 0);
;;;632        return 1;
;;;633      }
;;;634      /* modify pbuf length fields */
;;;635      p->len += header_size_increment;
;;;636      p->tot_len += header_size_increment;
;;;637    
;;;638      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE, ("pbuf_header: old %p new %p (%"S16_F")\n",
;;;639        (void *)payload, (void *)p->payload, header_size_increment));
;;;640    
;;;641      return 0;
;;;642    }
000040  bd70              POP      {r4-r6,pc}
                  |L15.66|
000042  2000              MOVS     r0,#0                 ;577
000044  bd70              POP      {r4-r6,pc}
                  |L15.70|
000046  b2ab              UXTH     r3,r5                 ;585
                  |L15.72|
000048  7b20              LDRB     r0,[r4,#0xc]          ;598
00004a  6861              LDR      r1,[r4,#4]            ;600
00004c  b170              CBZ      r0,|L15.108|
00004e  2803              CMP      r0,#3                 ;603
000050  d00c              BEQ      |L15.108|
000052  2802              CMP      r0,#2                 ;617
000054  d013              BEQ      |L15.126|
000056  2801              CMP      r0,#1                 ;617
000058  d011              BEQ      |L15.126|
00005a  a314              ADR      r3,|L15.172|
00005c  f2402277          MOV      r2,#0x277             ;631
000060  a133              ADR      r1,|L15.304|
000062  a021              ADR      r0,|L15.232|
000064  f7fffffe          BL       __2printf
000068  2001              MOVS     r0,#1                 ;632
00006a  bd70              POP      {r4-r6,pc}
                  |L15.108|
00006c  1b48              SUBS     r0,r1,r5              ;605
00006e  6060              STR      r0,[r4,#4]            ;605
000070  f1040210          ADD      r2,r4,#0x10           ;607
000074  4290              CMP      r0,r2                 ;607
000076  d20f              BCS      |L15.152|
000078  6061              STR      r1,[r4,#4]            ;612
00007a  2001              MOVS     r0,#1                 ;614
00007c  bd70              POP      {r4-r6,pc}
                  |L15.126|
00007e  2d00              CMP      r5,#0                 ;619
000080  da05              BGE      |L15.142|
000082  8960              LDRH     r0,[r4,#0xa]          ;619
000084  4298              CMP      r0,r3                 ;619
000086  d302              BCC      |L15.142|
000088  1b48              SUBS     r0,r1,r5              ;621
00008a  6060              STR      r0,[r4,#4]            ;621
00008c  e004              B        |L15.152|
                  |L15.142|
00008e  2d00              CMP      r5,#0                 ;622
000090  dd0a              BLE      |L15.168|
000092  b14e              CBZ      r6,|L15.168|
000094  1b48              SUBS     r0,r1,r5              ;623
000096  6060              STR      r0,[r4,#4]            ;623
                  |L15.152|
000098  8960              LDRH     r0,[r4,#0xa]          ;635
00009a  4428              ADD      r0,r0,r5              ;635
00009c  8160              STRH     r0,[r4,#0xa]          ;635
00009e  8920              LDRH     r0,[r4,#8]            ;636
0000a0  4428              ADD      r0,r0,r5              ;636
0000a2  8120              STRH     r0,[r4,#8]            ;636
0000a4  2000              MOVS     r0,#0                 ;641
0000a6  bd70              POP      {r4-r6,pc}
                  |L15.168|
0000a8  2001              MOVS     r0,#1                 ;627
0000aa  bd70              POP      {r4-r6,pc}
;;;643    
                          ENDP

                  |L15.172|
0000ac  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
0000b0  6964646c
0000b4  65776172
0000b8  65735c54
0000bc  68697264
0000c0  5f506172
0000c4  74795c4c
0000c8  7749505c
0000cc  7372635c
0000d0  636f7265
0000d4  5c706275
0000d8  662e6300
                  |L15.220|
0000dc  7020213d          DCB      "p != NULL",0
0000e0  204e554c
0000e4  4c00    
0000e6  00                DCB      0
0000e7  00                DCB      0
                  |L15.232|
0000e8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000ec  7274696f
0000f0  6e202225
0000f4  73222066
0000f8  61696c65
0000fc  64206174
000100  206c696e
000104  65202564
000108  20696e20
00010c  25730a00
                  |L15.272|
000110  696e6372          DCB      "increment_magnitude <= p->len",0
000114  656d656e
000118  745f6d61
00011c  676e6974
000120  75646520
000124  3c3d2070
000128  2d3e6c65
00012c  6e00    
00012e  00                DCB      0
00012f  00                DCB      0
                  |L15.304|
000130  62616420          DCB      "bad pbuf type",0
000134  70627566
000138  20747970
00013c  6500    
00013e  00                DCB      0
00013f  00                DCB      0

                          AREA ||i.pbuf_memcmp||, CODE, READONLY, ALIGN=1

                  pbuf_memcmp PROC
;;;1361   u16_t
;;;1362   pbuf_memcmp(const struct pbuf* p, u16_t offset, const void* s2, u16_t n)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1363   {
000004  4690              MOV      r8,r2
000006  461f              MOV      r7,r3
;;;1364     u16_t start = offset;
000008  460d              MOV      r5,r1
;;;1365     const struct pbuf* q = p;
00000a  4606              MOV      r6,r0
;;;1366     u16_t i;
;;;1367    
;;;1368     /* pbuf long enough to perform check? */
;;;1369     if(p->tot_len < (offset + n)) {
00000c  8900              LDRH     r0,[r0,#8]
00000e  4439              ADD      r1,r1,r7
000010  4288              CMP      r0,r1
000012  d206              BCS      |L16.34|
;;;1370       return 0xffff;
000014  f64f70ff          MOV      r0,#0xffff
                  |L16.24|
;;;1371     }
;;;1372    
;;;1373     /* get the correct pbuf from chain. We know it succeeds because of p->tot_len check above. */
;;;1374     while ((q != NULL) && (q->len <= start)) {
;;;1375       start -= q->len;
;;;1376       q = q->next;
;;;1377     }
;;;1378    
;;;1379     /* return requested data if pbuf is OK */
;;;1380     for (i = 0; i < n; i++) {
;;;1381       /* We know pbuf_get_at() succeeds because of p->tot_len check above. */
;;;1382       u8_t a = pbuf_get_at(q, start + i);
;;;1383       u8_t b = ((const u8_t*)s2)[i];
;;;1384       if (a != b) {
;;;1385         return i+1;
;;;1386       }
;;;1387     }
;;;1388     return 0;
;;;1389   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L16.28|
00001c  1a28              SUBS     r0,r5,r0              ;1375
00001e  b285              UXTH     r5,r0                 ;1375
000020  6836              LDR      r6,[r6,#0]            ;1376
                  |L16.34|
000022  b116              CBZ      r6,|L16.42|
000024  8970              LDRH     r0,[r6,#0xa]          ;1374
000026  42a8              CMP      r0,r5                 ;1374
000028  d9f8              BLS      |L16.28|
                  |L16.42|
00002a  2400              MOVS     r4,#0                 ;1380
00002c  e00d              B        |L16.74|
                  |L16.46|
00002e  1928              ADDS     r0,r5,r4              ;1382
000030  b281              UXTH     r1,r0                 ;1382
000032  4630              MOV      r0,r6                 ;1382
000034  f7fffffe          BL       pbuf_get_at
000038  f8181004          LDRB     r1,[r8,r4]            ;1383
00003c  4288              CMP      r0,r1                 ;1384
00003e  d002              BEQ      |L16.70|
000040  1c64              ADDS     r4,r4,#1              ;1385
000042  b2a0              UXTH     r0,r4                 ;1385
000044  e7e8              B        |L16.24|
                  |L16.70|
000046  1c64              ADDS     r4,r4,#1              ;1380
000048  b2a4              UXTH     r4,r4                 ;1380
                  |L16.74|
00004a  42bc              CMP      r4,r7                 ;1380
00004c  d3ef              BCC      |L16.46|
00004e  2000              MOVS     r0,#0                 ;1388
000050  e7e2              B        |L16.24|
;;;1390   
                          ENDP


                          AREA ||i.pbuf_memfind||, CODE, READONLY, ALIGN=1

                  pbuf_memfind PROC
;;;1403   u16_t
;;;1404   pbuf_memfind(const struct pbuf* p, const void* mem, u16_t mem_len, u16_t start_offset)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1405   {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4616              MOV      r6,r2
;;;1406     u16_t i;
;;;1407     u16_t max = p->tot_len - mem_len;
00000a  8938              LDRH     r0,[r7,#8]
00000c  1b81              SUBS     r1,r0,r6
00000e  b28d              UXTH     r5,r1
;;;1408     if (p->tot_len >= mem_len + start_offset) {
000010  18f1              ADDS     r1,r6,r3
000012  4288              CMP      r0,r1
000014  d30c              BCC      |L17.48|
;;;1409       for (i = start_offset; i <= max; i++) {
000016  461c              MOV      r4,r3
000018  e008              B        |L17.44|
                  |L17.26|
;;;1410         u16_t plus = pbuf_memcmp(p, i, mem, mem_len);
00001a  4633              MOV      r3,r6
00001c  4642              MOV      r2,r8
00001e  4621              MOV      r1,r4
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       pbuf_memcmp
;;;1411         if (plus == 0) {
000026  b138              CBZ      r0,|L17.56|
000028  1c64              ADDS     r4,r4,#1              ;1409
00002a  b2a4              UXTH     r4,r4                 ;1409
                  |L17.44|
00002c  42ac              CMP      r4,r5                 ;1409
00002e  d9f4              BLS      |L17.26|
                  |L17.48|
;;;1412           return i;
;;;1413         }
;;;1414       }
;;;1415     }
;;;1416     return 0xFFFF;
000030  f64f70ff          MOV      r0,#0xffff
                  |L17.52|
;;;1417   }
000034  e8bd81f0          POP      {r4-r8,pc}
                  |L17.56|
000038  4620              MOV      r0,r4                 ;1412
00003a  e7fb              B        |L17.52|
;;;1418   
                          ENDP


                          AREA ||i.pbuf_pool_is_empty||, CODE, READONLY, ALIGN=2

                  pbuf_pool_is_empty PROC
;;;194    static void
;;;195    pbuf_pool_is_empty(void)
000000  4901              LDR      r1,|L18.8|
;;;196    {
;;;197    #ifndef PBUF_POOL_FREE_OOSEQ_QUEUE_CALL
;;;198      SYS_ARCH_SET(pbuf_free_ooseq_pending, 1);
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;199    #else /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;200      u8_t queued;
;;;201      SYS_ARCH_DECL_PROTECT(old_level);
;;;202      SYS_ARCH_PROTECT(old_level);
;;;203      queued = pbuf_free_ooseq_pending;
;;;204      pbuf_free_ooseq_pending = 1;
;;;205      SYS_ARCH_UNPROTECT(old_level);
;;;206    
;;;207      if (!queued) {
;;;208        /* queue a call to pbuf_free_ooseq if not already queued */
;;;209        PBUF_POOL_FREE_OOSEQ_QUEUE_CALL();
;;;210      }
;;;211    #endif /* PBUF_POOL_FREE_OOSEQ_QUEUE_CALL */
;;;212    }
000006  4770              BX       lr
;;;213    #endif /* !LWIP_TCP || !TCP_QUEUE_OOSEQ || !PBUF_POOL_FREE_OOSEQ */
                          ENDP

                  |L18.8|
                          DCD      ||.data||

                          AREA ||i.pbuf_put_at||, CODE, READONLY, ALIGN=1

                  pbuf_put_at PROC
;;;1338   void
;;;1339   pbuf_put_at(struct pbuf* p, u16_t offset, u8_t data)
000000  b538              PUSH     {r3-r5,lr}
;;;1340   {
000002  4614              MOV      r4,r2
;;;1341     u16_t q_idx;
;;;1342     struct pbuf* q = pbuf_skip(p, offset, &q_idx);
000004  466a              MOV      r2,sp
000006  f7fffffe          BL       pbuf_skip
;;;1343   
;;;1344     /* write requested data if pbuf is OK */
;;;1345     if ((q != NULL) && (q->len > q_idx)) {
00000a  2800              CMP      r0,#0
00000c  d006              BEQ      |L19.28|
00000e  8943              LDRH     r3,[r0,#0xa]
000010  f8bd1000          LDRH     r1,[sp,#0]
000014  428b              CMP      r3,r1
000016  d901              BLS      |L19.28|
;;;1346       ((u8_t*)q->payload)[q_idx] = data;
000018  6840              LDR      r0,[r0,#4]
00001a  5444              STRB     r4,[r0,r1]
                  |L19.28|
;;;1347     }
;;;1348   }
00001c  bd38              POP      {r3-r5,pc}
;;;1349   
                          ENDP


                          AREA ||i.pbuf_realloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_realloc PROC
;;;492    void
;;;493    pbuf_realloc(struct pbuf *p, u16_t new_len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;494    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;495      struct pbuf *q;
;;;496      u16_t rem_len; /* remaining length */
;;;497      s32_t grow;
;;;498    
;;;499      LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
000008  2c00              CMP      r4,#0
00000a  d106              BNE      |L20.26|
00000c  a32e              ADR      r3,|L20.200|
00000e  f24012f3          MOV      r2,#0x1f3
000012  a139              ADR      r1,|L20.248|
000014  a03e              ADR      r0,|L20.272|
000016  f7fffffe          BL       __2printf
                  |L20.26|
;;;500      LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
00001a  7b20              LDRB     r0,[r4,#0xc]
00001c  2803              CMP      r0,#3
00001e  d00c              BEQ      |L20.58|
000020  2801              CMP      r0,#1
000022  d00a              BEQ      |L20.58|
000024  2800              CMP      r0,#0
000026  d008              BEQ      |L20.58|
000028  2802              CMP      r0,#2
00002a  d006              BEQ      |L20.58|
00002c  a326              ADR      r3,|L20.200|
00002e  f44f72fa          MOV      r2,#0x1f4
000032  a141              ADR      r1,|L20.312|
000034  a036              ADR      r0,|L20.272|
000036  f7fffffe          BL       __2printf
                  |L20.58|
;;;501                  p->type == PBUF_ROM ||
;;;502                  p->type == PBUF_RAM ||
;;;503                  p->type == PBUF_REF);
;;;504    
;;;505      /* desired length larger than current length? */
;;;506      if (new_len >= p->tot_len) {
00003a  8920              LDRH     r0,[r4,#8]
00003c  42a8              CMP      r0,r5
00003e  d940              BLS      |L20.194|
;;;507        /* enlarging not yet supported */
;;;508        return;
;;;509      }
;;;510    
;;;511      /* the pbuf chain grows by (new_len - p->tot_len) bytes
;;;512       * (which may be negative in case of shrinking) */
;;;513      grow = new_len - p->tot_len;
000040  1a2e              SUBS     r6,r5,r0
;;;514    
;;;515      /* first, step over any pbufs that should remain in the chain */
;;;516      rem_len = new_len;
;;;517      q = p;
;;;518      /* should this pbuf be kept? */
;;;519      while (rem_len > q->len) {
;;;520        /* decrease remaining length by pbuf length */
;;;521        rem_len -= q->len;
;;;522        /* decrease total length indicator */
;;;523        LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
000042  f64f77ff          MOV      r7,#0xffff
000046  f240280b          MOV      r8,#0x20b
;;;524        q->tot_len += (u16_t)grow;
;;;525        /* proceed to next pbuf in chain */
;;;526        q = q->next;
;;;527        LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
00004a  f240290f          MOV      r9,#0x20f
00004e  e014              B        |L20.122|
                  |L20.80|
000050  1a28              SUBS     r0,r5,r0              ;521
000052  b285              UXTH     r5,r0                 ;521
000054  42be              CMP      r6,r7                 ;523
000056  db05              BLT      |L20.100|
000058  a31b              ADR      r3,|L20.200|
00005a  4642              MOV      r2,r8                 ;523
00005c  a13d              ADR      r1,|L20.340|
00005e  a02c              ADR      r0,|L20.272|
000060  f7fffffe          BL       __2printf
                  |L20.100|
000064  8920              LDRH     r0,[r4,#8]            ;524
000066  4430              ADD      r0,r0,r6              ;524
000068  8120              STRH     r0,[r4,#8]            ;524
00006a  6824              LDR      r4,[r4,#0]            ;526
00006c  b92c              CBNZ     r4,|L20.122|
00006e  a316              ADR      r3,|L20.200|
000070  464a              MOV      r2,r9
000072  a13d              ADR      r1,|L20.360|
000074  a026              ADR      r0,|L20.272|
000076  f7fffffe          BL       __2printf
                  |L20.122|
00007a  8960              LDRH     r0,[r4,#0xa]          ;519
00007c  42a8              CMP      r0,r5                 ;519
00007e  d3e7              BCC      |L20.80|
;;;528      }
;;;529      /* we have now reached the new last pbuf (in q) */
;;;530      /* rem_len == desired length for pbuf q */
;;;531    
;;;532      /* shrink allocated memory for PBUF_RAM */
;;;533      /* (other types merely adjust their length fields */
;;;534      if ((q->type == PBUF_RAM) && (rem_len != q->len)
000080  7b20              LDRB     r0,[r4,#0xc]
000082  2800              CMP      r0,#0
000084  d115              BNE      |L20.178|
000086  8960              LDRH     r0,[r4,#0xa]
000088  42a8              CMP      r0,r5
00008a  d012              BEQ      |L20.178|
;;;535    #if LWIP_SUPPORT_CUSTOM_PBUF
;;;536          && ((q->flags & PBUF_FLAG_IS_CUSTOM) == 0)
00008c  7b60              LDRB     r0,[r4,#0xd]
00008e  0780              LSLS     r0,r0,#30
000090  d40f              BMI      |L20.178|
;;;537    #endif /* LWIP_SUPPORT_CUSTOM_PBUF */
;;;538         ) {
;;;539        /* reallocate and adjust the length of the pbuf that will be split */
;;;540        q = (struct pbuf *)mem_trim(q, (u16_t)((u8_t *)q->payload - (u8_t *)q) + rem_len);
000092  88a0              LDRH     r0,[r4,#4]
000094  1b00              SUBS     r0,r0,r4
000096  4428              ADD      r0,r0,r5
000098  b281              UXTH     r1,r0
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       mem_trim
0000a0  4604              MOV      r4,r0
;;;541        LWIP_ASSERT("mem_trim returned q == NULL", q != NULL);
0000a2  b934              CBNZ     r4,|L20.178|
0000a4  a308              ADR      r3,|L20.200|
0000a6  f240221d          MOV      r2,#0x21d
0000aa  a135              ADR      r1,|L20.384|
0000ac  a018              ADR      r0,|L20.272|
0000ae  f7fffffe          BL       __2printf
                  |L20.178|
;;;542      }
;;;543      /* adjust length fields for new last pbuf */
;;;544      q->len = rem_len;
0000b2  8165              STRH     r5,[r4,#0xa]
;;;545      q->tot_len = q->len;
0000b4  8125              STRH     r5,[r4,#8]
;;;546    
;;;547      /* any remaining pbufs in chain? */
;;;548      if (q->next != NULL) {
0000b6  6820              LDR      r0,[r4,#0]
0000b8  b108              CBZ      r0,|L20.190|
;;;549        /* free remaining pbufs in chain */
;;;550        pbuf_free(q->next);
0000ba  f7fffffe          BL       pbuf_free
                  |L20.190|
;;;551      }
;;;552      /* q is last packet in chain */
;;;553      q->next = NULL;
0000be  2000              MOVS     r0,#0
0000c0  6020              STR      r0,[r4,#0]
                  |L20.194|
;;;554    
;;;555    }
0000c2  e8bd87f0          POP      {r4-r10,pc}
;;;556    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L20.200|
0000c8  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
0000cc  6964646c
0000d0  65776172
0000d4  65735c54
0000d8  68697264
0000dc  5f506172
0000e0  74795c4c
0000e4  7749505c
0000e8  7372635c
0000ec  636f7265
0000f0  5c706275
0000f4  662e6300
                  |L20.248|
0000f8  70627566          DCB      "pbuf_realloc: p != NULL",0
0000fc  5f726561
000100  6c6c6f63
000104  3a207020
000108  213d204e
00010c  554c4c00
                  |L20.272|
000110  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000114  7274696f
000118  6e202225
00011c  73222066
000120  61696c65
000124  64206174
000128  206c696e
00012c  65202564
000130  20696e20
000134  25730a00
                  |L20.312|
000138  70627566          DCB      "pbuf_realloc: sane p->type",0
00013c  5f726561
000140  6c6c6f63
000144  3a207361
000148  6e652070
00014c  2d3e7479
000150  706500  
000153  00                DCB      0
                  |L20.340|
000154  67726f77          DCB      "grow < max_u16_t",0
000158  203c206d
00015c  61785f75
000160  31365f74
000164  00      
000165  00                DCB      0
000166  00                DCB      0
000167  00                DCB      0
                  |L20.360|
000168  70627566          DCB      "pbuf_realloc: q != NULL",0
00016c  5f726561
000170  6c6c6f63
000174  3a207120
000178  213d204e
00017c  554c4c00
                  |L20.384|
000180  6d656d5f          DCB      "mem_trim returned q == NULL",0
000184  7472696d
000188  20726574
00018c  75726e65
000190  64207120
000194  3d3d204e
000198  554c4c00

                          AREA ||i.pbuf_ref||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  pbuf_ref PROC
;;;819    void
;;;820    pbuf_ref(struct pbuf *p)
000000  2800              CMP      r0,#0
;;;821    {
000002  d00c              BEQ      |L21.30|
;;;822      /* pbuf given? */
;;;823      if (p != NULL) {
;;;824        SYS_ARCH_INC(p->ref, 1);
000004  89c1              LDRH     r1,[r0,#0xe]
000006  1c49              ADDS     r1,r1,#1
000008  b289              UXTH     r1,r1
00000a  81c1              STRH     r1,[r0,#0xe]
;;;825        LWIP_ASSERT("pbuf ref overflow", p->ref > 0);
00000c  2900              CMP      r1,#0
00000e  d106              BNE      |L21.30|
000010  a303              ADR      r3,|L21.32|
000012  f2403239          MOV      r2,#0x339
000016  a10e              ADR      r1,|L21.80|
000018  a012              ADR      r0,|L21.100|
00001a  f7ffbffe          B.W      __2printf
                  |L21.30|
;;;826      }
;;;827    }
00001e  4770              BX       lr
;;;828    
                          ENDP

                  |L21.32|
000020  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
000024  6964646c
000028  65776172
00002c  65735c54
000030  68697264
000034  5f506172
000038  74795c4c
00003c  7749505c
000040  7372635c
000044  636f7265
000048  5c706275
00004c  662e6300
                  |L21.80|
000050  70627566          DCB      "pbuf ref overflow",0
000054  20726566
000058  206f7665
00005c  72666c6f
000060  7700    
000062  00                DCB      0
000063  00                DCB      0
                  |L21.100|
000064  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000068  7274696f
00006c  6e202225
000070  73222066
000074  61696c65
000078  64206174
00007c  206c696e
000080  65202564
000084  20696e20
000088  25730a00

                          AREA ||i.pbuf_skip||, CODE, READONLY, ALIGN=1

                  pbuf_skip PROC
;;;1130   struct pbuf*
;;;1131   pbuf_skip(struct pbuf* in, u16_t in_offset, u16_t* out_offset)
000000  f7ffbffe          B.W      pbuf_skip_const
;;;1132   {
;;;1133     const struct pbuf* out = pbuf_skip_const(in, in_offset, out_offset);
;;;1134     return LWIP_CONST_CAST(struct pbuf*, out);
;;;1135   }
;;;1136   
                          ENDP


                          AREA ||i.pbuf_skip_const||, CODE, READONLY, ALIGN=1

                  pbuf_skip_const PROC
;;;1104   static const struct pbuf*
;;;1105   pbuf_skip_const(const struct pbuf* in, u16_t in_offset, u16_t* out_offset)
000000  e002              B        |L23.8|
                  |L23.2|
;;;1106   {
;;;1107     u16_t offset_left = in_offset;
;;;1108     const struct pbuf* q = in;
;;;1109   
;;;1110     /* get the correct pbuf */
;;;1111     while ((q != NULL) && (q->len <= offset_left)) {
;;;1112       offset_left -= q->len;
000002  1ac9              SUBS     r1,r1,r3
000004  b289              UXTH     r1,r1
;;;1113       q = q->next;
000006  6800              LDR      r0,[r0,#0]
                  |L23.8|
000008  b110              CBZ      r0,|L23.16|
00000a  8943              LDRH     r3,[r0,#0xa]          ;1111
00000c  428b              CMP      r3,r1                 ;1111
00000e  d9f8              BLS      |L23.2|
                  |L23.16|
;;;1114     }
;;;1115     if (out_offset != NULL) {
000010  2a00              CMP      r2,#0
000012  d000              BEQ      |L23.22|
;;;1116       *out_offset = offset_left;
000014  8011              STRH     r1,[r2,#0]
                  |L23.22|
;;;1117     }
;;;1118     return q;
;;;1119   }
000016  4770              BX       lr
;;;1120   
                          ENDP


                          AREA ||i.pbuf_strstr||, CODE, READONLY, ALIGN=1

                  pbuf_strstr PROC
;;;1430   u16_t
;;;1431   pbuf_strstr(const struct pbuf* p, const char* substr)
000000  b570              PUSH     {r4-r6,lr}
;;;1432   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;1433     size_t substr_len;
;;;1434     if ((substr == NULL) || (substr[0] == 0) || (p->tot_len == 0xFFFF)) {
000006  f64f75ff          MOV      r5,#0xffff
00000a  2c00              CMP      r4,#0
00000c  d004              BEQ      |L24.24|
00000e  7820              LDRB     r0,[r4,#0]
000010  b110              CBZ      r0,|L24.24|
000012  8930              LDRH     r0,[r6,#8]
000014  42a8              CMP      r0,r5
000016  d101              BNE      |L24.28|
                  |L24.24|
;;;1435       return 0xFFFF;
000018  4628              MOV      r0,r5
;;;1436     }
;;;1437     substr_len = strlen(substr);
;;;1438     if (substr_len >= 0xFFFF) {
;;;1439       return 0xFFFF;
;;;1440     }
;;;1441     return pbuf_memfind(p, substr, (u16_t)substr_len, 0);
;;;1442   }
00001a  bd70              POP      {r4-r6,pc}
                  |L24.28|
00001c  4620              MOV      r0,r4                 ;1437
00001e  f7fffffe          BL       strlen
000022  42a8              CMP      r0,r5                 ;1438
000024  d301              BCC      |L24.42|
000026  4628              MOV      r0,r5                 ;1439
000028  bd70              POP      {r4-r6,pc}
                  |L24.42|
00002a  b282              UXTH     r2,r0                 ;1441
00002c  4621              MOV      r1,r4                 ;1441
00002e  4630              MOV      r0,r6                 ;1441
000030  e8bd4070          POP      {r4-r6,lr}            ;1441
000034  2300              MOVS     r3,#0                 ;1441
000036  f7ffbffe          B.W      pbuf_memfind
                          ENDP


                          AREA ||i.pbuf_take||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  pbuf_take PROC
;;;1148   err_t
;;;1149   pbuf_take(struct pbuf *buf, const void *dataptr, u16_t len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1150   {
000004  4689              MOV      r9,r1
000006  4690              MOV      r8,r2
;;;1151     struct pbuf *p;
;;;1152     u16_t buf_copy_len;
;;;1153     u16_t total_copy_len = len;
000008  4646              MOV      r6,r8
;;;1154     u16_t copied_total = 0;
00000a  2700              MOVS     r7,#0
;;;1155   
;;;1156     LWIP_ERROR("pbuf_take: invalid buf", (buf != NULL), return ERR_ARG;);
00000c  f06f040f          MVN      r4,#0xf
000010  2800              CMP      r0,#0
000012  d00f              BEQ      |L25.52|
;;;1157     LWIP_ERROR("pbuf_take: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
000014  f1b90f00          CMP      r9,#0
000018  d015              BEQ      |L25.70|
;;;1158     LWIP_ERROR("pbuf_take: buf not large enough", (buf->tot_len >= len), return ERR_MEM;);
00001a  8901              LDRH     r1,[r0,#8]
00001c  4541              CMP      r1,r8
00001e  d21b              BCS      |L25.88|
000020  a321              ADR      r3,|L25.168|
000022  f2404286          MOV      r2,#0x486
000026  a12c              ADR      r1,|L25.216|
000028  a033              ADR      r0,|L25.248|
00002a  f7fffffe          BL       __2printf
00002e  1120              ASRS     r0,r4,#4
                  |L25.48|
;;;1159   
;;;1160     if ((buf == NULL) || (dataptr == NULL) || (buf->tot_len < len)) {
;;;1161       return ERR_ARG;
;;;1162     }
;;;1163   
;;;1164     /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
;;;1165     for (p = buf; total_copy_len != 0; p = p->next) {
;;;1166       LWIP_ASSERT("pbuf_take: invalid pbuf", p != NULL);
;;;1167       buf_copy_len = total_copy_len;
;;;1168       if (buf_copy_len > p->len) {
;;;1169         /* this pbuf cannot hold all remaining data */
;;;1170         buf_copy_len = p->len;
;;;1171       }
;;;1172       /* copy the necessary parts of the buffer */
;;;1173       MEMCPY(p->payload, &((const char*)dataptr)[copied_total], buf_copy_len);
;;;1174       total_copy_len -= buf_copy_len;
;;;1175       copied_total += buf_copy_len;
;;;1176     }
;;;1177     LWIP_ASSERT("did not copy all data", total_copy_len == 0 && copied_total == len);
;;;1178     return ERR_OK;
;;;1179   }
000030  e8bd87f0          POP      {r4-r10,pc}
                  |L25.52|
000034  a31c              ADR      r3,|L25.168|
000036  f2404284          MOV      r2,#0x484             ;1156
00003a  a139              ADR      r1,|L25.288|
00003c  a02e              ADR      r0,|L25.248|
00003e  f7fffffe          BL       __2printf
000042  4620              MOV      r0,r4                 ;1156
000044  e7f4              B        |L25.48|
                  |L25.70|
000046  a318              ADR      r3,|L25.168|
000048  f2404285          MOV      r2,#0x485             ;1157
00004c  a13a              ADR      r1,|L25.312|
00004e  a02a              ADR      r0,|L25.248|
000050  f7fffffe          BL       __2printf
000054  4620              MOV      r0,r4                 ;1157
000056  e7eb              B        |L25.48|
                  |L25.88|
000058  4604              MOV      r4,r0                 ;1165
00005a  e017              B        |L25.140|
                  |L25.92|
00005c  b934              CBNZ     r4,|L25.108|
00005e  a312              ADR      r3,|L25.168|
000060  f240428e          MOV      r2,#0x48e             ;1166
000064  a13b              ADR      r1,|L25.340|
000066  a024              ADR      r0,|L25.248|
000068  f7fffffe          BL       __2printf
                  |L25.108|
00006c  4635              MOV      r5,r6                 ;1167
00006e  8960              LDRH     r0,[r4,#0xa]          ;1168
000070  42a8              CMP      r0,r5                 ;1168
000072  d200              BCS      |L25.118|
000074  4605              MOV      r5,r0                 ;1170
                  |L25.118|
000076  eb090107          ADD      r1,r9,r7              ;1173
00007a  462a              MOV      r2,r5                 ;1173
00007c  6860              LDR      r0,[r4,#4]            ;1173
00007e  f7fffffe          BL       __aeabi_memcpy
000082  1b70              SUBS     r0,r6,r5              ;1174
000084  b286              UXTH     r6,r0                 ;1174
000086  1978              ADDS     r0,r7,r5              ;1175
000088  b287              UXTH     r7,r0                 ;1175
00008a  6824              LDR      r4,[r4,#0]            ;1165
                  |L25.140|
00008c  2e00              CMP      r6,#0                 ;1165
00008e  d1e5              BNE      |L25.92|
000090  4547              CMP      r7,r8                 ;1177
000092  d006              BEQ      |L25.162|
000094  a304              ADR      r3,|L25.168|
000096  f2404299          MOV      r2,#0x499             ;1177
00009a  a134              ADR      r1,|L25.364|
00009c  a016              ADR      r0,|L25.248|
00009e  f7fffffe          BL       __2printf
                  |L25.162|
0000a2  2000              MOVS     r0,#0                 ;1178
0000a4  e7c4              B        |L25.48|
;;;1180   
                          ENDP

0000a6  0000              DCW      0x0000
                  |L25.168|
0000a8  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c",0
0000ac  6964646c
0000b0  65776172
0000b4  65735c54
0000b8  68697264
0000bc  5f506172
0000c0  74795c4c
0000c4  7749505c
0000c8  7372635c
0000cc  636f7265
0000d0  5c706275
0000d4  662e6300
                  |L25.216|
0000d8  70627566          DCB      "pbuf_take: buf not large enough",0
0000dc  5f74616b
0000e0  653a2062
0000e4  7566206e
0000e8  6f74206c
0000ec  61726765
0000f0  20656e6f
0000f4  75676800
                  |L25.248|
0000f8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000fc  7274696f
000100  6e202225
000104  73222066
000108  61696c65
00010c  64206174
000110  206c696e
000114  65202564
000118  20696e20
00011c  25730a00
                  |L25.288|
000120  70627566          DCB      "pbuf_take: invalid buf",0
000124  5f74616b
000128  653a2069
00012c  6e76616c
000130  69642062
000134  756600  
000137  00                DCB      0
                  |L25.312|
000138  70627566          DCB      "pbuf_take: invalid dataptr",0
00013c  5f74616b
000140  653a2069
000144  6e76616c
000148  69642064
00014c  61746170
000150  747200  
000153  00                DCB      0
                  |L25.340|
000154  70627566          DCB      "pbuf_take: invalid pbuf",0
000158  5f74616b
00015c  653a2069
000160  6e76616c
000164  69642070
000168  62756600
                  |L25.364|
00016c  64696420          DCB      "did not copy all data",0
000170  6e6f7420
000174  636f7079
000178  20616c6c
00017c  20646174
000180  6100    
000182  00                DCB      0
000183  00                DCB      0

                          AREA ||i.pbuf_take_at||, CODE, READONLY, ALIGN=1

                  pbuf_take_at PROC
;;;1192   err_t
;;;1193   pbuf_take_at(struct pbuf *buf, const void *dataptr, u16_t len, u16_t offset)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1194   {
000002  460e              MOV      r6,r1
000004  4615              MOV      r5,r2
000006  4619              MOV      r1,r3
;;;1195     u16_t target_offset;
;;;1196     struct pbuf* q = pbuf_skip(buf, offset, &target_offset);
000008  466a              MOV      r2,sp
00000a  f7fffffe          BL       pbuf_skip
00000e  4604              MOV      r4,r0
;;;1197   
;;;1198     /* return requested data if pbuf is OK */
;;;1199     if ((q != NULL) && (q->tot_len >= target_offset + len)) {
000010  0020              MOVS     r0,r4
000012  d01c              BEQ      |L26.78|
000014  f8bd0000          LDRH     r0,[sp,#0]
000018  8921              LDRH     r1,[r4,#8]
00001a  1942              ADDS     r2,r0,r5
00001c  4291              CMP      r1,r2
00001e  d316              BCC      |L26.78|
;;;1200       u16_t remaining_len = len;
000020  462f              MOV      r7,r5
;;;1201       const u8_t* src_ptr = (const u8_t*)dataptr;
;;;1202       /* copy the part that goes into the first pbuf */
;;;1203       u16_t first_copy_len = LWIP_MIN(q->len - target_offset, len);
000022  8961              LDRH     r1,[r4,#0xa]
000024  1a09              SUBS     r1,r1,r0
000026  42a9              CMP      r1,r5
000028  da00              BGE      |L26.44|
00002a  460d              MOV      r5,r1
                  |L26.44|
00002c  b2ad              UXTH     r5,r5
;;;1204       MEMCPY(((u8_t*)q->payload) + target_offset, dataptr, first_copy_len);
00002e  6861              LDR      r1,[r4,#4]
000030  462a              MOV      r2,r5
000032  4408              ADD      r0,r0,r1
000034  4631              MOV      r1,r6
000036  f7fffffe          BL       __aeabi_memcpy
;;;1205       remaining_len -= first_copy_len;
00003a  1b78              SUBS     r0,r7,r5
00003c  b282              UXTH     r2,r0
;;;1206       src_ptr += first_copy_len;
00003e  1971              ADDS     r1,r6,r5
;;;1207       if (remaining_len > 0) {
000040  b11a              CBZ      r2,|L26.74|
;;;1208         return pbuf_take(q->next, src_ptr, remaining_len);
000042  6820              LDR      r0,[r4,#0]
000044  f7fffffe          BL       pbuf_take
;;;1209       }
;;;1210       return ERR_OK;
;;;1211     }
;;;1212     return ERR_MEM;
;;;1213   }
000048  bdf8              POP      {r3-r7,pc}
                  |L26.74|
00004a  2000              MOVS     r0,#0                 ;1210
00004c  bdf8              POP      {r3-r7,pc}
                  |L26.78|
00004e  f04f30ff          MOV      r0,#0xffffffff        ;1212
000052  bdf8              POP      {r3-r7,pc}
;;;1214   
                          ENDP


                          AREA ||i.pbuf_try_get_at||, CODE, READONLY, ALIGN=1

                  pbuf_try_get_at PROC
;;;1316   int
;;;1317   pbuf_try_get_at(const struct pbuf* p, u16_t offset)
000000  b508              PUSH     {r3,lr}
;;;1318   {
;;;1319     u16_t q_idx;
;;;1320     const struct pbuf* q = pbuf_skip_const(p, offset, &q_idx);
000002  466a              MOV      r2,sp
000004  f7fffffe          BL       pbuf_skip_const
;;;1321   
;;;1322     /* return requested data if pbuf is OK */
;;;1323     if ((q != NULL) && (q->len > q_idx)) {
000008  b138              CBZ      r0,|L27.26|
00000a  8942              LDRH     r2,[r0,#0xa]
00000c  f8bd1000          LDRH     r1,[sp,#0]
000010  428a              CMP      r2,r1
000012  d902              BLS      |L27.26|
;;;1324       return ((u8_t*)q->payload)[q_idx];
000014  6840              LDR      r0,[r0,#4]
000016  5c40              LDRB     r0,[r0,r1]
;;;1325     }
;;;1326     return -1;
;;;1327   }
000018  bd08              POP      {r3,pc}
                  |L27.26|
00001a  f04f30ff          MOV      r0,#0xffffffff        ;1326
00001e  bd08              POP      {r3,pc}
;;;1328   
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  pbuf_free_ooseq_pending
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\pbuf.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_pbuf_c_98275a01____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_pbuf_c_98275a01____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_pbuf_c_98275a01____REVSH|
#line 478
|__asm___6_pbuf_c_98275a01____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_pbuf_c_98275a01____RRX|
#line 665
|__asm___6_pbuf_c_98275a01____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
