; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ethernetif.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ethernetif.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\ethernetif.crf ..\Src\ethernetif.c]
                          THUMB

                          AREA ||i.HAL_ETH_MspDeInit||, CODE, READONLY, ALIGN=2

                  HAL_ETH_MspDeInit PROC
;;;150    
;;;151    void HAL_ETH_MspDeInit(ETH_HandleTypeDef* ethHandle)
000000  b510              PUSH     {r4,lr}
;;;152    {
;;;153      if(ethHandle->Instance==ETH)
000002  6800              LDR      r0,[r0,#0]
000004  4911              LDR      r1,|L1.76|
000006  4288              CMP      r0,r1
000008  d11e              BNE      |L1.72|
;;;154      {
;;;155      /* USER CODE BEGIN ETH_MspDeInit 0 */
;;;156    
;;;157      /* USER CODE END ETH_MspDeInit 0 */
;;;158        /* Disable Peripheral clock */
;;;159        __HAL_RCC_ETH_CLK_DISABLE();
00000a  4811              LDR      r0,|L1.80|
00000c  6941              LDR      r1,[r0,#0x14]
00000e  f4214100          BIC      r1,r1,#0x8000
000012  6141              STR      r1,[r0,#0x14]
000014  6941              LDR      r1,[r0,#0x14]
000016  f4213180          BIC      r1,r1,#0x10000
00001a  6141              STR      r1,[r0,#0x14]
00001c  6941              LDR      r1,[r0,#0x14]
00001e  f4214180          BIC      r1,r1,#0x4000
000022  6141              STR      r1,[r0,#0x14]
;;;160    
;;;161        /**ETH GPIO Configuration
;;;162        PC1     ------> ETH_MDC
;;;163        PA1     ------> ETH_REF_CLK
;;;164        PA2     ------> ETH_MDIO
;;;165        PA7     ------> ETH_CRS_DV
;;;166        PC4     ------> ETH_RXD0
;;;167        PC5     ------> ETH_RXD1
;;;168        PB11     ------> ETH_TX_EN
;;;169        PB12     ------> ETH_TXD0
;;;170        PB13     ------> ETH_TXD1
;;;171        */
;;;172        HAL_GPIO_DeInit(GPIOC, GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5);
000024  2132              MOVS     r1,#0x32
000026  480b              LDR      r0,|L1.84|
000028  f7fffffe          BL       HAL_GPIO_DeInit
;;;173    
;;;174        HAL_GPIO_DeInit(GPIOA, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_7);
00002c  218e              MOVS     r1,#0x8e
00002e  480a              LDR      r0,|L1.88|
000030  f7fffffe          BL       HAL_GPIO_DeInit
;;;175    
;;;176        HAL_GPIO_DeInit(GPIOB, GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13);
000034  f44f5160          MOV      r1,#0x3800
000038  4808              LDR      r0,|L1.92|
00003a  f7fffffe          BL       HAL_GPIO_DeInit
;;;177    
;;;178        /* Peripheral interrupt Deinit*/
;;;179        HAL_NVIC_DisableIRQ(ETH_IRQn);
00003e  e8bd4010          POP      {r4,lr}
000042  203d              MOVS     r0,#0x3d
000044  f7ffbffe          B.W      HAL_NVIC_DisableIRQ
                  |L1.72|
;;;180    
;;;181      /* USER CODE BEGIN ETH_MspDeInit 1 */
;;;182    
;;;183      /* USER CODE END ETH_MspDeInit 1 */
;;;184      }
;;;185    }
000048  bd10              POP      {r4,pc}
;;;186    
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
                          DCD      0x40028000
                  |L1.80|
                          DCD      0x40021000
                  |L1.84|
                          DCD      0x40011000
                  |L1.88|
                          DCD      0x40010800
                  |L1.92|
                          DCD      0x40010c00

                          AREA ||i.HAL_ETH_MspInit||, CODE, READONLY, ALIGN=2

                  HAL_ETH_MspInit PROC
;;;80     
;;;81     void HAL_ETH_MspInit(ETH_HandleTypeDef* ethHandle)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;82     {
000004  b086              SUB      sp,sp,#0x18
;;;83       GPIO_InitTypeDef GPIO_InitStruct = {0};
000006  2400              MOVS     r4,#0
000008  9402              STR      r4,[sp,#8]
00000a  9403              STR      r4,[sp,#0xc]
00000c  9404              STR      r4,[sp,#0x10]
00000e  9405              STR      r4,[sp,#0x14]
;;;84     
;;;85       if(ethHandle->Instance==ETH)
000010  6800              LDR      r0,[r0,#0]
000012  4941              LDR      r1,|L2.280|
000014  4288              CMP      r0,r1
000016  d17b              BNE      |L2.272|
;;;86       {
;;;87       /* USER CODE BEGIN ETH_MspInit 0 */
;;;88     
;;;89       /* USER CODE END ETH_MspInit 0 */
;;;90         /* Enable Peripheral clock */
;;;91         __HAL_RCC_ETH_CLK_ENABLE();
000018  4840              LDR      r0,|L2.284|
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f4414180          ORR      r1,r1,#0x4000
000020  6141              STR      r1,[r0,#0x14]
000022  6941              LDR      r1,[r0,#0x14]
000024  f4014180          AND      r1,r1,#0x4000
000028  9101              STR      r1,[sp,#4]
00002a  6941              LDR      r1,[r0,#0x14]
00002c  f4414100          ORR      r1,r1,#0x8000
000030  6141              STR      r1,[r0,#0x14]
000032  6941              LDR      r1,[r0,#0x14]
000034  f4014100          AND      r1,r1,#0x8000
000038  9101              STR      r1,[sp,#4]
00003a  6941              LDR      r1,[r0,#0x14]
00003c  f4413180          ORR      r1,r1,#0x10000
000040  6141              STR      r1,[r0,#0x14]
000042  6941              LDR      r1,[r0,#0x14]
000044  f4013180          AND      r1,r1,#0x10000
000048  9101              STR      r1,[sp,#4]
;;;92     
;;;93         __HAL_RCC_GPIOC_CLK_ENABLE();
00004a  6981              LDR      r1,[r0,#0x18]
00004c  f0410110          ORR      r1,r1,#0x10
000050  6181              STR      r1,[r0,#0x18]
000052  6981              LDR      r1,[r0,#0x18]
000054  f0010110          AND      r1,r1,#0x10
000058  9101              STR      r1,[sp,#4]
;;;94         __HAL_RCC_GPIOA_CLK_ENABLE();
00005a  6981              LDR      r1,[r0,#0x18]
00005c  f0410104          ORR      r1,r1,#4
000060  6181              STR      r1,[r0,#0x18]
000062  6981              LDR      r1,[r0,#0x18]
000064  f0010104          AND      r1,r1,#4
000068  9101              STR      r1,[sp,#4]
;;;95         __HAL_RCC_GPIOB_CLK_ENABLE();
00006a  6981              LDR      r1,[r0,#0x18]
00006c  f0410108          ORR      r1,r1,#8
000070  6181              STR      r1,[r0,#0x18]
000072  6980              LDR      r0,[r0,#0x18]
000074  f0000008          AND      r0,r0,#8
000078  9001              STR      r0,[sp,#4]
;;;96         /**ETH GPIO Configuration
;;;97         PC1     ------> ETH_MDC
;;;98         PA1     ------> ETH_REF_CLK
;;;99         PA2     ------> ETH_MDIO
;;;100        PA7     ------> ETH_CRS_DV
;;;101        PC4     ------> ETH_RXD0
;;;102        PC5     ------> ETH_RXD1
;;;103        PB11     ------> ETH_TX_EN
;;;104        PB12     ------> ETH_TXD0
;;;105        PB13     ------> ETH_TXD1
;;;106        */
;;;107        GPIO_InitStruct.Pin = GPIO_PIN_1;
00007a  2502              MOVS     r5,#2
00007c  9502              STR      r5,[sp,#8]
;;;108        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
00007e  9503              STR      r5,[sp,#0xc]
;;;109        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
000080  2603              MOVS     r6,#3
000082  9605              STR      r6,[sp,#0x14]
;;;110        HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
000084  4f26              LDR      r7,|L2.288|
000086  a902              ADD      r1,sp,#8
000088  4638              MOV      r0,r7
00008a  f7fffffe          BL       HAL_GPIO_Init
;;;111    
;;;112        GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_7;
00008e  2082              MOVS     r0,#0x82
000090  9002              STR      r0,[sp,#8]
;;;113        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
000092  9403              STR      r4,[sp,#0xc]
;;;114        GPIO_InitStruct.Pull = GPIO_NOPULL;
000094  9404              STR      r4,[sp,#0x10]
;;;115        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
000096  f8df808c          LDR      r8,|L2.292|
00009a  a902              ADD      r1,sp,#8
00009c  4640              MOV      r0,r8
00009e  f7fffffe          BL       HAL_GPIO_Init
;;;116    
;;;117        GPIO_InitStruct.Pin = GPIO_PIN_2;
0000a2  2004              MOVS     r0,#4
0000a4  9002              STR      r0,[sp,#8]
;;;118        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
0000a6  9503              STR      r5,[sp,#0xc]
;;;119        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
0000a8  9605              STR      r6,[sp,#0x14]
;;;120        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
0000aa  a902              ADD      r1,sp,#8
0000ac  4640              MOV      r0,r8
0000ae  f7fffffe          BL       HAL_GPIO_Init
;;;121    
;;;122        GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5;
0000b2  2030              MOVS     r0,#0x30
0000b4  9002              STR      r0,[sp,#8]
;;;123        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
0000b6  9403              STR      r4,[sp,#0xc]
;;;124        GPIO_InitStruct.Pull = GPIO_NOPULL;
0000b8  9404              STR      r4,[sp,#0x10]
;;;125        HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
0000ba  a902              ADD      r1,sp,#8
0000bc  4638              MOV      r0,r7
0000be  f7fffffe          BL       HAL_GPIO_Init
;;;126    
;;;127        GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13;
0000c2  f44f5060          MOV      r0,#0x3800
0000c6  9002              STR      r0,[sp,#8]
;;;128        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
0000c8  9503              STR      r5,[sp,#0xc]
;;;129        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
0000ca  9605              STR      r6,[sp,#0x14]
;;;130        HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
0000cc  a902              ADD      r1,sp,#8
0000ce  4816              LDR      r0,|L2.296|
0000d0  f7fffffe          BL       HAL_GPIO_Init
;;;131    
;;;132        /* USER CODE BEGIN ETH_MspInit 1 */
;;;133    
;;;134        GPIO_InitStruct.Pin = GPIO_PIN_3;
0000d4  2008              MOVS     r0,#8
0000d6  9002              STR      r0,[sp,#8]
;;;135        GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
0000d8  2001              MOVS     r0,#1
0000da  9003              STR      r0,[sp,#0xc]
;;;136        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
0000dc  9605              STR      r6,[sp,#0x14]
;;;137        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
0000de  a902              ADD      r1,sp,#8
0000e0  4640              MOV      r0,r8
0000e2  f7fffffe          BL       HAL_GPIO_Init
;;;138    
;;;139        /* Peripheral interrupt init */
;;;140        HAL_NVIC_SetPriority(ETH_IRQn, 0, 0);
0000e6  2200              MOVS     r2,#0
0000e8  4611              MOV      r1,r2
0000ea  203d              MOVS     r0,#0x3d
0000ec  f7fffffe          BL       HAL_NVIC_SetPriority
;;;141        HAL_NVIC_EnableIRQ(ETH_IRQn);
0000f0  203d              MOVS     r0,#0x3d
0000f2  f7fffffe          BL       HAL_NVIC_EnableIRQ
;;;142    
;;;143        HAL_GPIO_WritePin(GPIOA,GPIO_PIN_3,GPIO_PIN_RESET);
0000f6  2200              MOVS     r2,#0
0000f8  2108              MOVS     r1,#8
0000fa  4640              MOV      r0,r8
0000fc  f7fffffe          BL       HAL_GPIO_WritePin
;;;144        HAL_Delay(60);
000100  203c              MOVS     r0,#0x3c
000102  f7fffffe          BL       HAL_Delay
;;;145        HAL_GPIO_WritePin(GPIOA,GPIO_PIN_3,GPIO_PIN_SET);
000106  2201              MOVS     r2,#1
000108  2108              MOVS     r1,#8
00010a  4640              MOV      r0,r8
00010c  f7fffffe          BL       HAL_GPIO_WritePin
                  |L2.272|
;;;146    
;;;147      /* USER CODE END ETH_MspInit 1 */
;;;148      }
;;;149    }
000110  b006              ADD      sp,sp,#0x18
000112  e8bd81f0          POP      {r4-r8,pc}
;;;150    
                          ENDP

000116  0000              DCW      0x0000
                  |L2.280|
                          DCD      0x40028000
                  |L2.284|
                          DCD      0x40021000
                  |L2.288|
                          DCD      0x40011000
                  |L2.292|
                          DCD      0x40010800
                  |L2.296|
                          DCD      0x40010c00

                          AREA ||i.ethernetif_init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  ethernetif_init PROC
;;;524     */
;;;525    err_t ethernetif_init(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;526    {
000002  4604              MOV      r4,r0
;;;527      LWIP_ASSERT("netif != NULL", (netif != NULL));
000004  2c00              CMP      r4,#0
000006  d106              BNE      |L3.22|
000008  a30a              ADR      r3,|L3.52|
00000a  f240220f          MOV      r2,#0x20f
00000e  a10e              ADR      r1,|L3.72|
000010  a011              ADR      r0,|L3.88|
000012  f7fffffe          BL       __2printf
                  |L3.22|
;;;528    
;;;529    #if LWIP_NETIF_HOSTNAME
;;;530      /* Initialize interface hostname */
;;;531      netif->hostname = "lwip";
;;;532    #endif /* LWIP_NETIF_HOSTNAME */
;;;533    
;;;534      netif->name[0] = IFNAME0;
000016  2073              MOVS     r0,#0x73
000018  f8840038          STRB     r0,[r4,#0x38]
;;;535      netif->name[1] = IFNAME1;
00001c  2074              MOVS     r0,#0x74
00001e  f8840039          STRB     r0,[r4,#0x39]
;;;536      /* We directly use etharp_output() here to save a function call.
;;;537       * You can instead declare your own function an call etharp_output()
;;;538       * from it if you have to do some checks before sending (e.g. if link
;;;539       * is available...) */
;;;540    
;;;541    #if LWIP_IPV4
;;;542    #if LWIP_ARP || LWIP_ETHERNET
;;;543    #if LWIP_ARP
;;;544      netif->output = etharp_output;
000022  4817              LDR      r0,|L3.128|
000024  6160              STR      r0,[r4,#0x14]
;;;545    #else
;;;546      /* The user should write ist own code in low_level_output_arp_off function */
;;;547      netif->output = low_level_output_arp_off;
;;;548    #endif /* LWIP_ARP */
;;;549    #endif /* LWIP_ARP || LWIP_ETHERNET */
;;;550    #endif /* LWIP_IPV4 */
;;;551    
;;;552    #if LWIP_IPV6
;;;553      netif->output_ip6 = ethip6_output;
;;;554    #endif /* LWIP_IPV6 */
;;;555    
;;;556      netif->linkoutput = low_level_output;
000026  4817              LDR      r0,|L3.132|
000028  61a0              STR      r0,[r4,#0x18]
;;;557    
;;;558      /* initialize the hardware */
;;;559      low_level_init(netif);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       low_level_init
;;;560    
;;;561      return ERR_OK;
000030  2000              MOVS     r0,#0
;;;562    }
000032  bd10              POP      {r4,pc}
;;;563    
                          ENDP

                  |L3.52|
000034  2e2e5c53          DCB      "..\\Src\\ethernetif.c",0
000038  72635c65
00003c  74686572
000040  6e657469
000044  662e6300
                  |L3.72|
000048  6e657469          DCB      "netif != NULL",0
00004c  6620213d
000050  204e554c
000054  4c00    
000056  00                DCB      0
000057  00                DCB      0
                  |L3.88|
000058  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00005c  7274696f
000060  6e202225
000064  73222066
000068  61696c65
00006c  64206174
000070  206c696e
000074  65202564
000078  20696e20
00007c  25730a00
                  |L3.128|
                          DCD      etharp_output
                  |L3.132|
                          DCD      low_level_output

                          AREA ||i.ethernetif_input||, CODE, READONLY, ALIGN=1

                  ethernetif_input PROC
;;;469     */
;;;470    void ethernetif_input(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;471    {
000002  4605              MOV      r5,r0
;;;472      err_t err;
;;;473      struct pbuf *p;
;;;474    
;;;475      /* move received packet into a new pbuf */
;;;476      p = low_level_input(netif);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       low_level_input
00000a  4604              MOV      r4,r0
;;;477    
;;;478      /* no packet could be read, silently ignore this */
;;;479      if (p == NULL) return;
00000c  2c00              CMP      r4,#0
00000e  d00a              BEQ      |L4.38|
;;;480    
;;;481      /* entry point to the LwIP stack */
;;;482      err = netif->input(p, netif);
000010  692a              LDR      r2,[r5,#0x10]
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  4790              BLX      r2
;;;483    
;;;484      if (err != ERR_OK)
000018  2800              CMP      r0,#0
00001a  d004              BEQ      |L4.38|
;;;485      {
;;;486        LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
;;;487        pbuf_free(p);
00001c  4620              MOV      r0,r4
00001e  e8bd4070          POP      {r4-r6,lr}
000022  f7ffbffe          B.W      pbuf_free
                  |L4.38|
;;;488        p = NULL;
;;;489      }
;;;490    }
000026  bd70              POP      {r4-r6,pc}
;;;491    
                          ENDP


                          AREA ||i.ethernetif_notify_conn_changed||, CODE, READONLY, ALIGN=1

                  ethernetif_notify_conn_changed PROC
;;;724      */
;;;725    __weak void ethernetif_notify_conn_changed(struct netif *netif)
000000  4770              BX       lr
;;;726    {
;;;727      /* NOTE : This is function could be implemented in user file
;;;728                when the callback is needed,
;;;729      */
;;;730    
;;;731    }
;;;732    /* USER CODE END 8 */
                          ENDP


                          AREA ||i.ethernetif_set_link||, CODE, READONLY, ALIGN=2

                  ethernetif_set_link PROC
;;;598    
;;;599    void ethernetif_set_link(struct netif *netif)
000000  b538              PUSH     {r3-r5,lr}
;;;600    {
000002  4605              MOV      r5,r0
;;;601      uint32_t regvalue = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;602      /* Ethernet Link every 200ms */
;;;603      if (HAL_GetTick() - EthernetLinkTimer >= 200)
000008  f7fffffe          BL       HAL_GetTick
00000c  4c10              LDR      r4,|L6.80|
00000e  6821              LDR      r1,[r4,#0]  ; EthernetLinkTimer
000010  1a40              SUBS     r0,r0,r1
000012  28c8              CMP      r0,#0xc8
000014  d313              BCC      |L6.62|
;;;604      {
;;;605        EthernetLinkTimer = HAL_GetTick();
000016  f7fffffe          BL       HAL_GetTick
00001a  6020              STR      r0,[r4,#0]  ; EthernetLinkTimer
;;;606    
;;;607        /* Read PHY_BSR*/
;;;608        HAL_ETH_ReadPHYRegister(&heth, PHY_BSR, &regvalue);
00001c  466a              MOV      r2,sp
00001e  2101              MOVS     r1,#1
000020  480c              LDR      r0,|L6.84|
000022  f7fffffe          BL       HAL_ETH_ReadPHYRegister
;;;609    
;;;610        regvalue &= PHY_LINKED_STATUS;
000026  9800              LDR      r0,[sp,#0]
000028  f0000004          AND      r0,r0,#4
00002c  9000              STR      r0,[sp,#0]
;;;611    
;;;612        /* Check whether the netif link down and the PHY link is up */
;;;613        if(!netif_is_link_up(netif) && (regvalue))
00002e  f8951037          LDRB     r1,[r5,#0x37]
000032  074a              LSLS     r2,r1,#29
000034  d404              BMI      |L6.64|
000036  b118              CBZ      r0,|L6.64|
;;;614        {
;;;615          /* network cable is connected */
;;;616          netif_set_link_up(netif);
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       netif_set_link_up
                  |L6.62|
;;;617        }
;;;618        else if(netif_is_link_up(netif) && (!regvalue))
;;;619        {
;;;620          /* network cable is disconnected */
;;;621          netif_set_link_down(netif);
;;;622        }
;;;623      }
;;;624    }
00003e  bd38              POP      {r3-r5,pc}
                  |L6.64|
000040  0749              LSLS     r1,r1,#29             ;618
000042  d5fc              BPL      |L6.62|
000044  2800              CMP      r0,#0                 ;618
000046  d1fa              BNE      |L6.62|
000048  4628              MOV      r0,r5                 ;621
00004a  f7fffffe          BL       netif_set_link_down
00004e  bd38              POP      {r3-r5,pc}
;;;625    
                          ENDP

                  |L6.80|
                          DCD      ||.data||
                  |L6.84|
                          DCD      ||.bss||+0x4830

                          AREA ||i.ethernetif_update_config||, CODE, READONLY, ALIGN=2

                  ethernetif_update_config PROC
;;;636      */
;;;637    void ethernetif_update_config(struct netif *netif)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;638    {
000004  4607              MOV      r7,r0
;;;639      __IO uint32_t tickstart = 0;
000006  2500              MOVS     r5,#0
000008  9501              STR      r5,[sp,#4]
;;;640      uint32_t regvalue = 0;
00000a  9500              STR      r5,[sp,#0]
;;;641    
;;;642      if(netif_is_link_up(netif))
00000c  f8970037          LDRB     r0,[r7,#0x37]
000010  0740              LSLS     r0,r0,#29
000012  d543              BPL      |L7.156|
;;;643      {
;;;644        /* Restart the auto-negotiation */
;;;645        if(heth.Init.AutoNegotiation != ETH_AUTONEGOTIATION_DISABLE)
000014  4c25              LDR      r4,|L7.172|
000016  6860              LDR      r0,[r4,#4]  ; heth
000018  b368              CBZ      r0,|L7.118|
;;;646        {
;;;647          /* Enable Auto-Negotiation */
;;;648          HAL_ETH_WritePHYRegister(&heth, PHY_BCR, PHY_AUTONEGOTIATION);
00001a  f44f5280          MOV      r2,#0x1000
00001e  2100              MOVS     r1,#0
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       HAL_ETH_WritePHYRegister
;;;649    
;;;650          /* Get tick */
;;;651          tickstart = HAL_GetTick();
000026  f7fffffe          BL       HAL_GetTick
00002a  9001              STR      r0,[sp,#4]
;;;652    
;;;653          /* Wait until the auto-negotiation will be completed */
;;;654          do
;;;655          {
;;;656            HAL_ETH_ReadPHYRegister(&heth, PHY_BSR, &regvalue);
;;;657    
;;;658            /* Check for the Timeout ( 1s ) */
;;;659            if((HAL_GetTick() - tickstart ) > 1000)
00002c  f44f767a          MOV      r6,#0x3e8
                  |L7.48|
000030  466a              MOV      r2,sp                 ;656
000032  2101              MOVS     r1,#1                 ;656
000034  481d              LDR      r0,|L7.172|
000036  f7fffffe          BL       HAL_ETH_ReadPHYRegister
00003a  f7fffffe          BL       HAL_GetTick
00003e  9901              LDR      r1,[sp,#4]
000040  1a40              SUBS     r0,r0,r1
000042  42b0              CMP      r0,r6
000044  d817              BHI      |L7.118|
;;;660            {
;;;661              /* In case of timeout */
;;;662              goto error;
;;;663            }
;;;664          } while (((regvalue & PHY_AUTONEGO_COMPLETE) != PHY_AUTONEGO_COMPLETE));
000046  9800              LDR      r0,[sp,#0]
000048  0680              LSLS     r0,r0,#26
00004a  d5f1              BPL      |L7.48|
;;;665    
;;;666          /* Read the result of the auto-negotiation */
;;;667          HAL_ETH_ReadPHYRegister(&heth, PHY_SR, &regvalue);
00004c  466a              MOV      r2,sp
00004e  2131              MOVS     r1,#0x31
000050  4816              LDR      r0,|L7.172|
000052  f7fffffe          BL       HAL_ETH_ReadPHYRegister
;;;668    
;;;669          /* Configure the MAC with the Duplex Mode fixed by the auto-negotiation process */
;;;670          if((regvalue & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
000056  9800              LDR      r0,[sp,#0]
000058  06c1              LSLS     r1,r0,#27
00005a  d503              BPL      |L7.100|
;;;671          {
;;;672            /* Set Ethernet duplex mode to Full-duplex following the auto-negotiation */
;;;673            heth.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
00005c  f44f6100          MOV      r1,#0x800
000060  60e1              STR      r1,[r4,#0xc]  ; heth
000062  e000              B        |L7.102|
                  |L7.100|
;;;674          }
;;;675          else
;;;676          {
;;;677            /* Set Ethernet duplex mode to Half-duplex following the auto-negotiation */
;;;678            heth.Init.DuplexMode = ETH_MODE_HALFDUPLEX;
000064  60e5              STR      r5,[r4,#0xc]  ; heth
                  |L7.102|
;;;679          }
;;;680          /* Configure the MAC with the speed fixed by the auto-negotiation process */
;;;681          if(regvalue & PHY_SPEED_STATUS)
000066  0740              LSLS     r0,r0,#29
000068  d501              BPL      |L7.110|
;;;682          {
;;;683            /* Set Ethernet speed to 10M following the auto-negotiation */
;;;684            heth.Init.Speed = ETH_SPEED_10M;
00006a  60a5              STR      r5,[r4,#8]  ; heth
00006c  e00e              B        |L7.140|
                  |L7.110|
;;;685          }
;;;686          else
;;;687          {
;;;688            /* Set Ethernet speed to 100M following the auto-negotiation */
;;;689            heth.Init.Speed = ETH_SPEED_100M;
00006e  f44f4080          MOV      r0,#0x4000
000072  60a0              STR      r0,[r4,#8]  ; heth
000074  e00a              B        |L7.140|
                  |L7.118|
;;;690          }
;;;691        }
;;;692        else /* AutoNegotiation Disable */
;;;693        {
;;;694        error :
;;;695          /* Check parameters */
;;;696          assert_param(IS_ETH_SPEED(heth.Init.Speed));
;;;697          assert_param(IS_ETH_DUPLEX_MODE(heth.Init.DuplexMode));
;;;698    
;;;699          /* Set MAC Speed and Duplex Mode to PHY */
;;;700          HAL_ETH_WritePHYRegister(&heth, PHY_BCR, ((uint16_t)(heth.Init.DuplexMode >> 3) |
000076  68e0              LDR      r0,[r4,#0xc]  ; heth
000078  2100              MOVS     r1,#0
00007a  f3c002cf          UBFX     r2,r0,#3,#16
00007e  68a0              LDR      r0,[r4,#8]  ; heth
000080  f3c0004f          UBFX     r0,r0,#1,#16
000084  4302              ORRS     r2,r2,r0
000086  4809              LDR      r0,|L7.172|
000088  f7fffffe          BL       HAL_ETH_WritePHYRegister
                  |L7.140|
;;;701                                                         (uint16_t)(heth.Init.Speed >> 1)));
;;;702        }
;;;703    
;;;704        /* ETHERNET MAC Re-Configuration */
;;;705        HAL_ETH_ConfigMAC(&heth, (ETH_MACInitTypeDef *) NULL);
00008c  2100              MOVS     r1,#0
00008e  4807              LDR      r0,|L7.172|
000090  f7fffffe          BL       HAL_ETH_ConfigMAC
;;;706    
;;;707        /* Restart MAC interface */
;;;708        HAL_ETH_Start(&heth);
000094  4805              LDR      r0,|L7.172|
000096  f7fffffe          BL       HAL_ETH_Start
00009a  e002              B        |L7.162|
                  |L7.156|
;;;709      }
;;;710      else
;;;711      {
;;;712        /* Stop MAC interface */
;;;713        HAL_ETH_Stop(&heth);
00009c  4803              LDR      r0,|L7.172|
00009e  f7fffffe          BL       HAL_ETH_Stop
                  |L7.162|
;;;714      }
;;;715    
;;;716      ethernetif_notify_conn_changed(netif);
0000a2  4638              MOV      r0,r7
0000a4  f7fffffe          BL       ethernetif_notify_conn_changed
;;;717    }
0000a8  e8bd81fc          POP      {r2-r8,pc}
;;;718    
                          ENDP

                  |L7.172|
                          DCD      ||.bss||+0x4830

                          AREA ||i.low_level_init||, CODE, READONLY, ALIGN=2

                  low_level_init PROC
;;;200     */
;;;201    static void low_level_init(struct netif *netif)
000000  b57c              PUSH     {r2-r6,lr}
;;;202    {
000002  4604              MOV      r4,r0
;;;203      HAL_StatusTypeDef hal_eth_init_status;
;;;204    
;;;205    /* Init ETH */
;;;206    
;;;207       uint8_t MACAddr[6] ;
;;;208      heth.Instance = ETH;
000004  4d2a              LDR      r5,|L8.176|
000006  4829              LDR      r0,|L8.172|
000008  6028              STR      r0,[r5,#0]  ; heth
;;;209      heth.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
00000a  2001              MOVS     r0,#1
00000c  6068              STR      r0,[r5,#4]  ; heth
;;;210      heth.Init.PhyAddress = PHY_LAN8720A_PHY_ADDRESS;
00000e  2000              MOVS     r0,#0
000010  8228              STRH     r0,[r5,#0x10]
;;;211      MACAddr[0] = 0x00;
000012  f88d0000          STRB     r0,[sp,#0]
;;;212      MACAddr[1] = 0x80;
000016  2180              MOVS     r1,#0x80
000018  f88d1001          STRB     r1,[sp,#1]
;;;213      MACAddr[2] = 0xE1;
00001c  21e1              MOVS     r1,#0xe1
00001e  f88d1002          STRB     r1,[sp,#2]
;;;214      MACAddr[3] = 0x00;
000022  f88d0003          STRB     r0,[sp,#3]
;;;215      MACAddr[4] = 0x00;
000026  f88d0004          STRB     r0,[sp,#4]
;;;216      MACAddr[5] = 0x00;
00002a  f88d0005          STRB     r0,[sp,#5]
;;;217      heth.Init.MACAddr = &MACAddr[0];
00002e  f8c5d014          STR      sp,[r5,#0x14]  ; heth
;;;218      heth.Init.RxMode = ETH_RXPOLLING_MODE;
000032  61a8              STR      r0,[r5,#0x18]  ; heth
;;;219      heth.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
000034  61e8              STR      r0,[r5,#0x1c]  ; heth
;;;220      heth.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
000036  f44f0000          MOV      r0,#0x800000
00003a  6228              STR      r0,[r5,#0x20]  ; heth
;;;221    
;;;222      /* USER CODE BEGIN MACADDRESS */
;;;223    
;;;224      /* USER CODE END MACADDRESS */
;;;225    
;;;226      hal_eth_init_status = HAL_ETH_Init(&heth);
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       HAL_ETH_Init
;;;227    
;;;228      if (hal_eth_init_status == HAL_OK)
000042  b928              CBNZ     r0,|L8.80|
;;;229      {
;;;230        /* Set netif link flag */
;;;231        netif->flags |= NETIF_FLAG_LINK_UP;
000044  f8940037          LDRB     r0,[r4,#0x37]
000048  f0400004          ORR      r0,r0,#4
00004c  f8840037          STRB     r0,[r4,#0x37]
                  |L8.80|
;;;232      }
;;;233      /* Initialize Tx Descriptors list: Chain Mode */
;;;234      HAL_ETH_DMATxDescListInit(&heth, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
000050  2304              MOVS     r3,#4
000052  4a18              LDR      r2,|L8.180|
000054  4918              LDR      r1,|L8.184|
000056  4816              LDR      r0,|L8.176|
000058  f7fffffe          BL       HAL_ETH_DMATxDescListInit
;;;235    
;;;236      /* Initialize Rx Descriptors list: Chain Mode  */
;;;237      HAL_ETH_DMARxDescListInit(&heth, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
00005c  4a16              LDR      r2,|L8.184|
00005e  2308              MOVS     r3,#8
000060  3240              ADDS     r2,r2,#0x40
000062  f1a201c0          SUB      r1,r2,#0xc0
000066  4812              LDR      r0,|L8.176|
000068  f7fffffe          BL       HAL_ETH_DMARxDescListInit
;;;238    
;;;239    #if LWIP_ARP || LWIP_ETHERNET
;;;240    
;;;241      /* set MAC hardware address length */
;;;242      netif->hwaddr_len = ETH_HWADDR_LEN;
00006c  2006              MOVS     r0,#6
00006e  342e              ADDS     r4,r4,#0x2e
000070  70a0              STRB     r0,[r4,#2]
;;;243    
;;;244      /* set MAC hardware address */
;;;245      netif->hwaddr[0] =  heth.Init.MACAddr[0];
000072  6968              LDR      r0,[r5,#0x14]  ; heth
000074  7800              LDRB     r0,[r0,#0]
000076  70e0              STRB     r0,[r4,#3]
;;;246      netif->hwaddr[1] =  heth.Init.MACAddr[1];
000078  6968              LDR      r0,[r5,#0x14]  ; heth
00007a  7840              LDRB     r0,[r0,#1]
00007c  7120              STRB     r0,[r4,#4]
;;;247      netif->hwaddr[2] =  heth.Init.MACAddr[2];
00007e  6968              LDR      r0,[r5,#0x14]  ; heth
000080  7880              LDRB     r0,[r0,#2]
000082  7160              STRB     r0,[r4,#5]
;;;248      netif->hwaddr[3] =  heth.Init.MACAddr[3];
000084  6968              LDR      r0,[r5,#0x14]  ; heth
000086  78c0              LDRB     r0,[r0,#3]
000088  71a0              STRB     r0,[r4,#6]
;;;249      netif->hwaddr[4] =  heth.Init.MACAddr[4];
00008a  6968              LDR      r0,[r5,#0x14]  ; heth
00008c  7900              LDRB     r0,[r0,#4]
00008e  71e0              STRB     r0,[r4,#7]
;;;250      netif->hwaddr[5] =  heth.Init.MACAddr[5];
000090  6968              LDR      r0,[r5,#0x14]  ; heth
000092  7940              LDRB     r0,[r0,#5]
000094  7220              STRB     r0,[r4,#8]
;;;251    
;;;252      /* maximum transfer unit */
;;;253      netif->mtu = 1500;
000096  f24050dc          MOV      r0,#0x5dc
00009a  8020              STRH     r0,[r4,#0]
;;;254    
;;;255      /* Accept broadcast address and ARP traffic */
;;;256      /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
;;;257      #if LWIP_ARP
;;;258        netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
00009c  7a60              LDRB     r0,[r4,#9]
00009e  f040000a          ORR      r0,r0,#0xa
0000a2  7260              STRB     r0,[r4,#9]
;;;259      #else
;;;260        netif->flags |= NETIF_FLAG_BROADCAST;
;;;261      #endif /* LWIP_ARP */
;;;262    
;;;263      /* Enable MAC and DMA transmission and reception */
;;;264      HAL_ETH_Start(&heth);
0000a4  4802              LDR      r0,|L8.176|
0000a6  f7fffffe          BL       HAL_ETH_Start
;;;265    
;;;266    /* USER CODE BEGIN PHY_PRE_CONFIG */
;;;267    
;;;268    /* USER CODE END PHY_PRE_CONFIG */
;;;269    
;;;270    /* USER CODE BEGIN PHY_POST_CONFIG */
;;;271    
;;;272    /* USER CODE END PHY_POST_CONFIG */
;;;273    
;;;274    #endif /* LWIP_ARP || LWIP_ETHERNET */
;;;275    
;;;276    /* USER CODE BEGIN LOW_LEVEL_INIT */
;;;277    
;;;278    /* USER CODE END LOW_LEVEL_INIT */
;;;279    }
0000aa  bd7c              POP      {r2-r6,pc}
;;;280    
                          ENDP

                  |L8.172|
                          DCD      0x40028000
                  |L8.176|
                          DCD      ||.bss||+0x4830
                  |L8.180|
                          DCD      ||.bss||+0x3060
                  |L8.184|
                          DCD      ||.bss||+0x80

                          AREA ||i.low_level_input||, CODE, READONLY, ALIGN=2

                  low_level_input PROC
;;;380       */
;;;381    static struct pbuf * low_level_input(struct netif *netif)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;382    {
;;;383      struct pbuf *p = NULL;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;384      struct pbuf *q = NULL;
;;;385      uint16_t len = 0;
;;;386      uint8_t *buffer;
;;;387      __IO ETH_DMADescTypeDef *dmarxdesc;
;;;388      uint32_t bufferoffset = 0;
000008  2400              MOVS     r4,#0
;;;389      uint32_t payloadoffset = 0;
;;;390      uint32_t byteslefttocopy = 0;
;;;391      uint32_t i=0;
;;;392    
;;;393      /* get received frame */
;;;394      if (HAL_ETH_GetReceivedFrame(&heth) != HAL_OK)
00000a  482d              LDR      r0,|L9.192|
00000c  f7fffffe          BL       HAL_ETH_GetReceivedFrame
000010  b110              CBZ      r0,|L9.24|
;;;395    
;;;396        return NULL;
000012  2000              MOVS     r0,#0
                  |L9.20|
;;;397    
;;;398      /* Obtain the size of the packet and put it into the "len" variable. */
;;;399      len = heth.RxFrameInfos.length;
;;;400      buffer = (uint8_t *)heth.RxFrameInfos.buffer;
;;;401    
;;;402      if (len > 0)
;;;403      {
;;;404        /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
;;;405        p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
;;;406      }
;;;407    
;;;408      if (p != NULL)
;;;409      {
;;;410        dmarxdesc = heth.RxFrameInfos.FSRxDesc;
;;;411        bufferoffset = 0;
;;;412        for(q = p; q != NULL; q = q->next)
;;;413        {
;;;414          byteslefttocopy = q->len;
;;;415          payloadoffset = 0;
;;;416    
;;;417          /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size*/
;;;418          while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
;;;419          {
;;;420            /* Copy data to pbuf */
;;;421            memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
;;;422    
;;;423            /* Point to next descriptor */
;;;424            dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
;;;425            buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
;;;426    
;;;427            byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
;;;428            payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
;;;429            bufferoffset = 0;
;;;430          }
;;;431          /* Copy remaining data in pbuf */
;;;432          memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
;;;433          bufferoffset = bufferoffset + byteslefttocopy;
;;;434        }
;;;435      }
;;;436    
;;;437        /* Release descriptors to DMA */
;;;438        /* Point to first descriptor */
;;;439        dmarxdesc = heth.RxFrameInfos.FSRxDesc;
;;;440        /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
;;;441        for (i=0; i< heth.RxFrameInfos.SegCount; i++)
;;;442        {
;;;443          dmarxdesc->Status |= ETH_DMARXDESC_OWN;
;;;444          dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
;;;445        }
;;;446    
;;;447        /* Clear Segment_Count */
;;;448        heth.RxFrameInfos.SegCount =0;
;;;449    
;;;450      /* When Rx Buffer unavailable flag is set: clear it and resume reception */
;;;451      if ((heth.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)
;;;452      {
;;;453        /* Clear RBUS ETHERNET DMA flag */
;;;454        heth.Instance->DMASR = ETH_DMASR_RBUS;
;;;455        /* Resume DMA reception */
;;;456        heth.Instance->DMARPDR = 0;
;;;457      }
;;;458      return p;
;;;459    }
000014  e8bd8ff8          POP      {r3-r11,pc}
                  |L9.24|
000018  4829              LDR      r0,|L9.192|
00001a  8f81              LDRH     r1,[r0,#0x3c]         ;399  ; heth
00001c  b289              UXTH     r1,r1                 ;399
00001e  f8d09040          LDR      r9,[r0,#0x40]         ;400  ; heth
000022  b121              CBZ      r1,|L9.46|
000024  2203              MOVS     r2,#3                 ;405
000026  2004              MOVS     r0,#4                 ;405
000028  f7fffffe          BL       pbuf_alloc
00002c  9000              STR      r0,[sp,#0]            ;405
                  |L9.46|
00002e  9800              LDR      r0,[sp,#0]            ;408
000030  b358              CBZ      r0,|L9.138|
000032  4823              LDR      r0,|L9.192|
000034  f8d08030          LDR      r8,[r0,#0x30]         ;410  ; heth
000038  9d00              LDR      r5,[sp,#0]            ;412
00003a  e024              B        |L9.134|
                  |L9.60|
00003c  896f              LDRH     r7,[r5,#0xa]          ;414
00003e  2600              MOVS     r6,#0                 ;415
000040  f2405bf4          MOV      r11,#0x5f4            ;418
000044  e012              B        |L9.108|
                  |L9.70|
000046  6868              LDR      r0,[r5,#4]            ;421
000048  f2a452f4          SUB      r2,r4,#0x5f4          ;421
00004c  eb090104          ADD      r1,r9,r4              ;421
000050  4430              ADD      r0,r0,r6              ;421
000052  4252              RSBS     r2,r2,#0              ;421
000054  f7fffffe          BL       __aeabi_memcpy
000058  f8d8800c          LDR      r8,[r8,#0xc]          ;424
00005c  f8d89008          LDR      r9,[r8,#8]            ;425
000060  f2aa57f4          SUB      r7,r10,#0x5f4         ;427
000064  1b36              SUBS     r6,r6,r4              ;428
000066  f20656f4          ADD      r6,r6,#0x5f4          ;428
00006a  2400              MOVS     r4,#0                 ;429
                  |L9.108|
00006c  eb070a04          ADD      r10,r7,r4             ;418
000070  45da              CMP      r10,r11               ;418
000072  d8e8              BHI      |L9.70|
000074  6868              LDR      r0,[r5,#4]            ;432
000076  eb090104          ADD      r1,r9,r4              ;432
00007a  4430              ADD      r0,r0,r6              ;432
00007c  463a              MOV      r2,r7                 ;432
00007e  f7fffffe          BL       __aeabi_memcpy
000082  443c              ADD      r4,r4,r7              ;433
000084  682d              LDR      r5,[r5,#0]            ;412
                  |L9.134|
000086  2d00              CMP      r5,#0                 ;412
000088  d1d8              BNE      |L9.60|
                  |L9.138|
00008a  4a0d              LDR      r2,|L9.192|
00008c  6b10              LDR      r0,[r2,#0x30]         ;439  ; heth
00008e  2100              MOVS     r1,#0                 ;441
000090  e005              B        |L9.158|
                  |L9.146|
000092  6803              LDR      r3,[r0,#0]            ;443
000094  f0434300          ORR      r3,r3,#0x80000000     ;443
000098  6003              STR      r3,[r0,#0]            ;443
00009a  68c0              LDR      r0,[r0,#0xc]          ;444
00009c  1c49              ADDS     r1,r1,#1              ;441
                  |L9.158|
00009e  6b93              LDR      r3,[r2,#0x38]         ;441  ; heth
0000a0  428b              CMP      r3,r1                 ;441
0000a2  d8f6              BHI      |L9.146|
0000a4  2100              MOVS     r1,#0                 ;448
0000a6  6391              STR      r1,[r2,#0x38]         ;448  ; heth
0000a8  6810              LDR      r0,[r2,#0]            ;451  ; heth
0000aa  f5005080          ADD      r0,r0,#0x1000         ;451
0000ae  6942              LDR      r2,[r0,#0x14]         ;451
0000b0  0612              LSLS     r2,r2,#24             ;451
0000b2  d502              BPL      |L9.186|
0000b4  2280              MOVS     r2,#0x80              ;454
0000b6  6142              STR      r2,[r0,#0x14]         ;454
0000b8  6081              STR      r1,[r0,#8]            ;456
                  |L9.186|
0000ba  9800              LDR      r0,[sp,#0]            ;458
0000bc  e7aa              B        |L9.20|
;;;460    
                          ENDP

0000be  0000              DCW      0x0000
                  |L9.192|
                          DCD      ||.bss||+0x4830

                          AREA ||i.low_level_output||, CODE, READONLY, ALIGN=2

                  low_level_output PROC
;;;296    
;;;297    static err_t low_level_output(struct netif *netif, struct pbuf *p)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;298    {
000004  460e              MOV      r6,r1
;;;299      err_t errval;
;;;300      struct pbuf *q;
;;;301      uint8_t *buffer = (uint8_t *)(heth.TxDesc->Buffer1Addr);
000006  4829              LDR      r0,|L10.172|
000008  6ac5              LDR      r5,[r0,#0x2c]  ; heth
00000a  f8d5a008          LDR      r10,[r5,#8]
;;;302      __IO ETH_DMADescTypeDef *DmaTxDesc;
;;;303      uint32_t framelength = 0;
00000e  f04f0900          MOV      r9,#0
;;;304      uint32_t bufferoffset = 0;
000012  2400              MOVS     r4,#0
000014  e035              B        |L10.130|
                  |L10.22|
;;;305      uint32_t byteslefttocopy = 0;
;;;306      uint32_t payloadoffset = 0;
;;;307      DmaTxDesc = heth.TxDesc;
;;;308      bufferoffset = 0;
;;;309    
;;;310      /* copy frame from pbufs to driver buffers */
;;;311      for(q = p; q != NULL; q = q->next)
;;;312        {
;;;313          /* Is this buffer available? If not, goto error */
;;;314          if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
000016  6828              LDR      r0,[r5,#0]
000018  2800              CMP      r0,#0
00001a  da02              BGE      |L10.34|
;;;315          {
;;;316            errval = ERR_USE;
00001c  f06f0007          MVN      r0,#7
;;;317            goto error;
000020  e036              B        |L10.144|
                  |L10.34|
;;;318          }
;;;319    
;;;320          /* Get bytes in current lwIP buffer */
;;;321          byteslefttocopy = q->len;
000022  f8b6800a          LDRH     r8,[r6,#0xa]
;;;322          payloadoffset = 0;
000026  2700              MOVS     r7,#0
;;;323    
;;;324          /* Check if the length of data to copy is bigger than Tx buffer size*/
;;;325          while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
000028  e01b              B        |L10.98|
                  |L10.42|
;;;326          {
;;;327            /* Copy data to Tx buffer*/
;;;328            memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
00002a  6870              LDR      r0,[r6,#4]
00002c  f2a452f4          SUB      r2,r4,#0x5f4
000030  19c1              ADDS     r1,r0,r7
000032  eb0a0004          ADD      r0,r10,r4
000036  4252              RSBS     r2,r2,#0
000038  f7fffffe          BL       __aeabi_memcpy
;;;329    
;;;330            /* Point to next descriptor */
;;;331            DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
00003c  68ed              LDR      r5,[r5,#0xc]
;;;332    
;;;333            /* Check if the buffer is available */
;;;334            if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
00003e  6828              LDR      r0,[r5,#0]
000040  2800              CMP      r0,#0
000042  da02              BGE      |L10.74|
;;;335            {
;;;336              errval = ERR_USE;
000044  f06f0007          MVN      r0,#7
;;;337              goto error;
000048  e022              B        |L10.144|
                  |L10.74|
;;;338            }
;;;339    
;;;340            buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
00004a  f8d5a008          LDR      r10,[r5,#8]
;;;341    
;;;342            byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
00004e  f2ab58f4          SUB      r8,r11,#0x5f4
;;;343            payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
000052  1b3f              SUBS     r7,r7,r4
000054  f20757f4          ADD      r7,r7,#0x5f4
;;;344            framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
000058  eba90904          SUB      r9,r9,r4
00005c  f20959f4          ADD      r9,r9,#0x5f4
;;;345            bufferoffset = 0;
000060  2400              MOVS     r4,#0
                  |L10.98|
000062  eb080b04          ADD      r11,r8,r4             ;325
000066  f24050f4          MOV      r0,#0x5f4             ;325
00006a  4583              CMP      r11,r0                ;325
00006c  d8dd              BHI      |L10.42|
;;;346          }
;;;347    
;;;348          /* Copy the remaining bytes */
;;;349          memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
00006e  6870              LDR      r0,[r6,#4]
000070  4642              MOV      r2,r8
000072  19c1              ADDS     r1,r0,r7
000074  eb0a0004          ADD      r0,r10,r4
000078  f7fffffe          BL       __aeabi_memcpy
;;;350          bufferoffset = bufferoffset + byteslefttocopy;
00007c  4444              ADD      r4,r4,r8
;;;351          framelength = framelength + byteslefttocopy;
00007e  44c1              ADD      r9,r9,r8
000080  6836              LDR      r6,[r6,#0]            ;311
                  |L10.130|
000082  2e00              CMP      r6,#0                 ;311
000084  d1c7              BNE      |L10.22|
;;;352        }
;;;353    
;;;354      /* Prepare transmit descriptors to give to DMA */
;;;355      HAL_ETH_TransmitFrame(&heth, framelength);
000086  4649              MOV      r1,r9
000088  4808              LDR      r0,|L10.172|
00008a  f7fffffe          BL       HAL_ETH_TransmitFrame
;;;356    
;;;357      errval = ERR_OK;
00008e  2000              MOVS     r0,#0
                  |L10.144|
;;;358    
;;;359    error:
;;;360    
;;;361      /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
;;;362      if ((heth.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
000090  4906              LDR      r1,|L10.172|
000092  6809              LDR      r1,[r1,#0]  ; heth
000094  f5015180          ADD      r1,r1,#0x1000
000098  694a              LDR      r2,[r1,#0x14]
00009a  0692              LSLS     r2,r2,#26
00009c  d503              BPL      |L10.166|
;;;363      {
;;;364        /* Clear TUS ETHERNET DMA flag */
;;;365        heth.Instance->DMASR = ETH_DMASR_TUS;
00009e  2220              MOVS     r2,#0x20
0000a0  614a              STR      r2,[r1,#0x14]
;;;366    
;;;367        /* Resume DMA transmission*/
;;;368        heth.Instance->DMATPDR = 0;
0000a2  2200              MOVS     r2,#0
0000a4  604a              STR      r2,[r1,#4]
                  |L10.166|
;;;369      }
;;;370      return errval;
;;;371    }
0000a6  e8bd9ff0          POP      {r4-r12,pc}
;;;372    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L10.172|
                          DCD      ||.bss||+0x4830

                          AREA ||i.sys_jiffies||, CODE, READONLY, ALIGN=1

                  sys_jiffies PROC
;;;571    */
;;;572    u32_t sys_jiffies(void)
000000  f7ffbffe          B.W      HAL_GetTick
;;;573    {
;;;574      return HAL_GetTick();
;;;575    }
;;;576    
                          ENDP


                          AREA ||i.sys_now||, CODE, READONLY, ALIGN=1

                  sys_now PROC
;;;582    */
;;;583    u32_t sys_now(void)
000000  f7ffbffe          B.W      HAL_GetTick
;;;584    {
;;;585      return HAL_GetTick();
;;;586    }
;;;587    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  DMARxDscrTab
                          %        128
                  DMATxDscrTab
                          %        64
                  Rx_Buff
                          %        12192
                  Tx_Buff
                          %        6096
                  heth
                          %        72

                          AREA ||.data||, DATA, ALIGN=2

                  EthernetLinkTimer
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Src\\ethernetif.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_ethernetif_c_8fd98312____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_ethernetif_c_8fd98312____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_ethernetif_c_8fd98312____REVSH|
#line 478
|__asm___12_ethernetif_c_8fd98312____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_ethernetif_c_8fd98312____RRX|
#line 665
|__asm___12_ethernetif_c_8fd98312____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
