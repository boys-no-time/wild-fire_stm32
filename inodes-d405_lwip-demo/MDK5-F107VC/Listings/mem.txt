; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\mem.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mem.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\system\arch -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Inc -I..\Middlewares\Third_Party\LwIP\src\include -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\mem.crf ..\Middlewares\Third_Party\LwIP\src\core\mem.c]
                          THUMB

                          AREA ||i.mem_calloc||, CODE, READONLY, ALIGN=1

                  mem_calloc PROC
;;;764    void *
;;;765    mem_calloc(mem_size_t count, mem_size_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;766    {
;;;767      void *p;
;;;768    
;;;769      /* allocate 'count' objects of size 'size' */
;;;770      p = mem_malloc(count * size);
000002  4348              MULS     r0,r1,r0
000004  4605              MOV      r5,r0
000006  b280              UXTH     r0,r0
000008  f7fffffe          BL       mem_malloc
00000c  4604              MOV      r4,r0
;;;771      if (p) {
00000e  b11c              CBZ      r4,|L1.24|
;;;772        /* zero the memory */
;;;773        memset(p, 0, (size_t)count * (size_t)size);
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       __aeabi_memclr
                  |L1.24|
;;;774      }
;;;775      return p;
000018  4620              MOV      r0,r4
;;;776    }
00001a  bd70              POP      {r4-r6,pc}
;;;777    #endif /* MEM_LIBC_MALLOC && (!LWIP_STATS || !MEM_STATS) */
                          ENDP


                          AREA ||i.mem_free||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  mem_free PROC
;;;418    void
;;;419    mem_free(void *rmem)
000000  b570              PUSH     {r4-r6,lr}
;;;420    {
000002  4604              MOV      r4,r0
;;;421      struct mem *mem;
;;;422      LWIP_MEM_FREE_DECL_PROTECT();
;;;423    
;;;424      if (rmem == NULL) {
000004  2c00              CMP      r4,#0
000006  d031              BEQ      |L2.108|
;;;425        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("mem_free(p == NULL) was called.\n"));
;;;426        return;
;;;427      }
;;;428      LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
000008  07a0              LSLS     r0,r4,#30
00000a  d006              BEQ      |L2.26|
00000c  a318              ADR      r3,|L2.112|
00000e  f44f72d6          MOV      r2,#0x1ac
000012  a123              ADR      r1,|L2.160|
000014  a02b              ADR      r0,|L2.196|
000016  f7fffffe          BL       __2printf
                  |L2.26|
;;;429    
;;;430      LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
00001a  4d34              LDR      r5,|L2.236|
00001c  6828              LDR      r0,[r5,#0]  ; ram
00001e  4284              CMP      r4,r0
000020  d302              BCC      |L2.40|
000022  6868              LDR      r0,[r5,#4]  ; ram_end
000024  4284              CMP      r4,r0
000026  d306              BCC      |L2.54|
                  |L2.40|
000028  a311              ADR      r3,|L2.112|
00002a  f44f72d7          MOV      r2,#0x1ae
00002e  a130              ADR      r1,|L2.240|
000030  a024              ADR      r0,|L2.196|
000032  f7fffffe          BL       __2printf
                  |L2.54|
;;;431        (u8_t *)rmem < (u8_t *)ram_end);
;;;432    
;;;433      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
000036  6828              LDR      r0,[r5,#0]  ; ram
000038  4284              CMP      r4,r0
00003a  d317              BCC      |L2.108|
00003c  6868              LDR      r0,[r5,#4]  ; ram_end
00003e  4284              CMP      r4,r0
000040  d214              BCS      |L2.108|
;;;434        SYS_ARCH_DECL_PROTECT(lev);
;;;435        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_free: illegal memory\n"));
;;;436        /* protect mem stats from concurrent access */
;;;437        SYS_ARCH_PROTECT(lev);
;;;438        MEM_STATS_INC(illegal);
;;;439        SYS_ARCH_UNPROTECT(lev);
;;;440        return;
;;;441      }
;;;442      /* protect the heap from concurrent access */
;;;443      LWIP_MEM_FREE_PROTECT();
;;;444      /* Get the corresponding struct mem ... */
;;;445      /* cast through void* to get rid of alignment warnings */
;;;446      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
000042  3c08              SUBS     r4,r4,#8
;;;447      /* ... which has to be in a used state ... */
;;;448      LWIP_ASSERT("mem_free: mem->used", mem->used);
000044  7920              LDRB     r0,[r4,#4]
000046  b930              CBNZ     r0,|L2.86|
000048  a309              ADR      r3,|L2.112|
00004a  f44f72e0          MOV      r2,#0x1c0
00004e  a12e              ADR      r1,|L2.264|
000050  a01c              ADR      r0,|L2.196|
000052  f7fffffe          BL       __2printf
                  |L2.86|
;;;449      /* ... and is now unused. */
;;;450      mem->used = 0;
000056  2000              MOVS     r0,#0
000058  7120              STRB     r0,[r4,#4]
;;;451    
;;;452      if (mem < lfree) {
00005a  68a8              LDR      r0,[r5,#8]  ; lfree
00005c  4284              CMP      r4,r0
00005e  d200              BCS      |L2.98|
;;;453        /* the newly freed struct is now the lowest */
;;;454        lfree = mem;
000060  60ac              STR      r4,[r5,#8]  ; lfree
                  |L2.98|
;;;455      }
;;;456    
;;;457      MEM_STATS_DEC_USED(used, mem->next - (mem_size_t)(((u8_t *)mem - ram)));
;;;458    
;;;459      /* finally, see if prev or next are free also */
;;;460      plug_holes(mem);
000062  4620              MOV      r0,r4
000064  e8bd4070          POP      {r4-r6,lr}
000068  f7ffbffe          B.W      plug_holes
                  |L2.108|
;;;461    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;462      mem_free_count = 1;
;;;463    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;464      LWIP_MEM_FREE_UNPROTECT();
;;;465    }
00006c  bd70              POP      {r4-r6,pc}
;;;466    
                          ENDP

00006e  0000              DCW      0x0000
                  |L2.112|
000070  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\mem.c",0
000074  6964646c
000078  65776172
00007c  65735c54
000080  68697264
000084  5f506172
000088  74795c4c
00008c  7749505c
000090  7372635c
000094  636f7265
000098  5c6d656d
00009c  2e6300  
00009f  00                DCB      0
                  |L2.160|
0000a0  6d656d5f          DCB      "mem_free: sanity check alignment",0
0000a4  66726565
0000a8  3a207361
0000ac  6e697479
0000b0  20636865
0000b4  636b2061
0000b8  6c69676e
0000bc  6d656e74
0000c0  00      
0000c1  00                DCB      0
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L2.196|
0000c4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000c8  7274696f
0000cc  6e202225
0000d0  73222066
0000d4  61696c65
0000d8  64206174
0000dc  206c696e
0000e0  65202564
0000e4  20696e20
0000e8  25730a00
                  |L2.236|
                          DCD      ||.data||
                  |L2.240|
0000f0  6d656d5f          DCB      "mem_free: legal memory",0
0000f4  66726565
0000f8  3a206c65
0000fc  67616c20
000100  6d656d6f
000104  727900  
000107  00                DCB      0
                  |L2.264|
000108  6d656d5f          DCB      "mem_free: mem->used",0
00010c  66726565
000110  3a206d65
000114  6d2d3e75
000118  73656400

                          AREA ||i.mem_init||, CODE, READONLY, ALIGN=2

                  mem_init PROC
;;;381    void
;;;382    mem_init(void)
000000  b510              PUSH     {r4,lr}
;;;383    {
;;;384      struct mem *mem;
;;;385    
;;;386      LWIP_ASSERT("Sanity check alignment",
;;;387        (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);
;;;388    
;;;389      /* align the heap */
;;;390      ram = (u8_t *)LWIP_MEM_ALIGN(LWIP_RAM_HEAP_POINTER);
000002  480a              LDR      r0,|L3.44|
000004  4a0a              LDR      r2,|L3.48|
000006  f0200003          BIC      r0,r0,#3
00000a  6010              STR      r0,[r2,#0]  ; ram
;;;391      /* initialize the start of the heap */
;;;392      mem = (struct mem *)(void *)ram;
;;;393      mem->next = MEM_SIZE_ALIGNED;
00000c  f44f63c8          MOV      r3,#0x640
000010  8003              STRH     r3,[r0,#0]
;;;394      mem->prev = 0;
000012  2100              MOVS     r1,#0
000014  8041              STRH     r1,[r0,#2]
;;;395      mem->used = 0;
000016  7101              STRB     r1,[r0,#4]
;;;396      /* initialize the end of the heap */
;;;397      ram_end = (struct mem *)(void *)&ram[MEM_SIZE_ALIGNED];
000018  f50061c8          ADD      r1,r0,#0x640
00001c  6051              STR      r1,[r2,#4]  ; ram_end
;;;398      ram_end->used = 1;
00001e  2401              MOVS     r4,#1
000020  710c              STRB     r4,[r1,#4]
;;;399      ram_end->next = MEM_SIZE_ALIGNED;
000022  800b              STRH     r3,[r1,#0]
;;;400      ram_end->prev = MEM_SIZE_ALIGNED;
000024  804b              STRH     r3,[r1,#2]
;;;401    
;;;402      /* initialize the lowest-free pointer to the start of the heap */
;;;403      lfree = (struct mem *)(void *)ram;
000026  6090              STR      r0,[r2,#8]  ; lfree
;;;404    
;;;405      MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
;;;406    
;;;407      if (sys_mutex_new(&mem_mutex) != ERR_OK) {
;;;408        LWIP_ASSERT("failed to create mem_mutex", 0);
;;;409      }
;;;410    }
000028  bd10              POP      {r4,pc}
;;;411    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      ||.bss||+0x3
                  |L3.48|
                          DCD      ||.data||

                          AREA ||i.mem_malloc||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  mem_malloc PROC
;;;602    void *
;;;603    mem_malloc(mem_size_t size)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;604    {
;;;605      mem_size_t ptr, ptr2;
;;;606      struct mem *mem, *mem2;
;;;607    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;608      u8_t local_mem_free_count = 0;
;;;609    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;610      LWIP_MEM_ALLOC_DECL_PROTECT();
;;;611    
;;;612      if (size == 0) {
000004  2800              CMP      r0,#0
000006  d00e              BEQ      |L4.38|
;;;613        return NULL;
;;;614      }
;;;615    
;;;616      /* Expand the size of the allocated memory region so that we can
;;;617         adjust for alignment. */
;;;618      size = LWIP_MEM_ALIGN_SIZE(size);
000008  1cc0              ADDS     r0,r0,#3
00000a  f64f71fc          MOV      r1,#0xfffc
00000e  ea000501          AND      r5,r0,r1
;;;619    
;;;620      if (size < MIN_SIZE_ALIGNED) {
000012  2d0c              CMP      r5,#0xc
000014  d200              BCS      |L4.24|
;;;621        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;622        size = MIN_SIZE_ALIGNED;
000016  250c              MOVS     r5,#0xc
                  |L4.24|
;;;623      }
;;;624    
;;;625      if (size > MEM_SIZE_ALIGNED) {
000018  f44f6cc8          MOV      r12,#0x640
00001c  4565              CMP      r5,r12
00001e  d904              BLS      |L4.42|
;;;626        return NULL;
000020  2000              MOVS     r0,#0
                  |L4.34|
;;;627      }
;;;628    
;;;629      /* protect the heap from concurrent access */
;;;630      sys_mutex_lock(&mem_mutex);
;;;631      LWIP_MEM_ALLOC_PROTECT();
;;;632    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;633      /* run as long as a mem_free disturbed mem_malloc or mem_trim */
;;;634      do {
;;;635        local_mem_free_count = 0;
;;;636    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;637    
;;;638        /* Scan through the heap searching for a free block that is big enough,
;;;639         * beginning with the lowest free block.
;;;640         */
;;;641        for (ptr = (mem_size_t)((u8_t *)lfree - ram); ptr < MEM_SIZE_ALIGNED - size;
;;;642             ptr = ((struct mem *)(void *)&ram[ptr])->next) {
;;;643          mem = (struct mem *)(void *)&ram[ptr];
;;;644    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;645          mem_free_count = 0;
;;;646          LWIP_MEM_ALLOC_UNPROTECT();
;;;647          /* allow mem_free or mem_trim to run */
;;;648          LWIP_MEM_ALLOC_PROTECT();
;;;649          if (mem_free_count != 0) {
;;;650            /* If mem_free or mem_trim have run, we have to restart since they
;;;651               could have altered our current struct mem. */
;;;652            local_mem_free_count = 1;
;;;653            break;
;;;654          }
;;;655    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;656    
;;;657          if ((!mem->used) &&
;;;658              (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
;;;659            /* mem is not used and at least perfect fit is possible:
;;;660             * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
;;;661    
;;;662            if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
;;;663              /* (in addition to the above, we test if another struct mem (SIZEOF_STRUCT_MEM) containing
;;;664               * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
;;;665               * -> split large block, create empty remainder,
;;;666               * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
;;;667               * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
;;;668               * struct mem would fit in but no data between mem2 and mem2->next
;;;669               * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;670               *       region that couldn't hold data, but when mem->next gets freed,
;;;671               *       the 2 regions would be combined, resulting in more free memory
;;;672               */
;;;673              ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
;;;674              /* create mem2 struct */
;;;675              mem2 = (struct mem *)(void *)&ram[ptr2];
;;;676              mem2->used = 0;
;;;677              mem2->next = mem->next;
;;;678              mem2->prev = ptr;
;;;679              /* and insert it between mem and mem->next */
;;;680              mem->next = ptr2;
;;;681              mem->used = 1;
;;;682    
;;;683              if (mem2->next != MEM_SIZE_ALIGNED) {
;;;684                ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;685              }
;;;686              MEM_STATS_INC_USED(used, (size + SIZEOF_STRUCT_MEM));
;;;687            } else {
;;;688              /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
;;;689               * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
;;;690               * take care of this).
;;;691               * -> near fit or exact fit: do not split, no mem2 creation
;;;692               * also can't move mem->next directly behind mem, since mem->next
;;;693               * will always be used at this point!
;;;694               */
;;;695              mem->used = 1;
;;;696              MEM_STATS_INC_USED(used, mem->next - (mem_size_t)((u8_t *)mem - ram));
;;;697            }
;;;698    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;699    mem_malloc_adjust_lfree:
;;;700    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;701            if (mem == lfree) {
;;;702              struct mem *cur = lfree;
;;;703              /* Find next free block after mem and update lowest free pointer */
;;;704              while (cur->used && cur != ram_end) {
;;;705    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;706                mem_free_count = 0;
;;;707                LWIP_MEM_ALLOC_UNPROTECT();
;;;708                /* prevent high interrupt latency... */
;;;709                LWIP_MEM_ALLOC_PROTECT();
;;;710                if (mem_free_count != 0) {
;;;711                  /* If mem_free or mem_trim have run, we have to restart since they
;;;712                     could have altered our current struct mem or lfree. */
;;;713                  goto mem_malloc_adjust_lfree;
;;;714                }
;;;715    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;716                cur = (struct mem *)(void *)&ram[cur->next];
;;;717              }
;;;718              lfree = cur;
;;;719              LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
;;;720            }
;;;721            LWIP_MEM_ALLOC_UNPROTECT();
;;;722            sys_mutex_unlock(&mem_mutex);
;;;723            LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
;;;724             (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
;;;725            LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
;;;726             ((mem_ptr_t)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
;;;727            LWIP_ASSERT("mem_malloc: sanity check alignment",
;;;728              (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);
;;;729    
;;;730            return (u8_t *)mem + SIZEOF_STRUCT_MEM;
;;;731          }
;;;732        }
;;;733    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;734        /* if we got interrupted by a mem_free, try again */
;;;735      } while (local_mem_free_count != 0);
;;;736    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;737      LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
;;;738      MEM_STATS_INC(err);
;;;739      LWIP_MEM_ALLOC_UNPROTECT();
;;;740      sys_mutex_unlock(&mem_mutex);
;;;741      return NULL;
;;;742    }
000022  e8bd87f0          POP      {r4-r10,pc}
                  |L4.38|
000026  2000              MOVS     r0,#0                 ;613
000028  e7fb              B        |L4.34|
                  |L4.42|
00002a  4f37              LDR      r7,|L4.264|
00002c  683a              LDR      r2,[r7,#0]            ;641  ; ram
00002e  68b9              LDR      r1,[r7,#8]            ;641  ; lfree
000030  1a88              SUBS     r0,r1,r2              ;641
000032  b280              UXTH     r0,r0                 ;641
000034  f5c566c8          RSB      r6,r5,#0x640          ;641
000038  e062              B        |L4.256|
                  |L4.58|
00003a  1814              ADDS     r4,r2,r0              ;643
00003c  7923              LDRB     r3,[r4,#4]            ;657
00003e  2b00              CMP      r3,#0                 ;657
000040  d15d              BNE      |L4.254|
000042  8823              LDRH     r3,[r4,#0]            ;658
000044  1a1b              SUBS     r3,r3,r0              ;658
000046  3b08              SUBS     r3,r3,#8              ;658
000048  42ab              CMP      r3,r5                 ;658
00004a  d358              BCC      |L4.254|
00004c  8823              LDRH     r3,[r4,#0]            ;662
00004e  f1050614          ADD      r6,r5,#0x14           ;662
000052  1a1b              SUBS     r3,r3,r0              ;662
000054  3b08              SUBS     r3,r3,#8              ;662
000056  f04f0801          MOV      r8,#1                 ;681
00005a  42b3              CMP      r3,r6                 ;662
00005c  d315              BCC      |L4.138|
00005e  1943              ADDS     r3,r0,r5              ;673
000060  3308              ADDS     r3,r3,#8              ;673
000062  b29e              UXTH     r6,r3                 ;673
000064  1993              ADDS     r3,r2,r6              ;675
000066  f04f0900          MOV      r9,#0                 ;676
00006a  f8839004          STRB     r9,[r3,#4]            ;676
00006e  f8b49000          LDRH     r9,[r4,#0]            ;677
000072  f8a39000          STRH     r9,[r3,#0]            ;677
000076  8058              STRH     r0,[r3,#2]            ;678
000078  8026              STRH     r6,[r4,#0]            ;680
00007a  f8848004          STRB     r8,[r4,#4]            ;681
00007e  8818              LDRH     r0,[r3,#0]            ;683
000080  4560              CMP      r0,r12                ;683
000082  d004              BEQ      |L4.142|
000084  1c93              ADDS     r3,r2,#2              ;684
000086  52c6              STRH     r6,[r0,r3]            ;684
000088  e001              B        |L4.142|
                  |L4.138|
00008a  f8848004          STRB     r8,[r4,#4]            ;695
                  |L4.142|
00008e  428c              CMP      r4,r1                 ;701
000090  d113              BNE      |L4.186|
000092  6878              LDR      r0,[r7,#4]            ;704
000094  e001              B        |L4.154|
                  |L4.150|
000096  8809              LDRH     r1,[r1,#0]            ;716
000098  4411              ADD      r1,r1,r2              ;716
                  |L4.154|
00009a  790b              LDRB     r3,[r1,#4]            ;704
00009c  b10b              CBZ      r3,|L4.162|
00009e  4281              CMP      r1,r0                 ;704
0000a0  d1f9              BNE      |L4.150|
                  |L4.162|
0000a2  60b9              STR      r1,[r7,#8]            ;718  ; lfree
0000a4  4281              CMP      r1,r0                 ;719
0000a6  d008              BEQ      |L4.186|
0000a8  7908              LDRB     r0,[r1,#4]            ;719
0000aa  b130              CBZ      r0,|L4.186|
0000ac  a317              ADR      r3,|L4.268|
0000ae  f24022cf          MOV      r2,#0x2cf             ;719
0000b2  a122              ADR      r1,|L4.316|
0000b4  a028              ADR      r0,|L4.344|
0000b6  f7fffffe          BL       __2printf
                  |L4.186|
0000ba  1960              ADDS     r0,r4,r5              ;723
0000bc  6879              LDR      r1,[r7,#4]            ;723  ; ram_end
0000be  3008              ADDS     r0,r0,#8              ;723
0000c0  4288              CMP      r0,r1                 ;723
0000c2  d906              BLS      |L4.210|
0000c4  a311              ADR      r3,|L4.268|
0000c6  f24022d3          MOV      r2,#0x2d3             ;723
0000ca  a12d              ADR      r1,|L4.384|
0000cc  a022              ADR      r0,|L4.344|
0000ce  f7fffffe          BL       __2printf
                  |L4.210|
0000d2  f1040508          ADD      r5,r4,#8              ;725
0000d6  07a9              LSLS     r1,r5,#30             ;725
0000d8  d006              BEQ      |L4.232|
0000da  a30c              ADR      r3,|L4.268|
0000dc  f24022d5          MOV      r2,#0x2d5             ;725
0000e0  a133              ADR      r1,|L4.432|
0000e2  a01d              ADR      r0,|L4.344|
0000e4  f7fffffe          BL       __2printf
                  |L4.232|
0000e8  07a1              LSLS     r1,r4,#30             ;727
0000ea  d006              BEQ      |L4.250|
0000ec  a307              ADR      r3,|L4.268|
0000ee  f24022d7          MOV      r2,#0x2d7             ;727
0000f2  a13b              ADR      r1,|L4.480|
0000f4  a018              ADR      r0,|L4.344|
0000f6  f7fffffe          BL       __2printf
                  |L4.250|
0000fa  4628              MOV      r0,r5                 ;730
0000fc  e791              B        |L4.34|
                  |L4.254|
0000fe  5a10              LDRH     r0,[r2,r0]            ;642
                  |L4.256|
000100  4286              CMP      r6,r0                 ;641
000102  d89a              BHI      |L4.58|
000104  2000              MOVS     r0,#0                 ;741
000106  e78c              B        |L4.34|
;;;743    
                          ENDP

                  |L4.264|
                          DCD      ||.data||
                  |L4.268|
00010c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\mem.c",0
000110  6964646c
000114  65776172
000118  65735c54
00011c  68697264
000120  5f506172
000124  74795c4c
000128  7749505c
00012c  7372635c
000130  636f7265
000134  5c6d656d
000138  2e6300  
00013b  00                DCB      0
                  |L4.316|
00013c  6d656d5f          DCB      "mem_malloc: !lfree->used",0
000140  6d616c6c
000144  6f633a20
000148  216c6672
00014c  65652d3e
000150  75736564
000154  00      
000155  00                DCB      0
000156  00                DCB      0
000157  00                DCB      0
                  |L4.344|
000158  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00015c  7274696f
000160  6e202225
000164  73222066
000168  61696c65
00016c  64206174
000170  206c696e
000174  65202564
000178  20696e20
00017c  25730a00
                  |L4.384|
000180  6d656d5f          DCB      "mem_malloc: allocated memory not above ram_end.",0
000184  6d616c6c
000188  6f633a20
00018c  616c6c6f
000190  63617465
000194  64206d65
000198  6d6f7279
00019c  206e6f74
0001a0  2061626f
0001a4  76652072
0001a8  616d5f65
0001ac  6e642e00
                  |L4.432|
0001b0  6d656d5f          DCB      "mem_malloc: allocated memory properly aligned.",0
0001b4  6d616c6c
0001b8  6f633a20
0001bc  616c6c6f
0001c0  63617465
0001c4  64206d65
0001c8  6d6f7279
0001cc  2070726f
0001d0  7065726c
0001d4  7920616c
0001d8  69676e65
0001dc  642e00  
0001df  00                DCB      0
                  |L4.480|
0001e0  6d656d5f          DCB      "mem_malloc: sanity check alignment",0
0001e4  6d616c6c
0001e8  6f633a20
0001ec  73616e69
0001f0  74792063
0001f4  6865636b
0001f8  20616c69
0001fc  676e6d65
000200  6e7400  
000203  00                DCB      0

                          AREA ||i.mem_trim||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  mem_trim PROC
;;;477    void *
;;;478    mem_trim(void *rmem, mem_size_t newsize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;479    {
000004  4607              MOV      r7,r0
;;;480      mem_size_t size;
;;;481      mem_size_t ptr, ptr2;
;;;482      struct mem *mem, *mem2;
;;;483      /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
;;;484      LWIP_MEM_FREE_DECL_PROTECT();
;;;485    
;;;486      /* Expand the size of the allocated memory region so that we can
;;;487         adjust for alignment. */
;;;488      newsize = LWIP_MEM_ALIGN_SIZE(newsize);
000006  1cc9              ADDS     r1,r1,#3
000008  f64f70fc          MOV      r0,#0xfffc
00000c  ea010400          AND      r4,r1,r0
;;;489    
;;;490      if (newsize < MIN_SIZE_ALIGNED) {
000010  2c0c              CMP      r4,#0xc
000012  d200              BCS      |L5.22|
;;;491        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;492        newsize = MIN_SIZE_ALIGNED;
000014  240c              MOVS     r4,#0xc
                  |L5.22|
;;;493      }
;;;494    
;;;495      if (newsize > MEM_SIZE_ALIGNED) {
000016  f44f69c8          MOV      r9,#0x640
00001a  454c              CMP      r4,r9
00001c  d902              BLS      |L5.36|
;;;496        return NULL;
00001e  2000              MOVS     r0,#0
                  |L5.32|
;;;497      }
;;;498    
;;;499      LWIP_ASSERT("mem_trim: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
;;;500       (u8_t *)rmem < (u8_t *)ram_end);
;;;501    
;;;502      if ((u8_t *)rmem < (u8_t *)ram || (u8_t *)rmem >= (u8_t *)ram_end) {
;;;503        SYS_ARCH_DECL_PROTECT(lev);
;;;504        LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_LEVEL_SEVERE, ("mem_trim: illegal memory\n"));
;;;505        /* protect mem stats from concurrent access */
;;;506        SYS_ARCH_PROTECT(lev);
;;;507        MEM_STATS_INC(illegal);
;;;508        SYS_ARCH_UNPROTECT(lev);
;;;509        return rmem;
;;;510      }
;;;511      /* Get the corresponding struct mem ... */
;;;512      /* cast through void* to get rid of alignment warnings */
;;;513      mem = (struct mem *)(void *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;514      /* ... and its offset pointer */
;;;515      ptr = (mem_size_t)((u8_t *)mem - ram);
;;;516    
;;;517      size = mem->next - ptr - SIZEOF_STRUCT_MEM;
;;;518      LWIP_ASSERT("mem_trim can only shrink memory", newsize <= size);
;;;519      if (newsize > size) {
;;;520        /* not supported */
;;;521        return NULL;
;;;522      }
;;;523      if (newsize == size) {
;;;524        /* No change in size, simply return */
;;;525        return rmem;
;;;526      }
;;;527    
;;;528      /* protect the heap from concurrent access */
;;;529      LWIP_MEM_FREE_PROTECT();
;;;530    
;;;531      mem2 = (struct mem *)(void *)&ram[mem->next];
;;;532      if (mem2->used == 0) {
;;;533        /* The next struct is unused, we can simply move it at little */
;;;534        mem_size_t next;
;;;535        /* remember the old next pointer */
;;;536        next = mem2->next;
;;;537        /* create new struct mem which is moved directly after the shrinked mem */
;;;538        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;539        if (lfree == mem2) {
;;;540          lfree = (struct mem *)(void *)&ram[ptr2];
;;;541        }
;;;542        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;543        mem2->used = 0;
;;;544        /* restore the next pointer */
;;;545        mem2->next = next;
;;;546        /* link it back to mem */
;;;547        mem2->prev = ptr;
;;;548        /* link mem to it */
;;;549        mem->next = ptr2;
;;;550        /* last thing to restore linked list: as we have moved mem2,
;;;551         * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
;;;552         * the end of the heap */
;;;553        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;554          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;555        }
;;;556        MEM_STATS_DEC_USED(used, (size - newsize));
;;;557        /* no need to plug holes, we've already done that */
;;;558      } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
;;;559        /* Next struct is used but there's room for another struct mem with
;;;560         * at least MIN_SIZE_ALIGNED of data.
;;;561         * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
;;;562         * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
;;;563         * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;564         *       region that couldn't hold data, but when mem->next gets freed,
;;;565         *       the 2 regions would be combined, resulting in more free memory */
;;;566        ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;567        mem2 = (struct mem *)(void *)&ram[ptr2];
;;;568        if (mem2 < lfree) {
;;;569          lfree = mem2;
;;;570        }
;;;571        mem2->used = 0;
;;;572        mem2->next = mem->next;
;;;573        mem2->prev = ptr;
;;;574        mem->next = ptr2;
;;;575        if (mem2->next != MEM_SIZE_ALIGNED) {
;;;576          ((struct mem *)(void *)&ram[mem2->next])->prev = ptr2;
;;;577        }
;;;578        MEM_STATS_DEC_USED(used, (size - newsize));
;;;579        /* the original mem->next is used, so no need to plug holes! */
;;;580      }
;;;581      /* else {
;;;582        next struct mem is used but size between mem and mem2 is not big enough
;;;583        to create another struct mem
;;;584        -> don't do anyhting.
;;;585        -> the remaining space stays unused since it is too small
;;;586      } */
;;;587    #if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
;;;588      mem_free_count = 1;
;;;589    #endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
;;;590      LWIP_MEM_FREE_UNPROTECT();
;;;591      return rmem;
;;;592    }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L5.36|
000024  f8df80dc          LDR      r8,|L5.260|
000028  f8d80000          LDR      r0,[r8,#0]            ;499  ; ram
00002c  4287              CMP      r7,r0                 ;499
00002e  d303              BCC      |L5.56|
000030  f8d80004          LDR      r0,[r8,#4]            ;499  ; ram_end
000034  4287              CMP      r7,r0                 ;499
000036  d306              BCC      |L5.70|
                  |L5.56|
000038  a333              ADR      r3,|L5.264|
00003a  f24012f3          MOV      r2,#0x1f3             ;499
00003e  a13e              ADR      r1,|L5.312|
000040  a043              ADR      r0,|L5.336|
000042  f7fffffe          BL       __2printf
                  |L5.70|
000046  f8d80000          LDR      r0,[r8,#0]            ;502  ; ram
00004a  4287              CMP      r7,r0                 ;502
00004c  d303              BCC      |L5.86|
00004e  f8d81004          LDR      r1,[r8,#4]            ;502  ; ram_end
000052  428f              CMP      r7,r1                 ;502
000054  d301              BCC      |L5.90|
                  |L5.86|
000056  4638              MOV      r0,r7                 ;509
000058  e7e2              B        |L5.32|
                  |L5.90|
00005a  f1a70508          SUB      r5,r7,#8              ;513
00005e  1a28              SUBS     r0,r5,r0              ;515
000060  b286              UXTH     r6,r0                 ;515
000062  8828              LDRH     r0,[r5,#0]            ;517
000064  1b80              SUBS     r0,r0,r6              ;517
000066  3808              SUBS     r0,r0,#8              ;517
000068  fa1ffa80          UXTH     r10,r0                ;517
00006c  4554              CMP      r4,r10                ;518
00006e  d906              BLS      |L5.126|
000070  a325              ADR      r3,|L5.264|
000072  f2402206          MOV      r2,#0x206             ;518
000076  a140              ADR      r1,|L5.376|
000078  a035              ADR      r0,|L5.336|
00007a  f7fffffe          BL       __2printf
                  |L5.126|
00007e  4554              CMP      r4,r10                ;519
000080  d902              BLS      |L5.136|
000082  f04f0000          MOV      r0,#0                 ;521
000086  e7cb              B        |L5.32|
                  |L5.136|
000088  d101              BNE      |L5.142|
00008a  4638              MOV      r0,r7                 ;525
00008c  e7c8              B        |L5.32|
                  |L5.142|
00008e  8828              LDRH     r0,[r5,#0]            ;531
000090  f8d82000          LDR      r2,[r8,#0]            ;531  ; ram
000094  eb000102          ADD      r1,r0,r2              ;531
000098  f04f0300          MOV      r3,#0                 ;532
00009c  7908              LDRB     r0,[r1,#4]            ;532
00009e  b1c8              CBZ      r0,|L5.212|
0000a0  f1040014          ADD      r0,r4,#0x14           ;558
0000a4  4550              CMP      r0,r10                ;558
0000a6  d813              BHI      |L5.208|
0000a8  1930              ADDS     r0,r6,r4              ;566
0000aa  3008              ADDS     r0,r0,#8              ;566
0000ac  b280              UXTH     r0,r0                 ;566
0000ae  1811              ADDS     r1,r2,r0              ;567
0000b0  f8d84008          LDR      r4,[r8,#8]            ;568  ; lfree
0000b4  42a1              CMP      r1,r4                 ;568
0000b6  d201              BCS      |L5.188|
0000b8  f8c81008          STR      r1,[r8,#8]            ;569  ; lfree
                  |L5.188|
0000bc  710b              STRB     r3,[r1,#4]            ;571
0000be  882b              LDRH     r3,[r5,#0]            ;572
0000c0  800b              STRH     r3,[r1,#0]            ;572
0000c2  804e              STRH     r6,[r1,#2]            ;573
0000c4  8028              STRH     r0,[r5,#0]            ;574
0000c6  8809              LDRH     r1,[r1,#0]            ;575
0000c8  4549              CMP      r1,r9                 ;575
0000ca  d001              BEQ      |L5.208|
0000cc  1c92              ADDS     r2,r2,#2              ;576
0000ce  5288              STRH     r0,[r1,r2]            ;576
                  |L5.208|
0000d0  4638              MOV      r0,r7                 ;591
0000d2  e7a5              B        |L5.32|
                  |L5.212|
0000d4  f8b1c000          LDRH     r12,[r1,#0]           ;536
0000d8  1930              ADDS     r0,r6,r4              ;538
0000da  3008              ADDS     r0,r0,#8              ;538
0000dc  b280              UXTH     r0,r0                 ;538
0000de  f8d84008          LDR      r4,[r8,#8]            ;539  ; lfree
0000e2  428c              CMP      r4,r1                 ;539
0000e4  d102              BNE      |L5.236|
0000e6  1811              ADDS     r1,r2,r0              ;540
0000e8  f8c81008          STR      r1,[r8,#8]            ;540  ; lfree
                  |L5.236|
0000ec  1811              ADDS     r1,r2,r0              ;542
0000ee  710b              STRB     r3,[r1,#4]            ;543
0000f0  f8a1c000          STRH     r12,[r1,#0]           ;545
0000f4  804e              STRH     r6,[r1,#2]            ;547
0000f6  8028              STRH     r0,[r5,#0]            ;549
0000f8  8809              LDRH     r1,[r1,#0]            ;553
0000fa  4549              CMP      r1,r9                 ;553
0000fc  d0e8              BEQ      |L5.208|
0000fe  1c92              ADDS     r2,r2,#2              ;554
000100  5288              STRH     r0,[r1,r2]            ;554
000102  e7e5              B        |L5.208|
;;;593    
                          ENDP

                  |L5.260|
                          DCD      ||.data||
                  |L5.264|
000108  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\mem.c",0
00010c  6964646c
000110  65776172
000114  65735c54
000118  68697264
00011c  5f506172
000120  74795c4c
000124  7749505c
000128  7372635c
00012c  636f7265
000130  5c6d656d
000134  2e6300  
000137  00                DCB      0
                  |L5.312|
000138  6d656d5f          DCB      "mem_trim: legal memory",0
00013c  7472696d
000140  3a206c65
000144  67616c20
000148  6d656d6f
00014c  727900  
00014f  00                DCB      0
                  |L5.336|
000150  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000154  7274696f
000158  6e202225
00015c  73222066
000160  61696c65
000164  64206174
000168  206c696e
00016c  65202564
000170  20696e20
000174  25730a00
                  |L5.376|
000178  6d656d5f          DCB      "mem_trim can only shrink memory",0
00017c  7472696d
000180  2063616e
000184  206f6e6c
000188  79207368
00018c  72696e6b
000190  206d656d
000194  6f727900

                          AREA ||i.plug_holes||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  plug_holes PROC
;;;343    static void
;;;344    plug_holes(struct mem *mem)
000000  b570              PUSH     {r4-r6,lr}
;;;345    {
000002  4604              MOV      r4,r0
;;;346      struct mem *nmem;
;;;347      struct mem *pmem;
;;;348    
;;;349      LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
000004  4d27              LDR      r5,|L6.164|
000006  6828              LDR      r0,[r5,#0]  ; ram
000008  4284              CMP      r4,r0
00000a  d206              BCS      |L6.26|
00000c  a326              ADR      r3,|L6.168|
00000e  f240125d          MOV      r2,#0x15d
000012  a131              ADR      r1,|L6.216|
000014  a036              ADR      r0,|L6.240|
000016  f7fffffe          BL       __2printf
                  |L6.26|
;;;350      LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
00001a  6868              LDR      r0,[r5,#4]  ; ram_end
00001c  4284              CMP      r4,r0
00001e  d306              BCC      |L6.46|
000020  a321              ADR      r3,|L6.168|
000022  f44f72af          MOV      r2,#0x15e
000026  a13c              ADR      r1,|L6.280|
000028  a031              ADR      r0,|L6.240|
00002a  f7fffffe          BL       __2printf
                  |L6.46|
;;;351      LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);
00002e  7920              LDRB     r0,[r4,#4]
000030  b130              CBZ      r0,|L6.64|
000032  a31d              ADR      r3,|L6.168|
000034  f240125f          MOV      r2,#0x15f
000038  a13e              ADR      r1,|L6.308|
00003a  a02d              ADR      r0,|L6.240|
00003c  f7fffffe          BL       __2printf
                  |L6.64|
;;;352    
;;;353      /* plug hole forward */
;;;354      LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
000040  8820              LDRH     r0,[r4,#0]
000042  f5b06fc8          CMP      r0,#0x640
000046  d906              BLS      |L6.86|
000048  a317              ADR      r3,|L6.168|
00004a  f44f72b1          MOV      r2,#0x162
00004e  a140              ADR      r1,|L6.336|
000050  a027              ADR      r0,|L6.240|
000052  f7fffffe          BL       __2printf
                  |L6.86|
;;;355    
;;;356      nmem = (struct mem *)(void *)&ram[mem->next];
000056  8820              LDRH     r0,[r4,#0]
000058  6829              LDR      r1,[r5,#0]  ; ram
00005a  4408              ADD      r0,r0,r1
;;;357      if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
00005c  4284              CMP      r4,r0
00005e  d00e              BEQ      |L6.126|
000060  7902              LDRB     r2,[r0,#4]
000062  b962              CBNZ     r2,|L6.126|
000064  686a              LDR      r2,[r5,#4]  ; ram_end
000066  4290              CMP      r0,r2
000068  d009              BEQ      |L6.126|
;;;358        /* if mem->next is unused and not end of ram, combine mem and mem->next */
;;;359        if (lfree == nmem) {
00006a  68aa              LDR      r2,[r5,#8]  ; lfree
00006c  4282              CMP      r2,r0
00006e  d100              BNE      |L6.114|
;;;360          lfree = mem;
000070  60ac              STR      r4,[r5,#8]  ; lfree
                  |L6.114|
;;;361        }
;;;362        mem->next = nmem->next;
000072  8802              LDRH     r2,[r0,#0]
000074  8022              STRH     r2,[r4,#0]
;;;363        ((struct mem *)(void *)&ram[nmem->next])->prev = (mem_size_t)((u8_t *)mem - ram);
000076  8803              LDRH     r3,[r0,#0]
000078  1a62              SUBS     r2,r4,r1
00007a  1c88              ADDS     r0,r1,#2
00007c  521a              STRH     r2,[r3,r0]
                  |L6.126|
;;;364      }
;;;365    
;;;366      /* plug hole backward */
;;;367      pmem = (struct mem *)(void *)&ram[mem->prev];
00007e  8860              LDRH     r0,[r4,#2]
000080  4408              ADD      r0,r0,r1
;;;368      if (pmem != mem && pmem->used == 0) {
000082  42a0              CMP      r0,r4
000084  d00c              BEQ      |L6.160|
000086  7902              LDRB     r2,[r0,#4]
000088  2a00              CMP      r2,#0
00008a  d109              BNE      |L6.160|
;;;369        /* if mem->prev is unused, combine mem and mem->prev */
;;;370        if (lfree == mem) {
00008c  68aa              LDR      r2,[r5,#8]  ; lfree
00008e  42a2              CMP      r2,r4
000090  d100              BNE      |L6.148|
;;;371          lfree = pmem;
000092  60a8              STR      r0,[r5,#8]  ; lfree
                  |L6.148|
;;;372        }
;;;373        pmem->next = mem->next;
000094  8822              LDRH     r2,[r4,#0]
000096  8002              STRH     r2,[r0,#0]
;;;374        ((struct mem *)(void *)&ram[mem->next])->prev = (mem_size_t)((u8_t *)pmem - ram);
000098  8822              LDRH     r2,[r4,#0]
00009a  1a40              SUBS     r0,r0,r1
00009c  1c89              ADDS     r1,r1,#2
00009e  5250              STRH     r0,[r2,r1]
                  |L6.160|
;;;375      }
;;;376    }
0000a0  bd70              POP      {r4-r6,pc}
;;;377    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L6.164|
                          DCD      ||.data||
                  |L6.168|
0000a8  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\mem.c",0
0000ac  6964646c
0000b0  65776172
0000b4  65735c54
0000b8  68697264
0000bc  5f506172
0000c0  74795c4c
0000c4  7749505c
0000c8  7372635c
0000cc  636f7265
0000d0  5c6d656d
0000d4  2e6300  
0000d7  00                DCB      0
                  |L6.216|
0000d8  706c7567          DCB      "plug_holes: mem >= ram",0
0000dc  5f686f6c
0000e0  65733a20
0000e4  6d656d20
0000e8  3e3d2072
0000ec  616d00  
0000ef  00                DCB      0
                  |L6.240|
0000f0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000f4  7274696f
0000f8  6e202225
0000fc  73222066
000100  61696c65
000104  64206174
000108  206c696e
00010c  65202564
000110  20696e20
000114  25730a00
                  |L6.280|
000118  706c7567          DCB      "plug_holes: mem < ram_end",0
00011c  5f686f6c
000120  65733a20
000124  6d656d20
000128  3c207261
00012c  6d5f656e
000130  6400    
000132  00                DCB      0
000133  00                DCB      0
                  |L6.308|
000134  706c7567          DCB      "plug_holes: mem->used == 0",0
000138  5f686f6c
00013c  65733a20
000140  6d656d2d
000144  3e757365
000148  64203d3d
00014c  203000  
00014f  00                DCB      0
                  |L6.336|
000150  706c7567          DCB      "plug_holes: mem->next <= MEM_SIZE_ALIGNED",0
000154  5f686f6c
000158  65733a20
00015c  6d656d2d
000160  3e6e6578
000164  74203c3d
000168  204d454d
00016c  5f53495a
000170  455f414c
000174  49474e45
000178  4400    
00017a  00                DCB      0
00017b  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ram_heap
                          %        1619

                          AREA ||.data||, DATA, ALIGN=2

                  ||ram||
                          DCD      0x00000000
                  ram_end
                          DCD      0x00000000
                  lfree
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\mem.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_mem_c_mem_init____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_mem_c_mem_init____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_mem_c_mem_init____REVSH|
#line 478
|__asm___5_mem_c_mem_init____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_mem_c_mem_init____RRX|
#line 665
|__asm___5_mem_c_mem_init____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
