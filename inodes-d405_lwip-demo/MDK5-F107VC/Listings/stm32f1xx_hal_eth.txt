; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\stm32f1xx_hal_eth.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f1xx_hal_eth.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\system\arch -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Inc -I..\Middlewares\Third_Party\LwIP\src\include -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\stm32f1xx_hal_eth.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_eth.c]
                          THUMB

                          AREA ||i.ETH_DMAReceptionDisable||, CODE, READONLY, ALIGN=1

                  ETH_DMAReceptionDisable PROC
;;;2225     */
;;;2226   static void ETH_DMAReceptionDisable(ETH_HandleTypeDef *heth)
000000  6800              LDR      r0,[r0,#0]
;;;2227   {
;;;2228     /* Disable the DMA reception */
;;;2229     (heth->Instance)->DMAOMR &= ~ETH_DMAOMR_SR;
000002  f5005080          ADD      r0,r0,#0x1000
000006  6981              LDR      r1,[r0,#0x18]
000008  f0210102          BIC      r1,r1,#2
00000c  6181              STR      r1,[r0,#0x18]
;;;2230   }
00000e  4770              BX       lr
;;;2231   
                          ENDP


                          AREA ||i.ETH_DMAReceptionEnable||, CODE, READONLY, ALIGN=1

                  ETH_DMAReceptionEnable PROC
;;;2213     */
;;;2214   static void ETH_DMAReceptionEnable(ETH_HandleTypeDef *heth)
000000  6800              LDR      r0,[r0,#0]
;;;2215   {
;;;2216     /* Enable the DMA reception */
;;;2217     (heth->Instance)->DMAOMR |= ETH_DMAOMR_SR;
000002  f5005080          ADD      r0,r0,#0x1000
000006  6981              LDR      r1,[r0,#0x18]
000008  f0410102          ORR      r1,r1,#2
00000c  6181              STR      r1,[r0,#0x18]
;;;2218   }
00000e  4770              BX       lr
;;;2219   
                          ENDP


                          AREA ||i.ETH_DMATransmissionDisable||, CODE, READONLY, ALIGN=1

                  ETH_DMATransmissionDisable PROC
;;;2201     */
;;;2202   static void ETH_DMATransmissionDisable(ETH_HandleTypeDef *heth)
000000  6800              LDR      r0,[r0,#0]
;;;2203   {
;;;2204     /* Disable the DMA transmission */
;;;2205     (heth->Instance)->DMAOMR &= ~ETH_DMAOMR_ST;
000002  f5005080          ADD      r0,r0,#0x1000
000006  6981              LDR      r1,[r0,#0x18]
000008  f4215100          BIC      r1,r1,#0x2000
00000c  6181              STR      r1,[r0,#0x18]
;;;2206   }
00000e  4770              BX       lr
;;;2207   
                          ENDP


                          AREA ||i.ETH_DMATransmissionEnable||, CODE, READONLY, ALIGN=1

                  ETH_DMATransmissionEnable PROC
;;;2189     */
;;;2190   static void ETH_DMATransmissionEnable(ETH_HandleTypeDef *heth)
000000  6800              LDR      r0,[r0,#0]
;;;2191   {
;;;2192     /* Enable the DMA transmission */
;;;2193     (heth->Instance)->DMAOMR |= ETH_DMAOMR_ST;
000002  f5005080          ADD      r0,r0,#0x1000
000006  6981              LDR      r1,[r0,#0x18]
000008  f4415100          ORR      r1,r1,#0x2000
00000c  6181              STR      r1,[r0,#0x18]
;;;2194   }
00000e  4770              BX       lr
;;;2195   
                          ENDP


                          AREA ||i.ETH_Delay||, CODE, READONLY, ALIGN=2

                  ETH_Delay PROC
;;;2256     */
;;;2257   static void ETH_Delay(uint32_t mdelay)
000000  b508              PUSH     {r3,lr}
;;;2258   {
;;;2259     __IO uint32_t Delay = mdelay * (SystemCoreClock / 8U / 1000U);
000002  4907              LDR      r1,|L5.32|
000004  f44f52fa          MOV      r2,#0x1f40
000008  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00000a  fbb1f1f2          UDIV     r1,r1,r2
00000e  4341              MULS     r1,r0,r1
000010  9100              STR      r1,[sp,#0]
                  |L5.18|
;;;2260     do
;;;2261     {
;;;2262       __NOP();
000012  bf00              NOP      
;;;2263     }
;;;2264     while (Delay --);
000014  9800              LDR      r0,[sp,#0]
000016  1e41              SUBS     r1,r0,#1
000018  9100              STR      r1,[sp,#0]
00001a  d2fa              BCS      |L5.18|
;;;2265   }
00001c  bd08              POP      {r3,pc}
;;;2266   
                          ENDP

00001e  0000              DCW      0x0000
                  |L5.32|
                          DCD      SystemCoreClock

                          AREA ||i.ETH_FlushTransmitFIFO||, CODE, READONLY, ALIGN=1

                  ETH_FlushTransmitFIFO PROC
;;;2237     */
;;;2238   static void ETH_FlushTransmitFIFO(ETH_HandleTypeDef *heth)
000000  b538              PUSH     {r3-r5,lr}
;;;2239   {
000002  4604              MOV      r4,r0
;;;2240     __IO uint32_t tmpreg1 = 0U;
;;;2241   
;;;2242     /* Set the Flush Transmit FIFO bit */
;;;2243     (heth->Instance)->DMAOMR |= ETH_DMAOMR_FTF;
000004  6820              LDR      r0,[r4,#0]
000006  f5005080          ADD      r0,r0,#0x1000
00000a  6981              LDR      r1,[r0,#0x18]
00000c  f4411180          ORR      r1,r1,#0x100000
000010  6181              STR      r1,[r0,#0x18]
;;;2244   
;;;2245     /* Wait until the write operation will be taken into account:
;;;2246        at least four TX_CLK/RX_CLK clock cycles */
;;;2247     tmpreg1 = (heth->Instance)->DMAOMR;
000012  6820              LDR      r0,[r4,#0]
000014  f5005080          ADD      r0,r0,#0x1000
000018  6980              LDR      r0,[r0,#0x18]
00001a  9000              STR      r0,[sp,#0]
;;;2248     ETH_Delay(ETH_REG_WRITE_DELAY);
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       ETH_Delay
;;;2249     (heth->Instance)->DMAOMR = tmpreg1;
000022  6820              LDR      r0,[r4,#0]
000024  9900              LDR      r1,[sp,#0]
000026  f5005080          ADD      r0,r0,#0x1000
00002a  6181              STR      r1,[r0,#0x18]
;;;2250   }
00002c  bd38              POP      {r3-r5,pc}
;;;2251   
                          ENDP


                          AREA ||i.ETH_MACAddressConfig||, CODE, READONLY, ALIGN=2

                  ETH_MACAddressConfig PROC
;;;2082     */
;;;2083   static void ETH_MACAddressConfig(ETH_HandleTypeDef *heth, uint32_t MacAddr, uint8_t *Addr)
000000  7910              LDRB     r0,[r2,#4]
;;;2084   {
;;;2085     uint32_t tmpreg1;
;;;2086   
;;;2087     /* Prevent unused argument(s) compilation warning */
;;;2088     UNUSED(heth);
;;;2089   
;;;2090     /* Check the parameters */
;;;2091     assert_param(IS_ETH_MAC_ADDRESS0123(MacAddr));
;;;2092   
;;;2093     /* Calculate the selected MAC address high register */
;;;2094     tmpreg1 = ((uint32_t)Addr[5U] << 8U) | (uint32_t)Addr[4U];
000002  7953              LDRB     r3,[r2,#5]
000004  ea402303          ORR      r3,r0,r3,LSL #8
;;;2095     /* Load the selected MAC address high register */
;;;2096     (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_HBASE + MacAddr))) = tmpreg1;
000008  4807              LDR      r0,|L7.40|
00000a  4408              ADD      r0,r0,r1
00000c  6403              STR      r3,[r0,#0x40]
;;;2097     /* Calculate the selected MAC address low register */
;;;2098     tmpreg1 = ((uint32_t)Addr[3U] << 24U) | ((uint32_t)Addr[2U] << 16U) | ((uint32_t)Addr[1U] << 8U) | Addr[0U];
00000e  7811              LDRB     r1,[r2,#0]
000010  78d3              LDRB     r3,[r2,#3]
000012  ea416103          ORR      r1,r1,r3,LSL #24
000016  7893              LDRB     r3,[r2,#2]
000018  7852              LDRB     r2,[r2,#1]
00001a  041b              LSLS     r3,r3,#16
00001c  ea432202          ORR      r2,r3,r2,LSL #8
000020  4311              ORRS     r1,r1,r2
;;;2099   
;;;2100     /* Load the selected MAC address low register */
;;;2101     (*(__IO uint32_t *)((uint32_t)(ETH_MAC_ADDR_LBASE + MacAddr))) = tmpreg1;
000022  6441              STR      r1,[r0,#0x44]
;;;2102   }
000024  4770              BX       lr
;;;2103   
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0x40028000

                          AREA ||i.ETH_MACDMAConfig||, CODE, READONLY, ALIGN=2

                  ETH_MACDMAConfig PROC
;;;1822     */
;;;1823   static void ETH_MACDMAConfig(ETH_HandleTypeDef *heth, uint32_t err)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1824   {
000002  b0ad              SUB      sp,sp,#0xb4
000004  4604              MOV      r4,r0
;;;1825     ETH_MACInitTypeDef macinit;
;;;1826     ETH_DMAInitTypeDef dmainit;
;;;1827     uint32_t tmpreg1 = 0U;
;;;1828   
;;;1829     if (err != ETH_SUCCESS) /* Auto-negotiation failed */
000006  2900              CMP      r1,#0
000008  d004              BEQ      |L8.20|
;;;1830     {
;;;1831       /* Set Ethernet duplex mode to Full-duplex */
;;;1832       (heth->Init).DuplexMode = ETH_MODE_FULLDUPLEX;
00000a  f44f6000          MOV      r0,#0x800
00000e  60e0              STR      r0,[r4,#0xc]
;;;1833   
;;;1834       /* Set Ethernet speed to 100M */
;;;1835       (heth->Init).Speed = ETH_SPEED_100M;
000010  00c0              LSLS     r0,r0,#3
000012  60a0              STR      r0,[r4,#8]
                  |L8.20|
;;;1836     }
;;;1837   
;;;1838     /* Ethernet MAC default initialization **************************************/
;;;1839     macinit.Watchdog = ETH_WATCHDOG_ENABLE;
000014  2500              MOVS     r5,#0
000016  9510              STR      r5,[sp,#0x40]
;;;1840     macinit.Jabber = ETH_JABBER_ENABLE;
000018  9511              STR      r5,[sp,#0x44]
;;;1841     macinit.InterFrameGap = ETH_INTERFRAMEGAP_96BIT;
00001a  9512              STR      r5,[sp,#0x48]
;;;1842     macinit.CarrierSense = ETH_CARRIERSENCE_ENABLE;
00001c  9513              STR      r5,[sp,#0x4c]
;;;1843     macinit.ReceiveOwn = ETH_RECEIVEOWN_ENABLE;
00001e  9514              STR      r5,[sp,#0x50]
;;;1844     macinit.LoopbackMode = ETH_LOOPBACKMODE_DISABLE;
000020  9515              STR      r5,[sp,#0x54]
;;;1845     if (heth->Init.ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
000022  69e0              LDR      r0,[r4,#0x1c]
000024  2800              CMP      r0,#0
000026  d07d              BEQ      |L8.292|
;;;1846     {
;;;1847       macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_ENABLE;
;;;1848     }
;;;1849     else
;;;1850     {
;;;1851       macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_DISABLE;
000028  9516              STR      r5,[sp,#0x58]
                  |L8.42|
;;;1852     }
;;;1853     macinit.RetryTransmission = ETH_RETRYTRANSMISSION_DISABLE;
00002a  f44f7000          MOV      r0,#0x200
00002e  9017              STR      r0,[sp,#0x5c]
;;;1854     macinit.AutomaticPadCRCStrip = ETH_AUTOMATICPADCRCSTRIP_DISABLE;
000030  9518              STR      r5,[sp,#0x60]
;;;1855     macinit.BackOffLimit = ETH_BACKOFFLIMIT_10;
000032  9519              STR      r5,[sp,#0x64]
;;;1856     macinit.DeferralCheck = ETH_DEFFERRALCHECK_DISABLE;
000034  951a              STR      r5,[sp,#0x68]
;;;1857     macinit.ReceiveAll = ETH_RECEIVEAll_DISABLE;
000036  951b              STR      r5,[sp,#0x6c]
;;;1858     macinit.SourceAddrFilter = ETH_SOURCEADDRFILTER_DISABLE;
000038  951c              STR      r5,[sp,#0x70]
;;;1859     macinit.PassControlFrames = ETH_PASSCONTROLFRAMES_BLOCKALL;
00003a  2640              MOVS     r6,#0x40
00003c  961d              STR      r6,[sp,#0x74]
;;;1860     macinit.BroadcastFramesReception = ETH_BROADCASTFRAMESRECEPTION_ENABLE;
00003e  951e              STR      r5,[sp,#0x78]
;;;1861     macinit.DestinationAddrFilter = ETH_DESTINATIONADDRFILTER_NORMAL;
000040  951f              STR      r5,[sp,#0x7c]
;;;1862     macinit.PromiscuousMode = ETH_PROMISCUOUS_MODE_DISABLE;
000042  9520              STR      r5,[sp,#0x80]
;;;1863     macinit.MulticastFramesFilter = ETH_MULTICASTFRAMESFILTER_PERFECT;
000044  9521              STR      r5,[sp,#0x84]
;;;1864     macinit.UnicastFramesFilter = ETH_UNICASTFRAMESFILTER_PERFECT;
000046  9522              STR      r5,[sp,#0x88]
;;;1865     macinit.HashTableHigh = 0x0U;
000048  9523              STR      r5,[sp,#0x8c]
;;;1866     macinit.HashTableLow = 0x0U;
00004a  9524              STR      r5,[sp,#0x90]
;;;1867     macinit.PauseTime = 0x0U;
00004c  9525              STR      r5,[sp,#0x94]
;;;1868     macinit.ZeroQuantaPause = ETH_ZEROQUANTAPAUSE_DISABLE;
00004e  2080              MOVS     r0,#0x80
000050  9026              STR      r0,[sp,#0x98]
;;;1869     macinit.PauseLowThreshold = ETH_PAUSELOWTHRESHOLD_MINUS4;
000052  9527              STR      r5,[sp,#0x9c]
;;;1870     macinit.UnicastPauseFrameDetect = ETH_UNICASTPAUSEFRAMEDETECT_DISABLE;
000054  9528              STR      r5,[sp,#0xa0]
;;;1871     macinit.ReceiveFlowControl = ETH_RECEIVEFLOWCONTROL_DISABLE;
000056  9529              STR      r5,[sp,#0xa4]
;;;1872     macinit.TransmitFlowControl = ETH_TRANSMITFLOWCONTROL_DISABLE;
000058  952a              STR      r5,[sp,#0xa8]
;;;1873     macinit.VLANTagComparison = ETH_VLANTAGCOMPARISON_16BIT;
00005a  952b              STR      r5,[sp,#0xac]
;;;1874     macinit.VLANTagIdentifier = 0x0U;
00005c  952c              STR      r5,[sp,#0xb0]
;;;1875   
;;;1876     /*------------------------ ETHERNET MACCR Configuration --------------------*/
;;;1877     /* Get the ETHERNET MACCR value */
;;;1878     tmpreg1 = (heth->Instance)->MACCR;
00005e  6820              LDR      r0,[r4,#0]
000060  6802              LDR      r2,[r0,#0]
;;;1879     /* Clear WD, PCE, PS, TE and RE bits */
;;;1880     tmpreg1 &= ETH_MACCR_CLEAR_MASK;
000062  4945              LDR      r1,|L8.376|
000064  400a              ANDS     r2,r2,r1
;;;1881     /* Set the WD bit according to ETH Watchdog value */
;;;1882     /* Set the JD: bit according to ETH Jabber value */
;;;1883     /* Set the IFG bit according to ETH InterFrameGap value */
;;;1884     /* Set the DCRS bit according to ETH CarrierSense value */
;;;1885     /* Set the FES bit according to ETH Speed value */
;;;1886     /* Set the DO bit according to ETH ReceiveOwn value */
;;;1887     /* Set the LM bit according to ETH LoopbackMode value */
;;;1888     /* Set the DM bit according to ETH Mode value */
;;;1889     /* Set the IPCO bit according to ETH ChecksumOffload value */
;;;1890     /* Set the DR bit according to ETH RetryTransmission value */
;;;1891     /* Set the ACS bit according to ETH AutomaticPadCRCStrip value */
;;;1892     /* Set the BL bit according to ETH BackOffLimit value */
;;;1893     /* Set the DC bit according to ETH DeferralCheck value */
;;;1894     tmpreg1 |= (uint32_t)(macinit.Watchdog |
000066  e9d41302          LDRD     r1,r3,[r4,#8]
00006a  4319              ORRS     r1,r1,r3
00006c  9b16              LDR      r3,[sp,#0x58]
00006e  4319              ORRS     r1,r1,r3
000070  f4417100          ORR      r1,r1,#0x200
000074  4311              ORRS     r1,r1,r2
;;;1895                           macinit.Jabber |
;;;1896                           macinit.InterFrameGap |
;;;1897                           macinit.CarrierSense |
;;;1898                           (heth->Init).Speed |
;;;1899                           macinit.ReceiveOwn |
;;;1900                           macinit.LoopbackMode |
;;;1901                           (heth->Init).DuplexMode |
;;;1902                           macinit.ChecksumOffload |
;;;1903                           macinit.RetryTransmission |
;;;1904                           macinit.AutomaticPadCRCStrip |
;;;1905                           macinit.BackOffLimit |
;;;1906                           macinit.DeferralCheck);
;;;1907   
;;;1908     /* Write to ETHERNET MACCR */
;;;1909     (heth->Instance)->MACCR = (uint32_t)tmpreg1;
000076  6001              STR      r1,[r0,#0]
;;;1910   
;;;1911     /* Wait until the write operation will be taken into account:
;;;1912        at least four TX_CLK/RX_CLK clock cycles */
;;;1913     tmpreg1 = (heth->Instance)->MACCR;
000078  6820              LDR      r0,[r4,#0]
00007a  6807              LDR      r7,[r0,#0]
;;;1914     HAL_Delay(ETH_REG_WRITE_DELAY);
00007c  2001              MOVS     r0,#1
00007e  f7fffffe          BL       HAL_Delay
;;;1915     (heth->Instance)->MACCR = tmpreg1;
000082  6820              LDR      r0,[r4,#0]
000084  6007              STR      r7,[r0,#0]
;;;1916   
;;;1917     /*----------------------- ETHERNET MACFFR Configuration --------------------*/
;;;1918     /* Set the RA bit according to ETH ReceiveAll value */
;;;1919     /* Set the SAF and SAIF bits according to ETH SourceAddrFilter value */
;;;1920     /* Set the PCF bit according to ETH PassControlFrames value */
;;;1921     /* Set the DBF bit according to ETH BroadcastFramesReception value */
;;;1922     /* Set the DAIF bit according to ETH DestinationAddrFilter value */
;;;1923     /* Set the PR bit according to ETH PromiscuousMode value */
;;;1924     /* Set the PM, HMC and HPF bits according to ETH MulticastFramesFilter value */
;;;1925     /* Set the HUC and HPF bits according to ETH UnicastFramesFilter value */
;;;1926     /* Write to ETHERNET MACFFR */
;;;1927     (heth->Instance)->MACFFR = (uint32_t)(macinit.ReceiveAll |
000086  6820              LDR      r0,[r4,#0]
000088  6046              STR      r6,[r0,#4]
;;;1928                                           macinit.SourceAddrFilter |
;;;1929                                           macinit.PassControlFrames |
;;;1930                                           macinit.BroadcastFramesReception |
;;;1931                                           macinit.DestinationAddrFilter |
;;;1932                                           macinit.PromiscuousMode |
;;;1933                                           macinit.MulticastFramesFilter |
;;;1934                                           macinit.UnicastFramesFilter);
;;;1935   
;;;1936     /* Wait until the write operation will be taken into account:
;;;1937        at least four TX_CLK/RX_CLK clock cycles */
;;;1938     tmpreg1 = (heth->Instance)->MACFFR;
00008a  6820              LDR      r0,[r4,#0]
00008c  6846              LDR      r6,[r0,#4]
;;;1939     HAL_Delay(ETH_REG_WRITE_DELAY);
00008e  2001              MOVS     r0,#1
000090  f7fffffe          BL       HAL_Delay
;;;1940     (heth->Instance)->MACFFR = tmpreg1;
000094  6820              LDR      r0,[r4,#0]
000096  6046              STR      r6,[r0,#4]
;;;1941   
;;;1942     /*--------------- ETHERNET MACHTHR and MACHTLR Configuration --------------*/
;;;1943     /* Write to ETHERNET MACHTHR */
;;;1944     (heth->Instance)->MACHTHR = (uint32_t)macinit.HashTableHigh;
000098  6820              LDR      r0,[r4,#0]
00009a  6085              STR      r5,[r0,#8]
;;;1945   
;;;1946     /* Write to ETHERNET MACHTLR */
;;;1947     (heth->Instance)->MACHTLR = (uint32_t)macinit.HashTableLow;
00009c  6820              LDR      r0,[r4,#0]
00009e  60c5              STR      r5,[r0,#0xc]
;;;1948     /*----------------------- ETHERNET MACFCR Configuration -------------------*/
;;;1949   
;;;1950     /* Get the ETHERNET MACFCR value */
;;;1951     tmpreg1 = (heth->Instance)->MACFCR;
0000a0  6820              LDR      r0,[r4,#0]
0000a2  6981              LDR      r1,[r0,#0x18]
;;;1952     /* Clear xx bits */
;;;1953     tmpreg1 &= ETH_MACFCR_CLEAR_MASK;
0000a4  f64f7241          MOV      r2,#0xff41
0000a8  4011              ANDS     r1,r1,r2
;;;1954   
;;;1955     /* Set the PT bit according to ETH PauseTime value */
;;;1956     /* Set the DZPQ bit according to ETH ZeroQuantaPause value */
;;;1957     /* Set the PLT bit according to ETH PauseLowThreshold value */
;;;1958     /* Set the UP bit according to ETH UnicastPauseFrameDetect value */
;;;1959     /* Set the RFE bit according to ETH ReceiveFlowControl value */
;;;1960     /* Set the TFE bit according to ETH TransmitFlowControl value */
;;;1961     tmpreg1 |= (uint32_t)((macinit.PauseTime << 16U) |
0000aa  f0410180          ORR      r1,r1,#0x80
;;;1962                           macinit.ZeroQuantaPause |
;;;1963                           macinit.PauseLowThreshold |
;;;1964                           macinit.UnicastPauseFrameDetect |
;;;1965                           macinit.ReceiveFlowControl |
;;;1966                           macinit.TransmitFlowControl);
;;;1967   
;;;1968     /* Write to ETHERNET MACFCR */
;;;1969     (heth->Instance)->MACFCR = (uint32_t)tmpreg1;
0000ae  6181              STR      r1,[r0,#0x18]
;;;1970   
;;;1971     /* Wait until the write operation will be taken into account:
;;;1972     at least four TX_CLK/RX_CLK clock cycles */
;;;1973     tmpreg1 = (heth->Instance)->MACFCR;
0000b0  6820              LDR      r0,[r4,#0]
0000b2  6986              LDR      r6,[r0,#0x18]
;;;1974     HAL_Delay(ETH_REG_WRITE_DELAY);
0000b4  2001              MOVS     r0,#1
0000b6  f7fffffe          BL       HAL_Delay
;;;1975     (heth->Instance)->MACFCR = tmpreg1;
0000ba  6820              LDR      r0,[r4,#0]
0000bc  6186              STR      r6,[r0,#0x18]
;;;1976   
;;;1977     /*----------------------- ETHERNET MACVLANTR Configuration ----------------*/
;;;1978     /* Set the ETV bit according to ETH VLANTagComparison value */
;;;1979     /* Set the VL bit according to ETH VLANTagIdentifier value */
;;;1980     (heth->Instance)->MACVLANTR = (uint32_t)(macinit.VLANTagComparison |
0000be  6820              LDR      r0,[r4,#0]
0000c0  61c5              STR      r5,[r0,#0x1c]
;;;1981                                              macinit.VLANTagIdentifier);
;;;1982   
;;;1983     /* Wait until the write operation will be taken into account:
;;;1984        at least four TX_CLK/RX_CLK clock cycles */
;;;1985     tmpreg1 = (heth->Instance)->MACVLANTR;
0000c2  6820              LDR      r0,[r4,#0]
0000c4  69c6              LDR      r6,[r0,#0x1c]
;;;1986     HAL_Delay(ETH_REG_WRITE_DELAY);
0000c6  2001              MOVS     r0,#1
0000c8  f7fffffe          BL       HAL_Delay
;;;1987     (heth->Instance)->MACVLANTR = tmpreg1;
0000cc  6820              LDR      r0,[r4,#0]
0000ce  61c6              STR      r6,[r0,#0x1c]
;;;1988   
;;;1989     /* Ethernet DMA default initialization ************************************/
;;;1990     dmainit.DropTCPIPChecksumErrorFrame = ETH_DROPTCPIPCHECKSUMERRORFRAME_ENABLE;
0000d0  9501              STR      r5,[sp,#4]
;;;1991     dmainit.ReceiveStoreForward = ETH_RECEIVESTOREFORWARD_ENABLE;
0000d2  f04f7000          MOV      r0,#0x2000000
0000d6  9002              STR      r0,[sp,#8]
;;;1992     dmainit.FlushReceivedFrame = ETH_FLUSHRECEIVEDFRAME_ENABLE;
0000d8  9503              STR      r5,[sp,#0xc]
;;;1993     dmainit.TransmitStoreForward = ETH_TRANSMITSTOREFORWARD_ENABLE;
0000da  1101              ASRS     r1,r0,#4
0000dc  9104              STR      r1,[sp,#0x10]
;;;1994     dmainit.TransmitThresholdControl = ETH_TRANSMITTHRESHOLDCONTROL_64BYTES;
0000de  9505              STR      r5,[sp,#0x14]
;;;1995     dmainit.ForwardErrorFrames = ETH_FORWARDERRORFRAMES_DISABLE;
0000e0  9506              STR      r5,[sp,#0x18]
;;;1996     dmainit.ForwardUndersizedGoodFrames = ETH_FORWARDUNDERSIZEDGOODFRAMES_DISABLE;
0000e2  9507              STR      r5,[sp,#0x1c]
;;;1997     dmainit.ReceiveThresholdControl = ETH_RECEIVEDTHRESHOLDCONTROL_64BYTES;
0000e4  9508              STR      r5,[sp,#0x20]
;;;1998     dmainit.SecondFrameOperate = ETH_SECONDFRAMEOPERARTE_ENABLE;
0000e6  2104              MOVS     r1,#4
0000e8  9109              STR      r1,[sp,#0x24]
;;;1999     dmainit.AddressAlignedBeats = ETH_ADDRESSALIGNEDBEATS_ENABLE;
0000ea  900a              STR      r0,[sp,#0x28]
;;;2000     dmainit.FixedBurst = ETH_FIXEDBURST_ENABLE;
0000ec  1240              ASRS     r0,r0,#9
0000ee  900b              STR      r0,[sp,#0x2c]
;;;2001     dmainit.RxDMABurstLength = ETH_RXDMABURSTLENGTH_32BEAT;
0000f0  0180              LSLS     r0,r0,#6
0000f2  900c              STR      r0,[sp,#0x30]
;;;2002     dmainit.TxDMABurstLength = ETH_TXDMABURSTLENGTH_32BEAT;
0000f4  1240              ASRS     r0,r0,#9
0000f6  900d              STR      r0,[sp,#0x34]
;;;2003     dmainit.DescriptorSkipLength = 0x0U;
0000f8  950e              STR      r5,[sp,#0x38]
;;;2004     dmainit.DMAArbitration = ETH_DMAARBITRATION_ROUNDROBIN_RXTX_1_1;
0000fa  950f              STR      r5,[sp,#0x3c]
;;;2005   
;;;2006     /* Get the ETHERNET DMAOMR value */
;;;2007     tmpreg1 = (heth->Instance)->DMAOMR;
0000fc  6820              LDR      r0,[r4,#0]
0000fe  f5005080          ADD      r0,r0,#0x1000
000102  6981              LDR      r1,[r0,#0x18]
;;;2008     /* Clear xx bits */
;;;2009     tmpreg1 &= ETH_DMAOMR_CLEAR_MASK;
000104  4a1d              LDR      r2,|L8.380|
000106  4011              ANDS     r1,r1,r2
;;;2010   
;;;2011     /* Set the DT bit according to ETH DropTCPIPChecksumErrorFrame value */
;;;2012     /* Set the RSF bit according to ETH ReceiveStoreForward value */
;;;2013     /* Set the DFF bit according to ETH FlushReceivedFrame value */
;;;2014     /* Set the TSF bit according to ETH TransmitStoreForward value */
;;;2015     /* Set the TTC bit according to ETH TransmitThresholdControl value */
;;;2016     /* Set the FEF bit according to ETH ForwardErrorFrames value */
;;;2017     /* Set the FUF bit according to ETH ForwardUndersizedGoodFrames value */
;;;2018     /* Set the RTC bit according to ETH ReceiveThresholdControl value */
;;;2019     /* Set the OSF bit according to ETH SecondFrameOperate value */
;;;2020     tmpreg1 |= (uint32_t)(dmainit.DropTCPIPChecksumErrorFrame |
000108  4a1d              LDR      r2,|L8.384|
00010a  430a              ORRS     r2,r2,r1
;;;2021                           dmainit.ReceiveStoreForward |
;;;2022                           dmainit.FlushReceivedFrame |
;;;2023                           dmainit.TransmitStoreForward |
;;;2024                           dmainit.TransmitThresholdControl |
;;;2025                           dmainit.ForwardErrorFrames |
;;;2026                           dmainit.ForwardUndersizedGoodFrames |
;;;2027                           dmainit.ReceiveThresholdControl |
;;;2028                           dmainit.SecondFrameOperate);
;;;2029   
;;;2030     /* Write to ETHERNET DMAOMR */
;;;2031     (heth->Instance)->DMAOMR = (uint32_t)tmpreg1;
00010c  6182              STR      r2,[r0,#0x18]
;;;2032   
;;;2033     /* Wait until the write operation will be taken into account:
;;;2034        at least four TX_CLK/RX_CLK clock cycles */
;;;2035     tmpreg1 = (heth->Instance)->DMAOMR;
00010e  6820              LDR      r0,[r4,#0]
000110  f5005080          ADD      r0,r0,#0x1000
000114  6985              LDR      r5,[r0,#0x18]
;;;2036     HAL_Delay(ETH_REG_WRITE_DELAY);
000116  2001              MOVS     r0,#1
000118  f7fffffe          BL       HAL_Delay
;;;2037     (heth->Instance)->DMAOMR = tmpreg1;
00011c  6820              LDR      r0,[r4,#0]
00011e  f5005080          ADD      r0,r0,#0x1000
000122  e000              B        |L8.294|
                  |L8.292|
000124  e014              B        |L8.336|
                  |L8.294|
000126  6185              STR      r5,[r0,#0x18]
;;;2038   
;;;2039     /*----------------------- ETHERNET DMABMR Configuration ------------------*/
;;;2040     /* Set the AAL bit according to ETH AddressAlignedBeats value */
;;;2041     /* Set the FB bit according to ETH FixedBurst value */
;;;2042     /* Set the RPBL and 4*PBL bits according to ETH RxDMABurstLength value */
;;;2043     /* Set the PBL and 4*PBL bits according to ETH TxDMABurstLength value */
;;;2044     /* Set the DSL bit according to ETH DesciptorSkipLength value */
;;;2045     /* Set the PR and DA bits according to ETH DMAArbitration value */
;;;2046     (heth->Instance)->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats |
000128  6820              LDR      r0,[r4,#0]
00012a  4916              LDR      r1,|L8.388|
00012c  f5005080          ADD      r0,r0,#0x1000
000130  6001              STR      r1,[r0,#0]
;;;2047                                           dmainit.FixedBurst |
;;;2048                                           dmainit.RxDMABurstLength |    /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
;;;2049                                           dmainit.TxDMABurstLength |
;;;2050                                           (dmainit.DescriptorSkipLength << 2U) |
;;;2051                                           dmainit.DMAArbitration |
;;;2052                                           ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */
;;;2053   
;;;2054     /* Wait until the write operation will be taken into account:
;;;2055        at least four TX_CLK/RX_CLK clock cycles */
;;;2056     tmpreg1 = (heth->Instance)->DMABMR;
000132  6820              LDR      r0,[r4,#0]
000134  f5005080          ADD      r0,r0,#0x1000
000138  6805              LDR      r5,[r0,#0]
;;;2057     HAL_Delay(ETH_REG_WRITE_DELAY);
00013a  2001              MOVS     r0,#1
00013c  f7fffffe          BL       HAL_Delay
;;;2058     (heth->Instance)->DMABMR = tmpreg1;
000140  6820              LDR      r0,[r4,#0]
000142  f5005080          ADD      r0,r0,#0x1000
000146  6005              STR      r5,[r0,#0]
;;;2059   
;;;2060     if ((heth->Init).RxMode == ETH_RXINTERRUPT_MODE)
000148  69a0              LDR      r0,[r4,#0x18]
00014a  2801              CMP      r0,#1
00014c  d004              BEQ      |L8.344|
00014e  e00a              B        |L8.358|
                  |L8.336|
000150  f44f6080          MOV      r0,#0x400             ;1847
000154  9016              STR      r0,[sp,#0x58]         ;1847
000156  e768              B        |L8.42|
                  |L8.344|
;;;2061     {
;;;2062       /* Enable the Ethernet Rx Interrupt */
;;;2063       __HAL_ETH_DMA_ENABLE_IT((heth), ETH_DMA_IT_NIS | ETH_DMA_IT_R);
000158  6820              LDR      r0,[r4,#0]
00015a  f5005080          ADD      r0,r0,#0x1000
00015e  69c1              LDR      r1,[r0,#0x1c]
000160  4a09              LDR      r2,|L8.392|
000162  4311              ORRS     r1,r1,r2
000164  61c1              STR      r1,[r0,#0x1c]
                  |L8.358|
;;;2064     }
;;;2065   
;;;2066     /* Initialize MAC address in ethernet MAC */
;;;2067     ETH_MACAddressConfig(heth, ETH_MAC_ADDRESS0, heth->Init.MACAddr);
000166  6962              LDR      r2,[r4,#0x14]
000168  b02d              ADD      sp,sp,#0xb4
00016a  4620              MOV      r0,r4
00016c  e8bd40f0          POP      {r4-r7,lr}
000170  2100              MOVS     r1,#0
000172  f7ffbffe          B.W      ETH_MACAddressConfig
;;;2068   }
;;;2069   
                          ENDP

000176  0000              DCW      0x0000
                  |L8.376|
                          DCD      0xff20810f
                  |L8.380|
                          DCD      0xf8de3f23
                  |L8.384|
                          DCD      0x02200004
                  |L8.388|
                          DCD      0x02c12000
                  |L8.392|
                          DCD      0x00010040

                          AREA ||i.ETH_MACReceptionDisable||, CODE, READONLY, ALIGN=1

                  ETH_MACReceptionDisable PROC
;;;2169     */
;;;2170   static void ETH_MACReceptionDisable(ETH_HandleTypeDef *heth)
000000  b538              PUSH     {r3-r5,lr}
;;;2171   {
000002  4604              MOV      r4,r0
;;;2172     __IO uint32_t tmpreg1 = 0U;
;;;2173   
;;;2174     /* Disable the MAC reception */
;;;2175     (heth->Instance)->MACCR &= ~ETH_MACCR_RE;
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f0210104          BIC      r1,r1,#4
00000c  6001              STR      r1,[r0,#0]
;;;2176   
;;;2177     /* Wait until the write operation will be taken into account:
;;;2178        at least four TX_CLK/RX_CLK clock cycles */
;;;2179     tmpreg1 = (heth->Instance)->MACCR;
00000e  6820              LDR      r0,[r4,#0]
000010  6800              LDR      r0,[r0,#0]
000012  9000              STR      r0,[sp,#0]
;;;2180     ETH_Delay(ETH_REG_WRITE_DELAY);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       ETH_Delay
;;;2181     (heth->Instance)->MACCR = tmpreg1;
00001a  6821              LDR      r1,[r4,#0]
00001c  9800              LDR      r0,[sp,#0]
00001e  6008              STR      r0,[r1,#0]
;;;2182   }
000020  bd38              POP      {r3-r5,pc}
;;;2183   
                          ENDP


                          AREA ||i.ETH_MACReceptionEnable||, CODE, READONLY, ALIGN=1

                  ETH_MACReceptionEnable PROC
;;;2149     */
;;;2150   static void ETH_MACReceptionEnable(ETH_HandleTypeDef *heth)
000000  b538              PUSH     {r3-r5,lr}
;;;2151   {
000002  4604              MOV      r4,r0
;;;2152     __IO uint32_t tmpreg1 = 0U;
;;;2153   
;;;2154     /* Enable the MAC reception */
;;;2155     (heth->Instance)->MACCR |= ETH_MACCR_RE;
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f0410104          ORR      r1,r1,#4
00000c  6001              STR      r1,[r0,#0]
;;;2156   
;;;2157     /* Wait until the write operation will be taken into account:
;;;2158        at least four TX_CLK/RX_CLK clock cycles */
;;;2159     tmpreg1 = (heth->Instance)->MACCR;
00000e  6820              LDR      r0,[r4,#0]
000010  6800              LDR      r0,[r0,#0]
000012  9000              STR      r0,[sp,#0]
;;;2160     ETH_Delay(ETH_REG_WRITE_DELAY);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       ETH_Delay
;;;2161     (heth->Instance)->MACCR = tmpreg1;
00001a  6821              LDR      r1,[r4,#0]
00001c  9800              LDR      r0,[sp,#0]
00001e  6008              STR      r0,[r1,#0]
;;;2162   }
000020  bd38              POP      {r3-r5,pc}
;;;2163   
                          ENDP


                          AREA ||i.ETH_MACTransmissionDisable||, CODE, READONLY, ALIGN=1

                  ETH_MACTransmissionDisable PROC
;;;2129     */
;;;2130   static void ETH_MACTransmissionDisable(ETH_HandleTypeDef *heth)
000000  b538              PUSH     {r3-r5,lr}
;;;2131   {
000002  4604              MOV      r4,r0
;;;2132     __IO uint32_t tmpreg1 = 0U;
;;;2133   
;;;2134     /* Disable the MAC transmission */
;;;2135     (heth->Instance)->MACCR &= ~ETH_MACCR_TE;
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f0210108          BIC      r1,r1,#8
00000c  6001              STR      r1,[r0,#0]
;;;2136   
;;;2137     /* Wait until the write operation will be taken into account:
;;;2138        at least four TX_CLK/RX_CLK clock cycles */
;;;2139     tmpreg1 = (heth->Instance)->MACCR;
00000e  6820              LDR      r0,[r4,#0]
000010  6800              LDR      r0,[r0,#0]
000012  9000              STR      r0,[sp,#0]
;;;2140     ETH_Delay(ETH_REG_WRITE_DELAY);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       ETH_Delay
;;;2141     (heth->Instance)->MACCR = tmpreg1;
00001a  6821              LDR      r1,[r4,#0]
00001c  9800              LDR      r0,[sp,#0]
00001e  6008              STR      r0,[r1,#0]
;;;2142   }
000020  bd38              POP      {r3-r5,pc}
;;;2143   
                          ENDP


                          AREA ||i.ETH_MACTransmissionEnable||, CODE, READONLY, ALIGN=1

                  ETH_MACTransmissionEnable PROC
;;;2109     */
;;;2110   static void ETH_MACTransmissionEnable(ETH_HandleTypeDef *heth)
000000  b538              PUSH     {r3-r5,lr}
;;;2111   {
000002  4604              MOV      r4,r0
;;;2112     __IO uint32_t tmpreg1 = 0U;
;;;2113   
;;;2114     /* Enable the MAC transmission */
;;;2115     (heth->Instance)->MACCR |= ETH_MACCR_TE;
000004  6820              LDR      r0,[r4,#0]
000006  6801              LDR      r1,[r0,#0]
000008  f0410108          ORR      r1,r1,#8
00000c  6001              STR      r1,[r0,#0]
;;;2116   
;;;2117     /* Wait until the write operation will be taken into account:
;;;2118        at least four TX_CLK/RX_CLK clock cycles */
;;;2119     tmpreg1 = (heth->Instance)->MACCR;
00000e  6820              LDR      r0,[r4,#0]
000010  6800              LDR      r0,[r0,#0]
000012  9000              STR      r0,[sp,#0]
;;;2120     ETH_Delay(ETH_REG_WRITE_DELAY);
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       ETH_Delay
;;;2121     (heth->Instance)->MACCR = tmpreg1;
00001a  6821              LDR      r1,[r4,#0]
00001c  9800              LDR      r0,[sp,#0]
00001e  6008              STR      r0,[r1,#0]
;;;2122   }
000020  bd38              POP      {r3-r5,pc}
;;;2123   
                          ENDP


                          AREA ||i.HAL_ETH_ConfigDMA||, CODE, READONLY, ALIGN=2

                  HAL_ETH_ConfigDMA PROC
;;;1692     */
;;;1693   HAL_StatusTypeDef HAL_ETH_ConfigDMA(ETH_HandleTypeDef *heth, ETH_DMAInitTypeDef *dmaconf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1694   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1695     uint32_t tmpreg1 = 0U;
;;;1696   
;;;1697     /* Process Locked */
;;;1698     __HAL_LOCK(heth);
000008  f8950045          LDRB     r0,[r5,#0x45]
00000c  2801              CMP      r0,#1
00000e  d04d              BEQ      |L13.172|
000010  2701              MOVS     r7,#1
000012  f8857045          STRB     r7,[r5,#0x45]
;;;1699   
;;;1700     /* Set the ETH peripheral state to BUSY */
;;;1701     heth->State = HAL_ETH_STATE_BUSY;
000016  2002              MOVS     r0,#2
000018  f8850044          STRB     r0,[r5,#0x44]
;;;1702   
;;;1703     /* Check parameters */
;;;1704     assert_param(IS_ETH_DROP_TCPIP_CHECKSUM_FRAME(dmaconf->DropTCPIPChecksumErrorFrame));
;;;1705     assert_param(IS_ETH_RECEIVE_STORE_FORWARD(dmaconf->ReceiveStoreForward));
;;;1706     assert_param(IS_ETH_FLUSH_RECEIVE_FRAME(dmaconf->FlushReceivedFrame));
;;;1707     assert_param(IS_ETH_TRANSMIT_STORE_FORWARD(dmaconf->TransmitStoreForward));
;;;1708     assert_param(IS_ETH_TRANSMIT_THRESHOLD_CONTROL(dmaconf->TransmitThresholdControl));
;;;1709     assert_param(IS_ETH_FORWARD_ERROR_FRAMES(dmaconf->ForwardErrorFrames));
;;;1710     assert_param(IS_ETH_FORWARD_UNDERSIZED_GOOD_FRAMES(dmaconf->ForwardUndersizedGoodFrames));
;;;1711     assert_param(IS_ETH_RECEIVE_THRESHOLD_CONTROL(dmaconf->ReceiveThresholdControl));
;;;1712     assert_param(IS_ETH_SECOND_FRAME_OPERATE(dmaconf->SecondFrameOperate));
;;;1713     assert_param(IS_ETH_ADDRESS_ALIGNED_BEATS(dmaconf->AddressAlignedBeats));
;;;1714     assert_param(IS_ETH_FIXED_BURST(dmaconf->FixedBurst));
;;;1715     assert_param(IS_ETH_RXDMA_BURST_LENGTH(dmaconf->RxDMABurstLength));
;;;1716     assert_param(IS_ETH_TXDMA_BURST_LENGTH(dmaconf->TxDMABurstLength));
;;;1717     assert_param(IS_ETH_DMA_DESC_SKIP_LENGTH(dmaconf->DescriptorSkipLength));
;;;1718     assert_param(IS_ETH_DMA_ARBITRATION_ROUNDROBIN_RXTX(dmaconf->DMAArbitration));
;;;1719   
;;;1720     /*----------------------- ETHERNET DMAOMR Configuration --------------------*/
;;;1721     /* Get the ETHERNET DMAOMR value */
;;;1722     tmpreg1 = (heth->Instance)->DMAOMR;
00001c  6828              LDR      r0,[r5,#0]
00001e  f5005080          ADD      r0,r0,#0x1000
000022  6982              LDR      r2,[r0,#0x18]
;;;1723     /* Clear xx bits */
;;;1724     tmpreg1 &= ETH_DMAOMR_CLEAR_MASK;
000024  4922              LDR      r1,|L13.176|
000026  400a              ANDS     r2,r2,r1
;;;1725   
;;;1726     tmpreg1 |= (uint32_t)(dmaconf->DropTCPIPChecksumErrorFrame |
000028  e9d41300          LDRD     r1,r3,[r4,#0]
00002c  4319              ORRS     r1,r1,r3
00002e  e9d43602          LDRD     r3,r6,[r4,#8]
000032  4333              ORRS     r3,r3,r6
000034  4319              ORRS     r1,r1,r3
000036  6923              LDR      r3,[r4,#0x10]
000038  4319              ORRS     r1,r1,r3
00003a  6963              LDR      r3,[r4,#0x14]
00003c  4319              ORRS     r1,r1,r3
00003e  69a3              LDR      r3,[r4,#0x18]
000040  4319              ORRS     r1,r1,r3
000042  69e3              LDR      r3,[r4,#0x1c]
000044  4319              ORRS     r1,r1,r3
000046  6a23              LDR      r3,[r4,#0x20]
000048  4319              ORRS     r1,r1,r3
00004a  4311              ORRS     r1,r1,r2
;;;1727                           dmaconf->ReceiveStoreForward |
;;;1728                           dmaconf->FlushReceivedFrame |
;;;1729                           dmaconf->TransmitStoreForward |
;;;1730                           dmaconf->TransmitThresholdControl |
;;;1731                           dmaconf->ForwardErrorFrames |
;;;1732                           dmaconf->ForwardUndersizedGoodFrames |
;;;1733                           dmaconf->ReceiveThresholdControl |
;;;1734                           dmaconf->SecondFrameOperate);
;;;1735   
;;;1736     /* Write to ETHERNET DMAOMR */
;;;1737     (heth->Instance)->DMAOMR = (uint32_t)tmpreg1;
00004c  6181              STR      r1,[r0,#0x18]
;;;1738   
;;;1739     /* Wait until the write operation will be taken into account:
;;;1740     at least four TX_CLK/RX_CLK clock cycles */
;;;1741     tmpreg1 = (heth->Instance)->DMAOMR;
00004e  6828              LDR      r0,[r5,#0]
000050  f5005080          ADD      r0,r0,#0x1000
000054  6986              LDR      r6,[r0,#0x18]
;;;1742     HAL_Delay(ETH_REG_WRITE_DELAY);
000056  2001              MOVS     r0,#1
000058  f7fffffe          BL       HAL_Delay
;;;1743     (heth->Instance)->DMAOMR = tmpreg1;
00005c  6828              LDR      r0,[r5,#0]
00005e  f5005080          ADD      r0,r0,#0x1000
000062  6186              STR      r6,[r0,#0x18]
;;;1744   
;;;1745     /*----------------------- ETHERNET DMABMR Configuration --------------------*/
;;;1746     (heth->Instance)->DMABMR = (uint32_t)(dmaconf->AddressAlignedBeats |
000064  e9d40109          LDRD     r0,r1,[r4,#0x24]
000068  4308              ORRS     r0,r0,r1
00006a  e9d4120b          LDRD     r1,r2,[r4,#0x2c]
00006e  4311              ORRS     r1,r1,r2
000070  4308              ORRS     r0,r0,r1
000072  6b61              LDR      r1,[r4,#0x34]
000074  ea400081          ORR      r0,r0,r1,LSL #2
000078  6ba1              LDR      r1,[r4,#0x38]
00007a  4308              ORRS     r0,r0,r1
00007c  f4400100          ORR      r1,r0,#0x800000
000080  6828              LDR      r0,[r5,#0]
000082  f5005080          ADD      r0,r0,#0x1000
000086  6001              STR      r1,[r0,#0]
;;;1747                                           dmaconf->FixedBurst |
;;;1748                                           dmaconf->RxDMABurstLength | /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
;;;1749                                           dmaconf->TxDMABurstLength |
;;;1750                                           (dmaconf->DescriptorSkipLength << 2U) |
;;;1751                                           dmaconf->DMAArbitration |
;;;1752                                           ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */
;;;1753   
;;;1754     /* Wait until the write operation will be taken into account:
;;;1755        at least four TX_CLK/RX_CLK clock cycles */
;;;1756     tmpreg1 = (heth->Instance)->DMABMR;
000088  6828              LDR      r0,[r5,#0]
00008a  f5005080          ADD      r0,r0,#0x1000
00008e  6804              LDR      r4,[r0,#0]
;;;1757     HAL_Delay(ETH_REG_WRITE_DELAY);
000090  2001              MOVS     r0,#1
000092  f7fffffe          BL       HAL_Delay
;;;1758     (heth->Instance)->DMABMR = tmpreg1;
000096  6828              LDR      r0,[r5,#0]
000098  f5005080          ADD      r0,r0,#0x1000
00009c  6004              STR      r4,[r0,#0]
;;;1759   
;;;1760     /* Set the ETH state to Ready */
;;;1761     heth->State = HAL_ETH_STATE_READY;
00009e  f8857044          STRB     r7,[r5,#0x44]
;;;1762   
;;;1763     /* Process Unlocked */
;;;1764     __HAL_UNLOCK(heth);
0000a2  2000              MOVS     r0,#0
0000a4  f8850045          STRB     r0,[r5,#0x45]
                  |L13.168|
;;;1765   
;;;1766     /* Return function status */
;;;1767     return HAL_OK;
;;;1768   }
0000a8  e8bd81f0          POP      {r4-r8,pc}
                  |L13.172|
0000ac  2002              MOVS     r0,#2                 ;1698
0000ae  e7fb              B        |L13.168|
;;;1769   
                          ENDP

                  |L13.176|
                          DCD      0xf8de3f23

                          AREA ||i.HAL_ETH_ConfigMAC||, CODE, READONLY, ALIGN=2

                  HAL_ETH_ConfigMAC PROC
;;;1525     */
;;;1526   HAL_StatusTypeDef HAL_ETH_ConfigMAC(ETH_HandleTypeDef *heth, ETH_MACInitTypeDef *macconf)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1527   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1528     uint32_t tmpreg1 = 0U;
;;;1529   
;;;1530     /* Process Locked */
;;;1531     __HAL_LOCK(heth);
000008  f8950045          LDRB     r0,[r5,#0x45]
00000c  2801              CMP      r0,#1
00000e  d075              BEQ      |L14.252|
000010  2601              MOVS     r6,#1
000012  f8856045          STRB     r6,[r5,#0x45]
;;;1532   
;;;1533     /* Set the ETH peripheral state to BUSY */
;;;1534     heth->State = HAL_ETH_STATE_BUSY;
000016  2002              MOVS     r0,#2
000018  f8850044          STRB     r0,[r5,#0x44]
;;;1535   
;;;1536     assert_param(IS_ETH_SPEED(heth->Init.Speed));
;;;1537     assert_param(IS_ETH_DUPLEX_MODE(heth->Init.DuplexMode));
;;;1538   
;;;1539     if (macconf != NULL)
00001c  2c00              CMP      r4,#0
00001e  d070              BEQ      |L14.258|
;;;1540     {
;;;1541       /* Check the parameters */
;;;1542       assert_param(IS_ETH_WATCHDOG(macconf->Watchdog));
;;;1543       assert_param(IS_ETH_JABBER(macconf->Jabber));
;;;1544       assert_param(IS_ETH_INTER_FRAME_GAP(macconf->InterFrameGap));
;;;1545       assert_param(IS_ETH_CARRIER_SENSE(macconf->CarrierSense));
;;;1546       assert_param(IS_ETH_RECEIVE_OWN(macconf->ReceiveOwn));
;;;1547       assert_param(IS_ETH_LOOPBACK_MODE(macconf->LoopbackMode));
;;;1548       assert_param(IS_ETH_CHECKSUM_OFFLOAD(macconf->ChecksumOffload));
;;;1549       assert_param(IS_ETH_RETRY_TRANSMISSION(macconf->RetryTransmission));
;;;1550       assert_param(IS_ETH_AUTOMATIC_PADCRC_STRIP(macconf->AutomaticPadCRCStrip));
;;;1551       assert_param(IS_ETH_BACKOFF_LIMIT(macconf->BackOffLimit));
;;;1552       assert_param(IS_ETH_DEFERRAL_CHECK(macconf->DeferralCheck));
;;;1553       assert_param(IS_ETH_RECEIVE_ALL(macconf->ReceiveAll));
;;;1554       assert_param(IS_ETH_SOURCE_ADDR_FILTER(macconf->SourceAddrFilter));
;;;1555       assert_param(IS_ETH_CONTROL_FRAMES(macconf->PassControlFrames));
;;;1556       assert_param(IS_ETH_BROADCAST_FRAMES_RECEPTION(macconf->BroadcastFramesReception));
;;;1557       assert_param(IS_ETH_DESTINATION_ADDR_FILTER(macconf->DestinationAddrFilter));
;;;1558       assert_param(IS_ETH_PROMISCUOUS_MODE(macconf->PromiscuousMode));
;;;1559       assert_param(IS_ETH_MULTICAST_FRAMES_FILTER(macconf->MulticastFramesFilter));
;;;1560       assert_param(IS_ETH_UNICAST_FRAMES_FILTER(macconf->UnicastFramesFilter));
;;;1561       assert_param(IS_ETH_PAUSE_TIME(macconf->PauseTime));
;;;1562       assert_param(IS_ETH_ZEROQUANTA_PAUSE(macconf->ZeroQuantaPause));
;;;1563       assert_param(IS_ETH_PAUSE_LOW_THRESHOLD(macconf->PauseLowThreshold));
;;;1564       assert_param(IS_ETH_UNICAST_PAUSE_FRAME_DETECT(macconf->UnicastPauseFrameDetect));
;;;1565       assert_param(IS_ETH_RECEIVE_FLOWCONTROL(macconf->ReceiveFlowControl));
;;;1566       assert_param(IS_ETH_TRANSMIT_FLOWCONTROL(macconf->TransmitFlowControl));
;;;1567       assert_param(IS_ETH_VLAN_TAG_COMPARISON(macconf->VLANTagComparison));
;;;1568       assert_param(IS_ETH_VLAN_TAG_IDENTIFIER(macconf->VLANTagIdentifier));
;;;1569   
;;;1570       /*------------------------ ETHERNET MACCR Configuration --------------------*/
;;;1571       /* Get the ETHERNET MACCR value */
;;;1572       tmpreg1 = (heth->Instance)->MACCR;
000020  6828              LDR      r0,[r5,#0]
000022  6802              LDR      r2,[r0,#0]
;;;1573       /* Clear WD, PCE, PS, TE and RE bits */
;;;1574       tmpreg1 &= ETH_MACCR_CLEAR_MASK;
000024  4941              LDR      r1,|L14.300|
000026  400a              ANDS     r2,r2,r1
;;;1575   
;;;1576       tmpreg1 |= (uint32_t)(macconf->Watchdog |
000028  e9d41300          LDRD     r1,r3,[r4,#0]
00002c  4319              ORRS     r1,r1,r3
00002e  e9d43702          LDRD     r3,r7,[r4,#8]
000032  433b              ORRS     r3,r3,r7
000034  4319              ORRS     r1,r1,r3
000036  68ab              LDR      r3,[r5,#8]
000038  4319              ORRS     r1,r1,r3
00003a  6923              LDR      r3,[r4,#0x10]
00003c  4319              ORRS     r1,r1,r3
00003e  6963              LDR      r3,[r4,#0x14]
000040  4319              ORRS     r1,r1,r3
000042  68eb              LDR      r3,[r5,#0xc]
000044  4319              ORRS     r1,r1,r3
000046  69a3              LDR      r3,[r4,#0x18]
000048  4319              ORRS     r1,r1,r3
00004a  69e3              LDR      r3,[r4,#0x1c]
00004c  4319              ORRS     r1,r1,r3
00004e  6a23              LDR      r3,[r4,#0x20]
000050  4319              ORRS     r1,r1,r3
000052  6a63              LDR      r3,[r4,#0x24]
000054  4319              ORRS     r1,r1,r3
000056  6aa3              LDR      r3,[r4,#0x28]
000058  4319              ORRS     r1,r1,r3
00005a  4311              ORRS     r1,r1,r2
;;;1577                             macconf->Jabber |
;;;1578                             macconf->InterFrameGap |
;;;1579                             macconf->CarrierSense |
;;;1580                             (heth->Init).Speed |
;;;1581                             macconf->ReceiveOwn |
;;;1582                             macconf->LoopbackMode |
;;;1583                             (heth->Init).DuplexMode |
;;;1584                             macconf->ChecksumOffload |
;;;1585                             macconf->RetryTransmission |
;;;1586                             macconf->AutomaticPadCRCStrip |
;;;1587                             macconf->BackOffLimit |
;;;1588                             macconf->DeferralCheck);
;;;1589   
;;;1590       /* Write to ETHERNET MACCR */
;;;1591       (heth->Instance)->MACCR = (uint32_t)tmpreg1;
00005c  6001              STR      r1,[r0,#0]
;;;1592   
;;;1593       /* Wait until the write operation will be taken into account :
;;;1594       at least four TX_CLK/RX_CLK clock cycles */
;;;1595       tmpreg1 = (heth->Instance)->MACCR;
00005e  6828              LDR      r0,[r5,#0]
000060  6807              LDR      r7,[r0,#0]
;;;1596       HAL_Delay(ETH_REG_WRITE_DELAY);
000062  2001              MOVS     r0,#1
000064  f7fffffe          BL       HAL_Delay
;;;1597       (heth->Instance)->MACCR = tmpreg1;
000068  6828              LDR      r0,[r5,#0]
00006a  6007              STR      r7,[r0,#0]
;;;1598   
;;;1599       /*----------------------- ETHERNET MACFFR Configuration --------------------*/
;;;1600       /* Write to ETHERNET MACFFR */
;;;1601       (heth->Instance)->MACFFR = (uint32_t)(macconf->ReceiveAll |
00006c  e9d4010b          LDRD     r0,r1,[r4,#0x2c]
000070  4308              ORRS     r0,r0,r1
000072  e9d4120d          LDRD     r1,r2,[r4,#0x34]
000076  4311              ORRS     r1,r1,r2
000078  4308              ORRS     r0,r0,r1
00007a  6be1              LDR      r1,[r4,#0x3c]
00007c  4308              ORRS     r0,r0,r1
00007e  6c21              LDR      r1,[r4,#0x40]
000080  4308              ORRS     r0,r0,r1
000082  6c61              LDR      r1,[r4,#0x44]
000084  4308              ORRS     r0,r0,r1
000086  6ca1              LDR      r1,[r4,#0x48]
000088  4308              ORRS     r0,r0,r1
00008a  6829              LDR      r1,[r5,#0]
00008c  6048              STR      r0,[r1,#4]
;;;1602                                             macconf->SourceAddrFilter |
;;;1603                                             macconf->PassControlFrames |
;;;1604                                             macconf->BroadcastFramesReception |
;;;1605                                             macconf->DestinationAddrFilter |
;;;1606                                             macconf->PromiscuousMode |
;;;1607                                             macconf->MulticastFramesFilter |
;;;1608                                             macconf->UnicastFramesFilter);
;;;1609   
;;;1610       /* Wait until the write operation will be taken into account :
;;;1611       at least four TX_CLK/RX_CLK clock cycles */
;;;1612       tmpreg1 = (heth->Instance)->MACFFR;
00008e  6828              LDR      r0,[r5,#0]
000090  6847              LDR      r7,[r0,#4]
;;;1613       HAL_Delay(ETH_REG_WRITE_DELAY);
000092  2001              MOVS     r0,#1
000094  f7fffffe          BL       HAL_Delay
;;;1614       (heth->Instance)->MACFFR = tmpreg1;
000098  6828              LDR      r0,[r5,#0]
00009a  6047              STR      r7,[r0,#4]
;;;1615   
;;;1616       /*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/
;;;1617       /* Write to ETHERNET MACHTHR */
;;;1618       (heth->Instance)->MACHTHR = (uint32_t)macconf->HashTableHigh;
00009c  6829              LDR      r1,[r5,#0]
00009e  6ce0              LDR      r0,[r4,#0x4c]
0000a0  6088              STR      r0,[r1,#8]
;;;1619   
;;;1620       /* Write to ETHERNET MACHTLR */
;;;1621       (heth->Instance)->MACHTLR = (uint32_t)macconf->HashTableLow;
0000a2  6829              LDR      r1,[r5,#0]
0000a4  6d20              LDR      r0,[r4,#0x50]
0000a6  60c8              STR      r0,[r1,#0xc]
;;;1622       /*----------------------- ETHERNET MACFCR Configuration --------------------*/
;;;1623   
;;;1624       /* Get the ETHERNET MACFCR value */
;;;1625       tmpreg1 = (heth->Instance)->MACFCR;
0000a8  6828              LDR      r0,[r5,#0]
0000aa  6982              LDR      r2,[r0,#0x18]
;;;1626       /* Clear xx bits */
;;;1627       tmpreg1 &= ETH_MACFCR_CLEAR_MASK;
0000ac  f64f7141          MOV      r1,#0xff41
0000b0  400a              ANDS     r2,r2,r1
;;;1628   
;;;1629       tmpreg1 |= (uint32_t)((macconf->PauseTime << 16U) |
0000b2  e9d41316          LDRD     r1,r3,[r4,#0x58]
0000b6  4319              ORRS     r1,r1,r3
0000b8  f8b47054          LDRH     r7,[r4,#0x54]
0000bc  6e23              LDR      r3,[r4,#0x60]
0000be  ea434307          ORR      r3,r3,r7,LSL #16
0000c2  4319              ORRS     r1,r1,r3
0000c4  6e63              LDR      r3,[r4,#0x64]
0000c6  4319              ORRS     r1,r1,r3
0000c8  6ea3              LDR      r3,[r4,#0x68]
0000ca  4319              ORRS     r1,r1,r3
0000cc  4311              ORRS     r1,r1,r2
;;;1630                             macconf->ZeroQuantaPause |
;;;1631                             macconf->PauseLowThreshold |
;;;1632                             macconf->UnicastPauseFrameDetect |
;;;1633                             macconf->ReceiveFlowControl |
;;;1634                             macconf->TransmitFlowControl);
;;;1635   
;;;1636       /* Write to ETHERNET MACFCR */
;;;1637       (heth->Instance)->MACFCR = (uint32_t)tmpreg1;
0000ce  6181              STR      r1,[r0,#0x18]
;;;1638   
;;;1639       /* Wait until the write operation will be taken into account :
;;;1640       at least four TX_CLK/RX_CLK clock cycles */
;;;1641       tmpreg1 = (heth->Instance)->MACFCR;
0000d0  6828              LDR      r0,[r5,#0]
0000d2  6987              LDR      r7,[r0,#0x18]
;;;1642       HAL_Delay(ETH_REG_WRITE_DELAY);
0000d4  2001              MOVS     r0,#1
0000d6  f7fffffe          BL       HAL_Delay
;;;1643       (heth->Instance)->MACFCR = tmpreg1;
0000da  6828              LDR      r0,[r5,#0]
0000dc  6187              STR      r7,[r0,#0x18]
;;;1644   
;;;1645       /*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
;;;1646       (heth->Instance)->MACVLANTR = (uint32_t)(macconf->VLANTagComparison |
0000de  e9d4011b          LDRD     r0,r1,[r4,#0x6c]
0000e2  4308              ORRS     r0,r0,r1
0000e4  6829              LDR      r1,[r5,#0]
0000e6  61c8              STR      r0,[r1,#0x1c]
;;;1647                                                macconf->VLANTagIdentifier);
;;;1648   
;;;1649       /* Wait until the write operation will be taken into account :
;;;1650       at least four TX_CLK/RX_CLK clock cycles */
;;;1651       tmpreg1 = (heth->Instance)->MACVLANTR;
0000e8  6828              LDR      r0,[r5,#0]
0000ea  69c4              LDR      r4,[r0,#0x1c]
;;;1652       HAL_Delay(ETH_REG_WRITE_DELAY);
0000ec  2001              MOVS     r0,#1
0000ee  f7fffffe          BL       HAL_Delay
;;;1653       (heth->Instance)->MACVLANTR = tmpreg1;
0000f2  6828              LDR      r0,[r5,#0]
0000f4  61c4              STR      r4,[r0,#0x1c]
0000f6  e014              B        |L14.290|
0000f8  e000              B        |L14.252|
0000fa  e002              B        |L14.258|
                  |L14.252|
0000fc  2002              MOVS     r0,#2                 ;1531
                  |L14.254|
;;;1654     }
;;;1655     else /* macconf == NULL : here we just configure Speed and Duplex mode */
;;;1656     {
;;;1657       /*------------------------ ETHERNET MACCR Configuration --------------------*/
;;;1658       /* Get the ETHERNET MACCR value */
;;;1659       tmpreg1 = (heth->Instance)->MACCR;
;;;1660   
;;;1661       /* Clear FES and DM bits */
;;;1662       tmpreg1 &= ~(0x00004800U);
;;;1663   
;;;1664       tmpreg1 |= (uint32_t)(heth->Init.Speed | heth->Init.DuplexMode);
;;;1665   
;;;1666       /* Write to ETHERNET MACCR */
;;;1667       (heth->Instance)->MACCR = (uint32_t)tmpreg1;
;;;1668   
;;;1669       /* Wait until the write operation will be taken into account:
;;;1670       at least four TX_CLK/RX_CLK clock cycles */
;;;1671       tmpreg1 = (heth->Instance)->MACCR;
;;;1672       HAL_Delay(ETH_REG_WRITE_DELAY);
;;;1673       (heth->Instance)->MACCR = tmpreg1;
;;;1674     }
;;;1675   
;;;1676     /* Set the ETH state to Ready */
;;;1677     heth->State = HAL_ETH_STATE_READY;
;;;1678   
;;;1679     /* Process Unlocked */
;;;1680     __HAL_UNLOCK(heth);
;;;1681   
;;;1682     /* Return function status */
;;;1683     return HAL_OK;
;;;1684   }
0000fe  e8bd81f0          POP      {r4-r8,pc}
                  |L14.258|
000102  6828              LDR      r0,[r5,#0]            ;1659
000104  6801              LDR      r1,[r0,#0]            ;1659
000106  f4214290          BIC      r2,r1,#0x4800         ;1662
00010a  e9d51302          LDRD     r1,r3,[r5,#8]         ;1664
00010e  4319              ORRS     r1,r1,r3              ;1664
000110  4311              ORRS     r1,r1,r2              ;1664
000112  6001              STR      r1,[r0,#0]            ;1667
000114  6828              LDR      r0,[r5,#0]            ;1671
000116  6804              LDR      r4,[r0,#0]            ;1671
000118  2001              MOVS     r0,#1                 ;1672
00011a  f7fffffe          BL       HAL_Delay
00011e  6828              LDR      r0,[r5,#0]            ;1673
000120  6004              STR      r4,[r0,#0]            ;1673
                  |L14.290|
000122  f8056f44          STRB     r6,[r5,#0x44]!        ;1677
000126  2000              MOVS     r0,#0                 ;1680
000128  7068              STRB     r0,[r5,#1]            ;1680
00012a  e7e8              B        |L14.254|
;;;1685   
                          ENDP

                  |L14.300|
                          DCD      0xff20810f

                          AREA ||i.HAL_ETH_DMARxDescListInit||, CODE, READONLY, ALIGN=1

                  HAL_ETH_DMARxDescListInit PROC
;;;587      */
;;;588    HAL_StatusTypeDef HAL_ETH_DMARxDescListInit(ETH_HandleTypeDef *heth, ETH_DMADescTypeDef *DMARxDescTab, uint8_t *RxBuff, uint32_t RxBuffCount)
000000  b5f0              PUSH     {r4-r7,lr}
;;;589    {
;;;590      uint32_t i = 0U;
000002  2400              MOVS     r4,#0
;;;591      ETH_DMADescTypeDef *DMARxDesc;
;;;592    
;;;593      /* Process Locked */
;;;594      __HAL_LOCK(heth);
000004  f8905045          LDRB     r5,[r0,#0x45]
000008  2d01              CMP      r5,#1
00000a  d009              BEQ      |L15.32|
00000c  2701              MOVS     r7,#1
00000e  f8807045          STRB     r7,[r0,#0x45]
;;;595    
;;;596      /* Set the ETH peripheral state to BUSY */
;;;597      heth->State = HAL_ETH_STATE_BUSY;
000012  2502              MOVS     r5,#2
000014  f8805044          STRB     r5,[r0,#0x44]
;;;598    
;;;599      /* Set the Ethernet RxDesc pointer with the first one of the DMARxDescTab list */
;;;600      heth->RxDesc = DMARxDescTab;
000018  6281              STR      r1,[r0,#0x28]
;;;601    
;;;602      /* Fill each DMARxDesc descriptor with the right values */
;;;603      for (i = 0U; i < RxBuffCount; i++)
;;;604      {
;;;605        /* Get the pointer on the ith member of the Rx Desc list */
;;;606        DMARxDesc = DMARxDescTab + i;
;;;607    
;;;608        /* Set Own bit of the Rx descriptor Status */
;;;609        DMARxDesc->Status = ETH_DMARXDESC_OWN;
;;;610    
;;;611        /* Set Buffer1 size and Second Address Chained bit */
;;;612        DMARxDesc->ControlBufferSize = ETH_DMARXDESC_RCH | ETH_RX_BUF_SIZE;
00001a  f2445cf4          MOV      r12,#0x45f4
00001e  e019              B        |L15.84|
                  |L15.32|
000020  2002              MOVS     r0,#2                 ;594
;;;613    
;;;614        /* Set Buffer1 address pointer */
;;;615        DMARxDesc->Buffer1Addr = (uint32_t)(&RxBuff[i * ETH_RX_BUF_SIZE]);
;;;616    
;;;617        if ((heth->Init).RxMode == ETH_RXINTERRUPT_MODE)
;;;618        {
;;;619          /* Enable Ethernet DMA Rx Descriptor interrupt */
;;;620          DMARxDesc->ControlBufferSize &= ~ETH_DMARXDESC_DIC;
;;;621        }
;;;622    
;;;623        /* Initialize the next descriptor with the Next Descriptor Polling Enable */
;;;624        if (i < (RxBuffCount - 1U))
;;;625        {
;;;626          /* Set next descriptor address register with next descriptor base address */
;;;627          DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab + i + 1U);
;;;628        }
;;;629        else
;;;630        {
;;;631          /* For last descriptor, set next descriptor address register equal to the first descriptor base address */
;;;632          DMARxDesc->Buffer2NextDescAddr = (uint32_t)(DMARxDescTab);
;;;633        }
;;;634      }
;;;635    
;;;636      /* Set Receive Descriptor List Address Register */
;;;637      (heth->Instance)->DMARDLAR = (uint32_t) DMARxDescTab;
;;;638    
;;;639      /* Set ETH HAL State to Ready */
;;;640      heth->State = HAL_ETH_STATE_READY;
;;;641    
;;;642      /* Process Unlocked */
;;;643      __HAL_UNLOCK(heth);
;;;644    
;;;645      /* Return function status */
;;;646      return HAL_OK;
;;;647    }
000022  bdf0              POP      {r4-r7,pc}
                  |L15.36|
000024  eb011504          ADD      r5,r1,r4,LSL #4       ;606
000028  f04f4600          MOV      r6,#0x80000000        ;609
00002c  602e              STR      r6,[r5,#0]            ;609
00002e  f8c5c004          STR      r12,[r5,#4]           ;612
000032  ebc416c4          RSB      r6,r4,r4,LSL #7       ;615
000036  eb060646          ADD      r6,r6,r6,LSL #1       ;615
00003a  eb020686          ADD      r6,r2,r6,LSL #2       ;615
00003e  60ae              STR      r6,[r5,#8]            ;615
000040  6986              LDR      r6,[r0,#0x18]         ;617
000042  1e5e              SUBS     r6,r3,#1              ;624
000044  42b4              CMP      r4,r6                 ;624
000046  d203              BCS      |L15.80|
000048  f1050610          ADD      r6,r5,#0x10           ;627
00004c  60ee              STR      r6,[r5,#0xc]          ;627
00004e  e000              B        |L15.82|
                  |L15.80|
000050  60e9              STR      r1,[r5,#0xc]          ;632
                  |L15.82|
000052  1c64              ADDS     r4,r4,#1              ;603
                  |L15.84|
000054  429c              CMP      r4,r3                 ;603
000056  d3e5              BCC      |L15.36|
000058  6802              LDR      r2,[r0,#0]            ;637
00005a  f5025280          ADD      r2,r2,#0x1000         ;637
00005e  60d1              STR      r1,[r2,#0xc]          ;637
000060  f8807044          STRB     r7,[r0,#0x44]         ;640
000064  2100              MOVS     r1,#0                 ;643
000066  f8801045          STRB     r1,[r0,#0x45]         ;643
00006a  2000              MOVS     r0,#0                 ;646
00006c  bdf0              POP      {r4-r7,pc}
;;;648    
                          ENDP


                          AREA ||i.HAL_ETH_DMATxDescListInit||, CODE, READONLY, ALIGN=1

                  HAL_ETH_DMATxDescListInit PROC
;;;520      */
;;;521    HAL_StatusTypeDef HAL_ETH_DMATxDescListInit(ETH_HandleTypeDef *heth, ETH_DMADescTypeDef *DMATxDescTab, uint8_t *TxBuff, uint32_t TxBuffCount)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;522    {
;;;523      uint32_t i = 0U;
000004  2500              MOVS     r5,#0
;;;524      ETH_DMADescTypeDef *dmatxdesc;
;;;525    
;;;526      /* Process Locked */
;;;527      __HAL_LOCK(heth);
000006  f8904045          LDRB     r4,[r0,#0x45]
00000a  2c01              CMP      r4,#1
00000c  d00b              BEQ      |L16.38|
00000e  f04f0c01          MOV      r12,#1
000012  f880c045          STRB     r12,[r0,#0x45]
;;;528    
;;;529      /* Set the ETH peripheral state to BUSY */
;;;530      heth->State = HAL_ETH_STATE_BUSY;
000016  2402              MOVS     r4,#2
000018  f8804044          STRB     r4,[r0,#0x44]
;;;531    
;;;532      /* Set the DMATxDescToSet pointer with the first one of the DMATxDescTab list */
;;;533      heth->TxDesc = DMATxDescTab;
00001c  62c1              STR      r1,[r0,#0x2c]
;;;534    
;;;535      /* Fill each DMATxDesc descriptor with the right values */
;;;536      for (i = 0U; i < TxBuffCount; i++)
;;;537      {
;;;538        /* Get the pointer on the ith member of the Tx Desc list */
;;;539        dmatxdesc = DMATxDescTab + i;
;;;540    
;;;541        /* Set Second Address Chained bit */
;;;542        dmatxdesc->Status = ETH_DMATXDESC_TCH;
00001e  f44f1880          MOV      r8,#0x100000
;;;543    
;;;544        /* Set Buffer1 address pointer */
;;;545        dmatxdesc->Buffer1Addr = (uint32_t)(&TxBuff[i * ETH_TX_BUF_SIZE]);
;;;546    
;;;547        if ((heth->Init).ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
;;;548        {
;;;549          /* Set the DMA Tx descriptors checksum insertion */
;;;550          dmatxdesc->Status |= ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL;
;;;551        }
;;;552    
;;;553        /* Initialize the next descriptor with the Next Descriptor Polling Enable */
;;;554        if (i < (TxBuffCount - 1U))
000022  1e5f              SUBS     r7,r3,#1
000024  e01c              B        |L16.96|
                  |L16.38|
000026  2002              MOVS     r0,#2                 ;527
                  |L16.40|
;;;555        {
;;;556          /* Set next descriptor address register with next descriptor base address */
;;;557          dmatxdesc->Buffer2NextDescAddr = (uint32_t)(DMATxDescTab + i + 1U);
;;;558        }
;;;559        else
;;;560        {
;;;561          /* For last descriptor, set next descriptor address register equal to the first descriptor base address */
;;;562          dmatxdesc->Buffer2NextDescAddr = (uint32_t) DMATxDescTab;
;;;563        }
;;;564      }
;;;565    
;;;566      /* Set Transmit Descriptor List Address Register */
;;;567      (heth->Instance)->DMATDLAR = (uint32_t) DMATxDescTab;
;;;568    
;;;569      /* Set ETH HAL State to Ready */
;;;570      heth->State = HAL_ETH_STATE_READY;
;;;571    
;;;572      /* Process Unlocked */
;;;573      __HAL_UNLOCK(heth);
;;;574    
;;;575      /* Return function status */
;;;576      return HAL_OK;
;;;577    }
000028  e8bd83f0          POP      {r4-r9,pc}
                  |L16.44|
00002c  eb011405          ADD      r4,r1,r5,LSL #4       ;539
000030  f8c48000          STR      r8,[r4,#0]            ;542
000034  ebc516c5          RSB      r6,r5,r5,LSL #7       ;545
000038  eb060646          ADD      r6,r6,r6,LSL #1       ;545
00003c  eb020686          ADD      r6,r2,r6,LSL #2       ;545
000040  60a6              STR      r6,[r4,#8]            ;545
000042  69c6              LDR      r6,[r0,#0x1c]         ;547
000044  b926              CBNZ     r6,|L16.80|
000046  6826              LDR      r6,[r4,#0]            ;550
000048  f4460940          ORR      r9,r6,#0xc00000       ;550
00004c  f8c49000          STR      r9,[r4,#0]            ;550
                  |L16.80|
000050  42bd              CMP      r5,r7                 ;554
000052  d203              BCS      |L16.92|
000054  f1040610          ADD      r6,r4,#0x10           ;557
000058  60e6              STR      r6,[r4,#0xc]          ;557
00005a  e000              B        |L16.94|
                  |L16.92|
00005c  60e1              STR      r1,[r4,#0xc]          ;562
                  |L16.94|
00005e  1c6d              ADDS     r5,r5,#1              ;536
                  |L16.96|
000060  429d              CMP      r5,r3                 ;536
000062  d3e3              BCC      |L16.44|
000064  6802              LDR      r2,[r0,#0]            ;567
000066  f5025280          ADD      r2,r2,#0x1000         ;567
00006a  6111              STR      r1,[r2,#0x10]         ;567
00006c  f880c044          STRB     r12,[r0,#0x44]        ;570
000070  2100              MOVS     r1,#0                 ;573
000072  f8801045          STRB     r1,[r0,#0x45]         ;573
000076  2000              MOVS     r0,#0                 ;576
000078  e7d6              B        |L16.40|
;;;578    
                          ENDP


                          AREA ||i.HAL_ETH_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_ETH_DeInit PROC
;;;484      */
;;;485    HAL_StatusTypeDef HAL_ETH_DeInit(ETH_HandleTypeDef *heth)
000000  b510              PUSH     {r4,lr}
;;;486    {
000002  4604              MOV      r4,r0
;;;487      /* Set the ETH peripheral state to BUSY */
;;;488      heth->State = HAL_ETH_STATE_BUSY;
000004  2002              MOVS     r0,#2
000006  f8840044          STRB     r0,[r4,#0x44]
;;;489    
;;;490    #if (USE_HAL_ETH_REGISTER_CALLBACKS == 1)
;;;491      if (heth->MspDeInitCallback == NULL)
;;;492      {
;;;493        heth->MspDeInitCallback = HAL_ETH_MspDeInit;
;;;494      }
;;;495      /* De-Init the low level hardware : GPIO, CLOCK, NVIC. */
;;;496      heth->MspDeInitCallback(heth);
;;;497    #else
;;;498      /* De-Init the low level hardware : GPIO, CLOCK, NVIC. */
;;;499      HAL_ETH_MspDeInit(heth);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       HAL_ETH_MspDeInit
;;;500    #endif
;;;501    
;;;502      /* Set ETH HAL state to Disabled */
;;;503      heth->State = HAL_ETH_STATE_RESET;
000010  2000              MOVS     r0,#0
000012  f8040f44          STRB     r0,[r4,#0x44]!
;;;504    
;;;505      /* Release Lock */
;;;506      __HAL_UNLOCK(heth);
000016  7060              STRB     r0,[r4,#1]
;;;507    
;;;508      /* Return function status */
;;;509      return HAL_OK;
;;;510    }
000018  bd10              POP      {r4,pc}
;;;511    
                          ENDP


                          AREA ||i.HAL_ETH_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_ETH_ErrorCallback PROC
;;;1261     */
;;;1262   __weak void HAL_ETH_ErrorCallback(ETH_HandleTypeDef *heth)
000000  4770              BX       lr
;;;1263   {
;;;1264     /* Prevent unused argument(s) compilation warning */
;;;1265     UNUSED(heth);
;;;1266     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1267     the HAL_ETH_TxCpltCallback could be implemented in the user file
;;;1268     */
;;;1269   }
;;;1270   
                          ENDP


                          AREA ||i.HAL_ETH_GetReceivedFrame||, CODE, READONLY, ALIGN=1

                  HAL_ETH_GetReceivedFrame PROC
;;;992      */
;;;993    HAL_StatusTypeDef HAL_ETH_GetReceivedFrame(ETH_HandleTypeDef *heth)
000000  b510              PUSH     {r4,lr}
;;;994    {
;;;995      uint32_t framelength = 0U;
;;;996    
;;;997      /* Process Locked */
;;;998      __HAL_LOCK(heth);
000002  f8901045          LDRB     r1,[r0,#0x45]
000006  2901              CMP      r1,#1
000008  d013              BEQ      |L19.50|
00000a  2301              MOVS     r3,#1
00000c  f8803045          STRB     r3,[r0,#0x45]
;;;999    
;;;1000     /* Check the ETH state to BUSY */
;;;1001     heth->State = HAL_ETH_STATE_BUSY;
000010  2102              MOVS     r1,#2
000012  f8801044          STRB     r1,[r0,#0x44]
;;;1002   
;;;1003     /* Check if segment is not owned by DMA */
;;;1004     /* (((heth->RxDesc->Status & ETH_DMARXDESC_OWN) == (uint32_t)RESET) && ((heth->RxDesc->Status & ETH_DMARXDESC_LS) != (uint32_t)RESET)) */
;;;1005     if (((heth->RxDesc->Status & ETH_DMARXDESC_OWN) == (uint32_t)RESET))
000016  6a81              LDR      r1,[r0,#0x28]
000018  680a              LDR      r2,[r1,#0]
00001a  2400              MOVS     r4,#0
00001c  2a00              CMP      r2,#0
00001e  db29              BLT      |L19.116|
;;;1006     {
;;;1007       /* Check if last segment */
;;;1008       if (((heth->RxDesc->Status & ETH_DMARXDESC_LS) != (uint32_t)RESET))
000020  680a              LDR      r2,[r1,#0]
000022  05d2              LSLS     r2,r2,#23
000024  d518              BPL      |L19.88|
;;;1009       {
;;;1010         /* increment segment count */
;;;1011         (heth->RxFrameInfos).SegCount++;
000026  6b82              LDR      r2,[r0,#0x38]
000028  1c52              ADDS     r2,r2,#1
00002a  6382              STR      r2,[r0,#0x38]
;;;1012   
;;;1013         /* Check if last segment is first segment: one segment contains the frame */
;;;1014         if ((heth->RxFrameInfos).SegCount == 1U)
00002c  2a01              CMP      r2,#1
00002e  d002              BEQ      |L19.54|
000030  e002              B        |L19.56|
                  |L19.50|
000032  2002              MOVS     r0,#2                 ;998
;;;1015         {
;;;1016           (heth->RxFrameInfos).FSRxDesc = heth->RxDesc;
;;;1017         }
;;;1018   
;;;1019         heth->RxFrameInfos.LSRxDesc = heth->RxDesc;
;;;1020   
;;;1021         /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
;;;1022         framelength = (((heth->RxDesc)->Status & ETH_DMARXDESC_FL) >> ETH_DMARXDESC_FRAMELENGTHSHIFT) - 4U;
;;;1023         heth->RxFrameInfos.length = framelength;
;;;1024   
;;;1025         /* Get the address of the buffer start address */
;;;1026         heth->RxFrameInfos.buffer = ((heth->RxFrameInfos).FSRxDesc)->Buffer1Addr;
;;;1027         /* point to next descriptor */
;;;1028         heth->RxDesc = (ETH_DMADescTypeDef *)((heth->RxDesc)->Buffer2NextDescAddr);
;;;1029   
;;;1030         /* Set HAL State to Ready */
;;;1031         heth->State = HAL_ETH_STATE_READY;
;;;1032   
;;;1033         /* Process Unlocked */
;;;1034         __HAL_UNLOCK(heth);
;;;1035   
;;;1036         /* Return function status */
;;;1037         return HAL_OK;
;;;1038       }
;;;1039       /* Check if first segment */
;;;1040       else if ((heth->RxDesc->Status & ETH_DMARXDESC_FS) != (uint32_t)RESET)
;;;1041       {
;;;1042         (heth->RxFrameInfos).FSRxDesc = heth->RxDesc;
;;;1043         (heth->RxFrameInfos).LSRxDesc = NULL;
;;;1044         (heth->RxFrameInfos).SegCount = 1U;
;;;1045         /* Point to next descriptor */
;;;1046         heth->RxDesc = (ETH_DMADescTypeDef *)(heth->RxDesc->Buffer2NextDescAddr);
;;;1047       }
;;;1048       /* Check if intermediate segment */
;;;1049       else
;;;1050       {
;;;1051         (heth->RxFrameInfos).SegCount++;
;;;1052         /* Point to next descriptor */
;;;1053         heth->RxDesc = (ETH_DMADescTypeDef *)(heth->RxDesc->Buffer2NextDescAddr);
;;;1054       }
;;;1055     }
;;;1056   
;;;1057     /* Set ETH HAL State to Ready */
;;;1058     heth->State = HAL_ETH_STATE_READY;
;;;1059   
;;;1060     /* Process Unlocked */
;;;1061     __HAL_UNLOCK(heth);
;;;1062   
;;;1063     /* Return function status */
;;;1064     return HAL_ERROR;
;;;1065   }
000034  bd10              POP      {r4,pc}
                  |L19.54|
000036  6301              STR      r1,[r0,#0x30]         ;1016
                  |L19.56|
000038  3028              ADDS     r0,r0,#0x28           ;1019
00003a  60c1              STR      r1,[r0,#0xc]          ;1019
00003c  680a              LDR      r2,[r1,#0]            ;1022
00003e  f3c2420d          UBFX     r2,r2,#16,#14         ;1022
000042  1f12              SUBS     r2,r2,#4              ;1022
000044  6142              STR      r2,[r0,#0x14]         ;1023
000046  6882              LDR      r2,[r0,#8]            ;1026
000048  6892              LDR      r2,[r2,#8]            ;1026
00004a  6182              STR      r2,[r0,#0x18]         ;1026
00004c  68c9              LDR      r1,[r1,#0xc]          ;1028
00004e  6001              STR      r1,[r0,#0]            ;1028
000050  7703              STRB     r3,[r0,#0x1c]         ;1031
000052  7744              STRB     r4,[r0,#0x1d]         ;1034
000054  2000              MOVS     r0,#0                 ;1037
000056  bd10              POP      {r4,pc}
                  |L19.88|
000058  680a              LDR      r2,[r1,#0]            ;1040
00005a  0592              LSLS     r2,r2,#22             ;1040
00005c  d505              BPL      |L19.106|
00005e  6301              STR      r1,[r0,#0x30]         ;1042
000060  6344              STR      r4,[r0,#0x34]         ;1043
000062  6383              STR      r3,[r0,#0x38]         ;1044
000064  68c9              LDR      r1,[r1,#0xc]          ;1046
000066  6281              STR      r1,[r0,#0x28]         ;1046
000068  e004              B        |L19.116|
                  |L19.106|
00006a  6b82              LDR      r2,[r0,#0x38]         ;1051
00006c  1c52              ADDS     r2,r2,#1              ;1051
00006e  6382              STR      r2,[r0,#0x38]         ;1051
000070  68c9              LDR      r1,[r1,#0xc]          ;1053
000072  6281              STR      r1,[r0,#0x28]         ;1053
                  |L19.116|
000074  f8003f44          STRB     r3,[r0,#0x44]!        ;1058
000078  7044              STRB     r4,[r0,#1]            ;1061
00007a  2001              MOVS     r0,#1                 ;1064
00007c  bd10              POP      {r4,pc}
;;;1066   
                          ENDP


                          AREA ||i.HAL_ETH_GetReceivedFrame_IT||, CODE, READONLY, ALIGN=1

                  HAL_ETH_GetReceivedFrame_IT PROC
;;;1072     */
;;;1073   HAL_StatusTypeDef HAL_ETH_GetReceivedFrame_IT(ETH_HandleTypeDef *heth)
000000  b530              PUSH     {r4,r5,lr}
;;;1074   {
;;;1075     uint32_t descriptorscancounter = 0U;
000002  2200              MOVS     r2,#0
;;;1076   
;;;1077     /* Process Locked */
;;;1078     __HAL_LOCK(heth);
000004  f8901045          LDRB     r1,[r0,#0x45]
000008  2901              CMP      r1,#1
00000a  d007              BEQ      |L20.28|
00000c  2401              MOVS     r4,#1
00000e  f8804045          STRB     r4,[r0,#0x45]
;;;1079   
;;;1080     /* Set ETH HAL State to BUSY */
;;;1081     heth->State = HAL_ETH_STATE_BUSY;
000012  2102              MOVS     r1,#2
000014  f8801044          STRB     r1,[r0,#0x44]
;;;1082   
;;;1083     /* Scan descriptors owned by CPU */
;;;1084     while (((heth->RxDesc->Status & ETH_DMARXDESC_OWN) == (uint32_t)RESET) && (descriptorscancounter < ETH_RXBUFNB))
000018  2500              MOVS     r5,#0
00001a  e01d              B        |L20.88|
                  |L20.28|
00001c  2002              MOVS     r0,#2                 ;1078
;;;1085     {
;;;1086       /* Just for security */
;;;1087       descriptorscancounter++;
;;;1088   
;;;1089       /* Check if first segment in frame */
;;;1090       /* ((heth->RxDesc->Status & ETH_DMARXDESC_FS) != (uint32_t)RESET) && ((heth->RxDesc->Status & ETH_DMARXDESC_LS) == (uint32_t)RESET)) */
;;;1091       if ((heth->RxDesc->Status & (ETH_DMARXDESC_FS | ETH_DMARXDESC_LS)) == (uint32_t)ETH_DMARXDESC_FS)
;;;1092       {
;;;1093         heth->RxFrameInfos.FSRxDesc = heth->RxDesc;
;;;1094         heth->RxFrameInfos.SegCount = 1U;
;;;1095         /* Point to next descriptor */
;;;1096         heth->RxDesc = (ETH_DMADescTypeDef *)(heth->RxDesc->Buffer2NextDescAddr);
;;;1097       }
;;;1098       /* Check if intermediate segment */
;;;1099       /* ((heth->RxDesc->Status & ETH_DMARXDESC_LS) == (uint32_t)RESET)&& ((heth->RxDesc->Status & ETH_DMARXDESC_FS) == (uint32_t)RESET)) */
;;;1100       else if ((heth->RxDesc->Status & (ETH_DMARXDESC_LS | ETH_DMARXDESC_FS)) == (uint32_t)RESET)
;;;1101       {
;;;1102         /* Increment segment count */
;;;1103         (heth->RxFrameInfos.SegCount)++;
;;;1104         /* Point to next descriptor */
;;;1105         heth->RxDesc = (ETH_DMADescTypeDef *)(heth->RxDesc->Buffer2NextDescAddr);
;;;1106       }
;;;1107       /* Should be last segment */
;;;1108       else
;;;1109       {
;;;1110         /* Last segment */
;;;1111         heth->RxFrameInfos.LSRxDesc = heth->RxDesc;
;;;1112   
;;;1113         /* Increment segment count */
;;;1114         (heth->RxFrameInfos.SegCount)++;
;;;1115   
;;;1116         /* Check if last segment is first segment: one segment contains the frame */
;;;1117         if ((heth->RxFrameInfos.SegCount) == 1U)
;;;1118         {
;;;1119           heth->RxFrameInfos.FSRxDesc = heth->RxDesc;
;;;1120         }
;;;1121   
;;;1122         /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
;;;1123         heth->RxFrameInfos.length = (((heth->RxDesc)->Status & ETH_DMARXDESC_FL) >> ETH_DMARXDESC_FRAMELENGTHSHIFT) - 4U;
;;;1124   
;;;1125         /* Get the address of the buffer start address */
;;;1126         heth->RxFrameInfos.buffer = ((heth->RxFrameInfos).FSRxDesc)->Buffer1Addr;
;;;1127   
;;;1128         /* Point to next descriptor */
;;;1129         heth->RxDesc = (ETH_DMADescTypeDef *)(heth->RxDesc->Buffer2NextDescAddr);
;;;1130   
;;;1131         /* Set HAL State to Ready */
;;;1132         heth->State = HAL_ETH_STATE_READY;
;;;1133   
;;;1134         /* Process Unlocked */
;;;1135         __HAL_UNLOCK(heth);
;;;1136   
;;;1137         /* Return function status */
;;;1138         return HAL_OK;
;;;1139       }
;;;1140     }
;;;1141   
;;;1142     /* Set HAL State to Ready */
;;;1143     heth->State = HAL_ETH_STATE_READY;
;;;1144   
;;;1145     /* Process Unlocked */
;;;1146     __HAL_UNLOCK(heth);
;;;1147   
;;;1148     /* Return function status */
;;;1149     return HAL_ERROR;
;;;1150   }
00001e  bd30              POP      {r4,r5,pc}
                  |L20.32|
000020  1c52              ADDS     r2,r2,#1              ;1087
000022  680b              LDR      r3,[r1,#0]            ;1091
000024  f3c32301          UBFX     r3,r3,#8,#2           ;1091
000028  2b02              CMP      r3,#2                 ;1091
00002a  d00b              BEQ      |L20.68|
00002c  680b              LDR      r3,[r1,#0]            ;1100
00002e  f4137f40          TST      r3,#0x300             ;1100
000032  d00c              BEQ      |L20.78|
000034  6a82              LDR      r2,[r0,#0x28]         ;1111
000036  6342              STR      r2,[r0,#0x34]         ;1111
000038  6b82              LDR      r2,[r0,#0x38]         ;1114
00003a  1c52              ADDS     r2,r2,#1              ;1114
00003c  6382              STR      r2,[r0,#0x38]         ;1114
00003e  2a01              CMP      r2,#1                 ;1117
000040  d015              BEQ      |L20.110|
000042  e015              B        |L20.112|
                  |L20.68|
000044  6301              STR      r1,[r0,#0x30]         ;1093
000046  6384              STR      r4,[r0,#0x38]         ;1094
000048  68c9              LDR      r1,[r1,#0xc]          ;1096
00004a  6281              STR      r1,[r0,#0x28]         ;1096
00004c  e004              B        |L20.88|
                  |L20.78|
00004e  6b83              LDR      r3,[r0,#0x38]         ;1103
000050  1c5b              ADDS     r3,r3,#1              ;1103
000052  6383              STR      r3,[r0,#0x38]         ;1103
000054  68c9              LDR      r1,[r1,#0xc]          ;1105
000056  6281              STR      r1,[r0,#0x28]         ;1105
                  |L20.88|
000058  6a81              LDR      r1,[r0,#0x28]         ;1084
00005a  680b              LDR      r3,[r1,#0]            ;1084
00005c  2b00              CMP      r3,#0                 ;1084
00005e  db01              BLT      |L20.100|
000060  2a08              CMP      r2,#8                 ;1084
000062  d3dd              BCC      |L20.32|
                  |L20.100|
000064  f8004f44          STRB     r4,[r0,#0x44]!        ;1143
000068  7045              STRB     r5,[r0,#1]            ;1146
00006a  2001              MOVS     r0,#1                 ;1149
00006c  bd30              POP      {r4,r5,pc}
                  |L20.110|
00006e  6301              STR      r1,[r0,#0x30]         ;1119
                  |L20.112|
000070  680a              LDR      r2,[r1,#0]            ;1123
000072  f3c2420d          UBFX     r2,r2,#16,#14         ;1123
000076  1f12              SUBS     r2,r2,#4              ;1123
000078  3028              ADDS     r0,r0,#0x28           ;1123
00007a  6142              STR      r2,[r0,#0x14]         ;1123
00007c  6882              LDR      r2,[r0,#8]            ;1126
00007e  6892              LDR      r2,[r2,#8]            ;1126
000080  6182              STR      r2,[r0,#0x18]         ;1126
000082  68c9              LDR      r1,[r1,#0xc]          ;1129
000084  6001              STR      r1,[r0,#0]            ;1129
000086  7704              STRB     r4,[r0,#0x1c]         ;1132
000088  7745              STRB     r5,[r0,#0x1d]         ;1135
00008a  2000              MOVS     r0,#0                 ;1138
00008c  bd30              POP      {r4,r5,pc}
;;;1151   
                          ENDP


                          AREA ||i.HAL_ETH_GetState||, CODE, READONLY, ALIGN=1

                  HAL_ETH_GetState PROC
;;;1797     */
;;;1798   HAL_ETH_StateTypeDef HAL_ETH_GetState(ETH_HandleTypeDef *heth)
000000  f8900044          LDRB     r0,[r0,#0x44]
;;;1799   {
;;;1800     /* Return ETH state */
;;;1801     return heth->State;
;;;1802   }
000004  4770              BX       lr
;;;1803   
                          ENDP


                          AREA ||i.HAL_ETH_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_ETH_IRQHandler PROC
;;;1157     */
;;;1158   void HAL_ETH_IRQHandler(ETH_HandleTypeDef *heth)
000000  b570              PUSH     {r4-r6,lr}
;;;1159   {
000002  4604              MOV      r4,r0
;;;1160     /* Frame received */
;;;1161     if (__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_R))
000004  6820              LDR      r0,[r4,#0]
000006  f5005080          ADD      r0,r0,#0x1000
00000a  6941              LDR      r1,[r0,#0x14]
00000c  f04f0600          MOV      r6,#0
000010  0649              LSLS     r1,r1,#25
;;;1162     {
;;;1163   #if (USE_HAL_ETH_REGISTER_CALLBACKS == 1)
;;;1164       /*Call registered Receive complete callback*/
;;;1165       heth->RxCpltCallback(heth);
;;;1166   #else
;;;1167       /* Receive complete callback */
;;;1168       HAL_ETH_RxCpltCallback(heth);
;;;1169   #endif /* USE_HAL_ETH_REGISTER_CALLBACKS */
;;;1170   
;;;1171       /* Clear the Eth DMA Rx IT pending bits */
;;;1172       __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_IT_R);
;;;1173   
;;;1174       /* Set HAL State to Ready */
;;;1175       heth->State = HAL_ETH_STATE_READY;
000012  f04f0501          MOV      r5,#1
000016  d50c              BPL      |L22.50|
000018  4620              MOV      r0,r4                 ;1168
00001a  f7fffffe          BL       HAL_ETH_RxCpltCallback
00001e  6820              LDR      r0,[r4,#0]            ;1172
000020  2140              MOVS     r1,#0x40              ;1172
000022  f5005080          ADD      r0,r0,#0x1000         ;1172
000026  6141              STR      r1,[r0,#0x14]         ;1172
000028  f8845044          STRB     r5,[r4,#0x44]
;;;1176   
;;;1177       /* Process Unlocked */
;;;1178       __HAL_UNLOCK(heth);
00002c  f8846045          STRB     r6,[r4,#0x45]
000030  e00d              B        |L22.78|
                  |L22.50|
;;;1179   
;;;1180     }
;;;1181     /* Frame transmitted */
;;;1182     else if (__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_T))
000032  6940              LDR      r0,[r0,#0x14]
000034  07c0              LSLS     r0,r0,#31
000036  d00a              BEQ      |L22.78|
;;;1183     {
;;;1184   #if (USE_HAL_ETH_REGISTER_CALLBACKS == 1)
;;;1185       /*  Call resgistered Transfer complete callback*/
;;;1186       heth->TxCpltCallback(heth);
;;;1187   #else
;;;1188       /* Transfer complete callback */
;;;1189       HAL_ETH_TxCpltCallback(heth);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       HAL_ETH_TxCpltCallback
;;;1190   #endif /* USE_HAL_ETH_REGISTER_CALLBACKS */
;;;1191   
;;;1192       /* Clear the Eth DMA Tx IT pending bits */
;;;1193       __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_IT_T);
00003e  6820              LDR      r0,[r4,#0]
000040  f5005080          ADD      r0,r0,#0x1000
000044  6145              STR      r5,[r0,#0x14]
;;;1194   
;;;1195       /* Set HAL State to Ready */
;;;1196       heth->State = HAL_ETH_STATE_READY;
000046  f8845044          STRB     r5,[r4,#0x44]
;;;1197   
;;;1198       /* Process Unlocked */
;;;1199       __HAL_UNLOCK(heth);
00004a  f8846045          STRB     r6,[r4,#0x45]
                  |L22.78|
;;;1200     }
;;;1201   
;;;1202     /* Clear the interrupt flags */
;;;1203     __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_IT_NIS);
00004e  6820              LDR      r0,[r4,#0]
000050  f44f3180          MOV      r1,#0x10000
000054  f5005080          ADD      r0,r0,#0x1000
000058  6141              STR      r1,[r0,#0x14]
;;;1204   
;;;1205     /* ETH DMA Error */
;;;1206     if (__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_AIS))
00005a  6820              LDR      r0,[r4,#0]
00005c  f5005080          ADD      r0,r0,#0x1000
000060  6940              LDR      r0,[r0,#0x14]
000062  0400              LSLS     r0,r0,#16
000064  d50c              BPL      |L22.128|
;;;1207     {
;;;1208   #if (USE_HAL_ETH_REGISTER_CALLBACKS == 1)
;;;1209       heth->DMAErrorCallback(heth);
;;;1210   #else
;;;1211       /* Ethernet Error callback */
;;;1212       HAL_ETH_ErrorCallback(heth);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       HAL_ETH_ErrorCallback
;;;1213   #endif /* USE_HAL_ETH_REGISTER_CALLBACKS */
;;;1214   
;;;1215       /* Clear the interrupt flags */
;;;1216       __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_FLAG_AIS);
00006c  6820              LDR      r0,[r4,#0]
00006e  f44f4100          MOV      r1,#0x8000
000072  f5005080          ADD      r0,r0,#0x1000
000076  6141              STR      r1,[r0,#0x14]
;;;1217   
;;;1218       /* Set HAL State to Ready */
;;;1219       heth->State = HAL_ETH_STATE_READY;
000078  f8845044          STRB     r5,[r4,#0x44]
;;;1220   
;;;1221       /* Process Unlocked */
;;;1222       __HAL_UNLOCK(heth);
00007c  f8846045          STRB     r6,[r4,#0x45]
                  |L22.128|
;;;1223     }
;;;1224   }
000080  bd70              POP      {r4-r6,pc}
;;;1225   
                          ENDP


                          AREA ||i.HAL_ETH_Init||, CODE, READONLY, ALIGN=2

                  HAL_ETH_Init PROC
;;;211      */
;;;212    HAL_StatusTypeDef HAL_ETH_Init(ETH_HandleTypeDef *heth)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;213    {
000004  4604              MOV      r4,r0
;;;214      uint32_t tmpreg1 = 0U, phyreg = 0U;
000006  2600              MOVS     r6,#0
000008  9600              STR      r6,[sp,#0]
;;;215      uint32_t hclk = 60000000U;
;;;216      uint32_t tickstart = 0U;
;;;217      uint32_t err = ETH_SUCCESS;
00000a  46b1              MOV      r9,r6
;;;218    
;;;219      /* Check the ETH peripheral state */
;;;220      if (heth == NULL)
00000c  2c00              CMP      r4,#0
00000e  d003              BEQ      |L23.24|
;;;221      {
;;;222        return HAL_ERROR;
;;;223      }
;;;224    
;;;225      /* Check parameters */
;;;226      assert_param(IS_ETH_AUTONEGOTIATION(heth->Init.AutoNegotiation));
;;;227      assert_param(IS_ETH_RX_MODE(heth->Init.RxMode));
;;;228      assert_param(IS_ETH_CHECKSUM_MODE(heth->Init.ChecksumMode));
;;;229      assert_param(IS_ETH_MEDIA_INTERFACE(heth->Init.MediaInterface));
;;;230    
;;;231      if (heth->State == HAL_ETH_STATE_RESET)
000010  f8940044          LDRB     r0,[r4,#0x44]
000014  b118              CBZ      r0,|L23.30|
000016  e007              B        |L23.40|
                  |L23.24|
000018  2001              MOVS     r0,#1                 ;222
                  |L23.26|
;;;232      {
;;;233        /* Allocate lock resource and initialize it */
;;;234        heth->Lock = HAL_UNLOCKED;
;;;235    #if (USE_HAL_ETH_REGISTER_CALLBACKS == 1)
;;;236        ETH_InitCallbacksToDefault(heth);
;;;237    
;;;238        if (heth->MspInitCallback == NULL)
;;;239        {
;;;240          /* Init the low level hardware : GPIO, CLOCK, NVIC. */
;;;241          heth->MspInitCallback = HAL_ETH_MspInit;
;;;242        }
;;;243        heth->MspInitCallback(heth);
;;;244    
;;;245    #else
;;;246        /* Init the low level hardware : GPIO, CLOCK, NVIC. */
;;;247        HAL_ETH_MspInit(heth);
;;;248    #endif /* USE_HAL_ETH_REGISTER_CALLBACKS */
;;;249      }
;;;250    
;;;251      /* Select MII or RMII Mode*/
;;;252      AFIO->MAPR &= ~(AFIO_MAPR_MII_RMII_SEL);
;;;253      AFIO->MAPR |= (uint32_t)heth->Init.MediaInterface;
;;;254    
;;;255      /* Ethernet Software reset */
;;;256      /* Set the SWR bit: resets all MAC subsystem internal registers and logic */
;;;257      /* After reset all the registers holds their respective reset values */
;;;258      (heth->Instance)->DMABMR |= ETH_DMABMR_SR;
;;;259    
;;;260      /* Get tick */
;;;261      tickstart = HAL_GetTick();
;;;262    
;;;263      /* Wait for software reset */
;;;264      while (((heth->Instance)->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
;;;265      {
;;;266        /* Check for the Timeout */
;;;267        if ((HAL_GetTick() - tickstart) > ETH_TIMEOUT_SWRESET)
;;;268        {
;;;269          heth->State = HAL_ETH_STATE_TIMEOUT;
;;;270    
;;;271          /* Process Unlocked */
;;;272          __HAL_UNLOCK(heth);
;;;273    
;;;274          /* Note: The SWR is not performed if the ETH_RX_CLK or the ETH_TX_CLK are
;;;275             not available, please check your external PHY or the IO configuration */
;;;276          return HAL_TIMEOUT;
;;;277        }
;;;278      }
;;;279    
;;;280      /*-------------------------------- MAC Initialization ----------------------*/
;;;281      /* Get the ETHERNET MACMIIAR value */
;;;282      tmpreg1 = (heth->Instance)->MACMIIAR;
;;;283      /* Clear CSR Clock Range CR[2:0] bits */
;;;284      tmpreg1 &= ETH_MACMIIAR_CR_MASK;
;;;285    
;;;286      /* Get hclk frequency value */
;;;287      hclk = HAL_RCC_GetHCLKFreq();
;;;288    
;;;289      /* Set CR bits depending on hclk value */
;;;290      if ((hclk >= 20000000U) && (hclk < 35000000U))
;;;291      {
;;;292        /* CSR Clock Range between 20-35 MHz */
;;;293        tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_DIV16;
;;;294      }
;;;295      else if ((hclk >= 35000000U) && (hclk < 60000000U))
;;;296      {
;;;297        /* CSR Clock Range between 35-60 MHz */
;;;298        tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_DIV26;
;;;299      }
;;;300      else
;;;301      {
;;;302        /* CSR Clock Range between 60-72 MHz */
;;;303        tmpreg1 |= (uint32_t)ETH_MACMIIAR_CR_DIV42;
;;;304      }
;;;305    
;;;306      /* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
;;;307      (heth->Instance)->MACMIIAR = (uint32_t)tmpreg1;
;;;308    
;;;309      /*-------------------- PHY initialization and configuration ----------------*/
;;;310      /* Put the PHY in reset mode */
;;;311      if ((HAL_ETH_WritePHYRegister(heth, PHY_BCR, PHY_RESET)) != HAL_OK)
;;;312      {
;;;313        /* In case of write timeout */
;;;314        err = ETH_ERROR;
;;;315    
;;;316        /* Config MAC and DMA */
;;;317        ETH_MACDMAConfig(heth, err);
;;;318    
;;;319        /* Set the ETH peripheral state to READY */
;;;320        heth->State = HAL_ETH_STATE_READY;
;;;321    
;;;322        /* Return HAL_ERROR */
;;;323        return HAL_ERROR;
;;;324      }
;;;325    
;;;326      /* Delay to assure PHY reset */
;;;327      HAL_Delay(PHY_RESET_DELAY);
;;;328    
;;;329      if ((heth->Init).AutoNegotiation != ETH_AUTONEGOTIATION_DISABLE)
;;;330      {
;;;331        /* Get tick */
;;;332        tickstart = HAL_GetTick();
;;;333    
;;;334        /* We wait for linked status */
;;;335        do
;;;336        {
;;;337          HAL_ETH_ReadPHYRegister(heth, PHY_BSR, &phyreg);
;;;338    
;;;339          /* Check for the Timeout */
;;;340          if ((HAL_GetTick() - tickstart) > ETH_TIMEOUT_LINKED_STATE)
;;;341          {
;;;342            /* In case of write timeout */
;;;343            err = ETH_ERROR;
;;;344    
;;;345            /* Config MAC and DMA */
;;;346            ETH_MACDMAConfig(heth, err);
;;;347    
;;;348            heth->State = HAL_ETH_STATE_READY;
;;;349    
;;;350            /* Process Unlocked */
;;;351            __HAL_UNLOCK(heth);
;;;352    
;;;353            return HAL_TIMEOUT;
;;;354          }
;;;355        }
;;;356        while (((phyreg & PHY_LINKED_STATUS) != PHY_LINKED_STATUS));
;;;357    
;;;358    
;;;359        /* Enable Auto-Negotiation */
;;;360        if ((HAL_ETH_WritePHYRegister(heth, PHY_BCR, PHY_AUTONEGOTIATION)) != HAL_OK)
;;;361        {
;;;362          /* In case of write timeout */
;;;363          err = ETH_ERROR;
;;;364    
;;;365          /* Config MAC and DMA */
;;;366          ETH_MACDMAConfig(heth, err);
;;;367    
;;;368          /* Set the ETH peripheral state to READY */
;;;369          heth->State = HAL_ETH_STATE_READY;
;;;370    
;;;371          /* Return HAL_ERROR */
;;;372          return HAL_ERROR;
;;;373        }
;;;374    
;;;375        /* Get tick */
;;;376        tickstart = HAL_GetTick();
;;;377    
;;;378        /* Wait until the auto-negotiation will be completed */
;;;379        do
;;;380        {
;;;381          HAL_ETH_ReadPHYRegister(heth, PHY_BSR, &phyreg);
;;;382    
;;;383          /* Check for the Timeout */
;;;384          if ((HAL_GetTick() - tickstart) > ETH_TIMEOUT_AUTONEGO_COMPLETED)
;;;385          {
;;;386            /* In case of write timeout */
;;;387            err = ETH_ERROR;
;;;388    
;;;389            /* Config MAC and DMA */
;;;390            ETH_MACDMAConfig(heth, err);
;;;391    
;;;392            heth->State = HAL_ETH_STATE_READY;
;;;393    
;;;394            /* Process Unlocked */
;;;395            __HAL_UNLOCK(heth);
;;;396    
;;;397            return HAL_TIMEOUT;
;;;398          }
;;;399    
;;;400        }
;;;401        while (((phyreg & PHY_AUTONEGO_COMPLETE) != PHY_AUTONEGO_COMPLETE));
;;;402    
;;;403        /* Read the result of the auto-negotiation */
;;;404        if ((HAL_ETH_ReadPHYRegister(heth, PHY_SR, &phyreg)) != HAL_OK)
;;;405        {
;;;406          /* In case of write timeout */
;;;407          err = ETH_ERROR;
;;;408    
;;;409          /* Config MAC and DMA */
;;;410          ETH_MACDMAConfig(heth, err);
;;;411    
;;;412          /* Set the ETH peripheral state to READY */
;;;413          heth->State = HAL_ETH_STATE_READY;
;;;414    
;;;415          /* Return HAL_ERROR */
;;;416          return HAL_ERROR;
;;;417        }
;;;418    
;;;419        /* Configure the MAC with the Duplex Mode fixed by the auto-negotiation process */
;;;420        if ((phyreg & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
;;;421        {
;;;422          /* Set Ethernet duplex mode to Full-duplex following the auto-negotiation */
;;;423          (heth->Init).DuplexMode = ETH_MODE_FULLDUPLEX;
;;;424        }
;;;425        else
;;;426        {
;;;427          /* Set Ethernet duplex mode to Half-duplex following the auto-negotiation */
;;;428          (heth->Init).DuplexMode = ETH_MODE_HALFDUPLEX;
;;;429        }
;;;430        /* Configure the MAC with the speed fixed by the auto-negotiation process */
;;;431        if ((phyreg & PHY_SPEED_STATUS) == PHY_SPEED_STATUS)
;;;432        {
;;;433          /* Set Ethernet speed to 10M following the auto-negotiation */
;;;434          (heth->Init).Speed = ETH_SPEED_10M;
;;;435        }
;;;436        else
;;;437        {
;;;438          /* Set Ethernet speed to 100M following the auto-negotiation */
;;;439          (heth->Init).Speed = ETH_SPEED_100M;
;;;440        }
;;;441      }
;;;442      else /* AutoNegotiation Disable */
;;;443      {
;;;444        /* Check parameters */
;;;445        assert_param(IS_ETH_SPEED(heth->Init.Speed));
;;;446        assert_param(IS_ETH_DUPLEX_MODE(heth->Init.DuplexMode));
;;;447    
;;;448        /* Set MAC Speed and Duplex Mode */
;;;449        if (HAL_ETH_WritePHYRegister(heth, PHY_BCR, ((uint16_t)((heth->Init).DuplexMode >> 3U) |
;;;450                                                     (uint16_t)((heth->Init).Speed >> 1U))) != HAL_OK)
;;;451        {
;;;452          /* In case of write timeout */
;;;453          err = ETH_ERROR;
;;;454    
;;;455          /* Config MAC and DMA */
;;;456          ETH_MACDMAConfig(heth, err);
;;;457    
;;;458          /* Set the ETH peripheral state to READY */
;;;459          heth->State = HAL_ETH_STATE_READY;
;;;460    
;;;461          /* Return HAL_ERROR */
;;;462          return HAL_ERROR;
;;;463        }
;;;464    
;;;465        /* Delay to assure PHY configuration */
;;;466        HAL_Delay(PHY_CONFIG_DELAY);
;;;467      }
;;;468    
;;;469      /* Config MAC and DMA */
;;;470      ETH_MACDMAConfig(heth, err);
;;;471    
;;;472      /* Set ETH HAL State to Ready */
;;;473      heth->State = HAL_ETH_STATE_READY;
;;;474    
;;;475      /* Return function status */
;;;476      return HAL_OK;
;;;477    }
00001a  e8bd83f8          POP      {r3-r9,pc}
                  |L23.30|
00001e  f8846045          STRB     r6,[r4,#0x45]         ;234
000022  4620              MOV      r0,r4                 ;247
000024  f7fffffe          BL       HAL_ETH_MspInit
                  |L23.40|
000028  486a              LDR      r0,|L23.468|
00002a  6841              LDR      r1,[r0,#4]            ;252
00002c  f4210100          BIC      r1,r1,#0x800000       ;252
000030  6041              STR      r1,[r0,#4]            ;252
000032  6841              LDR      r1,[r0,#4]            ;253
000034  6a22              LDR      r2,[r4,#0x20]         ;253
000036  4311              ORRS     r1,r1,r2              ;253
000038  6041              STR      r1,[r0,#4]            ;253
00003a  6820              LDR      r0,[r4,#0]            ;258
00003c  f5005080          ADD      r0,r0,#0x1000         ;258
000040  6801              LDR      r1,[r0,#0]            ;258
000042  f0410101          ORR      r1,r1,#1              ;258
000046  6001              STR      r1,[r0,#0]            ;258
000048  f7fffffe          BL       HAL_GetTick
00004c  4605              MOV      r5,r0                 ;261
00004e  f44f77fa          MOV      r7,#0x1f4             ;267
000052  e009              B        |L23.104|
                  |L23.84|
000054  f7fffffe          BL       HAL_GetTick
000058  1b40              SUBS     r0,r0,r5              ;267
00005a  42b8              CMP      r0,r7                 ;267
00005c  d904              BLS      |L23.104|
00005e  2003              MOVS     r0,#3                 ;269
000060  f8040f44          STRB     r0,[r4,#0x44]!        ;269
000064  7066              STRB     r6,[r4,#1]            ;272
000066  e7d8              B        |L23.26|
                  |L23.104|
000068  6820              LDR      r0,[r4,#0]            ;264
00006a  f5005080          ADD      r0,r0,#0x1000         ;264
00006e  6800              LDR      r0,[r0,#0]            ;264
000070  07c0              LSLS     r0,r0,#31             ;264
000072  d1ef              BNE      |L23.84|
000074  6820              LDR      r0,[r4,#0]            ;282
000076  6900              LDR      r0,[r0,#0x10]         ;282
000078  f020051c          BIC      r5,r0,#0x1c           ;284
00007c  f7fffffe          BL       HAL_RCC_GetHCLKFreq
000080  4955              LDR      r1,|L23.472|
000082  4a56              LDR      r2,|L23.476|
000084  4401              ADD      r1,r1,r0              ;290
000086  4291              CMP      r1,r2                 ;290
000088  d202              BCS      |L23.144|
00008a  f0450508          ORR      r5,r5,#8              ;293
00008e  e006              B        |L23.158|
                  |L23.144|
000090  4953              LDR      r1,|L23.480|
000092  4408              ADD      r0,r0,r1              ;295
000094  4953              LDR      r1,|L23.484|
000096  4288              CMP      r0,r1                 ;295
000098  d201              BCS      |L23.158|
00009a  f045050c          ORR      r5,r5,#0xc            ;298
                  |L23.158|
00009e  6820              LDR      r0,[r4,#0]            ;307
0000a0  6105              STR      r5,[r0,#0x10]         ;307
0000a2  f44f4200          MOV      r2,#0x8000            ;311
0000a6  2100              MOVS     r1,#0                 ;311
0000a8  4620              MOV      r0,r4                 ;311
0000aa  f7fffffe          BL       HAL_ETH_WritePHYRegister
0000ae  2501              MOVS     r5,#1                 ;222
0000b0  b138              CBZ      r0,|L23.194|
0000b2  2101              MOVS     r1,#1                 ;314
0000b4  4620              MOV      r0,r4                 ;317
0000b6  f7fffffe          BL       ETH_MACDMAConfig
0000ba  f8845044          STRB     r5,[r4,#0x44]         ;320
0000be  2001              MOVS     r0,#1                 ;323
0000c0  e7ab              B        |L23.26|
                  |L23.194|
0000c2  4849              LDR      r0,|L23.488|
0000c4  f7fffffe          BL       HAL_Delay
0000c8  6860              LDR      r0,[r4,#4]            ;329
0000ca  2800              CMP      r0,#0                 ;329
0000cc  d062              BEQ      |L23.404|
0000ce  f7fffffe          BL       HAL_GetTick
0000d2  4680              MOV      r8,r0                 ;332
0000d4  f2413788          MOV      r7,#0x1388            ;340
                  |L23.216|
0000d8  466a              MOV      r2,sp                 ;337
0000da  2101              MOVS     r1,#1                 ;337
0000dc  4620              MOV      r0,r4                 ;337
0000de  f7fffffe          BL       HAL_ETH_ReadPHYRegister
0000e2  f7fffffe          BL       HAL_GetTick
0000e6  eba00008          SUB      r0,r0,r8              ;340
0000ea  42b8              CMP      r0,r7                 ;340
0000ec  d908              BLS      |L23.256|
0000ee  2101              MOVS     r1,#1                 ;343
0000f0  4620              MOV      r0,r4                 ;346
0000f2  f7fffffe          BL       ETH_MACDMAConfig
0000f6  f8045f44          STRB     r5,[r4,#0x44]!        ;348
0000fa  7066              STRB     r6,[r4,#1]            ;351
0000fc  2003              MOVS     r0,#3                 ;353
0000fe  e78c              B        |L23.26|
                  |L23.256|
000100  9800              LDR      r0,[sp,#0]            ;356
000102  0740              LSLS     r0,r0,#29             ;356
000104  d5e8              BPL      |L23.216|
000106  f44f5280          MOV      r2,#0x1000            ;360
00010a  2100              MOVS     r1,#0                 ;360
00010c  4620              MOV      r0,r4                 ;360
00010e  f7fffffe          BL       HAL_ETH_WritePHYRegister
000112  b138              CBZ      r0,|L23.292|
000114  2101              MOVS     r1,#1                 ;363
000116  4620              MOV      r0,r4                 ;366
000118  f7fffffe          BL       ETH_MACDMAConfig
00011c  f8845044          STRB     r5,[r4,#0x44]         ;369
000120  2001              MOVS     r0,#1                 ;372
000122  e77a              B        |L23.26|
                  |L23.292|
000124  f7fffffe          BL       HAL_GetTick
000128  4680              MOV      r8,r0                 ;376
                  |L23.298|
00012a  466a              MOV      r2,sp                 ;381
00012c  2101              MOVS     r1,#1                 ;381
00012e  4620              MOV      r0,r4                 ;381
000130  f7fffffe          BL       HAL_ETH_ReadPHYRegister
000134  f7fffffe          BL       HAL_GetTick
000138  eba00008          SUB      r0,r0,r8              ;384
00013c  42b8              CMP      r0,r7                 ;384
00013e  d908              BLS      |L23.338|
000140  2101              MOVS     r1,#1                 ;387
000142  4620              MOV      r0,r4                 ;390
000144  f7fffffe          BL       ETH_MACDMAConfig
000148  f8045f44          STRB     r5,[r4,#0x44]!        ;392
00014c  7066              STRB     r6,[r4,#1]            ;395
00014e  2003              MOVS     r0,#3                 ;397
000150  e763              B        |L23.26|
                  |L23.338|
000152  9800              LDR      r0,[sp,#0]            ;401
000154  0680              LSLS     r0,r0,#26             ;401
000156  d5e8              BPL      |L23.298|
000158  466a              MOV      r2,sp                 ;404
00015a  2131              MOVS     r1,#0x31              ;404
00015c  4620              MOV      r0,r4                 ;404
00015e  f7fffffe          BL       HAL_ETH_ReadPHYRegister
000162  b138              CBZ      r0,|L23.372|
000164  2101              MOVS     r1,#1                 ;407
000166  4620              MOV      r0,r4                 ;410
000168  f7fffffe          BL       ETH_MACDMAConfig
00016c  f8845044          STRB     r5,[r4,#0x44]         ;413
000170  2001              MOVS     r0,#1                 ;416
000172  e752              B        |L23.26|
                  |L23.372|
000174  9800              LDR      r0,[sp,#0]            ;420
000176  06c1              LSLS     r1,r0,#27             ;420
000178  d503              BPL      |L23.386|
00017a  f44f6100          MOV      r1,#0x800             ;423
00017e  60e1              STR      r1,[r4,#0xc]          ;423
000180  e000              B        |L23.388|
                  |L23.386|
000182  60e6              STR      r6,[r4,#0xc]          ;428
                  |L23.388|
000184  0740              LSLS     r0,r0,#29             ;431
000186  d501              BPL      |L23.396|
000188  60a6              STR      r6,[r4,#8]            ;434
00018a  e01b              B        |L23.452|
                  |L23.396|
00018c  f44f4080          MOV      r0,#0x4000            ;439
000190  60a0              STR      r0,[r4,#8]            ;439
000192  e017              B        |L23.452|
                  |L23.404|
000194  68e0              LDR      r0,[r4,#0xc]          ;449
000196  2100              MOVS     r1,#0                 ;449
000198  f3c002cf          UBFX     r2,r0,#3,#16          ;449
00019c  68a0              LDR      r0,[r4,#8]            ;449
00019e  f3c0004f          UBFX     r0,r0,#1,#16          ;449
0001a2  4302              ORRS     r2,r2,r0              ;449
0001a4  4620              MOV      r0,r4                 ;449
0001a6  f7fffffe          BL       HAL_ETH_WritePHYRegister
0001aa  b138              CBZ      r0,|L23.444|
0001ac  2101              MOVS     r1,#1                 ;453
0001ae  4620              MOV      r0,r4                 ;456
0001b0  f7fffffe          BL       ETH_MACDMAConfig
0001b4  f8845044          STRB     r5,[r4,#0x44]         ;459
0001b8  2001              MOVS     r0,#1                 ;462
0001ba  e72e              B        |L23.26|
                  |L23.444|
0001bc  f06f407f          MVN      r0,#0xff000000        ;466
0001c0  f7fffffe          BL       HAL_Delay
                  |L23.452|
0001c4  4649              MOV      r1,r9                 ;470
0001c6  4620              MOV      r0,r4                 ;470
0001c8  f7fffffe          BL       ETH_MACDMAConfig
0001cc  f8845044          STRB     r5,[r4,#0x44]         ;473
0001d0  2000              MOVS     r0,#0                 ;476
0001d2  e722              B        |L23.26|
;;;478    
                          ENDP

                  |L23.468|
                          DCD      0x40010000
                  |L23.472|
                          DCD      0xfeced300
                  |L23.476|
                          DCD      0x00e4e1c0
                  |L23.480|
                          DCD      0xfde9f140
                  |L23.484|
                          DCD      0x017d7840
                  |L23.488|
                          DCD      0x000fffff

                          AREA ||i.HAL_ETH_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_ETH_MspDeInit PROC
;;;669      */
;;;670    __weak void HAL_ETH_MspDeInit(ETH_HandleTypeDef *heth)
000000  4770              BX       lr
;;;671    {
;;;672      /* Prevent unused argument(s) compilation warning */
;;;673      UNUSED(heth);
;;;674      /* NOTE : This function Should not be modified, when the callback is needed,
;;;675      the HAL_ETH_MspDeInit could be implemented in the user file
;;;676      */
;;;677    }
;;;678    
                          ENDP


                          AREA ||i.HAL_ETH_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_ETH_MspInit PROC
;;;654      */
;;;655    __weak void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
000000  4770              BX       lr
;;;656    {
;;;657      /* Prevent unused argument(s) compilation warning */
;;;658      UNUSED(heth);
;;;659      /* NOTE : This function Should not be modified, when the callback is needed,
;;;660      the HAL_ETH_MspInit could be implemented in the user file
;;;661      */
;;;662    }
;;;663    
                          ENDP


                          AREA ||i.HAL_ETH_ReadPHYRegister||, CODE, READONLY, ALIGN=1

                  HAL_ETH_ReadPHYRegister PROC
;;;1282     */
;;;1283   HAL_StatusTypeDef HAL_ETH_ReadPHYRegister(ETH_HandleTypeDef *heth, uint16_t PHYReg, uint32_t *RegValue)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1284   {
000004  4604              MOV      r4,r0
000006  4691              MOV      r9,r2
;;;1285     uint32_t tmpreg1 = 0U;
;;;1286     uint32_t tickstart = 0U;
;;;1287   
;;;1288     /* Check parameters */
;;;1289     assert_param(IS_ETH_PHY_ADDRESS(heth->Init.PhyAddress));
;;;1290   
;;;1291     /* Check the ETH peripheral state */
;;;1292     if (heth->State == HAL_ETH_STATE_BUSY_RD)
000008  f8940044          LDRB     r0,[r4,#0x44]
00000c  2882              CMP      r0,#0x82
00000e  d01d              BEQ      |L26.76|
;;;1293     {
;;;1294       return HAL_BUSY;
;;;1295     }
;;;1296     /* Set ETH HAL State to BUSY_RD */
;;;1297     heth->State = HAL_ETH_STATE_BUSY_RD;
000010  2082              MOVS     r0,#0x82
000012  f8840044          STRB     r0,[r4,#0x44]
;;;1298   
;;;1299     /* Get the ETHERNET MACMIIAR value */
;;;1300     tmpreg1 = heth->Instance->MACMIIAR;
000016  6820              LDR      r0,[r4,#0]
000018  6902              LDR      r2,[r0,#0x10]
;;;1301   
;;;1302     /* Keep only the CSR Clock Range CR[2:0] bits value */
;;;1303     tmpreg1 &= ~ETH_MACMIIAR_CR_MASK;
00001a  f002031c          AND      r3,r2,#0x1c
;;;1304   
;;;1305     /* Prepare the MII address register value */
;;;1306     tmpreg1 |= (((uint32_t)heth->Init.PhyAddress << 11U) & ETH_MACMIIAR_PA); /* Set the PHY device address   */
00001e  8a22              LDRH     r2,[r4,#0x10]
000020  f64f75ff          MOV      r5,#0xffff
000024  ea0522c2          AND      r2,r5,r2,LSL #11
000028  431a              ORRS     r2,r2,r3
;;;1307     tmpreg1 |= (((uint32_t)PHYReg << 6U) & ETH_MACMIIAR_MR);                /* Set the PHY register address */
00002a  f44f63f8          MOV      r3,#0x7c0
00002e  ea031181          AND      r1,r3,r1,LSL #6
000032  4311              ORRS     r1,r1,r2
;;;1308     tmpreg1 &= ~ETH_MACMIIAR_MW;                                            /* Set the read mode            */
000034  f0210102          BIC      r1,r1,#2
;;;1309     tmpreg1 |= ETH_MACMIIAR_MB;                                             /* Set the MII Busy bit         */
000038  f0410501          ORR      r5,r1,#1
;;;1310   
;;;1311     /* Write the result value into the MII Address register */
;;;1312     heth->Instance->MACMIIAR = tmpreg1;
00003c  6105              STR      r5,[r0,#0x10]
;;;1313   
;;;1314     /* Get tick */
;;;1315     tickstart = HAL_GetTick();
00003e  f7fffffe          BL       HAL_GetTick
000042  4606              MOV      r6,r0
;;;1316   
;;;1317     /* Check for the Busy flag */
;;;1318     while ((tmpreg1 & ETH_MACMIIAR_MB) == ETH_MACMIIAR_MB)
;;;1319     {
;;;1320       /* Check for the Timeout */
;;;1321       if ((HAL_GetTick() - tickstart) > PHY_READ_TO)
;;;1322       {
;;;1323         heth->State = HAL_ETH_STATE_READY;
000044  2701              MOVS     r7,#1
000046  f44f28a0          MOV      r8,#0x50000           ;1321
00004a  e00f              B        |L26.108|
                  |L26.76|
00004c  2002              MOVS     r0,#2                 ;1294
                  |L26.78|
;;;1324   
;;;1325         /* Process Unlocked */
;;;1326         __HAL_UNLOCK(heth);
;;;1327   
;;;1328         return HAL_TIMEOUT;
;;;1329       }
;;;1330   
;;;1331       tmpreg1 = heth->Instance->MACMIIAR;
;;;1332     }
;;;1333   
;;;1334     /* Get MACMIIDR value */
;;;1335     *RegValue = (uint16_t)(heth->Instance->MACMIIDR);
;;;1336   
;;;1337     /* Set ETH HAL State to READY */
;;;1338     heth->State = HAL_ETH_STATE_READY;
;;;1339   
;;;1340     /* Return function status */
;;;1341     return HAL_OK;
;;;1342   }
00004e  e8bd87f0          POP      {r4-r10,pc}
                  |L26.82|
000052  f7fffffe          BL       HAL_GetTick
000056  1b80              SUBS     r0,r0,r6              ;1321
000058  4540              CMP      r0,r8                 ;1321
00005a  d305              BCC      |L26.104|
00005c  f8047f44          STRB     r7,[r4,#0x44]!        ;1323
000060  2000              MOVS     r0,#0                 ;1326
000062  7060              STRB     r0,[r4,#1]            ;1326
000064  2003              MOVS     r0,#3                 ;1328
000066  e7f2              B        |L26.78|
                  |L26.104|
000068  6820              LDR      r0,[r4,#0]            ;1331
00006a  6905              LDR      r5,[r0,#0x10]         ;1331
                  |L26.108|
00006c  07e8              LSLS     r0,r5,#31             ;1318
00006e  d1f0              BNE      |L26.82|
000070  6820              LDR      r0,[r4,#0]            ;1335
000072  6940              LDR      r0,[r0,#0x14]         ;1335
000074  b280              UXTH     r0,r0                 ;1335
000076  f8c90000          STR      r0,[r9,#0]            ;1335
00007a  f8847044          STRB     r7,[r4,#0x44]         ;1338
00007e  2000              MOVS     r0,#0                 ;1341
000080  e7e5              B        |L26.78|
;;;1343   
                          ENDP


                          AREA ||i.HAL_ETH_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ETH_RxCpltCallback PROC
;;;1246     */
;;;1247   __weak void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
000000  4770              BX       lr
;;;1248   {
;;;1249     /* Prevent unused argument(s) compilation warning */
;;;1250     UNUSED(heth);
;;;1251     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1252     the HAL_ETH_TxCpltCallback could be implemented in the user file
;;;1253     */
;;;1254   }
;;;1255   
                          ENDP


                          AREA ||i.HAL_ETH_Start||, CODE, READONLY, ALIGN=1

                  HAL_ETH_Start PROC
;;;1446    */
;;;1447   HAL_StatusTypeDef HAL_ETH_Start(ETH_HandleTypeDef *heth)
000000  b570              PUSH     {r4-r6,lr}
;;;1448   {
000002  4604              MOV      r4,r0
;;;1449     /* Process Locked */
;;;1450     __HAL_LOCK(heth);
000004  f8940045          LDRB     r0,[r4,#0x45]
000008  2801              CMP      r0,#1
00000a  d019              BEQ      |L28.64|
00000c  2501              MOVS     r5,#1
00000e  f8845045          STRB     r5,[r4,#0x45]
;;;1451   
;;;1452     /* Set the ETH peripheral state to BUSY */
;;;1453     heth->State = HAL_ETH_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f8840044          STRB     r0,[r4,#0x44]
;;;1454   
;;;1455     /* Enable transmit state machine of the MAC for transmission on the MII */
;;;1456     ETH_MACTransmissionEnable(heth);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       ETH_MACTransmissionEnable
;;;1457   
;;;1458     /* Enable receive state machine of the MAC for reception from the MII */
;;;1459     ETH_MACReceptionEnable(heth);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       ETH_MACReceptionEnable
;;;1460   
;;;1461     /* Flush Transmit FIFO */
;;;1462     ETH_FlushTransmitFIFO(heth);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       ETH_FlushTransmitFIFO
;;;1463   
;;;1464     /* Start DMA transmission */
;;;1465     ETH_DMATransmissionEnable(heth);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       ETH_DMATransmissionEnable
;;;1466   
;;;1467     /* Start DMA reception */
;;;1468     ETH_DMAReceptionEnable(heth);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       ETH_DMAReceptionEnable
;;;1469   
;;;1470     /* Set the ETH state to READY*/
;;;1471     heth->State = HAL_ETH_STATE_READY;
000036  f8045f44          STRB     r5,[r4,#0x44]!
;;;1472   
;;;1473     /* Process Unlocked */
;;;1474     __HAL_UNLOCK(heth);
00003a  2000              MOVS     r0,#0
00003c  7060              STRB     r0,[r4,#1]
;;;1475   
;;;1476     /* Return function status */
;;;1477     return HAL_OK;
;;;1478   }
00003e  bd70              POP      {r4-r6,pc}
                  |L28.64|
000040  2002              MOVS     r0,#2                 ;1450
000042  bd70              POP      {r4-r6,pc}
;;;1479   
                          ENDP


                          AREA ||i.HAL_ETH_Stop||, CODE, READONLY, ALIGN=1

                  HAL_ETH_Stop PROC
;;;1485     */
;;;1486   HAL_StatusTypeDef HAL_ETH_Stop(ETH_HandleTypeDef *heth)
000000  b570              PUSH     {r4-r6,lr}
;;;1487   {
000002  4604              MOV      r4,r0
;;;1488     /* Process Locked */
;;;1489     __HAL_LOCK(heth);
000004  f8940045          LDRB     r0,[r4,#0x45]
000008  2801              CMP      r0,#1
00000a  d019              BEQ      |L29.64|
00000c  2501              MOVS     r5,#1
00000e  f8845045          STRB     r5,[r4,#0x45]
;;;1490   
;;;1491     /* Set the ETH peripheral state to BUSY */
;;;1492     heth->State = HAL_ETH_STATE_BUSY;
000012  2002              MOVS     r0,#2
000014  f8840044          STRB     r0,[r4,#0x44]
;;;1493   
;;;1494     /* Stop DMA transmission */
;;;1495     ETH_DMATransmissionDisable(heth);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       ETH_DMATransmissionDisable
;;;1496   
;;;1497     /* Stop DMA reception */
;;;1498     ETH_DMAReceptionDisable(heth);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       ETH_DMAReceptionDisable
;;;1499   
;;;1500     /* Disable receive state machine of the MAC for reception from the MII */
;;;1501     ETH_MACReceptionDisable(heth);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       ETH_MACReceptionDisable
;;;1502   
;;;1503     /* Flush Transmit FIFO */
;;;1504     ETH_FlushTransmitFIFO(heth);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       ETH_FlushTransmitFIFO
;;;1505   
;;;1506     /* Disable transmit state machine of the MAC for transmission on the MII */
;;;1507     ETH_MACTransmissionDisable(heth);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       ETH_MACTransmissionDisable
;;;1508   
;;;1509     /* Set the ETH state*/
;;;1510     heth->State = HAL_ETH_STATE_READY;
000036  f8045f44          STRB     r5,[r4,#0x44]!
;;;1511   
;;;1512     /* Process Unlocked */
;;;1513     __HAL_UNLOCK(heth);
00003a  2000              MOVS     r0,#0
00003c  7060              STRB     r0,[r4,#1]
;;;1514   
;;;1515     /* Return function status */
;;;1516     return HAL_OK;
;;;1517   }
00003e  bd70              POP      {r4-r6,pc}
                  |L29.64|
000040  2002              MOVS     r0,#2                 ;1489
000042  bd70              POP      {r4-r6,pc}
;;;1518   
                          ENDP


                          AREA ||i.HAL_ETH_TransmitFrame||, CODE, READONLY, ALIGN=1

                  HAL_ETH_TransmitFrame PROC
;;;879      */
;;;880    HAL_StatusTypeDef HAL_ETH_TransmitFrame(ETH_HandleTypeDef *heth, uint32_t FrameLength)
000000  b5f0              PUSH     {r4-r7,lr}
;;;881    {
;;;882      uint32_t bufcount = 0U, size = 0U, i = 0U;
000002  2300              MOVS     r3,#0
;;;883    
;;;884      /* Process Locked */
;;;885      __HAL_LOCK(heth);
000004  f8902045          LDRB     r2,[r0,#0x45]
000008  2a01              CMP      r2,#1
00000a  d011              BEQ      |L30.48|
00000c  2701              MOVS     r7,#1
00000e  f8807045          STRB     r7,[r0,#0x45]
;;;886    
;;;887      /* Set the ETH peripheral state to BUSY */
;;;888      heth->State = HAL_ETH_STATE_BUSY;
000012  2202              MOVS     r2,#2
000014  f8802044          STRB     r2,[r0,#0x44]
;;;889    
;;;890      if (FrameLength == 0U)
000018  2600              MOVS     r6,#0
00001a  b159              CBZ      r1,|L30.52|
;;;891      {
;;;892        /* Set ETH HAL state to READY */
;;;893        heth->State = HAL_ETH_STATE_READY;
;;;894    
;;;895        /* Process Unlocked */
;;;896        __HAL_UNLOCK(heth);
;;;897    
;;;898        return  HAL_ERROR;
;;;899      }
;;;900    
;;;901      /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
;;;902      if (((heth->TxDesc)->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
00001c  6ac4              LDR      r4,[r0,#0x2c]
00001e  6822              LDR      r2,[r4,#0]
000020  2a00              CMP      r2,#0
000022  da0c              BGE      |L30.62|
;;;903      {
;;;904        /* OWN bit set */
;;;905        heth->State = HAL_ETH_STATE_BUSY_TX;
000024  2112              MOVS     r1,#0x12
000026  f8001f44          STRB     r1,[r0,#0x44]!
;;;906    
;;;907        /* Process Unlocked */
;;;908        __HAL_UNLOCK(heth);
00002a  7046              STRB     r6,[r0,#1]
;;;909    
;;;910        return HAL_ERROR;
00002c  2001              MOVS     r0,#1
;;;911      }
;;;912    
;;;913      /* Get the number of needed Tx buffers for the current frame */
;;;914      if (FrameLength > ETH_TX_BUF_SIZE)
;;;915      {
;;;916        bufcount = FrameLength / ETH_TX_BUF_SIZE;
;;;917        if (FrameLength % ETH_TX_BUF_SIZE)
;;;918        {
;;;919          bufcount++;
;;;920        }
;;;921      }
;;;922      else
;;;923      {
;;;924        bufcount = 1U;
;;;925      }
;;;926      if (bufcount == 1U)
;;;927      {
;;;928        /* Set LAST and FIRST segment */
;;;929        heth->TxDesc->Status |= ETH_DMATXDESC_FS | ETH_DMATXDESC_LS;
;;;930        /* Set frame size */
;;;931        heth->TxDesc->ControlBufferSize = (FrameLength & ETH_DMATXDESC_TBS1);
;;;932        /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
;;;933        heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
;;;934        /* Point to next descriptor */
;;;935        heth->TxDesc = (ETH_DMADescTypeDef *)(heth->TxDesc->Buffer2NextDescAddr);
;;;936      }
;;;937      else
;;;938      {
;;;939        for (i = 0U; i < bufcount; i++)
;;;940        {
;;;941          /* Clear FIRST and LAST segment bits */
;;;942          heth->TxDesc->Status &= ~(ETH_DMATXDESC_FS | ETH_DMATXDESC_LS);
;;;943    
;;;944          if (i == 0U)
;;;945          {
;;;946            /* Setting the first segment bit */
;;;947            heth->TxDesc->Status |= ETH_DMATXDESC_FS;
;;;948          }
;;;949    
;;;950          /* Program size */
;;;951          heth->TxDesc->ControlBufferSize = (ETH_TX_BUF_SIZE & ETH_DMATXDESC_TBS1);
;;;952    
;;;953          if (i == (bufcount - 1U))
;;;954          {
;;;955            /* Setting the last segment bit */
;;;956            heth->TxDesc->Status |= ETH_DMATXDESC_LS;
;;;957            size = FrameLength - (bufcount - 1U) * ETH_TX_BUF_SIZE;
;;;958            heth->TxDesc->ControlBufferSize = (size & ETH_DMATXDESC_TBS1);
;;;959          }
;;;960    
;;;961          /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
;;;962          heth->TxDesc->Status |= ETH_DMATXDESC_OWN;
;;;963          /* point to next descriptor */
;;;964          heth->TxDesc = (ETH_DMADescTypeDef *)(heth->TxDesc->Buffer2NextDescAddr);
;;;965        }
;;;966      }
;;;967    
;;;968      /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
;;;969      if (((heth->Instance)->DMASR & ETH_DMASR_TBUS) != (uint32_t)RESET)
;;;970      {
;;;971        /* Clear TBUS ETHERNET DMA flag */
;;;972        (heth->Instance)->DMASR = ETH_DMASR_TBUS;
;;;973        /* Resume DMA transmission*/
;;;974        (heth->Instance)->DMATPDR = 0U;
;;;975      }
;;;976    
;;;977      /* Set ETH HAL State to Ready */
;;;978      heth->State = HAL_ETH_STATE_READY;
;;;979    
;;;980      /* Process Unlocked */
;;;981      __HAL_UNLOCK(heth);
;;;982    
;;;983      /* Return function status */
;;;984      return HAL_OK;
;;;985    }
00002e  bdf0              POP      {r4-r7,pc}
                  |L30.48|
000030  2002              MOVS     r0,#2                 ;885
000032  bdf0              POP      {r4-r7,pc}
                  |L30.52|
000034  f8007f44          STRB     r7,[r0,#0x44]!        ;893
000038  7046              STRB     r6,[r0,#1]            ;896
00003a  2001              MOVS     r0,#1                 ;898
00003c  bdf0              POP      {r4-r7,pc}
                  |L30.62|
00003e  f24055f4          MOV      r5,#0x5f4             ;914
000042  42a9              CMP      r1,r5                 ;914
000044  d90a              BLS      |L30.92|
000046  fbb1f2f5          UDIV     r2,r1,r5              ;916
00004a  fbb1fcf5          UDIV     r12,r1,r5             ;917
00004e  fb051c1c          MLS      r12,r5,r12,r1         ;917
000052  f1bc0f00          CMP      r12,#0                ;917
000056  d002              BEQ      |L30.94|
000058  1c52              ADDS     r2,r2,#1              ;919
00005a  e000              B        |L30.94|
                  |L30.92|
00005c  2201              MOVS     r2,#1                 ;924
                  |L30.94|
00005e  2a01              CMP      r2,#1                 ;926
000060  d144              BNE      |L30.236|
000062  6822              LDR      r2,[r4,#0]            ;929
000064  f0425240          ORR      r2,r2,#0x30000000     ;929
000068  6022              STR      r2,[r4,#0]            ;929
00006a  6ac2              LDR      r2,[r0,#0x2c]         ;931
00006c  f3c1010c          UBFX     r1,r1,#0,#13          ;931
000070  6051              STR      r1,[r2,#4]            ;931
000072  6ac1              LDR      r1,[r0,#0x2c]         ;933
000074  680a              LDR      r2,[r1,#0]            ;933
000076  f0424200          ORR      r2,r2,#0x80000000     ;933
00007a  600a              STR      r2,[r1,#0]            ;933
00007c  6ac1              LDR      r1,[r0,#0x2c]         ;935
00007e  68c9              LDR      r1,[r1,#0xc]          ;935
000080  62c1              STR      r1,[r0,#0x2c]         ;935
000082  e035              B        |L30.240|
                  |L30.132|
000084  6ac4              LDR      r4,[r0,#0x2c]         ;942
000086  f8d4c000          LDR      r12,[r4,#0]           ;942
00008a  f02c5c40          BIC      r12,r12,#0x30000000   ;942
00008e  f8c4c000          STR      r12,[r4,#0]           ;942
000092  b933              CBNZ     r3,|L30.162|
000094  6ac4              LDR      r4,[r0,#0x2c]         ;947
000096  f8d4c000          LDR      r12,[r4,#0]           ;947
00009a  f04c5c80          ORR      r12,r12,#0x10000000   ;947
00009e  f8c4c000          STR      r12,[r4,#0]           ;947
                  |L30.162|
0000a2  6ac4              LDR      r4,[r0,#0x2c]         ;951
0000a4  6065              STR      r5,[r4,#4]            ;951
0000a6  1e54              SUBS     r4,r2,#1              ;953
0000a8  42a3              CMP      r3,r4                 ;953
0000aa  d114              BNE      |L30.214|
0000ac  6ac4              LDR      r4,[r0,#0x2c]         ;956
0000ae  f8d4c000          LDR      r12,[r4,#0]           ;956
0000b2  f04c5c00          ORR      r12,r12,#0x20000000   ;956
0000b6  f8c4c000          STR      r12,[r4,#0]           ;956
0000ba  f1c20401          RSB      r4,r2,#1              ;957
0000be  ebc414c4          RSB      r4,r4,r4,LSL #7       ;957
0000c2  eb040444          ADD      r4,r4,r4,LSL #1       ;957
0000c6  eb010484          ADD      r4,r1,r4,LSL #2       ;957
0000ca  f8d0c02c          LDR      r12,[r0,#0x2c]        ;958
0000ce  f3c4040c          UBFX     r4,r4,#0,#13          ;958
0000d2  f8cc4004          STR      r4,[r12,#4]           ;958
                  |L30.214|
0000d6  6ac4              LDR      r4,[r0,#0x2c]         ;962
0000d8  f8d4c000          LDR      r12,[r4,#0]           ;962
0000dc  f04c4c00          ORR      r12,r12,#0x80000000   ;962
0000e0  f8c4c000          STR      r12,[r4,#0]           ;962
0000e4  6ac4              LDR      r4,[r0,#0x2c]         ;964
0000e6  68e4              LDR      r4,[r4,#0xc]          ;964
0000e8  62c4              STR      r4,[r0,#0x2c]         ;964
0000ea  1c5b              ADDS     r3,r3,#1              ;939
                  |L30.236|
0000ec  4293              CMP      r3,r2                 ;939
0000ee  d3c9              BCC      |L30.132|
                  |L30.240|
0000f0  6801              LDR      r1,[r0,#0]            ;969
0000f2  f5015180          ADD      r1,r1,#0x1000         ;969
0000f6  694a              LDR      r2,[r1,#0x14]         ;969
0000f8  0752              LSLS     r2,r2,#29             ;969
0000fa  d505              BPL      |L30.264|
0000fc  2204              MOVS     r2,#4                 ;972
0000fe  614a              STR      r2,[r1,#0x14]         ;972
000100  6801              LDR      r1,[r0,#0]            ;974
000102  f5015180          ADD      r1,r1,#0x1000         ;974
000106  604e              STR      r6,[r1,#4]            ;974
                  |L30.264|
000108  f8007f44          STRB     r7,[r0,#0x44]!        ;978
00010c  7046              STRB     r6,[r0,#1]            ;981
00010e  2000              MOVS     r0,#0                 ;984
000110  bdf0              POP      {r4-r7,pc}
;;;986    
                          ENDP


                          AREA ||i.HAL_ETH_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_ETH_TxCpltCallback PROC
;;;1231     */
;;;1232   __weak void HAL_ETH_TxCpltCallback(ETH_HandleTypeDef *heth)
000000  4770              BX       lr
;;;1233   {
;;;1234     /* Prevent unused argument(s) compilation warning */
;;;1235     UNUSED(heth);
;;;1236     /* NOTE : This function Should not be modified, when the callback is needed,
;;;1237     the HAL_ETH_TxCpltCallback could be implemented in the user file
;;;1238     */
;;;1239   }
;;;1240   
                          ENDP


                          AREA ||i.HAL_ETH_WritePHYRegister||, CODE, READONLY, ALIGN=1

                  HAL_ETH_WritePHYRegister PROC
;;;1354     */
;;;1355   HAL_StatusTypeDef HAL_ETH_WritePHYRegister(ETH_HandleTypeDef *heth, uint16_t PHYReg, uint32_t RegValue)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1356   {
000004  4604              MOV      r4,r0
;;;1357     uint32_t tmpreg1 = 0U;
;;;1358     uint32_t tickstart = 0U;
;;;1359   
;;;1360     /* Check parameters */
;;;1361     assert_param(IS_ETH_PHY_ADDRESS(heth->Init.PhyAddress));
;;;1362   
;;;1363     /* Check the ETH peripheral state */
;;;1364     if (heth->State == HAL_ETH_STATE_BUSY_WR)
000006  f8940044          LDRB     r0,[r4,#0x44]
00000a  2842              CMP      r0,#0x42
00000c  d020              BEQ      |L32.80|
;;;1365     {
;;;1366       return HAL_BUSY;
;;;1367     }
;;;1368     /* Set ETH HAL State to BUSY_WR */
;;;1369     heth->State = HAL_ETH_STATE_BUSY_WR;
00000e  2042              MOVS     r0,#0x42
000010  f8840044          STRB     r0,[r4,#0x44]
;;;1370   
;;;1371     /* Get the ETHERNET MACMIIAR value */
;;;1372     tmpreg1 = heth->Instance->MACMIIAR;
000014  6820              LDR      r0,[r4,#0]
000016  6903              LDR      r3,[r0,#0x10]
;;;1373   
;;;1374     /* Keep only the CSR Clock Range CR[2:0] bits value */
;;;1375     tmpreg1 &= ~ETH_MACMIIAR_CR_MASK;
000018  f003031c          AND      r3,r3,#0x1c
;;;1376   
;;;1377     /* Prepare the MII register address value */
;;;1378     tmpreg1 |= (((uint32_t)heth->Init.PhyAddress << 11U) & ETH_MACMIIAR_PA); /* Set the PHY device address */
00001c  8a25              LDRH     r5,[r4,#0x10]
00001e  f64f76ff          MOV      r6,#0xffff
000022  ea0625c5          AND      r5,r6,r5,LSL #11
000026  431d              ORRS     r5,r5,r3
;;;1379     tmpreg1 |= (((uint32_t)PHYReg << 6U) & ETH_MACMIIAR_MR);              /* Set the PHY register address */
000028  f44f63f8          MOV      r3,#0x7c0
00002c  ea031181          AND      r1,r3,r1,LSL #6
000030  4329              ORRS     r1,r1,r5
;;;1380     tmpreg1 |= ETH_MACMIIAR_MW;                                           /* Set the write mode */
000032  f0410102          ORR      r1,r1,#2
;;;1381     tmpreg1 |= ETH_MACMIIAR_MB;                                           /* Set the MII Busy bit */
000036  f0410501          ORR      r5,r1,#1
;;;1382   
;;;1383     /* Give the value to the MII data register */
;;;1384     heth->Instance->MACMIIDR = (uint16_t)RegValue;
00003a  b291              UXTH     r1,r2
00003c  6141              STR      r1,[r0,#0x14]
;;;1385   
;;;1386     /* Write the result value into the MII Address register */
;;;1387     heth->Instance->MACMIIAR = tmpreg1;
00003e  6820              LDR      r0,[r4,#0]
000040  6105              STR      r5,[r0,#0x10]
;;;1388   
;;;1389     /* Get tick */
;;;1390     tickstart = HAL_GetTick();
000042  f7fffffe          BL       HAL_GetTick
000046  4606              MOV      r6,r0
;;;1391   
;;;1392     /* Check for the Busy flag */
;;;1393     while ((tmpreg1 & ETH_MACMIIAR_MB) == ETH_MACMIIAR_MB)
;;;1394     {
;;;1395       /* Check for the Timeout */
;;;1396       if ((HAL_GetTick() - tickstart) > PHY_WRITE_TO)
;;;1397       {
;;;1398         heth->State = HAL_ETH_STATE_READY;
000048  2701              MOVS     r7,#1
00004a  f44f28a0          MOV      r8,#0x50000           ;1396
00004e  e00f              B        |L32.112|
                  |L32.80|
000050  2002              MOVS     r0,#2                 ;1366
                  |L32.82|
;;;1399   
;;;1400         /* Process Unlocked */
;;;1401         __HAL_UNLOCK(heth);
;;;1402   
;;;1403         return HAL_TIMEOUT;
;;;1404       }
;;;1405   
;;;1406       tmpreg1 = heth->Instance->MACMIIAR;
;;;1407     }
;;;1408   
;;;1409     /* Set ETH HAL State to READY */
;;;1410     heth->State = HAL_ETH_STATE_READY;
;;;1411   
;;;1412     /* Return function status */
;;;1413     return HAL_OK;
;;;1414   }
000052  e8bd81f0          POP      {r4-r8,pc}
                  |L32.86|
000056  f7fffffe          BL       HAL_GetTick
00005a  1b80              SUBS     r0,r0,r6              ;1396
00005c  4540              CMP      r0,r8                 ;1396
00005e  d305              BCC      |L32.108|
000060  f8047f44          STRB     r7,[r4,#0x44]!        ;1398
000064  2000              MOVS     r0,#0                 ;1401
000066  7060              STRB     r0,[r4,#1]            ;1401
000068  2003              MOVS     r0,#3                 ;1403
00006a  e7f2              B        |L32.82|
                  |L32.108|
00006c  6820              LDR      r0,[r4,#0]            ;1406
00006e  6905              LDR      r5,[r0,#0x10]         ;1406
                  |L32.112|
000070  07e8              LSLS     r0,r5,#31             ;1393
000072  d1f0              BNE      |L32.86|
000074  f8847044          STRB     r7,[r4,#0x44]         ;1410
000078  e7eb              B        |L32.82|
;;;1415   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_eth.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_eth_c_dbbceda7____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_stm32f1xx_hal_eth_c_dbbceda7____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_eth_c_dbbceda7____REVSH|
#line 478
|__asm___19_stm32f1xx_hal_eth_c_dbbceda7____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f1xx_hal_eth_c_dbbceda7____RRX|
#line 665
|__asm___19_stm32f1xx_hal_eth_c_dbbceda7____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
