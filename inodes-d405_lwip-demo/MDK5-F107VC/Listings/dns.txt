; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\dns.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\dns.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\dns.crf ..\Middlewares\Third_Party\LwIP\src\core\dns.c]
                          THUMB

                          AREA ||i.dns_alloc_pcb||, CODE, READONLY, ALIGN=2

                  dns_alloc_pcb PROC
;;;899    static u8_t
;;;900    dns_alloc_pcb(void)
000000  b570              PUSH     {r4-r6,lr}
;;;901    {
;;;902      u8_t i;
;;;903      u8_t idx;
;;;904    
;;;905      for (i = 0; i < DNS_MAX_SOURCE_PORTS; i++) {
000002  2400              MOVS     r4,#0
;;;906        if (dns_pcbs[i] == NULL) {
000004  4d13              LDR      r5,|L1.84|
                  |L1.6|
000006  f8550024          LDR      r0,[r5,r4,LSL #2]
00000a  b118              CBZ      r0,|L1.20|
00000c  1c64              ADDS     r4,r4,#1              ;905
00000e  b2e4              UXTB     r4,r4                 ;905
000010  2c04              CMP      r4,#4                 ;905
000012  d3f8              BCC      |L1.6|
                  |L1.20|
;;;907          break;
;;;908        }
;;;909      }
;;;910      if (i < DNS_MAX_SOURCE_PORTS) {
;;;911        dns_pcbs[i] = dns_alloc_random_port();
;;;912        if (dns_pcbs[i] != NULL) {
;;;913          /* succeeded */
;;;914          dns_last_pcb_idx = i;
000014  4e10              LDR      r6,|L1.88|
000016  2c04              CMP      r4,#4                 ;910
000018  d207              BCS      |L1.42|
00001a  f7fffffe          BL       dns_alloc_random_port
00001e  f8450024          STR      r0,[r5,r4,LSL #2]     ;911
000022  b110              CBZ      r0,|L1.42|
000024  7034              STRB     r4,[r6,#0]
;;;915          return i;
000026  4620              MOV      r0,r4
;;;916        }
;;;917      }
;;;918      /* if we come here, creating a new UDP pcb failed, so we have to use
;;;919         an already existing one (so overflow is no issue) */
;;;920      for (i = 0, idx = (u8_t)(dns_last_pcb_idx + 1); i < DNS_MAX_SOURCE_PORTS; i++, idx++) {
;;;921        if (idx >= DNS_MAX_SOURCE_PORTS) {
;;;922          idx = 0;
;;;923        }
;;;924        if (dns_pcbs[idx] != NULL) {
;;;925          dns_last_pcb_idx = idx;
;;;926          return idx;
;;;927        }
;;;928      }
;;;929      return DNS_MAX_SOURCE_PORTS;
;;;930    }
000028  bd70              POP      {r4-r6,pc}
                  |L1.42|
00002a  2100              MOVS     r1,#0                 ;920
00002c  7830              LDRB     r0,[r6,#0]            ;920  ; dns_last_pcb_idx
00002e  1c40              ADDS     r0,r0,#1              ;920
000030  b2c0              UXTB     r0,r0                 ;920
000032  e00b              B        |L1.76|
                  |L1.52|
000034  2804              CMP      r0,#4                 ;921
000036  d300              BCC      |L1.58|
000038  2000              MOVS     r0,#0                 ;922
                  |L1.58|
00003a  f8552020          LDR      r2,[r5,r0,LSL #2]     ;924
00003e  b10a              CBZ      r2,|L1.68|
000040  7030              STRB     r0,[r6,#0]            ;925
000042  bd70              POP      {r4-r6,pc}
                  |L1.68|
000044  1c49              ADDS     r1,r1,#1              ;920
000046  b2c9              UXTB     r1,r1                 ;920
000048  1c40              ADDS     r0,r0,#1              ;920
00004a  b2c0              UXTB     r0,r0                 ;920
                  |L1.76|
00004c  2904              CMP      r1,#4                 ;920
00004e  d3f1              BCC      |L1.52|
000050  2004              MOVS     r0,#4                 ;929
000052  bd70              POP      {r4-r6,pc}
;;;931    #endif /* ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0) */
                          ENDP

                  |L1.84|
                          DCD      ||.bss||
                  |L1.88|
                          DCD      ||.data||

                          AREA ||i.dns_alloc_random_port||, CODE, READONLY, ALIGN=2

                  dns_alloc_random_port PROC
;;;865    static struct udp_pcb *
;;;866    dns_alloc_random_port(void)
000000  b570              PUSH     {r4-r6,lr}
;;;867    {
;;;868      err_t err;
;;;869      struct udp_pcb *pcb;
;;;870    
;;;871      pcb = udp_new_ip_type(IPADDR_TYPE_ANY);
000002  202e              MOVS     r0,#0x2e
000004  f7fffffe          BL       udp_new_ip_type
000008  4604              MOV      r4,r0
;;;872      if (pcb == NULL) {
00000a  0020              MOVS     r0,r4
00000c  d00d              BEQ      |L2.42|
;;;873        /* out of memory, have to reuse an existing pcb */
;;;874        return NULL;
;;;875      }
;;;876      do {
;;;877        u16_t port = (u16_t)DNS_RAND_TXID();
;;;878        if (DNS_PORT_ALLOWED(port)) {
00000e  f44f6680          MOV      r6,#0x400
;;;879          err = udp_bind(pcb, IP_ANY_TYPE, port);
;;;880        } else {
;;;881          /* this port is not allowed, try again */
;;;882          err = ERR_USE;
000012  f06f0507          MVN      r5,#7
                  |L2.22|
000016  f7fffffe          BL       rand
00001a  b282              UXTH     r2,r0                 ;877
00001c  42b2              CMP      r2,r6                 ;878
00001e  d306              BCC      |L2.46|
000020  490b              LDR      r1,|L2.80|
000022  4620              MOV      r0,r4                 ;879
000024  f7fffffe          BL       udp_bind
000028  e002              B        |L2.48|
                  |L2.42|
00002a  2000              MOVS     r0,#0                 ;874
;;;883        }
;;;884      } while (err == ERR_USE);
;;;885      if (err != ERR_OK) {
;;;886        udp_remove(pcb);
;;;887        return NULL;
;;;888      }
;;;889      udp_recv(pcb, dns_recv, NULL);
;;;890      return pcb;
;;;891    }
00002c  bd70              POP      {r4-r6,pc}
                  |L2.46|
00002e  4628              MOV      r0,r5                 ;882
                  |L2.48|
000030  f1100f08          CMN      r0,#8                 ;884
000034  d0ef              BEQ      |L2.22|
000036  b120              CBZ      r0,|L2.66|
000038  4620              MOV      r0,r4                 ;886
00003a  f7fffffe          BL       udp_remove
00003e  2000              MOVS     r0,#0                 ;887
000040  bd70              POP      {r4-r6,pc}
                  |L2.66|
000042  2200              MOVS     r2,#0                 ;889
000044  4903              LDR      r1,|L2.84|
000046  4620              MOV      r0,r4                 ;889
000048  f7fffffe          BL       udp_recv
00004c  4620              MOV      r0,r4                 ;890
00004e  bd70              POP      {r4-r6,pc}
;;;892    
                          ENDP

                  |L2.80|
                          DCD      ip_addr_any
                  |L2.84|
                          DCD      dns_recv

                          AREA ||i.dns_backupserver_available||, CODE, READONLY, ALIGN=2

                  dns_backupserver_available PROC
;;;1023   static u8_t
;;;1024   dns_backupserver_available(struct dns_table_entry *pentry)
000000  4601              MOV      r1,r0
;;;1025   {
;;;1026     u8_t ret = 0;
000002  2000              MOVS     r0,#0
;;;1027   
;;;1028     if (pentry) {
000004  2900              CMP      r1,#0
000006  d009              BEQ      |L3.28|
;;;1029       if ((pentry->server_idx + 1 < DNS_MAX_SERVERS) && !ip_addr_isany_val(dns_servers[pentry->server_idx + 1])) {
000008  7ac9              LDRB     r1,[r1,#0xb]
00000a  1c49              ADDS     r1,r1,#1
00000c  2902              CMP      r1,#2
00000e  d205              BCS      |L3.28|
000010  4a03              LDR      r2,|L3.32|
000012  f8521021          LDR      r1,[r2,r1,LSL #2]
000016  2900              CMP      r1,#0
000018  d000              BEQ      |L3.28|
;;;1030         ret = 1;
00001a  2001              MOVS     r0,#1
                  |L3.28|
;;;1031       }
;;;1032     }
;;;1033   
;;;1034     return ret;
;;;1035   }
00001c  4770              BX       lr
;;;1036   
                          ENDP

00001e  0000              DCW      0x0000
                  |L3.32|
                          DCD      ||.data||+0x4

                          AREA ||i.dns_call_found||, CODE, READONLY, ALIGN=2

                  dns_call_found PROC
;;;941    static void
;;;942    dns_call_found(u8_t idx, ip_addr_t *addr)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;943    {
000004  4607              MOV      r7,r0
000006  468b              MOV      r11,r1
;;;944    #if ((LWIP_DNS_SECURE & (LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING | LWIP_DNS_SECURE_RAND_SRC_PORT)) != 0)
;;;945      u8_t i;
;;;946    #endif
;;;947    
;;;948    #if LWIP_IPV4 && LWIP_IPV6
;;;949      if (addr != NULL) {
;;;950        /* check that address type matches the request and adapt the table entry */
;;;951        if (IP_IS_V6_VAL(*addr)) {
;;;952          LWIP_ASSERT("invalid response", LWIP_DNS_ADDRTYPE_IS_IPV6(dns_table[idx].reqaddrtype));
;;;953          dns_table[idx].reqaddrtype = LWIP_DNS_ADDRTYPE_IPV6;
;;;954        } else {
;;;955          LWIP_ASSERT("invalid response", !LWIP_DNS_ADDRTYPE_IS_IPV6(dns_table[idx].reqaddrtype));
;;;956          dns_table[idx].reqaddrtype = LWIP_DNS_ADDRTYPE_IPV4;
;;;957        }
;;;958      }
;;;959    #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;960    
;;;961    #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
;;;962      for (i = 0; i < DNS_MAX_REQUESTS; i++) {
000008  2500              MOVS     r5,#0
;;;963        if (dns_requests[i].found && (dns_requests[i].dns_table_idx == idx)) {
00000a  f8df8080          LDR      r8,|L4.140|
;;;964          (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
00000e  eb071007          ADD      r0,r7,r7,LSL #4
000012  f5a86a88          SUB      r10,r8,#0x440
000016  46a9              MOV      r9,r5                 ;962
000018  eb0a1400          ADD      r4,r10,r0,LSL #4
                  |L4.28|
00001c  eb050645          ADD      r6,r5,r5,LSL #1       ;963
000020  f8583026          LDR      r3,[r8,r6,LSL #2]     ;963
000024  b15b              CBZ      r3,|L4.62|
000026  eb080086          ADD      r0,r8,r6,LSL #2       ;963
00002a  7a01              LDRB     r1,[r0,#8]            ;963
00002c  42b9              CMP      r1,r7                 ;963
00002e  d106              BNE      |L4.62|
000030  6842              LDR      r2,[r0,#4]
000032  f1040010          ADD      r0,r4,#0x10
000036  4659              MOV      r1,r11
000038  4798              BLX      r3
;;;965          /* flush this entry */
;;;966          dns_requests[i].found = NULL;
00003a  f8489026          STR      r9,[r8,r6,LSL #2]
                  |L4.62|
00003e  1c6d              ADDS     r5,r5,#1              ;962
000040  b2ed              UXTB     r5,r5                 ;962
000042  2d04              CMP      r5,#4                 ;962
000044  d3ea              BCC      |L4.28|
;;;967        }
;;;968      }
;;;969    #else
;;;970      if (dns_requests[idx].found) {
;;;971        (*dns_requests[idx].found)(dns_table[idx].name, addr, dns_requests[idx].arg);
;;;972      }
;;;973      dns_requests[idx].found = NULL;
;;;974    #endif
;;;975    #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
;;;976      /* close the pcb used unless other request are using it */
;;;977      for (i = 0; i < DNS_MAX_REQUESTS; i++) {
000046  2100              MOVS     r1,#0
;;;978        if (i == idx) {
;;;979          continue; /* only check other requests */
;;;980        }
;;;981        if (dns_table[i].state == DNS_STATE_ASKING) {
;;;982          if (dns_table[i].pcb_idx == dns_table[idx].pcb_idx) {
;;;983            /* another request is still using the same pcb */
;;;984            dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
000048  2504              MOVS     r5,#4
                  |L4.74|
00004a  42b9              CMP      r1,r7                 ;978
00004c  d00c              BEQ      |L4.104|
00004e  eb011001          ADD      r0,r1,r1,LSL #4       ;981
000052  eb0a1000          ADD      r0,r10,r0,LSL #4      ;981
000056  7a82              LDRB     r2,[r0,#0xa]          ;981
000058  2a02              CMP      r2,#2                 ;981
00005a  d105              BNE      |L4.104|
00005c  7bc0              LDRB     r0,[r0,#0xf]          ;982
00005e  7be2              LDRB     r2,[r4,#0xf]          ;982
000060  4290              CMP      r0,r2                 ;982
000062  d101              BNE      |L4.104|
000064  73e5              STRB     r5,[r4,#0xf]
;;;985            break;
000066  e003              B        |L4.112|
                  |L4.104|
000068  1c49              ADDS     r1,r1,#1              ;977
00006a  b2c9              UXTB     r1,r1                 ;977
00006c  2904              CMP      r1,#4                 ;977
00006e  d3ec              BCC      |L4.74|
                  |L4.112|
;;;986          }
;;;987        }
;;;988      }
;;;989      if (dns_table[idx].pcb_idx < DNS_MAX_SOURCE_PORTS) {
000070  7be0              LDRB     r0,[r4,#0xf]
000072  2804              CMP      r0,#4
000074  d208              BCS      |L4.136|
;;;990        /* if we come here, the pcb is not used any more and can be removed */
;;;991        udp_remove(dns_pcbs[dns_table[idx].pcb_idx]);
000076  4e06              LDR      r6,|L4.144|
000078  f8560020          LDR      r0,[r6,r0,LSL #2]
00007c  f7fffffe          BL       udp_remove
;;;992        dns_pcbs[dns_table[idx].pcb_idx] = NULL;
000080  7be0              LDRB     r0,[r4,#0xf]
000082  f8469020          STR      r9,[r6,r0,LSL #2]
;;;993        dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
000086  73e5              STRB     r5,[r4,#0xf]
                  |L4.136|
;;;994      }
;;;995    #endif
;;;996    }
000088  e8bd9ff0          POP      {r4-r12,pc}
;;;997    
                          ENDP

                  |L4.140|
                          DCD      ||.bss||+0x450
                  |L4.144|
                          DCD      ||.bss||

                          AREA ||i.dns_check_entries||, CODE, READONLY, ALIGN=1

                  dns_check_entries PROC
;;;1123   static void
;;;1124   dns_check_entries(void)
000000  b510              PUSH     {r4,lr}
;;;1125   {
;;;1126     u8_t i;
;;;1127   
;;;1128     for (i = 0; i < DNS_TABLE_SIZE; ++i) {
000002  2400              MOVS     r4,#0
                  |L5.4|
;;;1129       dns_check_entry(i);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       dns_check_entry
00000a  1c64              ADDS     r4,r4,#1              ;1128
00000c  b2e4              UXTB     r4,r4                 ;1128
00000e  2c04              CMP      r4,#4                 ;1128
000010  d3f8              BCC      |L5.4|
;;;1130     }
;;;1131   }
000012  bd10              POP      {r4,pc}
;;;1132   
                          ENDP


                          AREA ||i.dns_check_entry||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  dns_check_entry PROC
;;;1046   static void
;;;1047   dns_check_entry(u8_t i)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1048   {
000004  4605              MOV      r5,r0
;;;1049     err_t err;
;;;1050     struct dns_table_entry *entry = &dns_table[i];
000006  492c              LDR      r1,|L6.184|
000008  eb051005          ADD      r0,r5,r5,LSL #4
00000c  eb011400          ADD      r4,r1,r0,LSL #4
;;;1051   
;;;1052     LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
000010  2d04              CMP      r5,#4
000012  d306              BCC      |L6.34|
000014  a329              ADR      r3,|L6.188|
000016  f240421c          MOV      r2,#0x41c
00001a  a134              ADR      r1,|L6.236|
00001c  a03a              ADR      r0,|L6.264|
00001e  f7fffffe          BL       __2printf
                  |L6.34|
;;;1053   
;;;1054     switch (entry->state) {
000022  7aa0              LDRB     r0,[r4,#0xa]
000024  2800              CMP      r0,#0
000026  d03e              BEQ      |L6.166|
000028  2600              MOVS     r6,#0
00002a  2701              MOVS     r7,#1
00002c  2801              CMP      r0,#1
00002e  d00c              BEQ      |L6.74|
000030  2802              CMP      r0,#2
000032  d017              BEQ      |L6.100|
000034  2803              CMP      r0,#3
000036  d038              BEQ      |L6.170|
;;;1055       case DNS_STATE_NEW:
;;;1056         /* initialize new entry */
;;;1057         entry->txid = dns_create_txid();
;;;1058         entry->state = DNS_STATE_ASKING;
;;;1059         entry->server_idx = 0;
;;;1060         entry->tmr = 1;
;;;1061         entry->retries = 0;
;;;1062   
;;;1063         /* send DNS packet for this entry */
;;;1064         err = dns_send(i);
;;;1065         if (err != ERR_OK) {
;;;1066           LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
;;;1067                       ("dns_send returned error: %s\n", lwip_strerr(err)));
;;;1068         }
;;;1069         break;
;;;1070       case DNS_STATE_ASKING:
;;;1071         if (--entry->tmr == 0) {
;;;1072           if (++entry->retries == DNS_MAX_RETRIES) {
;;;1073             if (dns_backupserver_available(entry)
;;;1074   #if LWIP_DNS_SUPPORT_MDNS_QUERIES
;;;1075                 && !entry->is_mdns
;;;1076   #endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
;;;1077                ) {
;;;1078               /* change of server */
;;;1079               entry->server_idx++;
;;;1080               entry->tmr = 1;
;;;1081               entry->retries = 0;
;;;1082             } else {
;;;1083               LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": timeout\n", entry->name));
;;;1084               /* call specified callback function if provided */
;;;1085               dns_call_found(i, NULL);
;;;1086               /* flush this entry */
;;;1087               entry->state = DNS_STATE_UNUSED;
;;;1088               break;
;;;1089             }
;;;1090           } else {
;;;1091             /* wait longer for the next retry */
;;;1092             entry->tmr = entry->retries;
;;;1093           }
;;;1094   
;;;1095           /* send DNS packet for this entry */
;;;1096           err = dns_send(i);
;;;1097           if (err != ERR_OK) {
;;;1098             LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
;;;1099                         ("dns_send returned error: %s\n", lwip_strerr(err)));
;;;1100           }
;;;1101         }
;;;1102         break;
;;;1103       case DNS_STATE_DONE:
;;;1104         /* if the time to live is nul */
;;;1105         if ((entry->ttl == 0) || (--entry->ttl == 0)) {
;;;1106           LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", entry->name));
;;;1107           /* flush this entry, there cannot be any related pending entries in this state */
;;;1108           entry->state = DNS_STATE_UNUSED;
;;;1109         }
;;;1110         break;
;;;1111       case DNS_STATE_UNUSED:
;;;1112         /* nothing to do */
;;;1113         break;
;;;1114       default:
;;;1115         LWIP_ASSERT("unknown dns_table entry state:", 0);
000038  e8bd41f0          POP      {r4-r8,lr}
00003c  a31f              ADR      r3,|L6.188|
00003e  f240425b          MOV      r2,#0x45b
000042  a13b              ADR      r1,|L6.304|
000044  a030              ADR      r0,|L6.264|
000046  f7ffbffe          B.W      __2printf
                  |L6.74|
00004a  f7fffffe          BL       dns_create_txid
00004e  8120              STRH     r0,[r4,#8]            ;1057
000050  2002              MOVS     r0,#2                 ;1058
000052  72a0              STRB     r0,[r4,#0xa]          ;1058
000054  72e6              STRB     r6,[r4,#0xb]          ;1059
000056  7327              STRB     r7,[r4,#0xc]          ;1060
000058  7366              STRB     r6,[r4,#0xd]          ;1061
00005a  4628              MOV      r0,r5                 ;1064
00005c  e8bd41f0          POP      {r4-r8,lr}            ;1064
000060  f7ffbffe          B.W      dns_send
                  |L6.100|
000064  7b20              LDRB     r0,[r4,#0xc]          ;1071
000066  1e40              SUBS     r0,r0,#1              ;1071
000068  f01000ff          ANDS     r0,r0,#0xff           ;1071
00006c  7320              STRB     r0,[r4,#0xc]          ;1071
00006e  d11a              BNE      |L6.166|
000070  7b60              LDRB     r0,[r4,#0xd]          ;1072
000072  1c40              ADDS     r0,r0,#1              ;1072
000074  b2c0              UXTB     r0,r0                 ;1072
000076  7360              STRB     r0,[r4,#0xd]          ;1072
000078  2804              CMP      r0,#4                 ;1072
00007a  d005              BEQ      |L6.136|
00007c  7320              STRB     r0,[r4,#0xc]          ;1092
                  |L6.126|
00007e  4628              MOV      r0,r5                 ;1096
000080  e8bd41f0          POP      {r4-r8,lr}            ;1096
000084  f7ffbffe          B.W      dns_send
                  |L6.136|
000088  4620              MOV      r0,r4                 ;1073
00008a  f7fffffe          BL       dns_backupserver_available
00008e  b128              CBZ      r0,|L6.156|
000090  7ae0              LDRB     r0,[r4,#0xb]          ;1079
000092  1c40              ADDS     r0,r0,#1              ;1079
000094  72e0              STRB     r0,[r4,#0xb]          ;1079
000096  7327              STRB     r7,[r4,#0xc]          ;1080
000098  7366              STRB     r6,[r4,#0xd]          ;1081
00009a  e7f0              B        |L6.126|
                  |L6.156|
00009c  2100              MOVS     r1,#0                 ;1085
00009e  4628              MOV      r0,r5                 ;1085
0000a0  f7fffffe          BL       dns_call_found
0000a4  72a6              STRB     r6,[r4,#0xa]          ;1087
                  |L6.166|
;;;1116         break;
;;;1117     }
;;;1118   }
0000a6  e8bd81f0          POP      {r4-r8,pc}
                  |L6.170|
0000aa  6820              LDR      r0,[r4,#0]            ;1105
0000ac  b110              CBZ      r0,|L6.180|
0000ae  1e40              SUBS     r0,r0,#1              ;1105
0000b0  6020              STR      r0,[r4,#0]            ;1105
0000b2  d1f8              BNE      |L6.166|
                  |L6.180|
0000b4  72a6              STRB     r6,[r4,#0xa]          ;1108
0000b6  e7f6              B        |L6.166|
;;;1119   
                          ENDP

                  |L6.184|
                          DCD      ||.bss||+0x10
                  |L6.188|
0000bc  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\dns.c",0
0000c0  6964646c
0000c4  65776172
0000c8  65735c54
0000cc  68697264
0000d0  5f506172
0000d4  74795c4c
0000d8  7749505c
0000dc  7372635c
0000e0  636f7265
0000e4  5c646e73
0000e8  2e6300  
0000eb  00                DCB      0
                  |L6.236|
0000ec  61727261          DCB      "array index out of bounds",0
0000f0  7920696e
0000f4  64657820
0000f8  6f757420
0000fc  6f662062
000100  6f756e64
000104  7300    
000106  00                DCB      0
000107  00                DCB      0
                  |L6.264|
000108  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00010c  7274696f
000110  6e202225
000114  73222066
000118  61696c65
00011c  64206174
000120  206c696e
000124  65202564
000128  20696e20
00012c  25730a00
                  |L6.304|
000130  756e6b6e          DCB      "unknown dns_table entry state:",0
000134  6f776e20
000138  646e735f
00013c  7461626c
000140  6520656e
000144  74727920
000148  73746174
00014c  653a00  
00014f  00                DCB      0

                          AREA ||i.dns_compare_name||, CODE, READONLY, ALIGN=1

                  dns_compare_name PROC
;;;650    static u16_t
;;;651    dns_compare_name(const char *query, struct pbuf *p, u16_t start_offset)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;652    {
000004  4606              MOV      r6,r0
000006  468a              MOV      r10,r1
000008  4614              MOV      r4,r2
;;;653      int n;
;;;654      u16_t response_offset = start_offset;
;;;655    
;;;656      do {
;;;657        n = pbuf_try_get_at(p, response_offset);
;;;658        if ((n < 0) || (response_offset == 0xFFFF)) {
00000a  f64f79ff          MOV      r9,#0xffff
                  |L7.14|
00000e  4621              MOV      r1,r4                 ;657
000010  4650              MOV      r0,r10                ;657
000012  f7fffffe          BL       pbuf_try_get_at
000016  4605              MOV      r5,r0                 ;657
000018  0028              MOVS     r0,r5
00001a  d401              BMI      |L7.32|
00001c  454c              CMP      r4,r9
00001e  d102              BNE      |L7.38|
                  |L7.32|
;;;659          /* error or overflow */
;;;660          return 0xFFFF;
000020  4648              MOV      r0,r9
                  |L7.34|
;;;661        }
;;;662        response_offset++;
;;;663        /** @see RFC 1035 - 4.1.4. Message compression */
;;;664        if ((n & 0xc0) == 0xc0) {
;;;665          /* Compressed name: cannot be equal since we don't send them */
;;;666          return 0xFFFF;
;;;667        } else {
;;;668          /* Not compressed name */
;;;669          while (n > 0) {
;;;670            int c = pbuf_try_get_at(p, response_offset);
;;;671            if (c < 0) {
;;;672              return 0xFFFF;
;;;673            }
;;;674            if (lwip_tolower((*query)) != lwip_tolower((u8_t)c)) {
;;;675              return 0xFFFF;
;;;676            }
;;;677            if (response_offset == 0xFFFF) {
;;;678              /* would overflow */
;;;679              return 0xFFFF;
;;;680            }
;;;681            response_offset++;
;;;682            ++query;
;;;683            --n;
;;;684          }
;;;685          ++query;
;;;686        }
;;;687        n = pbuf_try_get_at(p, response_offset);
;;;688        if (n < 0) {
;;;689          return 0xFFFF;
;;;690        }
;;;691      } while (n != 0);
;;;692    
;;;693      if (response_offset == 0xFFFF) {
;;;694        /* would overflow */
;;;695        return 0xFFFF;
;;;696      }
;;;697      return (u16_t)(response_offset + 1);
;;;698    }
000022  e8bd87f0          POP      {r4-r10,pc}
                  |L7.38|
000026  1c64              ADDS     r4,r4,#1              ;662
000028  b2a4              UXTH     r4,r4                 ;662
00002a  f3c51081          UBFX     r0,r5,#6,#2           ;664
00002e  2803              CMP      r0,#3                 ;664
000030  d11d              BNE      |L7.110|
000032  4648              MOV      r0,r9                 ;666
000034  e7f5              B        |L7.34|
                  |L7.54|
000036  4621              MOV      r1,r4                 ;670
000038  4650              MOV      r0,r10                ;670
00003a  f7fffffe          BL       pbuf_try_get_at
00003e  4607              MOV      r7,r0                 ;670
000040  0038              MOVS     r0,r7                 ;671
000042  d501              BPL      |L7.72|
000044  4648              MOV      r0,r9                 ;672
000046  e7ec              B        |L7.34|
                  |L7.72|
000048  7830              LDRB     r0,[r6,#0]            ;674
00004a  f7fffffe          BL       tolower
00004e  4680              MOV      r8,r0                 ;674
000050  b2f8              UXTB     r0,r7                 ;674
000052  f7fffffe          BL       tolower
000056  4580              CMP      r8,r0                 ;674
000058  d001              BEQ      |L7.94|
00005a  4648              MOV      r0,r9                 ;675
00005c  e7e1              B        |L7.34|
                  |L7.94|
00005e  454c              CMP      r4,r9                 ;677
000060  d101              BNE      |L7.102|
000062  4648              MOV      r0,r9                 ;679
000064  e7dd              B        |L7.34|
                  |L7.102|
000066  1c64              ADDS     r4,r4,#1              ;681
000068  b2a4              UXTH     r4,r4                 ;681
00006a  1c76              ADDS     r6,r6,#1              ;682
00006c  1e6d              SUBS     r5,r5,#1              ;683
                  |L7.110|
00006e  2d00              CMP      r5,#0                 ;669
000070  dce1              BGT      |L7.54|
000072  1c76              ADDS     r6,r6,#1              ;685
000074  4621              MOV      r1,r4                 ;687
000076  4650              MOV      r0,r10                ;687
000078  f7fffffe          BL       pbuf_try_get_at
00007c  2800              CMP      r0,#0                 ;688
00007e  da01              BGE      |L7.132|
000080  4648              MOV      r0,r9                 ;689
000082  e7ce              B        |L7.34|
                  |L7.132|
000084  d1c3              BNE      |L7.14|
000086  4648              MOV      r0,r9                 ;693
000088  4284              CMP      r4,r0                 ;693
00008a  d0ca              BEQ      |L7.34|
00008c  1c64              ADDS     r4,r4,#1              ;697
00008e  b2a0              UXTH     r0,r4                 ;697
000090  e7c7              B        |L7.34|
;;;699    
                          ENDP


                          AREA ||i.dns_correct_response||, CODE, READONLY, ALIGN=2

                  dns_correct_response PROC
;;;1136   static void
;;;1137   dns_correct_response(u8_t idx, u32_t ttl)
000000  b510              PUSH     {r4,lr}
;;;1138   {
;;;1139     struct dns_table_entry *entry = &dns_table[idx];
000002  4b0c              LDR      r3,|L8.52|
000004  eb001200          ADD      r2,r0,r0,LSL #4
000008  eb031402          ADD      r4,r3,r2,LSL #4
;;;1140   
;;;1141     entry->state = DNS_STATE_DONE;
00000c  2203              MOVS     r2,#3
00000e  72a2              STRB     r2,[r4,#0xa]
;;;1142   
;;;1143     LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response = ", entry->name));
;;;1144     ip_addr_debug_print_val(DNS_DEBUG, entry->ipaddr);
;;;1145     LWIP_DEBUGF(DNS_DEBUG, ("\n"));
;;;1146   
;;;1147     /* read the answer resource record's TTL, and maximize it if needed */
;;;1148     entry->ttl = ttl;
000010  6021              STR      r1,[r4,#0]
;;;1149     if (entry->ttl > DNS_MAX_TTL) {
000012  4a09              LDR      r2,|L8.56|
000014  4291              CMP      r1,r2
000016  d900              BLS      |L8.26|
;;;1150       entry->ttl = DNS_MAX_TTL;
000018  6022              STR      r2,[r4,#0]
                  |L8.26|
;;;1151     }
;;;1152     dns_call_found(idx, &entry->ipaddr);
00001a  1d21              ADDS     r1,r4,#4
00001c  f7fffffe          BL       dns_call_found
;;;1153   
;;;1154     if (entry->ttl == 0) {
000020  6820              LDR      r0,[r4,#0]
000022  2800              CMP      r0,#0
000024  d104              BNE      |L8.48|
;;;1155       /* RFC 883, page 29: "Zero values are
;;;1156          interpreted to mean that the RR can only be used for the
;;;1157          transaction in progress, and should not be cached."
;;;1158          -> flush this entry now */
;;;1159       /* entry reused during callback? */
;;;1160       if (entry->state == DNS_STATE_DONE) {
000026  7aa0              LDRB     r0,[r4,#0xa]
000028  2803              CMP      r0,#3
00002a  d101              BNE      |L8.48|
;;;1161         entry->state = DNS_STATE_UNUSED;
00002c  2000              MOVS     r0,#0
00002e  72a0              STRB     r0,[r4,#0xa]
                  |L8.48|
;;;1162       }
;;;1163     }
;;;1164   }
000030  bd10              POP      {r4,pc}
;;;1165   
                          ENDP

000032  0000              DCW      0x0000
                  |L8.52|
                          DCD      ||.bss||+0x10
                  |L8.56|
                          DCD      0x00093a80

                          AREA ||i.dns_create_txid||, CODE, READONLY, ALIGN=2

                  dns_create_txid PROC
;;;999    static u16_t
;;;1000   dns_create_txid(void)
000000  b510              PUSH     {r4,lr}
;;;1001   {
;;;1002     u16_t txid;
;;;1003     u8_t i;
;;;1004   
;;;1005   again:
;;;1006     txid = (u16_t)DNS_RAND_TXID();
;;;1007   
;;;1008     /* check whether the ID is unique */
;;;1009     for (i = 0; i < DNS_TABLE_SIZE; i++) {
;;;1010       if ((dns_table[i].state == DNS_STATE_ASKING) &&
000002  4c0a              LDR      r4,|L9.44|
                  |L9.4|
000004  f7fffffe          BL       rand
000008  b280              UXTH     r0,r0                 ;1006
00000a  2100              MOVS     r1,#0                 ;1009
                  |L9.12|
00000c  eb011201          ADD      r2,r1,r1,LSL #4
000010  eb041202          ADD      r2,r4,r2,LSL #4
000014  7a93              LDRB     r3,[r2,#0xa]
000016  2b02              CMP      r3,#2
000018  d102              BNE      |L9.32|
;;;1011           (dns_table[i].txid == txid)) {
00001a  8912              LDRH     r2,[r2,#8]
00001c  4282              CMP      r2,r0
00001e  d0f1              BEQ      |L9.4|
                  |L9.32|
000020  1c49              ADDS     r1,r1,#1              ;1009
000022  b2c9              UXTB     r1,r1                 ;1009
000024  2904              CMP      r1,#4                 ;1009
000026  d3f1              BCC      |L9.12|
;;;1012         /* ID already used by another pending query */
;;;1013         goto again;
;;;1014       }
;;;1015     }
;;;1016   
;;;1017     return txid;
;;;1018   }
000028  bd10              POP      {r4,pc}
;;;1019   
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      ||.bss||+0x10

                          AREA ||i.dns_enqueue||, CODE, READONLY, ALIGN=2

                  dns_enqueue PROC
;;;1374   static err_t
;;;1375   dns_enqueue(const char *name, size_t hostnamelen, dns_found_callback found,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;1376               void *callback_arg LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype) LWIP_DNS_ISMDNS_ARG(u8_t is_mdns))
;;;1377   {
000004  4688              MOV      r8,r1
000006  4691              MOV      r9,r2
000008  469a              MOV      r10,r3
;;;1378     u8_t i;
;;;1379     u8_t lseq, lseqi;
;;;1380     struct dns_table_entry *entry = NULL;
;;;1381     size_t namelen;
;;;1382     struct dns_req_entry *req;
;;;1383   
;;;1384   #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
;;;1385     u8_t r;
;;;1386     /* check for duplicate entries */
;;;1387     for (i = 0; i < DNS_TABLE_SIZE; i++) {
00000a  2400              MOVS     r4,#0
;;;1388       if ((dns_table[i].state == DNS_STATE_ASKING) &&
00000c  4e4c              LDR      r6,|L10.320|
;;;1389           (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0)) {
00000e  f44f7580          MOV      r5,#0x100
;;;1390   #if LWIP_IPV4 && LWIP_IPV6
;;;1391         if (dns_table[i].reqaddrtype != dns_addrtype) {
;;;1392           /* requested address types don't match
;;;1393              this can lead to 2 concurrent requests, but mixing the address types
;;;1394              for the same host should not be that common */
;;;1395           continue;
;;;1396         }
;;;1397   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1398         /* this is a duplicate entry, find a free request entry */
;;;1399         for (r = 0; r < DNS_MAX_REQUESTS; r++) {
;;;1400           if (dns_requests[r].found == 0) {
000012  f5066788          ADD      r7,r6,#0x440
                  |L10.22|
000016  eb041004          ADD      r0,r4,r4,LSL #4       ;1388
00001a  eb061100          ADD      r1,r6,r0,LSL #4       ;1388
00001e  7a88              LDRB     r0,[r1,#0xa]          ;1388
000020  2802              CMP      r0,#2                 ;1388
000022  d10f              BNE      |L10.68|
000024  3110              ADDS     r1,r1,#0x10           ;1389
000026  462a              MOV      r2,r5                 ;1389
000028  9800              LDR      r0,[sp,#0]            ;1389
00002a  f7fffffe          BL       lwip_strnicmp
00002e  b948              CBNZ     r0,|L10.68|
000030  2000              MOVS     r0,#0                 ;1399
                  |L10.50|
000032  eb000140          ADD      r1,r0,r0,LSL #1
000036  f8571021          LDR      r1,[r7,r1,LSL #2]
00003a  b1a9              CBZ      r1,|L10.104|
00003c  1c40              ADDS     r0,r0,#1              ;1399
00003e  b2c0              UXTB     r0,r0                 ;1399
000040  2804              CMP      r0,#4                 ;1399
000042  d3f6              BCC      |L10.50|
                  |L10.68|
000044  1c64              ADDS     r4,r4,#1              ;1387
000046  b2e4              UXTB     r4,r4                 ;1387
000048  2c04              CMP      r4,#4                 ;1387
00004a  d3e4              BCC      |L10.22|
;;;1401             dns_requests[r].found = found;
;;;1402             dns_requests[r].arg = callback_arg;
;;;1403             dns_requests[r].dns_table_idx = i;
;;;1404             LWIP_DNS_SET_ADDRTYPE(dns_requests[r].reqaddrtype, dns_addrtype);
;;;1405             LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": duplicate request\n", name));
;;;1406             return ERR_INPROGRESS;
;;;1407           }
;;;1408         }
;;;1409       }
;;;1410     }
;;;1411     /* no duplicate entries found */
;;;1412   #endif
;;;1413   
;;;1414     /* search an unused entry, or the oldest one */
;;;1415     lseq = 0;
00004c  f04f0c00          MOV      r12,#0
;;;1416     lseqi = DNS_TABLE_SIZE;
000050  2104              MOVS     r1,#4
;;;1417     for (i = 0; i < DNS_TABLE_SIZE; ++i) {
000052  2400              MOVS     r4,#0
;;;1418       entry = &dns_table[i];
;;;1419       /* is it an unused entry ? */
;;;1420       if (entry->state == DNS_STATE_UNUSED) {
;;;1421         break;
;;;1422       }
;;;1423       /* check if this is the oldest completed entry */
;;;1424       if (entry->state == DNS_STATE_DONE) {
;;;1425         u8_t age = (u8_t)(dns_seqno - entry->seqno);
000054  483b              LDR      r0,|L10.324|
                  |L10.86|
000056  eb041204          ADD      r2,r4,r4,LSL #4       ;1418
00005a  eb061502          ADD      r5,r6,r2,LSL #4       ;1418
00005e  7aab              LDRB     r3,[r5,#0xa]          ;1420
000060  b1e3              CBZ      r3,|L10.156|
000062  2b03              CMP      r3,#3                 ;1424
000064  d00e              BEQ      |L10.132|
000066  e015              B        |L10.148|
                  |L10.104|
000068  eb000040          ADD      r0,r0,r0,LSL #1       ;1401
00006c  f8479020          STR      r9,[r7,r0,LSL #2]     ;1401
000070  eb070080          ADD      r0,r7,r0,LSL #2       ;1402
000074  f8c0a004          STR      r10,[r0,#4]           ;1402
000078  7204              STRB     r4,[r0,#8]            ;1403
00007a  f06f0004          MVN      r0,#4                 ;1406
                  |L10.126|
;;;1426         if (age > lseq) {
;;;1427           lseq = age;
;;;1428           lseqi = i;
;;;1429         }
;;;1430       }
;;;1431     }
;;;1432   
;;;1433     /* if we don't have found an unused entry, use the oldest completed one */
;;;1434     if (i == DNS_TABLE_SIZE) {
;;;1435       if ((lseqi >= DNS_TABLE_SIZE) || (dns_table[lseqi].state != DNS_STATE_DONE)) {
;;;1436         /* no entry can be used now, table is full */
;;;1437         LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS entries table is full\n", name));
;;;1438         return ERR_MEM;
;;;1439       } else {
;;;1440         /* use the oldest completed one */
;;;1441         i = lseqi;
;;;1442         entry = &dns_table[i];
;;;1443       }
;;;1444     }
;;;1445   
;;;1446   #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
;;;1447     /* find a free request entry */
;;;1448     req = NULL;
;;;1449     for (r = 0; r < DNS_MAX_REQUESTS; r++) {
;;;1450       if (dns_requests[r].found == NULL) {
;;;1451         req = &dns_requests[r];
;;;1452         break;
;;;1453       }
;;;1454     }
;;;1455     if (req == NULL) {
;;;1456       /* no request entry can be used now, table is full */
;;;1457       LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS request entries table is full\n", name));
;;;1458       return ERR_MEM;
;;;1459     }
;;;1460     req->dns_table_idx = i;
;;;1461   #else
;;;1462     /* in this configuration, the entry index is the same as the request index */
;;;1463     req = &dns_requests[i];
;;;1464   #endif
;;;1465   
;;;1466     /* use this entry */
;;;1467     LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": use DNS entry %"U16_F"\n", name, (u16_t)(i)));
;;;1468   
;;;1469     /* fill the entry */
;;;1470     entry->state = DNS_STATE_NEW;
;;;1471     entry->seqno = dns_seqno;
;;;1472     LWIP_DNS_SET_ADDRTYPE(entry->reqaddrtype, dns_addrtype);
;;;1473     LWIP_DNS_SET_ADDRTYPE(req->reqaddrtype, dns_addrtype);
;;;1474     req->found = found;
;;;1475     req->arg   = callback_arg;
;;;1476     namelen = LWIP_MIN(hostnamelen, DNS_MAX_NAME_LENGTH - 1);
;;;1477     MEMCPY(entry->name, name, namelen);
;;;1478     entry->name[namelen] = 0;
;;;1479   
;;;1480   #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
;;;1481     entry->pcb_idx = dns_alloc_pcb();
;;;1482     if (entry->pcb_idx >= DNS_MAX_SOURCE_PORTS) {
;;;1483       /* failed to get a UDP pcb */
;;;1484       LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": failed to allocate a pcb\n", name));
;;;1485       entry->state = DNS_STATE_UNUSED;
;;;1486       req->found = NULL;
;;;1487       return ERR_MEM;
;;;1488     }
;;;1489     LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": use DNS pcb %"U16_F"\n", name, (u16_t)(entry->pcb_idx)));
;;;1490   #endif
;;;1491   
;;;1492   #if LWIP_DNS_SUPPORT_MDNS_QUERIES
;;;1493     entry->is_mdns = is_mdns;
;;;1494   #endif
;;;1495   
;;;1496     dns_seqno++;
;;;1497   
;;;1498     /* force to send query without waiting timer */
;;;1499     dns_check_entry(i);
;;;1500   
;;;1501     /* dns query is enqueued */
;;;1502     return ERR_INPROGRESS;
;;;1503   }
00007e  b004              ADD      sp,sp,#0x10
000080  e8bd9ff0          POP      {r4-r12,pc}
                  |L10.132|
000084  7baa              LDRB     r2,[r5,#0xe]          ;1425
000086  7843              LDRB     r3,[r0,#1]            ;1425  ; dns_seqno
000088  1a9a              SUBS     r2,r3,r2              ;1425
00008a  b2d2              UXTB     r2,r2                 ;1425
00008c  4562              CMP      r2,r12                ;1426
00008e  d901              BLS      |L10.148|
000090  4694              MOV      r12,r2                ;1427
000092  4621              MOV      r1,r4                 ;1428
                  |L10.148|
000094  1c64              ADDS     r4,r4,#1              ;1417
000096  b2e4              UXTB     r4,r4                 ;1417
000098  2c04              CMP      r4,#4                 ;1417
00009a  d3dc              BCC      |L10.86|
                  |L10.156|
00009c  f04f3bff          MOV      r11,#0xffffffff       ;1438
0000a0  2c04              CMP      r4,#4                 ;1434
0000a2  d10b              BNE      |L10.188|
0000a4  2904              CMP      r1,#4                 ;1435
0000a6  d206              BCS      |L10.182|
0000a8  eb011201          ADD      r2,r1,r1,LSL #4       ;1435
0000ac  eb061502          ADD      r5,r6,r2,LSL #4       ;1435
0000b0  7aaa              LDRB     r2,[r5,#0xa]          ;1435
0000b2  2a03              CMP      r2,#3                 ;1435
0000b4  d001              BEQ      |L10.186|
                  |L10.182|
0000b6  4658              MOV      r0,r11                ;1438
0000b8  e7e1              B        |L10.126|
                  |L10.186|
0000ba  460c              MOV      r4,r1                 ;1441
                  |L10.188|
0000bc  2600              MOVS     r6,#0                 ;1448
0000be  2100              MOVS     r1,#0                 ;1449
                  |L10.192|
0000c0  eb010241          ADD      r2,r1,r1,LSL #1       ;1450
0000c4  f8572022          LDR      r2,[r7,r2,LSL #2]     ;1450
0000c8  b352              CBZ      r2,|L10.288|
0000ca  1c49              ADDS     r1,r1,#1              ;1449
0000cc  b2c9              UXTB     r1,r1                 ;1449
0000ce  2904              CMP      r1,#4                 ;1449
0000d0  d3f6              BCC      |L10.192|
                  |L10.210|
0000d2  b356              CBZ      r6,|L10.298|
0000d4  7234              STRB     r4,[r6,#8]            ;1460
0000d6  2101              MOVS     r1,#1                 ;1470
0000d8  72a9              STRB     r1,[r5,#0xa]          ;1470
0000da  4607              MOV      r7,r0                 ;1471
0000dc  7840              LDRB     r0,[r0,#1]            ;1471  ; dns_seqno
0000de  73a8              STRB     r0,[r5,#0xe]          ;1471
0000e0  f8c69000          STR      r9,[r6,#0]            ;1474
0000e4  f8c6a004          STR      r10,[r6,#4]           ;1475
0000e8  f1b80fff          CMP      r8,#0xff              ;1476
0000ec  d301              BCC      |L10.242|
0000ee  f04f08ff          MOV      r8,#0xff              ;1476
                  |L10.242|
0000f2  4642              MOV      r2,r8                 ;1477
0000f4  f1050010          ADD      r0,r5,#0x10           ;1477
0000f8  9900              LDR      r1,[sp,#0]            ;1477
0000fa  f7fffffe          BL       __aeabi_memcpy
0000fe  eb050008          ADD      r0,r5,r8              ;1478
000102  f04f0900          MOV      r9,#0                 ;1478
000106  f8809010          STRB     r9,[r0,#0x10]         ;1478
00010a  f7fffffe          BL       dns_alloc_pcb
00010e  73e8              STRB     r0,[r5,#0xf]          ;1481
000110  2804              CMP      r0,#4                 ;1482
000112  d30c              BCC      |L10.302|
000114  f885900a          STRB     r9,[r5,#0xa]          ;1485
000118  f8c69000          STR      r9,[r6,#0]            ;1486
00011c  4658              MOV      r0,r11                ;1487
00011e  e7ae              B        |L10.126|
                  |L10.288|
000120  eb010141          ADD      r1,r1,r1,LSL #1       ;1451
000124  eb070681          ADD      r6,r7,r1,LSL #2       ;1451
000128  e7d3              B        |L10.210|
                  |L10.298|
00012a  4658              MOV      r0,r11                ;1458
00012c  e7a7              B        |L10.126|
                  |L10.302|
00012e  7878              LDRB     r0,[r7,#1]            ;1496  ; dns_seqno
000130  1c40              ADDS     r0,r0,#1              ;1496
000132  7078              STRB     r0,[r7,#1]            ;1496
000134  4620              MOV      r0,r4                 ;1499
000136  f7fffffe          BL       dns_check_entry
00013a  f06f0004          MVN      r0,#4                 ;1502
00013e  e79e              B        |L10.126|
;;;1504   
                          ENDP

                  |L10.320|
                          DCD      ||.bss||+0x10
                  |L10.324|
                          DCD      ||.data||

                          AREA ||i.dns_gethostbyname||, CODE, READONLY, ALIGN=1

                  dns_gethostbyname PROC
;;;1525   err_t
;;;1526   dns_gethostbyname(const char *hostname, ip_addr_t *addr, dns_found_callback found,
000000  b538              PUSH     {r3-r5,lr}
;;;1527                     void *callback_arg)
;;;1528   {
;;;1529     return dns_gethostbyname_addrtype(hostname, addr, found, callback_arg, LWIP_DNS_ADDRTYPE_DEFAULT);
000002  2400              MOVS     r4,#0
000004  9400              STR      r4,[sp,#0]
000006  f7fffffe          BL       dns_gethostbyname_addrtype
;;;1530   }
00000a  bd38              POP      {r3-r5,pc}
;;;1531   
                          ENDP


                          AREA ||i.dns_gethostbyname_addrtype||, CODE, READONLY, ALIGN=2

                  dns_gethostbyname_addrtype PROC
;;;1546   err_t
;;;1547   dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_callback found,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1548                              void *callback_arg, u8_t dns_addrtype)
;;;1549   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1550     size_t hostnamelen;
;;;1551   #if LWIP_DNS_SUPPORT_MDNS_QUERIES
;;;1552     u8_t is_mdns;
;;;1553   #endif
;;;1554     /* not initialized or no valid server yet, or invalid addr pointer
;;;1555      * or invalid hostname or invalid hostname length */
;;;1556     if ((addr == NULL) ||
;;;1557         (!hostname) || (!hostname[0])) {
;;;1558       return ERR_ARG;
00000c  f06f090f          MVN      r9,#0xf
000010  2e00              CMP      r6,#0                 ;1556
000012  d00b              BEQ      |L12.44|
000014  b155              CBZ      r5,|L12.44|
000016  7828              LDRB     r0,[r5,#0]            ;1557
000018  b140              CBZ      r0,|L12.44|
;;;1559     }
;;;1560   #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) == 0)
;;;1561     if (dns_pcbs[0] == NULL) {
;;;1562       return ERR_ARG;
;;;1563     }
;;;1564   #endif
;;;1565     hostnamelen = strlen(hostname);
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       strlen
000020  4604              MOV      r4,r0
;;;1566     if (hostnamelen >= DNS_MAX_NAME_LENGTH) {
000022  2cff              CMP      r4,#0xff
000024  d904              BLS      |L12.48|
;;;1567       LWIP_DEBUGF(DNS_DEBUG, ("dns_gethostbyname: name too long to resolve"));
;;;1568       return ERR_ARG;
000026  4648              MOV      r0,r9
                  |L12.40|
;;;1569     }
;;;1570   
;;;1571   
;;;1572   #if LWIP_HAVE_LOOPIF
;;;1573     if (strcmp(hostname, "localhost") == 0) {
;;;1574       ip_addr_set_loopback(LWIP_DNS_ADDRTYPE_IS_IPV6(dns_addrtype), addr);
;;;1575       return ERR_OK;
;;;1576     }
;;;1577   #endif /* LWIP_HAVE_LOOPIF */
;;;1578   
;;;1579     /* host name already in octet notation? set ip addr and return ERR_OK */
;;;1580     if (ipaddr_aton(hostname, addr)) {
;;;1581   #if LWIP_IPV4 && LWIP_IPV6
;;;1582       if ((IP_IS_V6(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV4)) ||
;;;1583           (IP_IS_V4(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV6)))
;;;1584   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1585       {
;;;1586         return ERR_OK;
;;;1587       }
;;;1588     }
;;;1589     /* already have this address cached? */
;;;1590     if (dns_lookup(hostname, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)) == ERR_OK) {
;;;1591       return ERR_OK;
;;;1592     }
;;;1593   #if LWIP_IPV4 && LWIP_IPV6
;;;1594     if ((dns_addrtype == LWIP_DNS_ADDRTYPE_IPV4_IPV6) || (dns_addrtype == LWIP_DNS_ADDRTYPE_IPV6_IPV4)) {
;;;1595       /* fallback to 2nd IP type and try again to lookup */
;;;1596       u8_t fallback;
;;;1597       if (dns_addrtype == LWIP_DNS_ADDRTYPE_IPV4_IPV6) {
;;;1598         fallback = LWIP_DNS_ADDRTYPE_IPV6;
;;;1599       } else {
;;;1600         fallback = LWIP_DNS_ADDRTYPE_IPV4;
;;;1601       }
;;;1602       if (dns_lookup(hostname, addr LWIP_DNS_ADDRTYPE_ARG(fallback)) == ERR_OK) {
;;;1603         return ERR_OK;
;;;1604       }
;;;1605     }
;;;1606   #else /* LWIP_IPV4 && LWIP_IPV6 */
;;;1607     LWIP_UNUSED_ARG(dns_addrtype);
;;;1608   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1609   
;;;1610   #if LWIP_DNS_SUPPORT_MDNS_QUERIES
;;;1611     if (strstr(hostname, ".local") == &hostname[hostnamelen] - 6) {
;;;1612       is_mdns = 1;
;;;1613     } else {
;;;1614       is_mdns = 0;
;;;1615     }
;;;1616   
;;;1617     if (!is_mdns)
;;;1618   #endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
;;;1619     {
;;;1620       /* prevent calling found callback if no server is set, return error instead */
;;;1621       if (ip_addr_isany_val(dns_servers[0])) {
;;;1622         return ERR_VAL;
;;;1623       }
;;;1624     }
;;;1625   
;;;1626     /* queue query with specified callback */
;;;1627     return dns_enqueue(hostname, hostnamelen, found, callback_arg LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)
;;;1628                        LWIP_DNS_ISMDNS_ARG(is_mdns));
;;;1629   }
000028  e8bd87f0          POP      {r4-r10,pc}
                  |L12.44|
00002c  4648              MOV      r0,r9                 ;1558
00002e  e7fb              B        |L12.40|
                  |L12.48|
000030  4631              MOV      r1,r6                 ;1580
000032  4628              MOV      r0,r5                 ;1580
000034  f7fffffe          BL       ip4addr_aton
000038  b108              CBZ      r0,|L12.62|
00003a  2000              MOVS     r0,#0                 ;1586
00003c  e7f4              B        |L12.40|
                  |L12.62|
00003e  4631              MOV      r1,r6                 ;1590
000040  4628              MOV      r0,r5                 ;1590
000042  f7fffffe          BL       dns_lookup
000046  b150              CBZ      r0,|L12.94|
000048  4807              LDR      r0,|L12.104|
00004a  6800              LDR      r0,[r0,#0]            ;1621  ; dns_servers
00004c  b148              CBZ      r0,|L12.98|
00004e  4643              MOV      r3,r8                 ;1627
000050  463a              MOV      r2,r7                 ;1627
000052  4621              MOV      r1,r4                 ;1627
000054  4628              MOV      r0,r5                 ;1627
000056  e8bd47f0          POP      {r4-r10,lr}           ;1627
00005a  f7ffbffe          B.W      dns_enqueue
                  |L12.94|
00005e  2000              MOVS     r0,#0                 ;1591
000060  e7e2              B        |L12.40|
                  |L12.98|
000062  f06f0005          MVN      r0,#5                 ;1622
000066  e7df              B        |L12.40|
;;;1630   
                          ENDP

                  |L12.104|
                          DCD      ||.data||+0x4

                          AREA ||i.dns_getserver||, CODE, READONLY, ALIGN=2

                  dns_getserver PROC
;;;380    const ip_addr_t *
;;;381    dns_getserver(u8_t numdns)
000000  2802              CMP      r0,#2
;;;382    {
000002  d203              BCS      |L13.12|
;;;383      if (numdns < DNS_MAX_SERVERS) {
;;;384        return &dns_servers[numdns];
000004  4902              LDR      r1,|L13.16|
000006  eb010080          ADD      r0,r1,r0,LSL #2
;;;385      } else {
;;;386        return IP_ADDR_ANY;
;;;387      }
;;;388    }
00000a  4770              BX       lr
                  |L13.12|
00000c  4801              LDR      r0,|L13.20|
00000e  4770              BX       lr
;;;389    
                          ENDP

                  |L13.16|
                          DCD      ||.data||+0x4
                  |L13.20|
                          DCD      ip_addr_any

                          AREA ||i.dns_init||, CODE, READONLY, ALIGN=1

                  dns_init PROC
;;;314    void
;;;315    dns_init(void)
000000  4770              BX       lr
;;;316    {
;;;317    #ifdef DNS_SERVER_ADDRESS
;;;318      /* initialize default DNS server address */
;;;319      ip_addr_t dnsserver;
;;;320      DNS_SERVER_ADDRESS(&dnsserver);
;;;321      dns_setserver(0, &dnsserver);
;;;322    #endif /* DNS_SERVER_ADDRESS */
;;;323    
;;;324      LWIP_ASSERT("sanity check SIZEOF_DNS_QUERY",
;;;325                  sizeof(struct dns_query) == SIZEOF_DNS_QUERY);
;;;326      LWIP_ASSERT("sanity check SIZEOF_DNS_ANSWER",
;;;327                  sizeof(struct dns_answer) <= SIZEOF_DNS_ANSWER_ASSERT);
;;;328    
;;;329      LWIP_DEBUGF(DNS_DEBUG, ("dns_init: initializing\n"));
;;;330    
;;;331      /* if dns client not yet initialized... */
;;;332    #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) == 0)
;;;333      if (dns_pcbs[0] == NULL) {
;;;334        dns_pcbs[0] = udp_new_ip_type(IPADDR_TYPE_ANY);
;;;335        LWIP_ASSERT("dns_pcbs[0] != NULL", dns_pcbs[0] != NULL);
;;;336    
;;;337        /* initialize DNS table not needed (initialized to zero since it is a
;;;338         * global variable) */
;;;339        LWIP_ASSERT("For implicit initialization to work, DNS_STATE_UNUSED needs to be 0",
;;;340                    DNS_STATE_UNUSED == 0);
;;;341    
;;;342        /* initialize DNS client */
;;;343        udp_bind(dns_pcbs[0], IP_ANY_TYPE, 0);
;;;344        udp_recv(dns_pcbs[0], dns_recv, NULL);
;;;345      }
;;;346    #endif
;;;347    
;;;348    #if DNS_LOCAL_HOSTLIST
;;;349      dns_init_local();
;;;350    #endif
;;;351    }
;;;352    
                          ENDP


                          AREA ||i.dns_lookup||, CODE, READONLY, ALIGN=2

                  dns_lookup PROC
;;;601    static err_t
;;;602    dns_lookup(const char *name, ip_addr_t *addr LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype))
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;603    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
;;;604      u8_t i;
;;;605    #if DNS_LOCAL_HOSTLIST
;;;606      if (dns_lookup_local(name, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)) == ERR_OK) {
;;;607        return ERR_OK;
;;;608      }
;;;609    #endif /* DNS_LOCAL_HOSTLIST */
;;;610    #ifdef DNS_LOOKUP_LOCAL_EXTERN
;;;611      if (DNS_LOOKUP_LOCAL_EXTERN(name, addr, LWIP_DNS_ADDRTYPE_ARG_OR_ZERO(dns_addrtype)) == ERR_OK) {
;;;612        return ERR_OK;
;;;613      }
;;;614    #endif /* DNS_LOOKUP_LOCAL_EXTERN */
;;;615    
;;;616      /* Walk through name list, return entry if found. If not, return NULL. */
;;;617      for (i = 0; i < DNS_TABLE_SIZE; ++i) {
000008  2400              MOVS     r4,#0
;;;618        if ((dns_table[i].state == DNS_STATE_DONE) &&
00000a  4d10              LDR      r5,|L15.76|
;;;619            (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0) &&
00000c  f44f7780          MOV      r7,#0x100
                  |L15.16|
000010  eb041004          ADD      r0,r4,r4,LSL #4       ;618
000014  eb051100          ADD      r1,r5,r0,LSL #4       ;618
000018  7a88              LDRB     r0,[r1,#0xa]          ;618
00001a  2803              CMP      r0,#3                 ;618
00001c  d105              BNE      |L15.42|
00001e  3110              ADDS     r1,r1,#0x10
000020  463a              MOV      r2,r7
000022  4640              MOV      r0,r8
000024  f7fffffe          BL       lwip_strnicmp
000028  b138              CBZ      r0,|L15.58|
                  |L15.42|
00002a  1c64              ADDS     r4,r4,#1              ;617
00002c  b2e4              UXTB     r4,r4                 ;617
00002e  2c04              CMP      r4,#4                 ;617
000030  d3ee              BCC      |L15.16|
;;;620            LWIP_DNS_ADDRTYPE_MATCH_IP(dns_addrtype, dns_table[i].ipaddr)) {
;;;621          LWIP_DEBUGF(DNS_DEBUG, ("dns_lookup: \"%s\": found = ", name));
;;;622          ip_addr_debug_print_val(DNS_DEBUG, dns_table[i].ipaddr);
;;;623          LWIP_DEBUGF(DNS_DEBUG, ("\n"));
;;;624          if (addr) {
;;;625            ip_addr_copy(*addr, dns_table[i].ipaddr);
;;;626          }
;;;627          return ERR_OK;
;;;628        }
;;;629      }
;;;630    
;;;631      return ERR_ARG;
000032  f06f000f          MVN      r0,#0xf
                  |L15.54|
;;;632    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L15.58|
00003a  b12e              CBZ      r6,|L15.72|
00003c  eb041004          ADD      r0,r4,r4,LSL #4       ;625
000040  eb051000          ADD      r0,r5,r0,LSL #4       ;625
000044  6840              LDR      r0,[r0,#4]            ;625
000046  6030              STR      r0,[r6,#0]            ;625
                  |L15.72|
000048  2000              MOVS     r0,#0                 ;627
00004a  e7f4              B        |L15.54|
;;;633    
                          ENDP

                  |L15.76|
                          DCD      ||.bss||+0x10

                          AREA ||i.dns_recv||, CODE, READONLY, ALIGN=2

                  dns_recv PROC
;;;1169   static void
;;;1170   dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1171   {
000004  b089              SUB      sp,sp,#0x24
000006  4617              MOV      r7,r2
000008  4699              MOV      r9,r3
;;;1172     u8_t i;
;;;1173     u16_t txid;
;;;1174     u16_t res_idx;
;;;1175     struct dns_hdr hdr;
;;;1176     struct dns_answer ans;
;;;1177     struct dns_query qry;
;;;1178     u16_t nquestions, nanswers;
;;;1179   
;;;1180     LWIP_UNUSED_ARG(arg);
;;;1181     LWIP_UNUSED_ARG(pcb);
;;;1182     LWIP_UNUSED_ARG(port);
;;;1183   
;;;1184     /* is the dns message big enough ? */
;;;1185     if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY)) {
00000a  8938              LDRH     r0,[r7,#8]
00000c  2810              CMP      r0,#0x10
00000e  d364              BCC      |L16.218|
;;;1186       LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: pbuf too small\n"));
;;;1187       /* free pbuf and return */
;;;1188       goto ignore_packet;
;;;1189     }
;;;1190   
;;;1191     /* copy dns payload inside static buffer for processing */
;;;1192     if (pbuf_copy_partial(p, &hdr, SIZEOF_DNS_HDR, 0) == SIZEOF_DNS_HDR) {
000010  2300              MOVS     r3,#0
000012  220c              MOVS     r2,#0xc
000014  a906              ADD      r1,sp,#0x18
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       pbuf_copy_partial
00001c  280c              CMP      r0,#0xc
00001e  d15c              BNE      |L16.218|
;;;1193       /* Match the ID in the DNS header with the name table. */
;;;1194       txid = lwip_htons(hdr.id);
000020  f8bd0018          LDRH     r0,[sp,#0x18]
000024  f7fffffe          BL       lwip_htons
;;;1195       for (i = 0; i < DNS_TABLE_SIZE; i++) {
000028  2400              MOVS     r4,#0
;;;1196         struct dns_table_entry *entry = &dns_table[i];
00002a  f8df8180          LDR      r8,|L16.428|
                  |L16.46|
00002e  eb041104          ADD      r1,r4,r4,LSL #4
000032  eb081601          ADD      r6,r8,r1,LSL #4
;;;1197         if ((entry->state == DNS_STATE_ASKING) &&
000036  7ab1              LDRB     r1,[r6,#0xa]
000038  2902              CMP      r1,#2
00003a  d17d              BNE      |L16.312|
;;;1198             (entry->txid == txid)) {
00003c  8931              LDRH     r1,[r6,#8]
00003e  4281              CMP      r1,r0
000040  d17a              BNE      |L16.312|
;;;1199   
;;;1200           /* We only care about the question(s) and the answers. The authrr
;;;1201              and the extrarr are simply discarded. */
;;;1202           nquestions = lwip_htons(hdr.numquestions);
000042  f8bd001c          LDRH     r0,[sp,#0x1c]
000046  f7fffffe          BL       lwip_htons
00004a  4682              MOV      r10,r0
;;;1203           nanswers   = lwip_htons(hdr.numanswers);
00004c  f8bd001e          LDRH     r0,[sp,#0x1e]
000050  f7fffffe          BL       lwip_htons
000054  4605              MOV      r5,r0
;;;1204   
;;;1205           /* Check for correct response. */
;;;1206           if ((hdr.flags1 & DNS_FLAG1_RESPONSE) == 0) {
000056  f89d001a          LDRB     r0,[sp,#0x1a]
00005a  0600              LSLS     r0,r0,#24
00005c  d53d              BPL      |L16.218|
;;;1207             LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": not a response\n", entry->name));
;;;1208             goto ignore_packet; /* ignore this packet */
;;;1209           }
;;;1210           if (nquestions != 1) {
00005e  f1ba0f01          CMP      r10,#1
000062  d13a              BNE      |L16.218|
;;;1211             LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
;;;1212             goto ignore_packet; /* ignore this packet */
;;;1213           }
;;;1214   
;;;1215   #if LWIP_DNS_SUPPORT_MDNS_QUERIES
;;;1216           if (!entry->is_mdns)
;;;1217   #endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
;;;1218           {
;;;1219             /* Check whether response comes from the same network address to which the
;;;1220                question was sent. (RFC 5452) */
;;;1221             if (!ip_addr_cmp(addr, &dns_servers[entry->server_idx])) {
000064  7af1              LDRB     r1,[r6,#0xb]
000066  4a52              LDR      r2,|L16.432|
000068  f8d90000          LDR      r0,[r9,#0]
00006c  f8521021          LDR      r1,[r2,r1,LSL #2]
000070  4288              CMP      r0,r1
000072  d132              BNE      |L16.218|
;;;1222               goto ignore_packet; /* ignore this packet */
;;;1223             }
;;;1224           }
;;;1225   
;;;1226           /* Check if the name in the "question" part match with the name in the entry and
;;;1227              skip it if equal. */
;;;1228           res_idx = dns_compare_name(entry->name, p, SIZEOF_DNS_HDR);
000074  220c              MOVS     r2,#0xc
000076  4639              MOV      r1,r7
000078  f1060010          ADD      r0,r6,#0x10
00007c  f7fffffe          BL       dns_compare_name
000080  4683              MOV      r11,r0
;;;1229           if (res_idx == 0xFFFF) {
000082  f64f79ff          MOV      r9,#0xffff
000086  45cb              CMP      r11,r9
000088  d027              BEQ      |L16.218|
;;;1230             LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
;;;1231             goto ignore_packet; /* ignore this packet */
;;;1232           }
;;;1233   
;;;1234           /* check if "question" part matches the request */
;;;1235           if (pbuf_copy_partial(p, &qry, SIZEOF_DNS_QUERY, res_idx) != SIZEOF_DNS_QUERY) {
00008a  465b              MOV      r3,r11
00008c  2204              MOVS     r2,#4
00008e  a902              ADD      r1,sp,#8
000090  4638              MOV      r0,r7
000092  f7fffffe          BL       pbuf_copy_partial
000096  2804              CMP      r0,#4
000098  d11f              BNE      |L16.218|
;;;1236             goto ignore_packet; /* ignore this packet */
;;;1237           }
;;;1238           if ((qry.cls != PP_HTONS(DNS_RRCLASS_IN)) ||
00009a  f8bd000a          LDRH     r0,[sp,#0xa]
00009e  f44f7a80          MOV      r10,#0x100
0000a2  4550              CMP      r0,r10
0000a4  d17d              BNE      |L16.418|
;;;1239               (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_AAAA))) ||
;;;1240               (!LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_A)))) {
0000a6  f8bd0008          LDRH     r0,[sp,#8]
0000aa  4550              CMP      r0,r10
0000ac  d179              BNE      |L16.418|
;;;1241             LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
;;;1242             goto ignore_packet; /* ignore this packet */
;;;1243           }
;;;1244           /* skip the rest of the "question" part */
;;;1245           if (res_idx + SIZEOF_DNS_QUERY > 0xFFFF) {
0000ae  f10b0004          ADD      r0,r11,#4
0000b2  f44f3b80          MOV      r11,#0x10000
0000b6  4558              CMP      r0,r11
0000b8  d273              BCS      |L16.418|
;;;1246             goto ignore_packet;
;;;1247           }
;;;1248           res_idx = (u16_t)(res_idx + SIZEOF_DNS_QUERY);
0000ba  b281              UXTH     r1,r0
;;;1249   
;;;1250           /* Check for error. If so, call callback to inform. */
;;;1251           if (hdr.flags2 & DNS_FLAG2_ERR_MASK) {
0000bc  f89d001b          LDRB     r0,[sp,#0x1b]
0000c0  0700              LSLS     r0,r0,#28
0000c2  d03c              BEQ      |L16.318|
;;;1252             LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in flags\n", entry->name));
;;;1253   
;;;1254             /* if there is another backup DNS server to try
;;;1255              * then don't stop the DNS request
;;;1256              */
;;;1257             if (dns_backupserver_available(entry)) {
0000c4  4630              MOV      r0,r6
0000c6  f7fffffe          BL       dns_backupserver_available
0000ca  b3b0              CBZ      r0,|L16.314|
;;;1258               /* avoid retrying the same server */
;;;1259               entry->retries = DNS_MAX_RETRIES-1;
0000cc  2003              MOVS     r0,#3
0000ce  7370              STRB     r0,[r6,#0xd]
;;;1260               entry->tmr     = 1;
0000d0  2001              MOVS     r0,#1
0000d2  7330              STRB     r0,[r6,#0xc]
;;;1261   
;;;1262               /* contact next available server for this entry */
;;;1263               dns_check_entry(i);
0000d4  4620              MOV      r0,r4
0000d6  f7fffffe          BL       dns_check_entry
                  |L16.218|
;;;1264   
;;;1265               goto ignore_packet;
0000da  e062              B        |L16.418|
                  |L16.220|
;;;1266             }
;;;1267           } else {
;;;1268             while ((nanswers > 0) && (res_idx < p->tot_len)) {
;;;1269               /* skip answer resource record's host name */
;;;1270               res_idx = dns_skip_name(p, res_idx);
0000dc  4638              MOV      r0,r7
0000de  f7fffffe          BL       dns_skip_name
0000e2  4606              MOV      r6,r0
;;;1271               if (res_idx == 0xFFFF) {
0000e4  454e              CMP      r6,r9
0000e6  d05c              BEQ      |L16.418|
;;;1272                 goto ignore_packet; /* ignore this packet */
;;;1273               }
;;;1274   
;;;1275               /* Check for IP address type and Internet class. Others are discarded. */
;;;1276               if (pbuf_copy_partial(p, &ans, SIZEOF_DNS_ANSWER, res_idx) != SIZEOF_DNS_ANSWER) {
0000e8  4633              MOV      r3,r6
0000ea  220a              MOVS     r2,#0xa
0000ec  a903              ADD      r1,sp,#0xc
0000ee  4638              MOV      r0,r7
0000f0  f7fffffe          BL       pbuf_copy_partial
0000f4  280a              CMP      r0,#0xa
0000f6  d154              BNE      |L16.418|
;;;1277                 goto ignore_packet; /* ignore this packet */
;;;1278               }
;;;1279               if (res_idx + SIZEOF_DNS_ANSWER > 0xFFFF) {
0000f8  360a              ADDS     r6,r6,#0xa
0000fa  455e              CMP      r6,r11
0000fc  d251              BCS      |L16.418|
;;;1280                 goto ignore_packet;
;;;1281               }
;;;1282               res_idx = (u16_t)(res_idx + SIZEOF_DNS_ANSWER);
0000fe  b2b6              UXTH     r6,r6
;;;1283   
;;;1284               if (ans.cls == PP_HTONS(DNS_RRCLASS_IN)) {
000100  f8bd000e          LDRH     r0,[sp,#0xe]
000104  4550              CMP      r0,r10
000106  d108              BNE      |L16.282|
;;;1285   #if LWIP_IPV4
;;;1286                 if ((ans.type == PP_HTONS(DNS_RRTYPE_A)) && (ans.len == PP_HTONS(sizeof(ip4_addr_t)))) {
000108  f8bd000c          LDRH     r0,[sp,#0xc]
00010c  4550              CMP      r0,r10
00010e  d104              BNE      |L16.282|
000110  f8bd0014          LDRH     r0,[sp,#0x14]
000114  f5b06f80          CMP      r0,#0x400
000118  d025              BEQ      |L16.358|
                  |L16.282|
;;;1287   #if LWIP_IPV4 && LWIP_IPV6
;;;1288                   if (!LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype))
;;;1289   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1290                   {
;;;1291                     ip4_addr_t ip4addr;
;;;1292                     /* read the IP address after answer resource record's header */
;;;1293                     if (pbuf_copy_partial(p, &ip4addr, sizeof(ip4_addr_t), res_idx) != sizeof(ip4_addr_t)) {
;;;1294                       goto ignore_packet; /* ignore this packet */
;;;1295                     }
;;;1296                     ip_addr_copy_from_ip4(dns_table[i].ipaddr, ip4addr);
;;;1297                     pbuf_free(p);
;;;1298                     /* handle correct response */
;;;1299                     dns_correct_response(i, lwip_ntohl(ans.ttl));
;;;1300                     return;
;;;1301                   }
;;;1302                 }
;;;1303   #endif /* LWIP_IPV4 */
;;;1304   #if LWIP_IPV6
;;;1305                 if ((ans.type == PP_HTONS(DNS_RRTYPE_AAAA)) && (ans.len == PP_HTONS(sizeof(ip6_addr_p_t)))) {
;;;1306   #if LWIP_IPV4 && LWIP_IPV6
;;;1307                   if (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype))
;;;1308   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1309                   {
;;;1310                     ip6_addr_p_t ip6addr;
;;;1311                     /* read the IP address after answer resource record's header */
;;;1312                     if (pbuf_copy_partial(p, &ip6addr, sizeof(ip6_addr_p_t), res_idx) != sizeof(ip6_addr_p_t)) {
;;;1313                       goto ignore_packet; /* ignore this packet */
;;;1314                     }
;;;1315                     /* @todo: scope ip6addr? Might be required for link-local addresses at least? */
;;;1316                     ip_addr_copy_from_ip6_packed(dns_table[i].ipaddr, ip6addr);
;;;1317                     pbuf_free(p);
;;;1318                     /* handle correct response */
;;;1319                     dns_correct_response(i, lwip_ntohl(ans.ttl));
;;;1320                     return;
;;;1321                   }
;;;1322                 }
;;;1323   #endif /* LWIP_IPV6 */
;;;1324               }
;;;1325               /* skip this answer */
;;;1326               if ((int)(res_idx + lwip_htons(ans.len)) > 0xFFFF) {
00011a  f8bd0014          LDRH     r0,[sp,#0x14]
00011e  f7fffffe          BL       lwip_htons
000122  4430              ADD      r0,r0,r6
000124  4558              CMP      r0,r11
000126  d23c              BCS      |L16.418|
;;;1327                 goto ignore_packet; /* ignore this packet */
;;;1328               }
;;;1329               res_idx = (u16_t)(res_idx + lwip_htons(ans.len));
000128  f8bd0014          LDRH     r0,[sp,#0x14]
00012c  f7fffffe          BL       lwip_htons
000130  4430              ADD      r0,r0,r6
000132  b281              UXTH     r1,r0
;;;1330               --nanswers;
000134  1e6d              SUBS     r5,r5,#1
000136  e001              B        |L16.316|
                  |L16.312|
000138  e02e              B        |L16.408|
                  |L16.314|
00013a  e004              B        |L16.326|
                  |L16.316|
00013c  b2ad              UXTH     r5,r5
                  |L16.318|
00013e  b115              CBZ      r5,|L16.326|
000140  8938              LDRH     r0,[r7,#8]            ;1268
000142  4288              CMP      r0,r1                 ;1268
000144  d8ca              BHI      |L16.220|
                  |L16.326|
;;;1331             }
;;;1332   #if LWIP_IPV4 && LWIP_IPV6
;;;1333             if ((entry->reqaddrtype == LWIP_DNS_ADDRTYPE_IPV4_IPV6) ||
;;;1334                 (entry->reqaddrtype == LWIP_DNS_ADDRTYPE_IPV6_IPV4)) {
;;;1335               if (entry->reqaddrtype == LWIP_DNS_ADDRTYPE_IPV4_IPV6) {
;;;1336                 /* IPv4 failed, try IPv6 */
;;;1337                 dns_table[i].reqaddrtype = LWIP_DNS_ADDRTYPE_IPV6;
;;;1338               } else {
;;;1339                 /* IPv6 failed, try IPv4 */
;;;1340                 dns_table[i].reqaddrtype = LWIP_DNS_ADDRTYPE_IPV4;
;;;1341               }
;;;1342               pbuf_free(p);
;;;1343               dns_table[i].state = DNS_STATE_NEW;
;;;1344               dns_check_entry(i);
;;;1345               return;
;;;1346             }
;;;1347   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1348             LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in response\n", entry->name));
;;;1349           }
;;;1350           /* call callback to indicate error, clean up memory and return */
;;;1351           pbuf_free(p);
000146  4638              MOV      r0,r7
000148  f7fffffe          BL       pbuf_free
;;;1352           dns_call_found(i, NULL);
00014c  2100              MOVS     r1,#0
00014e  4620              MOV      r0,r4
000150  f7fffffe          BL       dns_call_found
;;;1353           dns_table[i].state = DNS_STATE_UNUSED;
000154  eb041104          ADD      r1,r4,r4,LSL #4
000158  eb081101          ADD      r1,r8,r1,LSL #4
00015c  2000              MOVS     r0,#0
00015e  7288              STRB     r0,[r1,#0xa]
                  |L16.352|
;;;1354           return;
;;;1355         }
;;;1356       }
;;;1357     }
;;;1358   
;;;1359   ignore_packet:
;;;1360     /* deallocate memory and return */
;;;1361     pbuf_free(p);
;;;1362     return;
;;;1363   }
000160  b009              ADD      sp,sp,#0x24
000162  e8bd8ff0          POP      {r4-r11,pc}
                  |L16.358|
000166  4633              MOV      r3,r6                 ;1293
000168  2204              MOVS     r2,#4                 ;1293
00016a  a901              ADD      r1,sp,#4              ;1293
00016c  4638              MOV      r0,r7                 ;1293
00016e  f7fffffe          BL       pbuf_copy_partial
000172  2804              CMP      r0,#4                 ;1293
000174  d115              BNE      |L16.418|
000176  eb041104          ADD      r1,r4,r4,LSL #4       ;1296
00017a  eb081101          ADD      r1,r8,r1,LSL #4       ;1296
00017e  9801              LDR      r0,[sp,#4]            ;1296
000180  6048              STR      r0,[r1,#4]            ;1296
000182  4638              MOV      r0,r7                 ;1297
000184  f7fffffe          BL       pbuf_free
000188  9804              LDR      r0,[sp,#0x10]         ;1299
00018a  f7fffffe          BL       lwip_htonl
00018e  4601              MOV      r1,r0                 ;1299
000190  4620              MOV      r0,r4                 ;1299
000192  f7fffffe          BL       dns_correct_response
000196  e7e3              B        |L16.352|
                  |L16.408|
000198  1c64              ADDS     r4,r4,#1              ;1195
00019a  b2e4              UXTB     r4,r4                 ;1195
00019c  2c04              CMP      r4,#4                 ;1195
00019e  f4ffaf46          BCC      |L16.46|
                  |L16.418|
0001a2  4638              MOV      r0,r7                 ;1361
0001a4  f7fffffe          BL       pbuf_free
0001a8  e7da              B        |L16.352|
;;;1364   
                          ENDP

0001aa  0000              DCW      0x0000
                  |L16.428|
                          DCD      ||.bss||+0x10
                  |L16.432|
                          DCD      ||.data||+0x4

                          AREA ||i.dns_send||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dns_send PROC
;;;747    static err_t
;;;748    dns_send(u8_t idx)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;749    {
000004  4604              MOV      r4,r0
;;;750      err_t err;
;;;751      struct dns_hdr hdr;
;;;752      struct dns_query qry;
;;;753      struct pbuf *p;
;;;754      u16_t query_idx, copy_len;
;;;755      const char *hostname, *hostname_part;
;;;756      u8_t n;
;;;757      u8_t pcb_idx;
;;;758      struct dns_table_entry *entry = &dns_table[idx];
000006  494b              LDR      r1,|L17.308|
000008  eb041004          ADD      r0,r4,r4,LSL #4
00000c  eb011500          ADD      r5,r1,r0,LSL #4
;;;759    
;;;760      LWIP_DEBUGF(DNS_DEBUG, ("dns_send: dns_servers[%"U16_F"] \"%s\": request\n",
;;;761                              (u16_t)(entry->server_idx), entry->name));
;;;762      LWIP_ASSERT("dns server out of array", entry->server_idx < DNS_MAX_SERVERS);
000010  7ae8              LDRB     r0,[r5,#0xb]
000012  2802              CMP      r0,#2
000014  d306              BCC      |L17.36|
000016  a348              ADR      r3,|L17.312|
000018  f24022fa          MOV      r2,#0x2fa
00001c  a152              ADR      r1,|L17.360|
00001e  a058              ADR      r0,|L17.384|
000020  f7fffffe          BL       __2printf
                  |L17.36|
;;;763      if (ip_addr_isany_val(dns_servers[entry->server_idx])
000024  7aea              LDRB     r2,[r5,#0xb]
000026  4960              LDR      r1,|L17.424|
000028  2600              MOVS     r6,#0
00002a  f8510022          LDR      r0,[r1,r2,LSL #2]
00002e  b348              CBZ      r0,|L17.132|
;;;764    #if LWIP_DNS_SUPPORT_MDNS_QUERIES
;;;765          && !entry->is_mdns
;;;766    #endif
;;;767         ) {
;;;768        /* DNS server not valid anymore, e.g. PPP netif has been shut down */
;;;769        /* call specified callback function if provided */
;;;770        dns_call_found(idx, NULL);
;;;771        /* flush this entry */
;;;772        entry->state = DNS_STATE_UNUSED;
;;;773        return ERR_OK;
;;;774      }
;;;775    
;;;776      /* if here, we have either a new query or a retry on a previous query to process */
;;;777      p = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(SIZEOF_DNS_HDR + strlen(entry->name) + 2 +
000030  f1050010          ADD      r0,r5,#0x10
000034  4604              MOV      r4,r0
000036  f7fffffe          BL       strlen
00003a  3012              ADDS     r0,r0,#0x12
00003c  b281              UXTH     r1,r0
00003e  f44f7220          MOV      r2,#0x280
000042  2036              MOVS     r0,#0x36
000044  f7fffffe          BL       pbuf_alloc
000048  4682              MOV      r10,r0
;;;778                                             SIZEOF_DNS_QUERY), PBUF_RAM);
;;;779      if (p != NULL) {
00004a  ea5f000a          MOVS     r0,r10
00004e  d06c              BEQ      |L17.298|
;;;780        const ip_addr_t *dst;
;;;781        u16_t dst_port;
;;;782        /* fill dns header */
;;;783        memset(&hdr, 0, SIZEOF_DNS_HDR);
000050  9601              STR      r6,[sp,#4]
000052  9602              STR      r6,[sp,#8]
000054  9603              STR      r6,[sp,#0xc]
;;;784        hdr.id = lwip_htons(entry->txid);
000056  8928              LDRH     r0,[r5,#8]
000058  f7fffffe          BL       lwip_htons
00005c  f8ad0004          STRH     r0,[sp,#4]
;;;785        hdr.flags1 = DNS_FLAG1_RD;
000060  2001              MOVS     r0,#1
000062  f88d0006          STRB     r0,[sp,#6]
;;;786        hdr.numquestions = PP_HTONS(1);
000066  f44f7b80          MOV      r11,#0x100
00006a  f8adb008          STRH     r11,[sp,#8]
;;;787        pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
00006e  220c              MOVS     r2,#0xc
000070  a901              ADD      r1,sp,#4
000072  4650              MOV      r0,r10
000074  f7fffffe          BL       pbuf_take
;;;788        hostname = entry->name;
;;;789        --hostname;
000078  1e64              SUBS     r4,r4,#1
;;;790    
;;;791        /* convert hostname into suitable query format. */
;;;792        query_idx = SIZEOF_DNS_HDR;
00007a  260c              MOVS     r6,#0xc
                  |L17.124|
;;;793        do {
;;;794          ++hostname;
00007c  1c64              ADDS     r4,r4,#1
;;;795          hostname_part = hostname;
00007e  4627              MOV      r7,r4
;;;796          for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
000080  2200              MOVS     r2,#0
000082  e00b              B        |L17.156|
                  |L17.132|
000084  2100              MOVS     r1,#0                 ;770
000086  4620              MOV      r0,r4                 ;770
000088  f7fffffe          BL       dns_call_found
00008c  72ae              STRB     r6,[r5,#0xa]          ;772
00008e  2000              MOVS     r0,#0                 ;773
                  |L17.144|
;;;797            ++n;
;;;798          }
;;;799          copy_len = (u16_t)(hostname - hostname_part);
;;;800          if (query_idx + n + 1 > 0xFFFF) {
;;;801            /* u16_t overflow */
;;;802            goto overflow_return;
;;;803          }
;;;804          pbuf_put_at(p, query_idx, n);
;;;805          pbuf_take_at(p, hostname_part, copy_len, (u16_t)(query_idx + 1));
;;;806          query_idx = (u16_t)(query_idx + n + 1);
;;;807        } while (*hostname != 0);
;;;808        pbuf_put_at(p, query_idx, 0);
;;;809        query_idx++;
;;;810    
;;;811        /* fill dns query */
;;;812        if (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype)) {
;;;813          qry.type = PP_HTONS(DNS_RRTYPE_AAAA);
;;;814        } else {
;;;815          qry.type = PP_HTONS(DNS_RRTYPE_A);
;;;816        }
;;;817        qry.cls = PP_HTONS(DNS_RRCLASS_IN);
;;;818        pbuf_take_at(p, &qry, SIZEOF_DNS_QUERY, query_idx);
;;;819    
;;;820    #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
;;;821        pcb_idx = entry->pcb_idx;
;;;822    #else
;;;823        pcb_idx = 0;
;;;824    #endif
;;;825        /* send dns packet */
;;;826        LWIP_DEBUGF(DNS_DEBUG, ("sending DNS request ID %d for name \"%s\" to server %d\r\n",
;;;827                                entry->txid, entry->name, entry->server_idx));
;;;828    #if LWIP_DNS_SUPPORT_MDNS_QUERIES
;;;829        if (entry->is_mdns) {
;;;830          dst_port = DNS_MQUERY_PORT;
;;;831    #if LWIP_IPV6
;;;832          if (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype)) {
;;;833            dst = &dns_mquery_v6group;
;;;834          }
;;;835    #endif
;;;836    #if LWIP_IPV4 && LWIP_IPV6
;;;837          else
;;;838    #endif
;;;839    #if LWIP_IPV4
;;;840          {
;;;841            dst = &dns_mquery_v4group;
;;;842          }
;;;843    #endif
;;;844        } else
;;;845    #endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
;;;846        {
;;;847          dst_port = DNS_SERVER_PORT;
;;;848          dst = &dns_servers[entry->server_idx];
;;;849        }
;;;850        err = udp_sendto(dns_pcbs[pcb_idx], p, dst, dst_port);
;;;851    
;;;852        /* free pbuf */
;;;853        pbuf_free(p);
;;;854      } else {
;;;855        err = ERR_MEM;
;;;856      }
;;;857    
;;;858      return err;
;;;859    overflow_return:
;;;860      pbuf_free(p);
;;;861      return ERR_VAL;
;;;862    }
000090  b004              ADD      sp,sp,#0x10
000092  e8bd9ff0          POP      {r4-r12,pc}
                  |L17.150|
000096  1c52              ADDS     r2,r2,#1              ;797
000098  b2d2              UXTB     r2,r2                 ;797
00009a  1c64              ADDS     r4,r4,#1              ;796
                  |L17.156|
00009c  7820              LDRB     r0,[r4,#0]            ;796
00009e  282e              CMP      r0,#0x2e              ;796
0000a0  d001              BEQ      |L17.166|
0000a2  2800              CMP      r0,#0                 ;796
0000a4  d1f7              BNE      |L17.150|
                  |L17.166|
0000a6  1be0              SUBS     r0,r4,r7              ;799
0000a8  fa1ff980          UXTH     r9,r0                 ;799
0000ac  eb060802          ADD      r8,r6,r2              ;800
0000b0  f1080801          ADD      r8,r8,#1              ;800
0000b4  f5b83f80          CMP      r8,#0x10000           ;800
0000b8  d305              BCC      |L17.198|
0000ba  4650              MOV      r0,r10                ;860
0000bc  f7fffffe          BL       pbuf_free
0000c0  f06f0005          MVN      r0,#5                 ;861
0000c4  e7e4              B        |L17.144|
                  |L17.198|
0000c6  4631              MOV      r1,r6                 ;804
0000c8  4650              MOV      r0,r10                ;804
0000ca  f7fffffe          BL       pbuf_put_at
0000ce  1c76              ADDS     r6,r6,#1              ;805
0000d0  b2b3              UXTH     r3,r6                 ;805
0000d2  464a              MOV      r2,r9                 ;805
0000d4  4639              MOV      r1,r7                 ;805
0000d6  4650              MOV      r0,r10                ;805
0000d8  f7fffffe          BL       pbuf_take_at
0000dc  fa1ff688          UXTH     r6,r8                 ;806
0000e0  7820              LDRB     r0,[r4,#0]            ;807
0000e2  2800              CMP      r0,#0                 ;807
0000e4  d1ca              BNE      |L17.124|
0000e6  2200              MOVS     r2,#0                 ;808
0000e8  4631              MOV      r1,r6                 ;808
0000ea  4650              MOV      r0,r10                ;808
0000ec  f7fffffe          BL       pbuf_put_at
0000f0  1c76              ADDS     r6,r6,#1              ;809
0000f2  b2b3              UXTH     r3,r6                 ;809
0000f4  f8adb000          STRH     r11,[sp,#0]           ;815
0000f8  f8adb002          STRH     r11,[sp,#2]           ;817
0000fc  2204              MOVS     r2,#4                 ;818
0000fe  4669              MOV      r1,sp                 ;818
000100  4650              MOV      r0,r10                ;818
000102  f7fffffe          BL       pbuf_take_at
000106  7be8              LDRB     r0,[r5,#0xf]          ;821
000108  2335              MOVS     r3,#0x35              ;847
00010a  7aea              LDRB     r2,[r5,#0xb]          ;848
00010c  4926              LDR      r1,|L17.424|
00010e  eb010282          ADD      r2,r1,r2,LSL #2       ;848
000112  4908              LDR      r1,|L17.308|
000114  3910              SUBS     r1,r1,#0x10           ;850
000116  f8510020          LDR      r0,[r1,r0,LSL #2]     ;850
00011a  4651              MOV      r1,r10                ;850
00011c  f7fffffe          BL       udp_sendto
000120  4604              MOV      r4,r0                 ;850
000122  4650              MOV      r0,r10                ;853
000124  f7fffffe          BL       pbuf_free
000128  e001              B        |L17.302|
                  |L17.298|
00012a  f04f34ff          MOV      r4,#0xffffffff        ;855
                  |L17.302|
00012e  4620              MOV      r0,r4                 ;858
000130  e7ae              B        |L17.144|
;;;863    
                          ENDP

000132  0000              DCW      0x0000
                  |L17.308|
                          DCD      ||.bss||+0x10
                  |L17.312|
000138  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\dns.c",0
00013c  6964646c
000140  65776172
000144  65735c54
000148  68697264
00014c  5f506172
000150  74795c4c
000154  7749505c
000158  7372635c
00015c  636f7265
000160  5c646e73
000164  2e6300  
000167  00                DCB      0
                  |L17.360|
000168  646e7320          DCB      "dns server out of array",0
00016c  73657276
000170  6572206f
000174  7574206f
000178  66206172
00017c  72617900
                  |L17.384|
000180  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000184  7274696f
000188  6e202225
00018c  73222066
000190  61696c65
000194  64206174
000198  206c696e
00019c  65202564
0001a0  20696e20
0001a4  25730a00
                  |L17.424|
                          DCD      ||.data||+0x4

                          AREA ||i.dns_setserver||, CODE, READONLY, ALIGN=2

                  dns_setserver PROC
;;;360    void
;;;361    dns_setserver(u8_t numdns, const ip_addr_t *dnsserver)
000000  2802              CMP      r0,#2
;;;362    {
000002  d205              BCS      |L18.16|
;;;363      if (numdns < DNS_MAX_SERVERS) {
;;;364        if (dnsserver != NULL) {
;;;365          dns_servers[numdns] = (*dnsserver);
000004  4a05              LDR      r2,|L18.28|
000006  eb020080          ADD      r0,r2,r0,LSL #2
00000a  b111              CBZ      r1,|L18.18|
00000c  6809              LDR      r1,[r1,#0]
00000e  6001              STR      r1,[r0,#0]
                  |L18.16|
;;;366        } else {
;;;367          dns_servers[numdns] = *IP_ADDR_ANY;
;;;368        }
;;;369      }
;;;370    }
000010  4770              BX       lr
                  |L18.18|
000012  4903              LDR      r1,|L18.32|
000014  6809              LDR      r1,[r1,#0]            ;367  ; ip_addr_any
000016  6001              STR      r1,[r0,#0]            ;367
000018  4770              BX       lr
;;;371    
                          ENDP

00001a  0000              DCW      0x0000
                  |L18.28|
                          DCD      ||.data||+0x4
                  |L18.32|
                          DCD      ip_addr_any

                          AREA ||i.dns_skip_name||, CODE, READONLY, ALIGN=1

                  dns_skip_name PROC
;;;707    static u16_t
;;;708    dns_skip_name(struct pbuf *p, u16_t query_idx)
000000  b570              PUSH     {r4-r6,lr}
;;;709    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;710      int n;
;;;711      u16_t offset = query_idx;
;;;712    
;;;713      do {
;;;714        n = pbuf_try_get_at(p, offset++);
;;;715        if ((n < 0) || (offset == 0)) {
;;;716          return 0xFFFF;
000006  f64f76ff          MOV      r6,#0xffff
                  |L19.10|
00000a  4621              MOV      r1,r4                 ;714
00000c  1c64              ADDS     r4,r4,#1              ;714
00000e  b2a4              UXTH     r4,r4                 ;714
000010  4628              MOV      r0,r5                 ;714
000012  f7fffffe          BL       pbuf_try_get_at
000016  2800              CMP      r0,#0                 ;715
000018  db0a              BLT      |L19.48|
00001a  b14c              CBZ      r4,|L19.48|
;;;717        }
;;;718        /** @see RFC 1035 - 4.1.4. Message compression */
;;;719        if ((n & 0xc0) == 0xc0) {
00001c  f3c01181          UBFX     r1,r0,#6,#2
000020  2903              CMP      r1,#3
000022  d011              BEQ      |L19.72|
;;;720          /* Compressed name: since we only want to skip it (not check it), stop here */
;;;721          break;
;;;722        } else {
;;;723          /* Not compressed name */
;;;724          if (offset + n >= p->tot_len) {
000024  8929              LDRH     r1,[r5,#8]
000026  4420              ADD      r0,r0,r4
000028  4288              CMP      r0,r1
00002a  db03              BLT      |L19.52|
;;;725            return 0xFFFF;
00002c  4630              MOV      r0,r6
;;;726          }
;;;727          offset = (u16_t)(offset + n);
;;;728        }
;;;729        n = pbuf_try_get_at(p, offset);
;;;730        if (n < 0) {
;;;731          return 0xFFFF;
;;;732        }
;;;733      } while (n != 0);
;;;734    
;;;735      if (offset == 0xFFFF) {
;;;736        return 0xFFFF;
;;;737      }
;;;738      return (u16_t)(offset + 1);
;;;739    }
00002e  bd70              POP      {r4-r6,pc}
                  |L19.48|
000030  4630              MOV      r0,r6                 ;716
000032  bd70              POP      {r4-r6,pc}
                  |L19.52|
000034  b284              UXTH     r4,r0                 ;727
000036  4621              MOV      r1,r4                 ;729
000038  4628              MOV      r0,r5                 ;729
00003a  f7fffffe          BL       pbuf_try_get_at
00003e  2800              CMP      r0,#0                 ;730
000040  da01              BGE      |L19.70|
000042  4630              MOV      r0,r6                 ;731
                  |L19.68|
000044  bd70              POP      {r4-r6,pc}
                  |L19.70|
000046  d1e0              BNE      |L19.10|
                  |L19.72|
000048  4630              MOV      r0,r6                 ;735
00004a  4284              CMP      r4,r0                 ;735
00004c  d0fa              BEQ      |L19.68|
00004e  1c64              ADDS     r4,r4,#1              ;738
000050  b2a0              UXTH     r0,r4                 ;738
000052  bd70              POP      {r4-r6,pc}
;;;740    
                          ENDP


                          AREA ||i.dns_tmr||, CODE, READONLY, ALIGN=1

                  dns_tmr PROC
;;;394    void
;;;395    dns_tmr(void)
000000  f7ffbffe          B.W      dns_check_entries
;;;396    {
;;;397      LWIP_DEBUGF(DNS_DEBUG, ("dns_tmr: dns_check_entries\n"));
;;;398      dns_check_entries();
;;;399    }
;;;400    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  dns_pcbs
                          %        16
                  dns_table
                          %        1088
                  dns_requests
                          %        48

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  dns_mquery_v4group
                          DCD      0xfb0000e0

                          AREA ||.data||, DATA, ALIGN=2

                  dns_last_pcb_idx
000000  00                DCB      0x00
                  dns_seqno
000001  000000            DCB      0x00,0x00,0x00
                  dns_servers
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\dns.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_dns_c_cd221b19____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_dns_c_cd221b19____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_dns_c_cd221b19____REVSH|
#line 478
|__asm___5_dns_c_cd221b19____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_dns_c_cd221b19____RRX|
#line 665
|__asm___5_dns_c_cd221b19____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
