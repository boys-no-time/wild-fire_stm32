; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\dns.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\dns.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\dns.crf ..\Middlewares\Third_Party\LwIP\src\core\dns.c]
                          THUMB

                          AREA ||i.dns_alloc_pcb||, CODE, READONLY, ALIGN=2

                  dns_alloc_pcb PROC
;;;880    static u8_t
;;;881    dns_alloc_pcb(void)
000000  b570              PUSH     {r4-r6,lr}
;;;882    {
;;;883      u8_t i;
;;;884      u8_t idx;
;;;885    
;;;886      for (i = 0; i < DNS_MAX_SOURCE_PORTS; i++) {
000002  2400              MOVS     r4,#0
;;;887        if (dns_pcbs[i] == NULL) {
000004  4d13              LDR      r5,|L1.84|
                  |L1.6|
000006  f8550024          LDR      r0,[r5,r4,LSL #2]
00000a  b118              CBZ      r0,|L1.20|
00000c  1c64              ADDS     r4,r4,#1              ;886
00000e  b2e4              UXTB     r4,r4                 ;886
000010  2c04              CMP      r4,#4                 ;886
000012  d3f8              BCC      |L1.6|
                  |L1.20|
;;;888          break;
;;;889        }
;;;890      }
;;;891      if (i < DNS_MAX_SOURCE_PORTS) {
;;;892        dns_pcbs[i] = dns_alloc_random_port();
;;;893        if (dns_pcbs[i] != NULL) {
;;;894          /* succeeded */
;;;895          dns_last_pcb_idx = i;
000014  4e10              LDR      r6,|L1.88|
000016  2c04              CMP      r4,#4                 ;891
000018  d207              BCS      |L1.42|
00001a  f7fffffe          BL       dns_alloc_random_port
00001e  f8450024          STR      r0,[r5,r4,LSL #2]     ;892
000022  b110              CBZ      r0,|L1.42|
000024  7034              STRB     r4,[r6,#0]
;;;896          return i;
000026  4620              MOV      r0,r4
;;;897        }
;;;898      }
;;;899      /* if we come here, creating a new UDP pcb failed, so we have to use
;;;900         an already existing one */
;;;901      for (i = 0, idx = dns_last_pcb_idx + 1; i < DNS_MAX_SOURCE_PORTS; i++, idx++) {
;;;902        if (idx >= DNS_MAX_SOURCE_PORTS) {
;;;903          idx = 0;
;;;904        }
;;;905        if (dns_pcbs[idx] != NULL) {
;;;906          dns_last_pcb_idx = idx;
;;;907          return idx;
;;;908        }
;;;909      }
;;;910      return DNS_MAX_SOURCE_PORTS;
;;;911    }
000028  bd70              POP      {r4-r6,pc}
                  |L1.42|
00002a  2100              MOVS     r1,#0                 ;901
00002c  7830              LDRB     r0,[r6,#0]            ;901  ; dns_last_pcb_idx
00002e  1c40              ADDS     r0,r0,#1              ;901
000030  b2c0              UXTB     r0,r0                 ;901
000032  e00b              B        |L1.76|
                  |L1.52|
000034  2804              CMP      r0,#4                 ;902
000036  d300              BCC      |L1.58|
000038  2000              MOVS     r0,#0                 ;903
                  |L1.58|
00003a  f8552020          LDR      r2,[r5,r0,LSL #2]     ;905
00003e  b10a              CBZ      r2,|L1.68|
000040  7030              STRB     r0,[r6,#0]            ;906
000042  bd70              POP      {r4-r6,pc}
                  |L1.68|
000044  1c49              ADDS     r1,r1,#1              ;901
000046  b2c9              UXTB     r1,r1                 ;901
000048  1c40              ADDS     r0,r0,#1              ;901
00004a  b2c0              UXTB     r0,r0                 ;901
                  |L1.76|
00004c  2904              CMP      r1,#4                 ;901
00004e  d3f1              BCC      |L1.52|
000050  2004              MOVS     r0,#4                 ;910
000052  bd70              POP      {r4-r6,pc}
;;;912    #endif /* ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0) */
                          ENDP

                  |L1.84|
                          DCD      ||.bss||
                  |L1.88|
                          DCD      ||.data||

                          AREA ||i.dns_alloc_random_port||, CODE, READONLY, ALIGN=2

                  dns_alloc_random_port PROC
;;;846    static struct udp_pcb*
;;;847    dns_alloc_random_port(void)
000000  b570              PUSH     {r4-r6,lr}
;;;848    {
;;;849      err_t err;
;;;850      struct udp_pcb* ret;
;;;851    
;;;852      ret = udp_new_ip_type(IPADDR_TYPE_ANY);
000002  202e              MOVS     r0,#0x2e
000004  f7fffffe          BL       udp_new_ip_type
000008  4604              MOV      r4,r0
;;;853      if (ret == NULL) {
00000a  0020              MOVS     r0,r4
00000c  d00a              BEQ      |L2.36|
;;;854        /* out of memory, have to reuse an existing pcb */
;;;855        return NULL;
;;;856      }
;;;857      do {
;;;858        u16_t port = (u16_t)DNS_RAND_TXID();
;;;859        if (!DNS_PORT_ALLOWED(port)) {
00000e  f44f6680          MOV      r6,#0x400
;;;860          /* this port is not allowed, try again */
;;;861          err = ERR_USE;
000012  f06f0507          MVN      r5,#7
                  |L2.22|
000016  f7fffffe          BL       rand
00001a  b282              UXTH     r2,r0                 ;858
00001c  42b2              CMP      r2,r6                 ;859
00001e  d203              BCS      |L2.40|
000020  4628              MOV      r0,r5
;;;862          continue;
000022  e005              B        |L2.48|
                  |L2.36|
000024  2000              MOVS     r0,#0                 ;855
;;;863        }
;;;864        err = udp_bind(ret, IP_ANY_TYPE, port);
;;;865      } while (err == ERR_USE);
;;;866      if (err != ERR_OK) {
;;;867        udp_remove(ret);
;;;868        return NULL;
;;;869      }
;;;870      udp_recv(ret, dns_recv, NULL);
;;;871      return ret;
;;;872    }
000026  bd70              POP      {r4-r6,pc}
                  |L2.40|
000028  4909              LDR      r1,|L2.80|
00002a  4620              MOV      r0,r4                 ;864
00002c  f7fffffe          BL       udp_bind
                  |L2.48|
000030  f1100f08          CMN      r0,#8                 ;865
000034  d0ef              BEQ      |L2.22|
000036  b120              CBZ      r0,|L2.66|
000038  4620              MOV      r0,r4                 ;867
00003a  f7fffffe          BL       udp_remove
00003e  2000              MOVS     r0,#0                 ;868
000040  bd70              POP      {r4-r6,pc}
                  |L2.66|
000042  2200              MOVS     r2,#0                 ;870
000044  4903              LDR      r1,|L2.84|
000046  4620              MOV      r0,r4                 ;870
000048  f7fffffe          BL       udp_recv
00004c  4620              MOV      r0,r4                 ;871
00004e  bd70              POP      {r4-r6,pc}
;;;873    
                          ENDP

                  |L2.80|
                          DCD      ip_addr_any
                  |L2.84|
                          DCD      dns_recv

                          AREA ||i.dns_call_found||, CODE, READONLY, ALIGN=2

                  dns_call_found PROC
;;;922    static void
;;;923    dns_call_found(u8_t idx, ip_addr_t* addr)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;924    {
000004  4607              MOV      r7,r0
000006  468b              MOV      r11,r1
;;;925    #if ((LWIP_DNS_SECURE & (LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING | LWIP_DNS_SECURE_RAND_SRC_PORT)) != 0)
;;;926      u8_t i;
;;;927    #endif
;;;928    
;;;929    #if LWIP_IPV4 && LWIP_IPV6
;;;930      if (addr != NULL) {
;;;931        /* check that address type matches the request and adapt the table entry */
;;;932        if (IP_IS_V6_VAL(*addr)) {
;;;933          LWIP_ASSERT("invalid response", LWIP_DNS_ADDRTYPE_IS_IPV6(dns_table[idx].reqaddrtype));
;;;934          dns_table[idx].reqaddrtype = LWIP_DNS_ADDRTYPE_IPV6;
;;;935        } else {
;;;936          LWIP_ASSERT("invalid response", !LWIP_DNS_ADDRTYPE_IS_IPV6(dns_table[idx].reqaddrtype));
;;;937          dns_table[idx].reqaddrtype = LWIP_DNS_ADDRTYPE_IPV4;
;;;938        }
;;;939      }
;;;940    #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;941    
;;;942    #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
;;;943      for (i = 0; i < DNS_MAX_REQUESTS; i++) {
000008  2500              MOVS     r5,#0
;;;944        if (dns_requests[i].found && (dns_requests[i].dns_table_idx == idx)) {
00000a  f8df8080          LDR      r8,|L3.140|
;;;945          (*dns_requests[i].found)(dns_table[idx].name, addr, dns_requests[i].arg);
00000e  eb071007          ADD      r0,r7,r7,LSL #4
000012  f5a86a88          SUB      r10,r8,#0x440
000016  46a9              MOV      r9,r5                 ;943
000018  eb0a1400          ADD      r4,r10,r0,LSL #4
                  |L3.28|
00001c  eb050645          ADD      r6,r5,r5,LSL #1       ;944
000020  f8583026          LDR      r3,[r8,r6,LSL #2]     ;944
000024  b15b              CBZ      r3,|L3.62|
000026  eb080086          ADD      r0,r8,r6,LSL #2       ;944
00002a  7a01              LDRB     r1,[r0,#8]            ;944
00002c  42b9              CMP      r1,r7                 ;944
00002e  d106              BNE      |L3.62|
000030  6842              LDR      r2,[r0,#4]
000032  f1040010          ADD      r0,r4,#0x10
000036  4659              MOV      r1,r11
000038  4798              BLX      r3
;;;946          /* flush this entry */
;;;947          dns_requests[i].found = NULL;
00003a  f8489026          STR      r9,[r8,r6,LSL #2]
                  |L3.62|
00003e  1c6d              ADDS     r5,r5,#1              ;943
000040  b2ed              UXTB     r5,r5                 ;943
000042  2d04              CMP      r5,#4                 ;943
000044  d3ea              BCC      |L3.28|
;;;948        }
;;;949      }
;;;950    #else
;;;951      if (dns_requests[idx].found) {
;;;952        (*dns_requests[idx].found)(dns_table[idx].name, addr, dns_requests[idx].arg);
;;;953      }
;;;954      dns_requests[idx].found = NULL;
;;;955    #endif
;;;956    #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
;;;957      /* close the pcb used unless other request are using it */
;;;958      for (i = 0; i < DNS_MAX_REQUESTS; i++) {
000046  2100              MOVS     r1,#0
;;;959        if (i == idx) {
;;;960          continue; /* only check other requests */
;;;961        }
;;;962        if (dns_table[i].state == DNS_STATE_ASKING) {
;;;963          if (dns_table[i].pcb_idx == dns_table[idx].pcb_idx) {
;;;964            /* another request is still using the same pcb */
;;;965            dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
000048  2504              MOVS     r5,#4
                  |L3.74|
00004a  42b9              CMP      r1,r7                 ;959
00004c  d00c              BEQ      |L3.104|
00004e  eb011001          ADD      r0,r1,r1,LSL #4       ;962
000052  eb0a1000          ADD      r0,r10,r0,LSL #4      ;962
000056  7a82              LDRB     r2,[r0,#0xa]          ;962
000058  2a02              CMP      r2,#2                 ;962
00005a  d105              BNE      |L3.104|
00005c  7bc0              LDRB     r0,[r0,#0xf]          ;963
00005e  7be2              LDRB     r2,[r4,#0xf]          ;963
000060  4290              CMP      r0,r2                 ;963
000062  d101              BNE      |L3.104|
000064  73e5              STRB     r5,[r4,#0xf]
;;;966            break;
000066  e003              B        |L3.112|
                  |L3.104|
000068  1c49              ADDS     r1,r1,#1              ;958
00006a  b2c9              UXTB     r1,r1                 ;958
00006c  2904              CMP      r1,#4                 ;958
00006e  d3ec              BCC      |L3.74|
                  |L3.112|
;;;967          }
;;;968        }
;;;969      }
;;;970      if (dns_table[idx].pcb_idx < DNS_MAX_SOURCE_PORTS) {
000070  7be0              LDRB     r0,[r4,#0xf]
000072  2804              CMP      r0,#4
000074  d208              BCS      |L3.136|
;;;971        /* if we come here, the pcb is not used any more and can be removed */
;;;972        udp_remove(dns_pcbs[dns_table[idx].pcb_idx]);
000076  4e06              LDR      r6,|L3.144|
000078  f8560020          LDR      r0,[r6,r0,LSL #2]
00007c  f7fffffe          BL       udp_remove
;;;973        dns_pcbs[dns_table[idx].pcb_idx] = NULL;
000080  7be0              LDRB     r0,[r4,#0xf]
000082  f8469020          STR      r9,[r6,r0,LSL #2]
;;;974        dns_table[idx].pcb_idx = DNS_MAX_SOURCE_PORTS;
000086  73e5              STRB     r5,[r4,#0xf]
                  |L3.136|
;;;975      }
;;;976    #endif
;;;977    }
000088  e8bd9ff0          POP      {r4-r12,pc}
;;;978    
                          ENDP

                  |L3.140|
                          DCD      ||.bss||+0x450
                  |L3.144|
                          DCD      ||.bss||

                          AREA ||i.dns_check_entries||, CODE, READONLY, ALIGN=1

                  dns_check_entries PROC
;;;1087   static void
;;;1088   dns_check_entries(void)
000000  b510              PUSH     {r4,lr}
;;;1089   {
;;;1090     u8_t i;
;;;1091   
;;;1092     for (i = 0; i < DNS_TABLE_SIZE; ++i) {
000002  2400              MOVS     r4,#0
                  |L4.4|
;;;1093       dns_check_entry(i);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       dns_check_entry
00000a  1c64              ADDS     r4,r4,#1              ;1092
00000c  b2e4              UXTB     r4,r4                 ;1092
00000e  2c04              CMP      r4,#4                 ;1092
000010  d3f8              BCC      |L4.4|
;;;1094     }
;;;1095   }
000012  bd10              POP      {r4,pc}
;;;1096   
                          ENDP


                          AREA ||i.dns_check_entry||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  dns_check_entry PROC
;;;1010   static void
;;;1011   dns_check_entry(u8_t i)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1012   {
000004  4606              MOV      r6,r0
;;;1013     err_t err;
;;;1014     struct dns_table_entry *entry = &dns_table[i];
000006  492d              LDR      r1,|L5.188|
000008  eb061006          ADD      r0,r6,r6,LSL #4
00000c  eb011400          ADD      r4,r1,r0,LSL #4
;;;1015   
;;;1016     LWIP_ASSERT("array index out of bounds", i < DNS_TABLE_SIZE);
000010  2e04              CMP      r6,#4
000012  d306              BCC      |L5.34|
000014  a32a              ADR      r3,|L5.192|
000016  f44f727e          MOV      r2,#0x3f8
00001a  a135              ADR      r1,|L5.240|
00001c  a03b              ADR      r0,|L5.268|
00001e  f7fffffe          BL       __2printf
                  |L5.34|
;;;1017   
;;;1018     switch (entry->state) {
000022  7aa1              LDRB     r1,[r4,#0xa]
000024  2900              CMP      r1,#0
000026  d040              BEQ      |L5.170|
000028  2500              MOVS     r5,#0
00002a  2701              MOVS     r7,#1
00002c  2901              CMP      r1,#1
00002e  d00c              BEQ      |L5.74|
000030  2902              CMP      r1,#2
000032  d017              BEQ      |L5.100|
000034  2903              CMP      r1,#3
000036  d03a              BEQ      |L5.174|
;;;1019       case DNS_STATE_NEW:
;;;1020         /* initialize new entry */
;;;1021         entry->txid = dns_create_txid();
;;;1022         entry->state = DNS_STATE_ASKING;
;;;1023         entry->server_idx = 0;
;;;1024         entry->tmr = 1;
;;;1025         entry->retries = 0;
;;;1026   
;;;1027         /* send DNS packet for this entry */
;;;1028         err = dns_send(i);
;;;1029         if (err != ERR_OK) {
;;;1030           LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
;;;1031                       ("dns_send returned error: %s\n", lwip_strerr(err)));
;;;1032         }
;;;1033         break;
;;;1034       case DNS_STATE_ASKING:
;;;1035         if (--entry->tmr == 0) {
;;;1036           if (++entry->retries == DNS_MAX_RETRIES) {
;;;1037             if ((entry->server_idx + 1 < DNS_MAX_SERVERS) && !ip_addr_isany_val(dns_servers[entry->server_idx + 1])
;;;1038   #if LWIP_DNS_SUPPORT_MDNS_QUERIES
;;;1039               && !entry->is_mdns
;;;1040   #endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
;;;1041               ) {
;;;1042               /* change of server */
;;;1043               entry->server_idx++;
;;;1044               entry->tmr = 1;
;;;1045               entry->retries = 0;
;;;1046             } else {
;;;1047               LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": timeout\n", entry->name));
;;;1048               /* call specified callback function if provided */
;;;1049               dns_call_found(i, NULL);
;;;1050               /* flush this entry */
;;;1051               entry->state = DNS_STATE_UNUSED;
;;;1052               break;
;;;1053             }
;;;1054           } else {
;;;1055             /* wait longer for the next retry */
;;;1056             entry->tmr = entry->retries;
;;;1057           }
;;;1058   
;;;1059           /* send DNS packet for this entry */
;;;1060           err = dns_send(i);
;;;1061           if (err != ERR_OK) {
;;;1062             LWIP_DEBUGF(DNS_DEBUG | LWIP_DBG_LEVEL_WARNING,
;;;1063                         ("dns_send returned error: %s\n", lwip_strerr(err)));
;;;1064           }
;;;1065         }
;;;1066         break;
;;;1067       case DNS_STATE_DONE:
;;;1068         /* if the time to live is nul */
;;;1069         if ((entry->ttl == 0) || (--entry->ttl == 0)) {
;;;1070           LWIP_DEBUGF(DNS_DEBUG, ("dns_check_entry: \"%s\": flush\n", entry->name));
;;;1071           /* flush this entry, there cannot be any related pending entries in this state */
;;;1072           entry->state = DNS_STATE_UNUSED;
;;;1073         }
;;;1074         break;
;;;1075       case DNS_STATE_UNUSED:
;;;1076         /* nothing to do */
;;;1077         break;
;;;1078       default:
;;;1079         LWIP_ASSERT("unknown dns_table entry state:", 0);
000038  e8bd41f0          POP      {r4-r8,lr}
00003c  a320              ADR      r3,|L5.192|
00003e  f2404237          MOV      r2,#0x437
000042  a13c              ADR      r1,|L5.308|
000044  a031              ADR      r0,|L5.268|
000046  f7ffbffe          B.W      __2printf
                  |L5.74|
00004a  f7fffffe          BL       dns_create_txid
00004e  8120              STRH     r0,[r4,#8]            ;1021
000050  2002              MOVS     r0,#2                 ;1022
000052  72a0              STRB     r0,[r4,#0xa]          ;1022
000054  72e5              STRB     r5,[r4,#0xb]          ;1023
000056  7327              STRB     r7,[r4,#0xc]          ;1024
000058  7365              STRB     r5,[r4,#0xd]          ;1025
00005a  4630              MOV      r0,r6                 ;1028
00005c  e8bd41f0          POP      {r4-r8,lr}            ;1028
000060  f7ffbffe          B.W      dns_send
                  |L5.100|
000064  7b20              LDRB     r0,[r4,#0xc]          ;1035
000066  1e40              SUBS     r0,r0,#1              ;1035
000068  f01000ff          ANDS     r0,r0,#0xff           ;1035
00006c  7320              STRB     r0,[r4,#0xc]          ;1035
00006e  d11c              BNE      |L5.170|
000070  7b60              LDRB     r0,[r4,#0xd]          ;1036
000072  1c40              ADDS     r0,r0,#1              ;1036
000074  b2c1              UXTB     r1,r0                 ;1036
000076  7361              STRB     r1,[r4,#0xd]          ;1036
000078  2904              CMP      r1,#4                 ;1036
00007a  d005              BEQ      |L5.136|
00007c  7321              STRB     r1,[r4,#0xc]          ;1056
                  |L5.126|
00007e  4630              MOV      r0,r6                 ;1060
000080  e8bd41f0          POP      {r4-r8,lr}            ;1060
000084  f7ffbffe          B.W      dns_send
                  |L5.136|
000088  7ae1              LDRB     r1,[r4,#0xb]          ;1037
00008a  1c49              ADDS     r1,r1,#1              ;1037
00008c  2902              CMP      r1,#2                 ;1037
00008e  d207              BCS      |L5.160|
000090  4830              LDR      r0,|L5.340|
000092  f8500021          LDR      r0,[r0,r1,LSL #2]     ;1037
000096  b118              CBZ      r0,|L5.160|
000098  72e1              STRB     r1,[r4,#0xb]          ;1043
00009a  7327              STRB     r7,[r4,#0xc]          ;1044
00009c  7365              STRB     r5,[r4,#0xd]          ;1045
00009e  e7ee              B        |L5.126|
                  |L5.160|
0000a0  2100              MOVS     r1,#0                 ;1049
0000a2  4630              MOV      r0,r6                 ;1049
0000a4  f7fffffe          BL       dns_call_found
0000a8  72a5              STRB     r5,[r4,#0xa]          ;1051
                  |L5.170|
;;;1080         break;
;;;1081     }
;;;1082   }
0000aa  e8bd81f0          POP      {r4-r8,pc}
                  |L5.174|
0000ae  6820              LDR      r0,[r4,#0]            ;1069
0000b0  b110              CBZ      r0,|L5.184|
0000b2  1e40              SUBS     r0,r0,#1              ;1069
0000b4  6020              STR      r0,[r4,#0]            ;1069
0000b6  d1f8              BNE      |L5.170|
                  |L5.184|
0000b8  72a5              STRB     r5,[r4,#0xa]          ;1072
0000ba  e7f6              B        |L5.170|
;;;1083   
                          ENDP

                  |L5.188|
                          DCD      ||.bss||+0x10
                  |L5.192|
0000c0  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\dns.c",0
0000c4  6964646c
0000c8  65776172
0000cc  65735c54
0000d0  68697264
0000d4  5f506172
0000d8  74795c4c
0000dc  7749505c
0000e0  7372635c
0000e4  636f7265
0000e8  5c646e73
0000ec  2e6300  
0000ef  00                DCB      0
                  |L5.240|
0000f0  61727261          DCB      "array index out of bounds",0
0000f4  7920696e
0000f8  64657820
0000fc  6f757420
000100  6f662062
000104  6f756e64
000108  7300    
00010a  00                DCB      0
00010b  00                DCB      0
                  |L5.268|
00010c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000110  7274696f
000114  6e202225
000118  73222066
00011c  61696c65
000120  64206174
000124  206c696e
000128  65202564
00012c  20696e20
000130  25730a00
                  |L5.308|
000134  756e6b6e          DCB      "unknown dns_table entry state:",0
000138  6f776e20
00013c  646e735f
000140  7461626c
000144  6520656e
000148  74727920
00014c  73746174
000150  653a00  
000153  00                DCB      0
                  |L5.340|
                          DCD      ||.data||+0x4

                          AREA ||i.dns_compare_name||, CODE, READONLY, ALIGN=1

                  dns_compare_name PROC
;;;650    static u16_t
;;;651    dns_compare_name(const char *query, struct pbuf* p, u16_t start_offset)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;652    {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
000008  4615              MOV      r5,r2
;;;653      int n;
;;;654      u16_t response_offset = start_offset;
;;;655    
;;;656      do {
;;;657        n = pbuf_try_get_at(p, response_offset++);
;;;658        if (n < 0) {
;;;659          return 0xFFFF;
00000a  f64f77ff          MOV      r7,#0xffff
                  |L6.14|
00000e  4629              MOV      r1,r5                 ;657
000010  1c6d              ADDS     r5,r5,#1              ;657
000012  b2ad              UXTH     r5,r5                 ;657
000014  4640              MOV      r0,r8                 ;657
000016  f7fffffe          BL       pbuf_try_get_at
00001a  4604              MOV      r4,r0                 ;657
00001c  0020              MOVS     r0,r4                 ;658
00001e  d502              BPL      |L6.38|
000020  4638              MOV      r0,r7
                  |L6.34|
;;;660        }
;;;661        /** @see RFC 1035 - 4.1.4. Message compression */
;;;662        if ((n & 0xc0) == 0xc0) {
;;;663          /* Compressed name: cannot be equal since we don't send them */
;;;664          return 0xFFFF;
;;;665        } else {
;;;666          /* Not compressed name */
;;;667          while (n > 0) {
;;;668            int c = pbuf_try_get_at(p, response_offset);
;;;669            if (c < 0) {
;;;670              return 0xFFFF;
;;;671            }
;;;672            if ((*query) != (u8_t)c) {
;;;673              return 0xFFFF;
;;;674            }
;;;675            ++response_offset;
;;;676            ++query;
;;;677            --n;
;;;678          }
;;;679          ++query;
;;;680        }
;;;681        n = pbuf_try_get_at(p, response_offset);
;;;682        if (n < 0) {
;;;683          return 0xFFFF;
;;;684        }
;;;685      } while (n != 0);
;;;686    
;;;687      return response_offset + 1;
;;;688    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L6.38|
000026  f3c41081          UBFX     r0,r4,#6,#2           ;662
00002a  2803              CMP      r0,#3                 ;662
00002c  d113              BNE      |L6.86|
00002e  4638              MOV      r0,r7                 ;664
000030  e7f7              B        |L6.34|
                  |L6.50|
000032  4629              MOV      r1,r5                 ;668
000034  4640              MOV      r0,r8                 ;668
000036  f7fffffe          BL       pbuf_try_get_at
00003a  2800              CMP      r0,#0                 ;669
00003c  da01              BGE      |L6.66|
00003e  4638              MOV      r0,r7                 ;670
000040  e7ef              B        |L6.34|
                  |L6.66|
000042  7831              LDRB     r1,[r6,#0]            ;672
000044  b2c0              UXTB     r0,r0                 ;672
000046  4281              CMP      r1,r0                 ;672
000048  d001              BEQ      |L6.78|
00004a  4638              MOV      r0,r7                 ;673
00004c  e7e9              B        |L6.34|
                  |L6.78|
00004e  1c6d              ADDS     r5,r5,#1              ;675
000050  b2ad              UXTH     r5,r5                 ;675
000052  1c76              ADDS     r6,r6,#1              ;676
000054  1e64              SUBS     r4,r4,#1              ;677
                  |L6.86|
000056  2c00              CMP      r4,#0                 ;667
000058  dceb              BGT      |L6.50|
00005a  1c76              ADDS     r6,r6,#1              ;679
00005c  4629              MOV      r1,r5                 ;681
00005e  4640              MOV      r0,r8                 ;681
000060  f7fffffe          BL       pbuf_try_get_at
000064  2800              CMP      r0,#0                 ;682
000066  da01              BGE      |L6.108|
000068  4638              MOV      r0,r7                 ;683
00006a  e7da              B        |L6.34|
                  |L6.108|
00006c  d1cf              BNE      |L6.14|
00006e  f1050501          ADD      r5,r5,#1              ;687
000072  b2a8              UXTH     r0,r5                 ;687
000074  e7d5              B        |L6.34|
;;;689    
                          ENDP


                          AREA ||i.dns_correct_response||, CODE, READONLY, ALIGN=2

                  dns_correct_response PROC
;;;1100   static void
;;;1101   dns_correct_response(u8_t idx, u32_t ttl)
000000  b510              PUSH     {r4,lr}
;;;1102   {
;;;1103     struct dns_table_entry *entry = &dns_table[idx];
000002  4b0c              LDR      r3,|L7.52|
000004  eb001200          ADD      r2,r0,r0,LSL #4
000008  eb031402          ADD      r4,r3,r2,LSL #4
;;;1104   
;;;1105     entry->state = DNS_STATE_DONE;
00000c  2203              MOVS     r2,#3
00000e  72a2              STRB     r2,[r4,#0xa]
;;;1106   
;;;1107     LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response = ", entry->name));
;;;1108     ip_addr_debug_print(DNS_DEBUG, (&(entry->ipaddr)));
;;;1109     LWIP_DEBUGF(DNS_DEBUG, ("\n"));
;;;1110   
;;;1111     /* read the answer resource record's TTL, and maximize it if needed */
;;;1112     entry->ttl = ttl;
000010  6021              STR      r1,[r4,#0]
;;;1113     if (entry->ttl > DNS_MAX_TTL) {
000012  4a09              LDR      r2,|L7.56|
000014  4291              CMP      r1,r2
000016  d900              BLS      |L7.26|
;;;1114       entry->ttl = DNS_MAX_TTL;
000018  6022              STR      r2,[r4,#0]
                  |L7.26|
;;;1115     }
;;;1116     dns_call_found(idx, &entry->ipaddr);
00001a  1d21              ADDS     r1,r4,#4
00001c  f7fffffe          BL       dns_call_found
;;;1117   
;;;1118     if (entry->ttl == 0) {
000020  6820              LDR      r0,[r4,#0]
000022  2800              CMP      r0,#0
000024  d104              BNE      |L7.48|
;;;1119       /* RFC 883, page 29: "Zero values are
;;;1120          interpreted to mean that the RR can only be used for the
;;;1121          transaction in progress, and should not be cached."
;;;1122          -> flush this entry now */
;;;1123       /* entry reused during callback? */
;;;1124       if (entry->state == DNS_STATE_DONE) {
000026  7aa0              LDRB     r0,[r4,#0xa]
000028  2803              CMP      r0,#3
00002a  d101              BNE      |L7.48|
;;;1125         entry->state = DNS_STATE_UNUSED;
00002c  2000              MOVS     r0,#0
00002e  72a0              STRB     r0,[r4,#0xa]
                  |L7.48|
;;;1126       }
;;;1127     }
;;;1128   }
000030  bd10              POP      {r4,pc}
;;;1129   /**
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      ||.bss||+0x10
                  |L7.56|
                          DCD      0x00093a80

                          AREA ||i.dns_create_txid||, CODE, READONLY, ALIGN=2

                  dns_create_txid PROC
;;;980    static u16_t
;;;981    dns_create_txid(void)
000000  b510              PUSH     {r4,lr}
;;;982    {
;;;983      u16_t txid;
;;;984      u8_t i;
;;;985    
;;;986    again:
;;;987      txid = (u16_t)DNS_RAND_TXID();
;;;988    
;;;989      /* check whether the ID is unique */
;;;990      for (i = 0; i < DNS_TABLE_SIZE; i++) {
;;;991        if ((dns_table[i].state == DNS_STATE_ASKING) &&
000002  4c0a              LDR      r4,|L8.44|
                  |L8.4|
000004  f7fffffe          BL       rand
000008  b280              UXTH     r0,r0                 ;987
00000a  2100              MOVS     r1,#0                 ;990
                  |L8.12|
00000c  eb011201          ADD      r2,r1,r1,LSL #4
000010  eb041202          ADD      r2,r4,r2,LSL #4
000014  7a93              LDRB     r3,[r2,#0xa]
000016  2b02              CMP      r3,#2
000018  d102              BNE      |L8.32|
;;;992            (dns_table[i].txid == txid)) {
00001a  8912              LDRH     r2,[r2,#8]
00001c  4282              CMP      r2,r0
00001e  d0f1              BEQ      |L8.4|
                  |L8.32|
000020  1c49              ADDS     r1,r1,#1              ;990
000022  b2c9              UXTB     r1,r1                 ;990
000024  2904              CMP      r1,#4                 ;990
000026  d3f1              BCC      |L8.12|
;;;993          /* ID already used by another pending query */
;;;994          goto again;
;;;995        }
;;;996      }
;;;997    
;;;998      return txid;
;;;999    }
000028  bd10              POP      {r4,pc}
;;;1000   
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      ||.bss||+0x10

                          AREA ||i.dns_enqueue||, CODE, READONLY, ALIGN=2

                  dns_enqueue PROC
;;;1316   static err_t
;;;1317   dns_enqueue(const char *name, size_t hostnamelen, dns_found_callback found,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;1318               void *callback_arg LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype) LWIP_DNS_ISMDNS_ARG(u8_t is_mdns))
;;;1319   {
000004  4688              MOV      r8,r1
000006  4691              MOV      r9,r2
000008  469a              MOV      r10,r3
;;;1320     u8_t i;
;;;1321     u8_t lseq, lseqi;
;;;1322     struct dns_table_entry *entry = NULL;
;;;1323     size_t namelen;
;;;1324     struct dns_req_entry* req;
;;;1325   
;;;1326   #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
;;;1327     u8_t r;
;;;1328     /* check for duplicate entries */
;;;1329     for (i = 0; i < DNS_TABLE_SIZE; i++) {
00000a  2400              MOVS     r4,#0
;;;1330       if ((dns_table[i].state == DNS_STATE_ASKING) &&
00000c  4e4c              LDR      r6,|L9.320|
;;;1331           (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0)) {
00000e  f44f7580          MOV      r5,#0x100
;;;1332   #if LWIP_IPV4 && LWIP_IPV6
;;;1333         if (dns_table[i].reqaddrtype != dns_addrtype) {
;;;1334           /* requested address types don't match
;;;1335              this can lead to 2 concurrent requests, but mixing the address types
;;;1336              for the same host should not be that common */
;;;1337           continue;
;;;1338         }
;;;1339   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1340         /* this is a duplicate entry, find a free request entry */
;;;1341         for (r = 0; r < DNS_MAX_REQUESTS; r++) {
;;;1342           if (dns_requests[r].found == 0) {
000012  f5066788          ADD      r7,r6,#0x440
                  |L9.22|
000016  eb041004          ADD      r0,r4,r4,LSL #4       ;1330
00001a  eb061100          ADD      r1,r6,r0,LSL #4       ;1330
00001e  7a88              LDRB     r0,[r1,#0xa]          ;1330
000020  2802              CMP      r0,#2                 ;1330
000022  d10f              BNE      |L9.68|
000024  3110              ADDS     r1,r1,#0x10           ;1331
000026  462a              MOV      r2,r5                 ;1331
000028  9800              LDR      r0,[sp,#0]            ;1331
00002a  f7fffffe          BL       lwip_strnicmp
00002e  b948              CBNZ     r0,|L9.68|
000030  2000              MOVS     r0,#0                 ;1341
                  |L9.50|
000032  eb000140          ADD      r1,r0,r0,LSL #1
000036  f8571021          LDR      r1,[r7,r1,LSL #2]
00003a  b1a9              CBZ      r1,|L9.104|
00003c  1c40              ADDS     r0,r0,#1              ;1341
00003e  b2c0              UXTB     r0,r0                 ;1341
000040  2804              CMP      r0,#4                 ;1341
000042  d3f6              BCC      |L9.50|
                  |L9.68|
000044  1c64              ADDS     r4,r4,#1              ;1329
000046  b2e4              UXTB     r4,r4                 ;1329
000048  2c04              CMP      r4,#4                 ;1329
00004a  d3e4              BCC      |L9.22|
;;;1343             dns_requests[r].found = found;
;;;1344             dns_requests[r].arg = callback_arg;
;;;1345             dns_requests[r].dns_table_idx = i;
;;;1346             LWIP_DNS_SET_ADDRTYPE(dns_requests[r].reqaddrtype, dns_addrtype);
;;;1347             LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": duplicate request\n", name));
;;;1348             return ERR_INPROGRESS;
;;;1349           }
;;;1350         }
;;;1351       }
;;;1352     }
;;;1353     /* no duplicate entries found */
;;;1354   #endif
;;;1355   
;;;1356     /* search an unused entry, or the oldest one */
;;;1357     lseq = 0;
00004c  f04f0c00          MOV      r12,#0
;;;1358     lseqi = DNS_TABLE_SIZE;
000050  2104              MOVS     r1,#4
;;;1359     for (i = 0; i < DNS_TABLE_SIZE; ++i) {
000052  2400              MOVS     r4,#0
;;;1360       entry = &dns_table[i];
;;;1361       /* is it an unused entry ? */
;;;1362       if (entry->state == DNS_STATE_UNUSED) {
;;;1363         break;
;;;1364       }
;;;1365       /* check if this is the oldest completed entry */
;;;1366       if (entry->state == DNS_STATE_DONE) {
;;;1367         u8_t age = dns_seqno - entry->seqno;
000054  483b              LDR      r0,|L9.324|
                  |L9.86|
000056  eb041204          ADD      r2,r4,r4,LSL #4       ;1360
00005a  eb061502          ADD      r5,r6,r2,LSL #4       ;1360
00005e  7aab              LDRB     r3,[r5,#0xa]          ;1362
000060  b1e3              CBZ      r3,|L9.156|
000062  2b03              CMP      r3,#3                 ;1366
000064  d00e              BEQ      |L9.132|
000066  e015              B        |L9.148|
                  |L9.104|
000068  eb000040          ADD      r0,r0,r0,LSL #1       ;1343
00006c  f8479020          STR      r9,[r7,r0,LSL #2]     ;1343
000070  eb070080          ADD      r0,r7,r0,LSL #2       ;1344
000074  f8c0a004          STR      r10,[r0,#4]           ;1344
000078  7204              STRB     r4,[r0,#8]            ;1345
00007a  f06f0004          MVN      r0,#4                 ;1348
                  |L9.126|
;;;1368         if (age > lseq) {
;;;1369           lseq = age;
;;;1370           lseqi = i;
;;;1371         }
;;;1372       }
;;;1373     }
;;;1374   
;;;1375     /* if we don't have found an unused entry, use the oldest completed one */
;;;1376     if (i == DNS_TABLE_SIZE) {
;;;1377       if ((lseqi >= DNS_TABLE_SIZE) || (dns_table[lseqi].state != DNS_STATE_DONE)) {
;;;1378         /* no entry can be used now, table is full */
;;;1379         LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS entries table is full\n", name));
;;;1380         return ERR_MEM;
;;;1381       } else {
;;;1382         /* use the oldest completed one */
;;;1383         i = lseqi;
;;;1384         entry = &dns_table[i];
;;;1385       }
;;;1386     }
;;;1387   
;;;1388   #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING) != 0)
;;;1389     /* find a free request entry */
;;;1390     req = NULL;
;;;1391     for (r = 0; r < DNS_MAX_REQUESTS; r++) {
;;;1392       if (dns_requests[r].found == NULL) {
;;;1393         req = &dns_requests[r];
;;;1394         break;
;;;1395       }
;;;1396     }
;;;1397     if (req == NULL) {
;;;1398       /* no request entry can be used now, table is full */
;;;1399       LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": DNS request entries table is full\n", name));
;;;1400       return ERR_MEM;
;;;1401     }
;;;1402     req->dns_table_idx = i;
;;;1403   #else
;;;1404     /* in this configuration, the entry index is the same as the request index */
;;;1405     req = &dns_requests[i];
;;;1406   #endif
;;;1407   
;;;1408     /* use this entry */
;;;1409     LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": use DNS entry %"U16_F"\n", name, (u16_t)(i)));
;;;1410   
;;;1411     /* fill the entry */
;;;1412     entry->state = DNS_STATE_NEW;
;;;1413     entry->seqno = dns_seqno;
;;;1414     LWIP_DNS_SET_ADDRTYPE(entry->reqaddrtype, dns_addrtype);
;;;1415     LWIP_DNS_SET_ADDRTYPE(req->reqaddrtype, dns_addrtype);
;;;1416     req->found = found;
;;;1417     req->arg   = callback_arg;
;;;1418     namelen = LWIP_MIN(hostnamelen, DNS_MAX_NAME_LENGTH-1);
;;;1419     MEMCPY(entry->name, name, namelen);
;;;1420     entry->name[namelen] = 0;
;;;1421   
;;;1422   #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
;;;1423     entry->pcb_idx = dns_alloc_pcb();
;;;1424     if (entry->pcb_idx >= DNS_MAX_SOURCE_PORTS) {
;;;1425       /* failed to get a UDP pcb */
;;;1426       LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": failed to allocate a pcb\n", name));
;;;1427       entry->state = DNS_STATE_UNUSED;
;;;1428       req->found = NULL;
;;;1429       return ERR_MEM;
;;;1430     }
;;;1431     LWIP_DEBUGF(DNS_DEBUG, ("dns_enqueue: \"%s\": use DNS pcb %"U16_F"\n", name, (u16_t)(entry->pcb_idx)));
;;;1432   #endif
;;;1433   
;;;1434   #if LWIP_DNS_SUPPORT_MDNS_QUERIES
;;;1435     entry->is_mdns = is_mdns;
;;;1436   #endif
;;;1437   
;;;1438     dns_seqno++;
;;;1439   
;;;1440     /* force to send query without waiting timer */
;;;1441     dns_check_entry(i);
;;;1442   
;;;1443     /* dns query is enqueued */
;;;1444     return ERR_INPROGRESS;
;;;1445   }
00007e  b004              ADD      sp,sp,#0x10
000080  e8bd9ff0          POP      {r4-r12,pc}
                  |L9.132|
000084  7baa              LDRB     r2,[r5,#0xe]          ;1367
000086  7843              LDRB     r3,[r0,#1]            ;1367  ; dns_seqno
000088  1a9a              SUBS     r2,r3,r2              ;1367
00008a  b2d2              UXTB     r2,r2                 ;1367
00008c  4562              CMP      r2,r12                ;1368
00008e  d901              BLS      |L9.148|
000090  4694              MOV      r12,r2                ;1369
000092  4621              MOV      r1,r4                 ;1370
                  |L9.148|
000094  1c64              ADDS     r4,r4,#1              ;1359
000096  b2e4              UXTB     r4,r4                 ;1359
000098  2c04              CMP      r4,#4                 ;1359
00009a  d3dc              BCC      |L9.86|
                  |L9.156|
00009c  f04f3bff          MOV      r11,#0xffffffff       ;1380
0000a0  2c04              CMP      r4,#4                 ;1376
0000a2  d10b              BNE      |L9.188|
0000a4  2904              CMP      r1,#4                 ;1377
0000a6  d206              BCS      |L9.182|
0000a8  eb011201          ADD      r2,r1,r1,LSL #4       ;1377
0000ac  eb061502          ADD      r5,r6,r2,LSL #4       ;1377
0000b0  7aaa              LDRB     r2,[r5,#0xa]          ;1377
0000b2  2a03              CMP      r2,#3                 ;1377
0000b4  d001              BEQ      |L9.186|
                  |L9.182|
0000b6  4658              MOV      r0,r11                ;1380
0000b8  e7e1              B        |L9.126|
                  |L9.186|
0000ba  460c              MOV      r4,r1                 ;1383
                  |L9.188|
0000bc  2600              MOVS     r6,#0                 ;1390
0000be  2100              MOVS     r1,#0                 ;1391
                  |L9.192|
0000c0  eb010241          ADD      r2,r1,r1,LSL #1       ;1392
0000c4  f8572022          LDR      r2,[r7,r2,LSL #2]     ;1392
0000c8  b352              CBZ      r2,|L9.288|
0000ca  1c49              ADDS     r1,r1,#1              ;1391
0000cc  b2c9              UXTB     r1,r1                 ;1391
0000ce  2904              CMP      r1,#4                 ;1391
0000d0  d3f6              BCC      |L9.192|
                  |L9.210|
0000d2  b356              CBZ      r6,|L9.298|
0000d4  7234              STRB     r4,[r6,#8]            ;1402
0000d6  2101              MOVS     r1,#1                 ;1412
0000d8  72a9              STRB     r1,[r5,#0xa]          ;1412
0000da  4607              MOV      r7,r0                 ;1413
0000dc  7840              LDRB     r0,[r0,#1]            ;1413  ; dns_seqno
0000de  73a8              STRB     r0,[r5,#0xe]          ;1413
0000e0  f8c69000          STR      r9,[r6,#0]            ;1416
0000e4  f8c6a004          STR      r10,[r6,#4]           ;1417
0000e8  f1b80fff          CMP      r8,#0xff              ;1418
0000ec  d301              BCC      |L9.242|
0000ee  f04f08ff          MOV      r8,#0xff              ;1418
                  |L9.242|
0000f2  4642              MOV      r2,r8                 ;1419
0000f4  f1050010          ADD      r0,r5,#0x10           ;1419
0000f8  9900              LDR      r1,[sp,#0]            ;1419
0000fa  f7fffffe          BL       __aeabi_memcpy
0000fe  eb050008          ADD      r0,r5,r8              ;1420
000102  f04f0900          MOV      r9,#0                 ;1420
000106  f8809010          STRB     r9,[r0,#0x10]         ;1420
00010a  f7fffffe          BL       dns_alloc_pcb
00010e  73e8              STRB     r0,[r5,#0xf]          ;1423
000110  2804              CMP      r0,#4                 ;1424
000112  d30c              BCC      |L9.302|
000114  f885900a          STRB     r9,[r5,#0xa]          ;1427
000118  f8c69000          STR      r9,[r6,#0]            ;1428
00011c  4658              MOV      r0,r11                ;1429
00011e  e7ae              B        |L9.126|
                  |L9.288|
000120  eb010141          ADD      r1,r1,r1,LSL #1       ;1393
000124  eb070681          ADD      r6,r7,r1,LSL #2       ;1393
000128  e7d3              B        |L9.210|
                  |L9.298|
00012a  4658              MOV      r0,r11                ;1400
00012c  e7a7              B        |L9.126|
                  |L9.302|
00012e  7878              LDRB     r0,[r7,#1]            ;1438  ; dns_seqno
000130  1c40              ADDS     r0,r0,#1              ;1438
000132  7078              STRB     r0,[r7,#1]            ;1438
000134  4620              MOV      r0,r4                 ;1441
000136  f7fffffe          BL       dns_check_entry
00013a  f06f0004          MVN      r0,#4                 ;1444
00013e  e79e              B        |L9.126|
;;;1446   
                          ENDP

                  |L9.320|
                          DCD      ||.bss||+0x10
                  |L9.324|
                          DCD      ||.data||

                          AREA ||i.dns_gethostbyname||, CODE, READONLY, ALIGN=1

                  dns_gethostbyname PROC
;;;1467   err_t
;;;1468   dns_gethostbyname(const char *hostname, ip_addr_t *addr, dns_found_callback found,
000000  b538              PUSH     {r3-r5,lr}
;;;1469                     void *callback_arg)
;;;1470   {
;;;1471     return dns_gethostbyname_addrtype(hostname, addr, found, callback_arg, LWIP_DNS_ADDRTYPE_DEFAULT);
000002  2400              MOVS     r4,#0
000004  9400              STR      r4,[sp,#0]
000006  f7fffffe          BL       dns_gethostbyname_addrtype
;;;1472   }
00000a  bd38              POP      {r3-r5,pc}
;;;1473   
                          ENDP


                          AREA ||i.dns_gethostbyname_addrtype||, CODE, READONLY, ALIGN=2

                  dns_gethostbyname_addrtype PROC
;;;1488   err_t
;;;1489   dns_gethostbyname_addrtype(const char *hostname, ip_addr_t *addr, dns_found_callback found,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1490                              void *callback_arg, u8_t dns_addrtype)
;;;1491   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
;;;1492     size_t hostnamelen;
;;;1493   #if LWIP_DNS_SUPPORT_MDNS_QUERIES
;;;1494     u8_t is_mdns;
;;;1495   #endif
;;;1496     /* not initialized or no valid server yet, or invalid addr pointer
;;;1497      * or invalid hostname or invalid hostname length */
;;;1498     if ((addr == NULL) ||
;;;1499         (!hostname) || (!hostname[0])) {
;;;1500       return ERR_ARG;
00000c  f06f090f          MVN      r9,#0xf
000010  2e00              CMP      r6,#0                 ;1498
000012  d00b              BEQ      |L11.44|
000014  b155              CBZ      r5,|L11.44|
000016  7828              LDRB     r0,[r5,#0]            ;1499
000018  b140              CBZ      r0,|L11.44|
;;;1501     }
;;;1502   #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) == 0)
;;;1503     if (dns_pcbs[0] == NULL) {
;;;1504       return ERR_ARG;
;;;1505     }
;;;1506   #endif
;;;1507     hostnamelen = strlen(hostname);
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       strlen
000020  4604              MOV      r4,r0
;;;1508     if (hostnamelen >= DNS_MAX_NAME_LENGTH) {
000022  2cff              CMP      r4,#0xff
000024  d904              BLS      |L11.48|
;;;1509       LWIP_DEBUGF(DNS_DEBUG, ("dns_gethostbyname: name too long to resolve"));
;;;1510       return ERR_ARG;
000026  4648              MOV      r0,r9
                  |L11.40|
;;;1511     }
;;;1512   
;;;1513   
;;;1514   #if LWIP_HAVE_LOOPIF
;;;1515     if (strcmp(hostname, "localhost") == 0) {
;;;1516       ip_addr_set_loopback(LWIP_DNS_ADDRTYPE_IS_IPV6(dns_addrtype), addr);
;;;1517       return ERR_OK;
;;;1518     }
;;;1519   #endif /* LWIP_HAVE_LOOPIF */
;;;1520   
;;;1521     /* host name already in octet notation? set ip addr and return ERR_OK */
;;;1522     if (ipaddr_aton(hostname, addr)) {
;;;1523   #if LWIP_IPV4 && LWIP_IPV6
;;;1524       if ((IP_IS_V6(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV4)) ||
;;;1525           (IP_IS_V4(addr) && (dns_addrtype != LWIP_DNS_ADDRTYPE_IPV6)))
;;;1526   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1527       {
;;;1528         return ERR_OK;
;;;1529       }
;;;1530     }
;;;1531     /* already have this address cached? */
;;;1532     if (dns_lookup(hostname, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)) == ERR_OK) {
;;;1533       return ERR_OK;
;;;1534     }
;;;1535   #if LWIP_IPV4 && LWIP_IPV6
;;;1536     if ((dns_addrtype == LWIP_DNS_ADDRTYPE_IPV4_IPV6) || (dns_addrtype == LWIP_DNS_ADDRTYPE_IPV6_IPV4)) {
;;;1537       /* fallback to 2nd IP type and try again to lookup */
;;;1538       u8_t fallback;
;;;1539       if (dns_addrtype == LWIP_DNS_ADDRTYPE_IPV4_IPV6) {
;;;1540         fallback = LWIP_DNS_ADDRTYPE_IPV6;
;;;1541       } else {
;;;1542         fallback = LWIP_DNS_ADDRTYPE_IPV4;
;;;1543       }
;;;1544       if (dns_lookup(hostname, addr LWIP_DNS_ADDRTYPE_ARG(fallback)) == ERR_OK) {
;;;1545         return ERR_OK;
;;;1546       }
;;;1547     }
;;;1548   #else /* LWIP_IPV4 && LWIP_IPV6 */
;;;1549     LWIP_UNUSED_ARG(dns_addrtype);
;;;1550   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1551   
;;;1552   #if LWIP_DNS_SUPPORT_MDNS_QUERIES
;;;1553     if (strstr(hostname, ".local") == &hostname[hostnamelen] - 6) {
;;;1554       is_mdns = 1;
;;;1555     } else {
;;;1556       is_mdns = 0;
;;;1557     }
;;;1558   
;;;1559     if (!is_mdns)
;;;1560   #endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
;;;1561     {
;;;1562       /* prevent calling found callback if no server is set, return error instead */
;;;1563       if (ip_addr_isany_val(dns_servers[0])) {
;;;1564         return ERR_VAL;
;;;1565       }
;;;1566     }
;;;1567   
;;;1568     /* queue query with specified callback */
;;;1569     return dns_enqueue(hostname, hostnamelen, found, callback_arg LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)
;;;1570        LWIP_DNS_ISMDNS_ARG(is_mdns));
;;;1571   }
000028  e8bd87f0          POP      {r4-r10,pc}
                  |L11.44|
00002c  4648              MOV      r0,r9                 ;1500
00002e  e7fb              B        |L11.40|
                  |L11.48|
000030  4631              MOV      r1,r6                 ;1522
000032  4628              MOV      r0,r5                 ;1522
000034  f7fffffe          BL       ip4addr_aton
000038  b108              CBZ      r0,|L11.62|
00003a  2000              MOVS     r0,#0                 ;1528
00003c  e7f4              B        |L11.40|
                  |L11.62|
00003e  4631              MOV      r1,r6                 ;1532
000040  4628              MOV      r0,r5                 ;1532
000042  f7fffffe          BL       dns_lookup
000046  b150              CBZ      r0,|L11.94|
000048  4807              LDR      r0,|L11.104|
00004a  6800              LDR      r0,[r0,#0]            ;1563  ; dns_servers
00004c  b148              CBZ      r0,|L11.98|
00004e  4643              MOV      r3,r8                 ;1569
000050  463a              MOV      r2,r7                 ;1569
000052  4621              MOV      r1,r4                 ;1569
000054  4628              MOV      r0,r5                 ;1569
000056  e8bd47f0          POP      {r4-r10,lr}           ;1569
00005a  f7ffbffe          B.W      dns_enqueue
                  |L11.94|
00005e  2000              MOVS     r0,#0                 ;1533
000060  e7e2              B        |L11.40|
                  |L11.98|
000062  f06f0005          MVN      r0,#5                 ;1564
000066  e7df              B        |L11.40|
;;;1572   
                          ENDP

                  |L11.104|
                          DCD      ||.data||+0x4

                          AREA ||i.dns_getserver||, CODE, READONLY, ALIGN=2

                  dns_getserver PROC
;;;383    const ip_addr_t*
;;;384    dns_getserver(u8_t numdns)
000000  2802              CMP      r0,#2
;;;385    {
000002  d203              BCS      |L12.12|
;;;386      if (numdns < DNS_MAX_SERVERS) {
;;;387        return &dns_servers[numdns];
000004  4902              LDR      r1,|L12.16|
000006  eb010080          ADD      r0,r1,r0,LSL #2
;;;388      } else {
;;;389        return IP_ADDR_ANY;
;;;390      }
;;;391    }
00000a  4770              BX       lr
                  |L12.12|
00000c  4801              LDR      r0,|L12.20|
00000e  4770              BX       lr
;;;392    
                          ENDP

                  |L12.16|
                          DCD      ||.data||+0x4
                  |L12.20|
                          DCD      ip_addr_any

                          AREA ||i.dns_init||, CODE, READONLY, ALIGN=1

                  dns_init PROC
;;;317    void
;;;318    dns_init(void)
000000  4770              BX       lr
;;;319    {
;;;320    #ifdef DNS_SERVER_ADDRESS
;;;321      /* initialize default DNS server address */
;;;322      ip_addr_t dnsserver;
;;;323      DNS_SERVER_ADDRESS(&dnsserver);
;;;324      dns_setserver(0, &dnsserver);
;;;325    #endif /* DNS_SERVER_ADDRESS */
;;;326    
;;;327      LWIP_ASSERT("sanity check SIZEOF_DNS_QUERY",
;;;328        sizeof(struct dns_query) == SIZEOF_DNS_QUERY);
;;;329      LWIP_ASSERT("sanity check SIZEOF_DNS_ANSWER",
;;;330        sizeof(struct dns_answer) <= SIZEOF_DNS_ANSWER_ASSERT);
;;;331    
;;;332      LWIP_DEBUGF(DNS_DEBUG, ("dns_init: initializing\n"));
;;;333    
;;;334      /* if dns client not yet initialized... */
;;;335    #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) == 0)
;;;336      if (dns_pcbs[0] == NULL) {
;;;337        dns_pcbs[0] = udp_new_ip_type(IPADDR_TYPE_ANY);
;;;338        LWIP_ASSERT("dns_pcbs[0] != NULL", dns_pcbs[0] != NULL);
;;;339    
;;;340        /* initialize DNS table not needed (initialized to zero since it is a
;;;341         * global variable) */
;;;342        LWIP_ASSERT("For implicit initialization to work, DNS_STATE_UNUSED needs to be 0",
;;;343          DNS_STATE_UNUSED == 0);
;;;344    
;;;345        /* initialize DNS client */
;;;346        udp_bind(dns_pcbs[0], IP_ANY_TYPE, 0);
;;;347        udp_recv(dns_pcbs[0], dns_recv, NULL);
;;;348      }
;;;349    #endif
;;;350    
;;;351    #if DNS_LOCAL_HOSTLIST
;;;352      dns_init_local();
;;;353    #endif
;;;354    }
;;;355    
                          ENDP


                          AREA ||i.dns_lookup||, CODE, READONLY, ALIGN=2

                  dns_lookup PROC
;;;604    static err_t
;;;605    dns_lookup(const char *name, ip_addr_t *addr LWIP_DNS_ADDRTYPE_ARG(u8_t dns_addrtype))
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;606    {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
;;;607      u8_t i;
;;;608    #if DNS_LOCAL_HOSTLIST || defined(DNS_LOOKUP_LOCAL_EXTERN)
;;;609    #endif /* DNS_LOCAL_HOSTLIST || defined(DNS_LOOKUP_LOCAL_EXTERN) */
;;;610    #if DNS_LOCAL_HOSTLIST
;;;611      if (dns_lookup_local(name, addr LWIP_DNS_ADDRTYPE_ARG(dns_addrtype)) == ERR_OK) {
;;;612        return ERR_OK;
;;;613      }
;;;614    #endif /* DNS_LOCAL_HOSTLIST */
;;;615    #ifdef DNS_LOOKUP_LOCAL_EXTERN
;;;616      if (DNS_LOOKUP_LOCAL_EXTERN(name, addr, LWIP_DNS_ADDRTYPE_ARG_OR_ZERO(dns_addrtype)) == ERR_OK) {
;;;617        return ERR_OK;
;;;618      }
;;;619    #endif /* DNS_LOOKUP_LOCAL_EXTERN */
;;;620    
;;;621      /* Walk through name list, return entry if found. If not, return NULL. */
;;;622      for (i = 0; i < DNS_TABLE_SIZE; ++i) {
000008  2400              MOVS     r4,#0
;;;623        if ((dns_table[i].state == DNS_STATE_DONE) &&
00000a  4d10              LDR      r5,|L14.76|
;;;624            (lwip_strnicmp(name, dns_table[i].name, sizeof(dns_table[i].name)) == 0) &&
00000c  f44f7780          MOV      r7,#0x100
                  |L14.16|
000010  eb041004          ADD      r0,r4,r4,LSL #4       ;623
000014  eb051100          ADD      r1,r5,r0,LSL #4       ;623
000018  7a88              LDRB     r0,[r1,#0xa]          ;623
00001a  2803              CMP      r0,#3                 ;623
00001c  d105              BNE      |L14.42|
00001e  3110              ADDS     r1,r1,#0x10
000020  463a              MOV      r2,r7
000022  4640              MOV      r0,r8
000024  f7fffffe          BL       lwip_strnicmp
000028  b138              CBZ      r0,|L14.58|
                  |L14.42|
00002a  1c64              ADDS     r4,r4,#1              ;622
00002c  b2e4              UXTB     r4,r4                 ;622
00002e  2c04              CMP      r4,#4                 ;622
000030  d3ee              BCC      |L14.16|
;;;625            LWIP_DNS_ADDRTYPE_MATCH_IP(dns_addrtype, dns_table[i].ipaddr)) {
;;;626          LWIP_DEBUGF(DNS_DEBUG, ("dns_lookup: \"%s\": found = ", name));
;;;627          ip_addr_debug_print(DNS_DEBUG, &(dns_table[i].ipaddr));
;;;628          LWIP_DEBUGF(DNS_DEBUG, ("\n"));
;;;629          if (addr) {
;;;630            ip_addr_copy(*addr, dns_table[i].ipaddr);
;;;631          }
;;;632          return ERR_OK;
;;;633        }
;;;634      }
;;;635    
;;;636      return ERR_ARG;
000032  f06f000f          MVN      r0,#0xf
                  |L14.54|
;;;637    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L14.58|
00003a  b12e              CBZ      r6,|L14.72|
00003c  eb041004          ADD      r0,r4,r4,LSL #4       ;630
000040  eb051000          ADD      r0,r5,r0,LSL #4       ;630
000044  6840              LDR      r0,[r0,#4]            ;630
000046  6030              STR      r0,[r6,#0]            ;630
                  |L14.72|
000048  2000              MOVS     r0,#0                 ;632
00004a  e7f4              B        |L14.54|
;;;638    
                          ENDP

                  |L14.76|
                          DCD      ||.bss||+0x10

                          AREA ||i.dns_recv||, CODE, READONLY, ALIGN=2

                  dns_recv PROC
;;;1132   static void
;;;1133   dns_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1134   {
000004  b088              SUB      sp,sp,#0x20
000006  4617              MOV      r7,r2
000008  4699              MOV      r9,r3
;;;1135     u8_t i;
;;;1136     u16_t txid;
;;;1137     u16_t res_idx;
;;;1138     struct dns_hdr hdr;
;;;1139     struct dns_answer ans;
;;;1140     struct dns_query qry;
;;;1141     u16_t nquestions, nanswers;
;;;1142   
;;;1143     LWIP_UNUSED_ARG(arg);
;;;1144     LWIP_UNUSED_ARG(pcb);
;;;1145     LWIP_UNUSED_ARG(port);
;;;1146   
;;;1147     /* is the dns message big enough ? */
;;;1148     if (p->tot_len < (SIZEOF_DNS_HDR + SIZEOF_DNS_QUERY)) {
00000a  8938              LDRH     r0,[r7,#8]
00000c  2810              CMP      r0,#0x10
00000e  d37d              BCC      |L15.268|
;;;1149       LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: pbuf too small\n"));
;;;1150       /* free pbuf and return */
;;;1151       goto memerr;
;;;1152     }
;;;1153   
;;;1154     /* copy dns payload inside static buffer for processing */
;;;1155     if (pbuf_copy_partial(p, &hdr, SIZEOF_DNS_HDR, 0) == SIZEOF_DNS_HDR) {
000010  2300              MOVS     r3,#0
000012  220c              MOVS     r2,#0xc
000014  a905              ADD      r1,sp,#0x14
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       pbuf_copy_partial
00001c  280c              CMP      r0,#0xc
00001e  d175              BNE      |L15.268|
;;;1156       /* Match the ID in the DNS header with the name table. */
;;;1157       txid = lwip_htons(hdr.id);
000020  f8bd0014          LDRH     r0,[sp,#0x14]
000024  f7fffffe          BL       lwip_htons
;;;1158       for (i = 0; i < DNS_TABLE_SIZE; i++) {
000028  2400              MOVS     r4,#0
;;;1159         const struct dns_table_entry *entry = &dns_table[i];
00002a  f8df815c          LDR      r8,|L15.392|
                  |L15.46|
00002e  eb041104          ADD      r1,r4,r4,LSL #4
000032  eb081501          ADD      r5,r8,r1,LSL #4
;;;1160         if ((entry->state == DNS_STATE_ASKING) &&
000036  7aa9              LDRB     r1,[r5,#0xa]
000038  2902              CMP      r1,#2
00003a  d168              BNE      |L15.270|
;;;1161             (entry->txid == txid)) {
00003c  8929              LDRH     r1,[r5,#8]
00003e  4281              CMP      r1,r0
000040  d165              BNE      |L15.270|
;;;1162   
;;;1163           /* We only care about the question(s) and the answers. The authrr
;;;1164              and the extrarr are simply discarded. */
;;;1165           nquestions = lwip_htons(hdr.numquestions);
000042  f8bd0018          LDRH     r0,[sp,#0x18]
000046  f7fffffe          BL       lwip_htons
00004a  4682              MOV      r10,r0
;;;1166           nanswers   = lwip_htons(hdr.numanswers);
00004c  f8bd001a          LDRH     r0,[sp,#0x1a]
000050  f7fffffe          BL       lwip_htons
000054  4606              MOV      r6,r0
;;;1167   
;;;1168           /* Check for correct response. */
;;;1169           if ((hdr.flags1 & DNS_FLAG1_RESPONSE) == 0) {
000056  f89d0016          LDRB     r0,[sp,#0x16]
00005a  0600              LSLS     r0,r0,#24
00005c  d556              BPL      |L15.268|
;;;1170             LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": not a response\n", entry->name));
;;;1171             goto memerr; /* ignore this packet */
;;;1172           }
;;;1173           if (nquestions != 1) {
00005e  f1ba0f01          CMP      r10,#1
000062  d153              BNE      |L15.268|
;;;1174             LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
;;;1175             goto memerr; /* ignore this packet */
;;;1176           }
;;;1177   
;;;1178   #if LWIP_DNS_SUPPORT_MDNS_QUERIES
;;;1179           if (!entry->is_mdns)
;;;1180   #endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
;;;1181           {
;;;1182             /* Check whether response comes from the same network address to which the
;;;1183                question was sent. (RFC 5452) */
;;;1184             if (!ip_addr_cmp(addr, &dns_servers[entry->server_idx])) {
000064  7ae9              LDRB     r1,[r5,#0xb]
000066  4a49              LDR      r2,|L15.396|
000068  f8d90000          LDR      r0,[r9,#0]
00006c  f8521021          LDR      r1,[r2,r1,LSL #2]
000070  4288              CMP      r0,r1
000072  d14b              BNE      |L15.268|
;;;1185               goto memerr; /* ignore this packet */
;;;1186             }
;;;1187           }
;;;1188   
;;;1189           /* Check if the name in the "question" part match with the name in the entry and
;;;1190              skip it if equal. */
;;;1191           res_idx = dns_compare_name(entry->name, p, SIZEOF_DNS_HDR);
000074  220c              MOVS     r2,#0xc
000076  4639              MOV      r1,r7
000078  f1050010          ADD      r0,r5,#0x10
00007c  f7fffffe          BL       dns_compare_name
000080  4605              MOV      r5,r0
;;;1192           if (res_idx == 0xFFFF) {
000082  f64f79ff          MOV      r9,#0xffff
000086  454d              CMP      r5,r9
000088  d07a              BEQ      |L15.384|
;;;1193             LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
;;;1194             goto memerr; /* ignore this packet */
;;;1195           }
;;;1196   
;;;1197           /* check if "question" part matches the request */
;;;1198           if (pbuf_copy_partial(p, &qry, SIZEOF_DNS_QUERY, res_idx) != SIZEOF_DNS_QUERY) {
00008a  462b              MOV      r3,r5
00008c  2204              MOVS     r2,#4
00008e  a901              ADD      r1,sp,#4
000090  4638              MOV      r0,r7
000092  f7fffffe          BL       pbuf_copy_partial
000096  2804              CMP      r0,#4
000098  d172              BNE      |L15.384|
;;;1199             goto memerr; /* ignore this packet */
;;;1200           }
;;;1201           if ((qry.cls != PP_HTONS(DNS_RRCLASS_IN)) ||
00009a  f8bd0006          LDRH     r0,[sp,#6]
00009e  f44f7a80          MOV      r10,#0x100
0000a2  4550              CMP      r0,r10
0000a4  d16c              BNE      |L15.384|
;;;1202             (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_AAAA))) ||
;;;1203             (!LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype) && (qry.type != PP_HTONS(DNS_RRTYPE_A)))) {
0000a6  f8bd0004          LDRH     r0,[sp,#4]
0000aa  4550              CMP      r0,r10
0000ac  d168              BNE      |L15.384|
;;;1204             LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": response not match to query\n", entry->name));
;;;1205             goto memerr; /* ignore this packet */
;;;1206           }
;;;1207           /* skip the rest of the "question" part */
;;;1208           res_idx += SIZEOF_DNS_QUERY;
0000ae  1d2d              ADDS     r5,r5,#4
0000b0  b2a9              UXTH     r1,r5
;;;1209   
;;;1210           /* Check for error. If so, call callback to inform. */
;;;1211           if (hdr.flags2 & DNS_FLAG2_ERR_MASK) {
0000b2  f89d0017          LDRB     r0,[sp,#0x17]
0000b6  0700              LSLS     r0,r0,#28
0000b8  d134              BNE      |L15.292|
0000ba  e02f              B        |L15.284|
                  |L15.188|
;;;1212             LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in flags\n", entry->name));
;;;1213           } else {
;;;1214             while ((nanswers > 0) && (res_idx < p->tot_len)) {
;;;1215               /* skip answer resource record's host name */
;;;1216               res_idx = dns_skip_name(p, res_idx);
0000bc  4638              MOV      r0,r7
0000be  f7fffffe          BL       dns_skip_name
0000c2  4605              MOV      r5,r0
;;;1217               if (res_idx == 0xFFFF) {
0000c4  454d              CMP      r5,r9
0000c6  d05b              BEQ      |L15.384|
;;;1218                 goto memerr; /* ignore this packet */
;;;1219               }
;;;1220   
;;;1221               /* Check for IP address type and Internet class. Others are discarded. */
;;;1222               if (pbuf_copy_partial(p, &ans, SIZEOF_DNS_ANSWER, res_idx) != SIZEOF_DNS_ANSWER) {
0000c8  462b              MOV      r3,r5
0000ca  220a              MOVS     r2,#0xa
0000cc  a902              ADD      r1,sp,#8
0000ce  4638              MOV      r0,r7
0000d0  f7fffffe          BL       pbuf_copy_partial
0000d4  280a              CMP      r0,#0xa
0000d6  d153              BNE      |L15.384|
;;;1223                 goto memerr; /* ignore this packet */
;;;1224               }
;;;1225               res_idx += SIZEOF_DNS_ANSWER;
0000d8  350a              ADDS     r5,r5,#0xa
0000da  b2ad              UXTH     r5,r5
;;;1226   
;;;1227               if (ans.cls == PP_HTONS(DNS_RRCLASS_IN)) {
0000dc  f8bd000a          LDRH     r0,[sp,#0xa]
0000e0  4550              CMP      r0,r10
0000e2  d108              BNE      |L15.246|
;;;1228   #if LWIP_IPV4
;;;1229                 if ((ans.type == PP_HTONS(DNS_RRTYPE_A)) && (ans.len == PP_HTONS(sizeof(ip4_addr_t)))) {
0000e4  f8bd0008          LDRH     r0,[sp,#8]
0000e8  4550              CMP      r0,r10
0000ea  d104              BNE      |L15.246|
0000ec  f8bd0010          LDRH     r0,[sp,#0x10]
0000f0  f5b06f80          CMP      r0,#0x400
0000f4  d026              BEQ      |L15.324|
                  |L15.246|
;;;1230   #if LWIP_IPV4 && LWIP_IPV6
;;;1231                   if (!LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype))
;;;1232   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1233                   {
;;;1234                     ip4_addr_t ip4addr;
;;;1235                     /* read the IP address after answer resource record's header */
;;;1236                     if (pbuf_copy_partial(p, &ip4addr, sizeof(ip4_addr_t), res_idx) != sizeof(ip4_addr_t)) {
;;;1237                       goto memerr; /* ignore this packet */
;;;1238                     }
;;;1239                     ip_addr_copy_from_ip4(dns_table[i].ipaddr, ip4addr);
;;;1240                     pbuf_free(p);
;;;1241                     /* handle correct response */
;;;1242                     dns_correct_response(i, lwip_ntohl(ans.ttl));
;;;1243                     return;
;;;1244                   }
;;;1245                 }
;;;1246   #endif /* LWIP_IPV4 */
;;;1247   #if LWIP_IPV6
;;;1248                 if ((ans.type == PP_HTONS(DNS_RRTYPE_AAAA)) && (ans.len == PP_HTONS(sizeof(ip6_addr_t)))) {
;;;1249   #if LWIP_IPV4 && LWIP_IPV6
;;;1250                   if (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype))
;;;1251   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1252                   {
;;;1253                     ip6_addr_t ip6addr;
;;;1254                     /* read the IP address after answer resource record's header */
;;;1255                     if (pbuf_copy_partial(p, &ip6addr, sizeof(ip6_addr_t), res_idx) != sizeof(ip6_addr_t)) {
;;;1256                       goto memerr; /* ignore this packet */
;;;1257                     }
;;;1258                     ip_addr_copy_from_ip6(dns_table[i].ipaddr, ip6addr);
;;;1259                     pbuf_free(p);
;;;1260                     /* handle correct response */
;;;1261                     dns_correct_response(i, lwip_ntohl(ans.ttl));
;;;1262                     return;
;;;1263                   }
;;;1264                 }
;;;1265   #endif /* LWIP_IPV6 */
;;;1266               }
;;;1267               /* skip this answer */
;;;1268               if ((int)(res_idx + lwip_htons(ans.len)) > 0xFFFF) {
0000f6  f8bd0010          LDRH     r0,[sp,#0x10]
0000fa  f7fffffe          BL       lwip_htons
0000fe  4428              ADD      r0,r0,r5
000100  f5b03f80          CMP      r0,#0x10000
000104  d23c              BCS      |L15.384|
;;;1269                 goto memerr; /* ignore this packet */
;;;1270               }
;;;1271               res_idx += lwip_htons(ans.len);
000106  f8bd0010          LDRH     r0,[sp,#0x10]
00010a  e001              B        |L15.272|
                  |L15.268|
00010c  e038              B        |L15.384|
                  |L15.270|
00010e  e032              B        |L15.374|
                  |L15.272|
000110  f7fffffe          BL       lwip_htons
000114  4428              ADD      r0,r0,r5
000116  b281              UXTH     r1,r0
;;;1272               --nanswers;
000118  1e76              SUBS     r6,r6,#1
00011a  b2b6              UXTH     r6,r6
                  |L15.284|
00011c  b116              CBZ      r6,|L15.292|
00011e  8938              LDRH     r0,[r7,#8]            ;1214
000120  4288              CMP      r0,r1                 ;1214
000122  d8cb              BHI      |L15.188|
                  |L15.292|
;;;1273             }
;;;1274   #if LWIP_IPV4 && LWIP_IPV6
;;;1275             if ((entry->reqaddrtype == LWIP_DNS_ADDRTYPE_IPV4_IPV6) ||
;;;1276                 (entry->reqaddrtype == LWIP_DNS_ADDRTYPE_IPV6_IPV4)) {
;;;1277               if (entry->reqaddrtype == LWIP_DNS_ADDRTYPE_IPV4_IPV6) {
;;;1278                 /* IPv4 failed, try IPv6 */
;;;1279                 dns_table[i].reqaddrtype = LWIP_DNS_ADDRTYPE_IPV6;
;;;1280               } else {
;;;1281                 /* IPv6 failed, try IPv4 */
;;;1282                 dns_table[i].reqaddrtype = LWIP_DNS_ADDRTYPE_IPV4;
;;;1283               }
;;;1284               pbuf_free(p);
;;;1285               dns_table[i].state = DNS_STATE_NEW;
;;;1286               dns_check_entry(i);
;;;1287               return;
;;;1288             }
;;;1289   #endif /* LWIP_IPV4 && LWIP_IPV6 */
;;;1290             LWIP_DEBUGF(DNS_DEBUG, ("dns_recv: \"%s\": error in response\n", entry->name));
;;;1291           }
;;;1292           /* call callback to indicate error, clean up memory and return */
;;;1293           pbuf_free(p);
000124  4638              MOV      r0,r7
000126  f7fffffe          BL       pbuf_free
;;;1294           dns_call_found(i, NULL);
00012a  2100              MOVS     r1,#0
00012c  4620              MOV      r0,r4
00012e  f7fffffe          BL       dns_call_found
;;;1295           dns_table[i].state = DNS_STATE_UNUSED;
000132  eb041104          ADD      r1,r4,r4,LSL #4
000136  eb081101          ADD      r1,r8,r1,LSL #4
00013a  2000              MOVS     r0,#0
00013c  7288              STRB     r0,[r1,#0xa]
                  |L15.318|
;;;1296           return;
;;;1297         }
;;;1298       }
;;;1299     }
;;;1300   
;;;1301   memerr:
;;;1302     /* deallocate memory and return */
;;;1303     pbuf_free(p);
;;;1304     return;
;;;1305   }
00013e  b008              ADD      sp,sp,#0x20
000140  e8bd87f0          POP      {r4-r10,pc}
                  |L15.324|
000144  462b              MOV      r3,r5                 ;1236
000146  2204              MOVS     r2,#4                 ;1236
000148  4669              MOV      r1,sp                 ;1236
00014a  4638              MOV      r0,r7                 ;1236
00014c  f7fffffe          BL       pbuf_copy_partial
000150  2804              CMP      r0,#4                 ;1236
000152  d115              BNE      |L15.384|
000154  eb041104          ADD      r1,r4,r4,LSL #4       ;1239
000158  eb081101          ADD      r1,r8,r1,LSL #4       ;1239
00015c  9800              LDR      r0,[sp,#0]            ;1239
00015e  6048              STR      r0,[r1,#4]            ;1239
000160  4638              MOV      r0,r7                 ;1240
000162  f7fffffe          BL       pbuf_free
000166  9803              LDR      r0,[sp,#0xc]          ;1242
000168  f7fffffe          BL       lwip_htonl
00016c  4601              MOV      r1,r0                 ;1242
00016e  4620              MOV      r0,r4                 ;1242
000170  f7fffffe          BL       dns_correct_response
000174  e7e3              B        |L15.318|
                  |L15.374|
000176  1c64              ADDS     r4,r4,#1              ;1158
000178  b2e4              UXTB     r4,r4                 ;1158
00017a  2c04              CMP      r4,#4                 ;1158
00017c  f4ffaf57          BCC      |L15.46|
                  |L15.384|
000180  4638              MOV      r0,r7                 ;1303
000182  f7fffffe          BL       pbuf_free
000186  e7da              B        |L15.318|
;;;1306   
                          ENDP

                  |L15.392|
                          DCD      ||.bss||+0x10
                  |L15.396|
                          DCD      ||.data||+0x4

                          AREA ||i.dns_send||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dns_send PROC
;;;734    static err_t
;;;735    dns_send(u8_t idx)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;736    {
000004  4604              MOV      r4,r0
;;;737      err_t err;
;;;738      struct dns_hdr hdr;
;;;739      struct dns_query qry;
;;;740      struct pbuf *p;
;;;741      u16_t query_idx, copy_len;
;;;742      const char *hostname, *hostname_part;
;;;743      u8_t n;
;;;744      u8_t pcb_idx;
;;;745      struct dns_table_entry* entry = &dns_table[idx];
000006  4945              LDR      r1,|L16.284|
000008  eb041004          ADD      r0,r4,r4,LSL #4
00000c  eb011600          ADD      r6,r1,r0,LSL #4
;;;746    
;;;747      LWIP_DEBUGF(DNS_DEBUG, ("dns_send: dns_servers[%"U16_F"] \"%s\": request\n",
;;;748                  (u16_t)(entry->server_idx), entry->name));
;;;749      LWIP_ASSERT("dns server out of array", entry->server_idx < DNS_MAX_SERVERS);
000010  7af0              LDRB     r0,[r6,#0xb]
000012  2802              CMP      r0,#2
000014  d306              BCC      |L16.36|
000016  a342              ADR      r3,|L16.288|
000018  f24022ed          MOV      r2,#0x2ed
00001c  a14c              ADR      r1,|L16.336|
00001e  a052              ADR      r0,|L16.360|
000020  f7fffffe          BL       __2printf
                  |L16.36|
;;;750      if (ip_addr_isany_val(dns_servers[entry->server_idx])
000024  7af2              LDRB     r2,[r6,#0xb]
000026  495a              LDR      r1,|L16.400|
000028  2500              MOVS     r5,#0
00002a  f8510022          LDR      r0,[r1,r2,LSL #2]
00002e  b340              CBZ      r0,|L16.130|
;;;751    #if LWIP_DNS_SUPPORT_MDNS_QUERIES
;;;752          && !entry->is_mdns
;;;753    #endif
;;;754        ) {
;;;755        /* DNS server not valid anymore, e.g. PPP netif has been shut down */
;;;756        /* call specified callback function if provided */
;;;757        dns_call_found(idx, NULL);
;;;758        /* flush this entry */
;;;759        entry->state = DNS_STATE_UNUSED;
;;;760        return ERR_OK;
;;;761      }
;;;762    
;;;763      /* if here, we have either a new query or a retry on a previous query to process */
;;;764      p = pbuf_alloc(PBUF_TRANSPORT, (u16_t)(SIZEOF_DNS_HDR + strlen(entry->name) + 2 +
000030  f1060010          ADD      r0,r6,#0x10
000034  4604              MOV      r4,r0
000036  f7fffffe          BL       strlen
00003a  3012              ADDS     r0,r0,#0x12
00003c  b281              UXTH     r1,r0
00003e  2200              MOVS     r2,#0
000040  4610              MOV      r0,r2
000042  f7fffffe          BL       pbuf_alloc
000046  4681              MOV      r9,r0
;;;765                     SIZEOF_DNS_QUERY), PBUF_RAM);
;;;766      if (p != NULL) {
000048  ea5f0009          MOVS     r0,r9
00004c  d062              BEQ      |L16.276|
;;;767        const ip_addr_t* dst;
;;;768        u16_t dst_port;
;;;769        /* fill dns header */
;;;770        memset(&hdr, 0, SIZEOF_DNS_HDR);
00004e  9501              STR      r5,[sp,#4]
000050  9502              STR      r5,[sp,#8]
000052  9503              STR      r5,[sp,#0xc]
;;;771        hdr.id = lwip_htons(entry->txid);
000054  8930              LDRH     r0,[r6,#8]
000056  f7fffffe          BL       lwip_htons
00005a  f8ad0004          STRH     r0,[sp,#4]
;;;772        hdr.flags1 = DNS_FLAG1_RD;
00005e  2001              MOVS     r0,#1
000060  f88d0006          STRB     r0,[sp,#6]
;;;773        hdr.numquestions = PP_HTONS(1);
000064  f44f7a80          MOV      r10,#0x100
000068  f8ada008          STRH     r10,[sp,#8]
;;;774        pbuf_take(p, &hdr, SIZEOF_DNS_HDR);
00006c  220c              MOVS     r2,#0xc
00006e  a901              ADD      r1,sp,#4
000070  4648              MOV      r0,r9
000072  f7fffffe          BL       pbuf_take
;;;775        hostname = entry->name;
;;;776        --hostname;
000076  1e64              SUBS     r4,r4,#1
;;;777    
;;;778        /* convert hostname into suitable query format. */
;;;779        query_idx = SIZEOF_DNS_HDR;
000078  270c              MOVS     r7,#0xc
                  |L16.122|
;;;780        do {
;;;781          ++hostname;
00007a  1c64              ADDS     r4,r4,#1
;;;782          hostname_part = hostname;
00007c  46a0              MOV      r8,r4
;;;783          for (n = 0; *hostname != '.' && *hostname != 0; ++hostname) {
00007e  2500              MOVS     r5,#0
000080  e00b              B        |L16.154|
                  |L16.130|
000082  2100              MOVS     r1,#0                 ;757
000084  4620              MOV      r0,r4                 ;757
000086  f7fffffe          BL       dns_call_found
00008a  72b5              STRB     r5,[r6,#0xa]          ;759
00008c  2000              MOVS     r0,#0                 ;760
                  |L16.142|
;;;784            ++n;
;;;785          }
;;;786          copy_len = (u16_t)(hostname - hostname_part);
;;;787          pbuf_put_at(p, query_idx, n);
;;;788          pbuf_take_at(p, hostname_part, copy_len, query_idx + 1);
;;;789          query_idx += n + 1;
;;;790        } while (*hostname != 0);
;;;791        pbuf_put_at(p, query_idx, 0);
;;;792        query_idx++;
;;;793    
;;;794        /* fill dns query */
;;;795        if (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype)) {
;;;796          qry.type = PP_HTONS(DNS_RRTYPE_AAAA);
;;;797        } else {
;;;798          qry.type = PP_HTONS(DNS_RRTYPE_A);
;;;799        }
;;;800        qry.cls = PP_HTONS(DNS_RRCLASS_IN);
;;;801        pbuf_take_at(p, &qry, SIZEOF_DNS_QUERY, query_idx);
;;;802    
;;;803    #if ((LWIP_DNS_SECURE & LWIP_DNS_SECURE_RAND_SRC_PORT) != 0)
;;;804        pcb_idx = entry->pcb_idx;
;;;805    #else
;;;806        pcb_idx = 0;
;;;807    #endif
;;;808        /* send dns packet */
;;;809        LWIP_DEBUGF(DNS_DEBUG, ("sending DNS request ID %d for name \"%s\" to server %d\r\n",
;;;810          entry->txid, entry->name, entry->server_idx));
;;;811    #if LWIP_DNS_SUPPORT_MDNS_QUERIES
;;;812        if (entry->is_mdns) {
;;;813          dst_port = DNS_MQUERY_PORT;
;;;814    #if LWIP_IPV6
;;;815          if (LWIP_DNS_ADDRTYPE_IS_IPV6(entry->reqaddrtype))
;;;816          {
;;;817            dst = &dns_mquery_v6group;
;;;818          }
;;;819    #endif
;;;820    #if LWIP_IPV4 && LWIP_IPV6
;;;821          else
;;;822    #endif
;;;823    #if LWIP_IPV4
;;;824          {
;;;825            dst = &dns_mquery_v4group;
;;;826          }
;;;827    #endif
;;;828        } else
;;;829    #endif /* LWIP_DNS_SUPPORT_MDNS_QUERIES */
;;;830        {
;;;831          dst_port = DNS_SERVER_PORT;
;;;832          dst = &dns_servers[entry->server_idx];
;;;833        }
;;;834        err = udp_sendto(dns_pcbs[pcb_idx], p, dst, dst_port);
;;;835    
;;;836        /* free pbuf */
;;;837        pbuf_free(p);
;;;838      } else {
;;;839        err = ERR_MEM;
;;;840      }
;;;841    
;;;842      return err;
;;;843    }
00008e  b004              ADD      sp,sp,#0x10
000090  e8bd9ff0          POP      {r4-r12,pc}
                  |L16.148|
000094  1c6d              ADDS     r5,r5,#1              ;784
000096  b2ed              UXTB     r5,r5                 ;784
000098  1c64              ADDS     r4,r4,#1              ;783
                  |L16.154|
00009a  7820              LDRB     r0,[r4,#0]            ;783
00009c  282e              CMP      r0,#0x2e              ;783
00009e  d001              BEQ      |L16.164|
0000a0  2800              CMP      r0,#0                 ;783
0000a2  d1f7              BNE      |L16.148|
                  |L16.164|
0000a4  eba40008          SUB      r0,r4,r8              ;786
0000a8  fa1ffb80          UXTH     r11,r0                ;786
0000ac  462a              MOV      r2,r5                 ;787
0000ae  4639              MOV      r1,r7                 ;787
0000b0  4648              MOV      r0,r9                 ;787
0000b2  f7fffffe          BL       pbuf_put_at
0000b6  1c78              ADDS     r0,r7,#1              ;788
0000b8  b283              UXTH     r3,r0                 ;788
0000ba  465a              MOV      r2,r11                ;788
0000bc  4641              MOV      r1,r8                 ;788
0000be  4648              MOV      r0,r9                 ;788
0000c0  f7fffffe          BL       pbuf_take_at
0000c4  1978              ADDS     r0,r7,r5              ;789
0000c6  1c40              ADDS     r0,r0,#1              ;789
0000c8  b287              UXTH     r7,r0                 ;789
0000ca  7820              LDRB     r0,[r4,#0]            ;790
0000cc  2800              CMP      r0,#0                 ;790
0000ce  d1d4              BNE      |L16.122|
0000d0  2200              MOVS     r2,#0                 ;791
0000d2  4639              MOV      r1,r7                 ;791
0000d4  4648              MOV      r0,r9                 ;791
0000d6  f7fffffe          BL       pbuf_put_at
0000da  1c7f              ADDS     r7,r7,#1              ;792
0000dc  b2bb              UXTH     r3,r7                 ;792
0000de  f8ada000          STRH     r10,[sp,#0]           ;798
0000e2  f8ada002          STRH     r10,[sp,#2]           ;800
0000e6  2204              MOVS     r2,#4                 ;801
0000e8  4669              MOV      r1,sp                 ;801
0000ea  4648              MOV      r0,r9                 ;801
0000ec  f7fffffe          BL       pbuf_take_at
0000f0  7bf0              LDRB     r0,[r6,#0xf]          ;804
0000f2  2335              MOVS     r3,#0x35              ;831
0000f4  7af2              LDRB     r2,[r6,#0xb]          ;832
0000f6  4926              LDR      r1,|L16.400|
0000f8  eb010282          ADD      r2,r1,r2,LSL #2       ;832
0000fc  4907              LDR      r1,|L16.284|
0000fe  3910              SUBS     r1,r1,#0x10           ;834
000100  f8510020          LDR      r0,[r1,r0,LSL #2]     ;834
000104  4649              MOV      r1,r9                 ;834
000106  f7fffffe          BL       udp_sendto
00010a  4604              MOV      r4,r0                 ;834
00010c  4648              MOV      r0,r9                 ;837
00010e  f7fffffe          BL       pbuf_free
000112  e001              B        |L16.280|
                  |L16.276|
000114  f04f34ff          MOV      r4,#0xffffffff        ;839
                  |L16.280|
000118  4620              MOV      r0,r4                 ;842
00011a  e7b8              B        |L16.142|
;;;844    
                          ENDP

                  |L16.284|
                          DCD      ||.bss||+0x10
                  |L16.288|
000120  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\dns.c",0
000124  6964646c
000128  65776172
00012c  65735c54
000130  68697264
000134  5f506172
000138  74795c4c
00013c  7749505c
000140  7372635c
000144  636f7265
000148  5c646e73
00014c  2e6300  
00014f  00                DCB      0
                  |L16.336|
000150  646e7320          DCB      "dns server out of array",0
000154  73657276
000158  6572206f
00015c  7574206f
000160  66206172
000164  72617900
                  |L16.360|
000168  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00016c  7274696f
000170  6e202225
000174  73222066
000178  61696c65
00017c  64206174
000180  206c696e
000184  65202564
000188  20696e20
00018c  25730a00
                  |L16.400|
                          DCD      ||.data||+0x4

                          AREA ||i.dns_setserver||, CODE, READONLY, ALIGN=2

                  dns_setserver PROC
;;;363    void
;;;364    dns_setserver(u8_t numdns, const ip_addr_t *dnsserver)
000000  2802              CMP      r0,#2
;;;365    {
000002  d205              BCS      |L17.16|
;;;366      if (numdns < DNS_MAX_SERVERS) {
;;;367        if (dnsserver != NULL) {
;;;368          dns_servers[numdns] = (*dnsserver);
000004  4a05              LDR      r2,|L17.28|
000006  eb020080          ADD      r0,r2,r0,LSL #2
00000a  b111              CBZ      r1,|L17.18|
00000c  6809              LDR      r1,[r1,#0]
00000e  6001              STR      r1,[r0,#0]
                  |L17.16|
;;;369        } else {
;;;370          dns_servers[numdns] = *IP_ADDR_ANY;
;;;371        }
;;;372      }
;;;373    }
000010  4770              BX       lr
                  |L17.18|
000012  4903              LDR      r1,|L17.32|
000014  6809              LDR      r1,[r1,#0]            ;370  ; ip_addr_any
000016  6001              STR      r1,[r0,#0]            ;370
000018  4770              BX       lr
;;;374    
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      ||.data||+0x4
                  |L17.32|
                          DCD      ip_addr_any

                          AREA ||i.dns_skip_name||, CODE, READONLY, ALIGN=1

                  dns_skip_name PROC
;;;697    static u16_t
;;;698    dns_skip_name(struct pbuf* p, u16_t query_idx)
000000  b570              PUSH     {r4-r6,lr}
;;;699    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;700      int n;
;;;701      u16_t offset = query_idx;
;;;702    
;;;703      do {
;;;704        n = pbuf_try_get_at(p, offset++);
;;;705        if (n < 0) {
;;;706          return 0xFFFF;
000006  f64f76ff          MOV      r6,#0xffff
                  |L18.10|
00000a  4621              MOV      r1,r4                 ;704
00000c  1c64              ADDS     r4,r4,#1              ;704
00000e  b2a4              UXTH     r4,r4                 ;704
000010  4628              MOV      r0,r5                 ;704
000012  f7fffffe          BL       pbuf_try_get_at
000016  2800              CMP      r0,#0                 ;705
000018  da01              BGE      |L18.30|
00001a  4630              MOV      r0,r6
;;;707        }
;;;708        /** @see RFC 1035 - 4.1.4. Message compression */
;;;709        if ((n & 0xc0) == 0xc0) {
;;;710          /* Compressed name: since we only want to skip it (not check it), stop here */
;;;711          break;
;;;712        } else {
;;;713          /* Not compressed name */
;;;714          if (offset + n >= p->tot_len) {
;;;715            return 0xFFFF;
;;;716          }
;;;717          offset = (u16_t)(offset + n);
;;;718        }
;;;719        n = pbuf_try_get_at(p, offset);
;;;720        if (n < 0) {
;;;721          return 0xFFFF;
;;;722        }
;;;723      } while (n != 0);
;;;724    
;;;725      return offset + 1;
;;;726    }
00001c  bd70              POP      {r4-r6,pc}
                  |L18.30|
00001e  f3c01181          UBFX     r1,r0,#6,#2           ;709
000022  2903              CMP      r1,#3                 ;709
000024  d00f              BEQ      |L18.70|
000026  8929              LDRH     r1,[r5,#8]            ;714
000028  4420              ADD      r0,r0,r4              ;714
00002a  4288              CMP      r0,r1                 ;714
00002c  db01              BLT      |L18.50|
00002e  4630              MOV      r0,r6                 ;715
000030  bd70              POP      {r4-r6,pc}
                  |L18.50|
000032  b284              UXTH     r4,r0                 ;717
000034  4621              MOV      r1,r4                 ;719
000036  4628              MOV      r0,r5                 ;719
000038  f7fffffe          BL       pbuf_try_get_at
00003c  2800              CMP      r0,#0                 ;720
00003e  da01              BGE      |L18.68|
000040  4630              MOV      r0,r6                 ;721
000042  bd70              POP      {r4-r6,pc}
                  |L18.68|
000044  d1e1              BNE      |L18.10|
                  |L18.70|
000046  f1040401          ADD      r4,r4,#1              ;725
00004a  b2a0              UXTH     r0,r4                 ;725
00004c  bd70              POP      {r4-r6,pc}
;;;727    
                          ENDP


                          AREA ||i.dns_tmr||, CODE, READONLY, ALIGN=1

                  dns_tmr PROC
;;;397    void
;;;398    dns_tmr(void)
000000  f7ffbffe          B.W      dns_check_entries
;;;399    {
;;;400      LWIP_DEBUGF(DNS_DEBUG, ("dns_tmr: dns_check_entries\n"));
;;;401      dns_check_entries();
;;;402    }
;;;403    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  dns_pcbs
                          %        16
                  dns_table
                          %        1088
                  dns_requests
                          %        48

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  dns_mquery_v4group
                          DCD      0xfb0000e0

                          AREA ||.data||, DATA, ALIGN=2

                  dns_last_pcb_idx
000000  00                DCB      0x00
                  dns_seqno
000001  000000            DCB      0x00,0x00,0x00
                  dns_servers
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\dns.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_dns_c_cd221b19____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_dns_c_cd221b19____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_dns_c_cd221b19____REVSH|
#line 478
|__asm___5_dns_c_cd221b19____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_dns_c_cd221b19____RRX|
#line 665
|__asm___5_dns_c_cd221b19____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
