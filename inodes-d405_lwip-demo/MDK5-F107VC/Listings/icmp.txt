; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\icmp.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\icmp.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\icmp.crf ..\Middlewares\Third_Party\LwIP\src\core\ipv4\icmp.c]
                          THUMB

                          AREA ||i.icmp_dest_unreach||, CODE, READONLY, ALIGN=1

                  icmp_dest_unreach PROC
;;;300    void
;;;301    icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
000000  460a              MOV      r2,r1
;;;302    {
;;;303      MIB2_STATS_INC(mib2.icmpoutdestunreachs);
;;;304      icmp_send_response(p, ICMP_DUR, t);
000002  2103              MOVS     r1,#3
000004  f7ffbffe          B.W      icmp_send_response
;;;305    }
;;;306    
                          ENDP


                          AREA ||i.icmp_input||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  icmp_input PROC
;;;79     void
;;;80     icmp_input(struct pbuf *p, struct netif *inp)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;81     {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;82       u8_t type;
;;;83     #ifdef LWIP_DEBUG
;;;84       u8_t code;
;;;85     #endif /* LWIP_DEBUG */
;;;86       struct icmp_echo_hdr *iecho;
;;;87       const struct ip_hdr *iphdr_in;
;;;88       u16_t hlen;
;;;89       const ip4_addr_t* src;
;;;90     
;;;91       ICMP_STATS_INC(icmp.recv);
;;;92       MIB2_STATS_INC(mib2.icmpinmsgs);
;;;93     
;;;94       iphdr_in = ip4_current_header();
000008  4f4d              LDR      r7,|L2.320|
00000a  f8d7a008          LDR      r10,[r7,#8]  ; ip_data
;;;95       hlen = IPH_HL(iphdr_in) * 4;
00000e  f89a0000          LDRB     r0,[r10,#0]
000012  0700              LSLS     r0,r0,#28
000014  0e85              LSRS     r5,r0,#26
;;;96       if (hlen < IP_HLEN) {
000016  2d14              CMP      r5,#0x14
                  |L2.24|
000018  d37e              BCC      |L2.280|
;;;97         LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short IP header (%"S16_F" bytes) received\n", hlen));
;;;98         goto lenerr;
;;;99       }
;;;100      if (p->len < sizeof(u16_t)*2) {
00001a  8960              LDRH     r0,[r4,#0xa]
00001c  2804              CMP      r0,#4
00001e  d3fb              BCC      |L2.24|
;;;101        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
;;;102        goto lenerr;
;;;103      }
;;;104    
;;;105      type = *((u8_t *)p->payload);
000020  6860              LDR      r0,[r4,#4]
000022  7803              LDRB     r3,[r0,#0]
;;;106    #ifdef LWIP_DEBUG
;;;107      code = *(((u8_t *)p->payload)+1);
;;;108    #endif /* LWIP_DEBUG */
;;;109      switch (type) {
000024  2b00              CMP      r3,#0
000026  d078              BEQ      |L2.282|
000028  2b08              CMP      r3,#8
00002a  d17f              BNE      |L2.300|
;;;110      case ICMP_ER:
;;;111        /* This is OK, echo reply might have been parsed by a raw PCB
;;;112           (as obviously, an echo request has been sent, too). */
;;;113        MIB2_STATS_INC(mib2.icmpinechoreps);
;;;114        break;
;;;115      case ICMP_ECHO:
;;;116        MIB2_STATS_INC(mib2.icmpinechos);
;;;117        src = ip4_current_dest_addr();
00002c  f1070914          ADD      r9,r7,#0x14
;;;118        /* multicast destination address? */
;;;119        if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
000030  6978              LDR      r0,[r7,#0x14]  ; ip_data
000032  f3c01103          UBFX     r1,r0,#4,#4
000036  290e              CMP      r1,#0xe
000038  d054              BEQ      |L2.228|
;;;120    #if LWIP_MULTICAST_PING
;;;121          /* For multicast, use address of receiving interface as source address */
;;;122          src = netif_ip4_addr(inp);
;;;123    #else /* LWIP_MULTICAST_PING */
;;;124          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast pings\n"));
;;;125          goto icmperr;
;;;126    #endif /* LWIP_MULTICAST_PING */
;;;127        }
;;;128        /* broadcast destination address? */
;;;129        if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
00003a  6839              LDR      r1,[r7,#0]  ; ip_data
00003c  f7fffffe          BL       ip4_addr_isbroadcast_u32
000040  2800              CMP      r0,#0
000042  d14f              BNE      |L2.228|
;;;130    #if LWIP_BROADCAST_PING
;;;131          /* For broadcast, use address of receiving interface as source address */
;;;132          src = netif_ip4_addr(inp);
;;;133    #else /* LWIP_BROADCAST_PING */
;;;134          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to broadcast pings\n"));
;;;135          goto icmperr;
;;;136    #endif /* LWIP_BROADCAST_PING */
;;;137        }
;;;138        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
;;;139        if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
000044  8920              LDRH     r0,[r4,#8]
000046  2808              CMP      r0,#8
000048  d375              BCC      |L2.310|
;;;140          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
;;;141          goto lenerr;
;;;142        }
;;;143    #if CHECKSUM_CHECK_ICMP
;;;144        IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_ICMP) {
;;;145          if (inet_chksum_pbuf(p) != 0) {
;;;146            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
;;;147            pbuf_free(p);
;;;148            ICMP_STATS_INC(icmp.chkerr);
;;;149            MIB2_STATS_INC(mib2.icmpinerrors);
;;;150            return;
;;;151          }
;;;152        }
;;;153    #endif
;;;154    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;155        if (pbuf_header(p, (s16_t)(hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
00004a  f105000e          ADD      r0,r5,#0xe
00004e  b201              SXTH     r1,r0
000050  460e              MOV      r6,r1
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       pbuf_header
000058  2800              CMP      r0,#0
00005a  d036              BEQ      |L2.202|
;;;156          /* p is not big enough to contain link headers
;;;157           * allocate a new one and copy p into it
;;;158           */
;;;159          struct pbuf *r;
;;;160          /* allocate new packet buffer with space for link headers */
;;;161          r = pbuf_alloc(PBUF_LINK, p->tot_len + hlen, PBUF_RAM);
00005c  8920              LDRH     r0,[r4,#8]
00005e  2200              MOVS     r2,#0
000060  4428              ADD      r0,r0,r5
000062  b281              UXTH     r1,r0
000064  2002              MOVS     r0,#2
000066  f7fffffe          BL       pbuf_alloc
00006a  4606              MOV      r6,r0
;;;162          if (r == NULL) {
00006c  2e00              CMP      r6,#0
00006e  d039              BEQ      |L2.228|
;;;163            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
;;;164            goto icmperr;
;;;165          }
;;;166          if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
000070  8971              LDRH     r1,[r6,#0xa]
000072  f1050008          ADD      r0,r5,#8
000076  4281              CMP      r1,r0
000078  d203              BCS      |L2.130|
;;;167            LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("first pbuf cannot hold the ICMP header"));
;;;168            pbuf_free(r);
00007a  4630              MOV      r0,r6
00007c  f7fffffe          BL       pbuf_free
;;;169            goto icmperr;
000080  e030              B        |L2.228|
                  |L2.130|
;;;170          }
;;;171          /* copy the ip header */
;;;172          MEMCPY(r->payload, iphdr_in, hlen);
000082  462a              MOV      r2,r5
000084  4651              MOV      r1,r10
000086  6870              LDR      r0,[r6,#4]
000088  f7fffffe          BL       __aeabi_memcpy
;;;173          /* switch r->payload back to icmp header (cannot fail) */
;;;174          if (pbuf_header(r, (s16_t)-hlen)) {
00008c  4268              RSBS     r0,r5,#0
00008e  b201              SXTH     r1,r0
000090  4630              MOV      r0,r6
000092  f7fffffe          BL       pbuf_header
000096  2800              CMP      r0,#0
000098  d009              BEQ      |L2.174|
;;;175            LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
00009a  a32a              ADR      r3,|L2.324|
00009c  22af              MOVS     r2,#0xaf
00009e  a137              ADR      r1,|L2.380|
0000a0  a044              ADR      r0,|L2.436|
0000a2  f7fffffe          BL       __2printf
;;;176            pbuf_free(r);
0000a6  4630              MOV      r0,r6
0000a8  f7fffffe          BL       pbuf_free
;;;177            goto icmperr;
0000ac  e01a              B        |L2.228|
                  |L2.174|
;;;178          }
;;;179          /* copy the rest of the packet without ip header */
;;;180          if (pbuf_copy(r, p) != ERR_OK) {
0000ae  4621              MOV      r1,r4
0000b0  4630              MOV      r0,r6
0000b2  f7fffffe          BL       pbuf_copy
0000b6  b118              CBZ      r0,|L2.192|
;;;181            LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("icmp_input: copying to new pbuf failed"));
;;;182            pbuf_free(r);
0000b8  4630              MOV      r0,r6
0000ba  f7fffffe          BL       pbuf_free
;;;183            goto icmperr;
0000be  e011              B        |L2.228|
                  |L2.192|
;;;184          }
;;;185          /* free the original p */
;;;186          pbuf_free(p);
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       pbuf_free
;;;187          /* we now have an identical copy of p that has room for link headers */
;;;188          p = r;
0000c6  4634              MOV      r4,r6
;;;189        } else {
0000c8  e011              B        |L2.238|
                  |L2.202|
;;;190          /* restore p->payload to point to icmp header (cannot fail) */
;;;191          if (pbuf_header(p, -(s16_t)(hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN))) {
0000ca  4270              RSBS     r0,r6,#0
0000cc  b201              SXTH     r1,r0
0000ce  4620              MOV      r0,r4
0000d0  f7fffffe          BL       pbuf_header
0000d4  2800              CMP      r0,#0
0000d6  d00a              BEQ      |L2.238|
;;;192            LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
0000d8  a31a              ADR      r3,|L2.324|
0000da  22c0              MOVS     r2,#0xc0
0000dc  a13f              ADR      r1,|L2.476|
0000de  a035              ADR      r0,|L2.436|
0000e0  f7fffffe          BL       __2printf
                  |L2.228|
;;;193            goto icmperr;
;;;194          }
;;;195        }
;;;196    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;197        /* At this point, all checks are OK. */
;;;198        /* We generate an answer by switching the dest and src ip addresses,
;;;199         * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
;;;200        iecho = (struct icmp_echo_hdr *)p->payload;
;;;201        if (pbuf_header(p, (s16_t)hlen)) {
;;;202          LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Can't move over header in packet"));
;;;203        } else {
;;;204          err_t ret;
;;;205          struct ip_hdr *iphdr = (struct ip_hdr*)p->payload;
;;;206          ip4_addr_copy(iphdr->src, *src);
;;;207          ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
;;;208          ICMPH_TYPE_SET(iecho, ICMP_ER);
;;;209    #if CHECKSUM_GEN_ICMP
;;;210          IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_ICMP) {
;;;211            /* adjust the checksum */
;;;212            if (iecho->chksum > PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
;;;213              iecho->chksum += PP_HTONS(ICMP_ECHO << 8) + 1;
;;;214            } else {
;;;215              iecho->chksum += PP_HTONS(ICMP_ECHO << 8);
;;;216            }
;;;217          }
;;;218    #if LWIP_CHECKSUM_CTRL_PER_NETIF
;;;219          else {
;;;220            iecho->chksum = 0;
;;;221          }
;;;222    #endif /* LWIP_CHECKSUM_CTRL_PER_NETIF */
;;;223    #else /* CHECKSUM_GEN_ICMP */
;;;224          iecho->chksum = 0;
;;;225    #endif /* CHECKSUM_GEN_ICMP */
;;;226    
;;;227          /* Set the correct TTL and recalculate the header checksum. */
;;;228          IPH_TTL_SET(iphdr, ICMP_TTL);
;;;229          IPH_CHKSUM_SET(iphdr, 0);
;;;230    #if CHECKSUM_GEN_IP
;;;231          IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_IP) {
;;;232            IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, hlen));
;;;233          }
;;;234    #endif /* CHECKSUM_GEN_IP */
;;;235    
;;;236          ICMP_STATS_INC(icmp.xmit);
;;;237          /* increase number of messages attempted to send */
;;;238          MIB2_STATS_INC(mib2.icmpoutmsgs);
;;;239          /* increase number of echo replies attempted to send */
;;;240          MIB2_STATS_INC(mib2.icmpoutechoreps);
;;;241    
;;;242          /* send an ICMP packet */
;;;243          ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
;;;244                       ICMP_TTL, 0, IP_PROTO_ICMP, inp);
;;;245          if (ret != ERR_OK) {
;;;246            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %s\n", lwip_strerr(ret)));
;;;247          }
;;;248        }
;;;249        break;
;;;250      default:
;;;251        if (type == ICMP_DUR) {
;;;252          MIB2_STATS_INC(mib2.icmpindestunreachs);
;;;253        } else if (type == ICMP_TE) {
;;;254          MIB2_STATS_INC(mib2.icmpintimeexcds);
;;;255        } else if (type == ICMP_PP) {
;;;256          MIB2_STATS_INC(mib2.icmpinparmprobs);
;;;257        } else if (type == ICMP_SQ) {
;;;258          MIB2_STATS_INC(mib2.icmpinsrcquenchs);
;;;259        } else if (type == ICMP_RD) {
;;;260          MIB2_STATS_INC(mib2.icmpinredirects);
;;;261        } else if (type == ICMP_TS) {
;;;262          MIB2_STATS_INC(mib2.icmpintimestamps);
;;;263        } else if (type == ICMP_TSR) {
;;;264          MIB2_STATS_INC(mib2.icmpintimestampreps);
;;;265        } else if (type == ICMP_AM) {
;;;266          MIB2_STATS_INC(mib2.icmpinaddrmasks);
;;;267        } else if (type == ICMP_AMR) {
;;;268          MIB2_STATS_INC(mib2.icmpinaddrmaskreps);
;;;269        }
;;;270        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n",
;;;271                    (s16_t)type, (s16_t)code));
;;;272        ICMP_STATS_INC(icmp.proterr);
;;;273        ICMP_STATS_INC(icmp.drop);
;;;274      }
;;;275      pbuf_free(p);
;;;276      return;
;;;277    lenerr:
;;;278      pbuf_free(p);
;;;279      ICMP_STATS_INC(icmp.lenerr);
;;;280      MIB2_STATS_INC(mib2.icmpinerrors);
;;;281      return;
;;;282    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
;;;283    icmperr:
;;;284      pbuf_free(p);
0000e4  4620              MOV      r0,r4
0000e6  e8bd4ffe          POP      {r1-r11,lr}
0000ea  f7ffbffe          B.W      pbuf_free
                  |L2.238|
0000ee  6866              LDR      r6,[r4,#4]            ;200
0000f0  b229              SXTH     r1,r5                 ;201
0000f2  4620              MOV      r0,r4                 ;201
0000f4  f7fffffe          BL       pbuf_header
0000f8  b978              CBNZ     r0,|L2.282|
0000fa  6860              LDR      r0,[r4,#4]            ;205
0000fc  f8d91000          LDR      r1,[r9,#0]            ;206
000100  60c1              STR      r1,[r0,#0xc]          ;206
000102  6939              LDR      r1,[r7,#0x10]         ;207  ; ip_data
000104  6101              STR      r1,[r0,#0x10]         ;207
000106  2100              MOVS     r1,#0                 ;208
000108  7031              STRB     r1,[r6,#0]            ;208
00010a  8071              STRH     r1,[r6,#2]            ;224
00010c  22ff              MOVS     r2,#0xff              ;228
00010e  7202              STRB     r2,[r0,#8]            ;228
000110  8141              STRH     r1,[r0,#0xa]          ;229
000112  2001              MOVS     r0,#1                 ;243
000114  23ff              MOVS     r3,#0xff              ;243
000116  e001              B        |L2.284|
                  |L2.280|
000118  e00d              B        |L2.310|
                  |L2.282|
00011a  e007              B        |L2.300|
                  |L2.284|
00011c  e9cd0801          STRD     r0,r8,[sp,#4]         ;243
000120  9100              STR      r1,[sp,#0]            ;243
000122  2200              MOVS     r2,#0                 ;243
000124  4649              MOV      r1,r9                 ;243
000126  4620              MOV      r0,r4                 ;243
000128  f7fffffe          BL       ip4_output_if
                  |L2.300|
00012c  4620              MOV      r0,r4                 ;275
00012e  e8bd4ffe          POP      {r1-r11,lr}           ;275
000132  f7ffbffe          B.W      pbuf_free
                  |L2.310|
000136  4620              MOV      r0,r4                 ;278
000138  e8bd4ffe          POP      {r1-r11,lr}           ;278
00013c  f7ffbffe          B.W      pbuf_free
;;;285      ICMP_STATS_INC(icmp.err);
;;;286      MIB2_STATS_INC(mib2.icmpinerrors);
;;;287      return;
;;;288    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
;;;289    }
;;;290    
                          ENDP

                  |L2.320|
                          DCD      ip_data
                  |L2.324|
000144  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ic"
000148  6964646c
00014c  65776172
000150  65735c54
000154  68697264
000158  5f506172
00015c  74795c4c
000160  7749505c
000164  7372635c
000168  636f7265
00016c  5c697076
000170  345c6963
000174  6d702e63          DCB      "mp.c",0
000178  00      
000179  00                DCB      0
00017a  00                DCB      0
00017b  00                DCB      0
                  |L2.380|
00017c  69636d70          DCB      "icmp_input: moving r->payload to icmp header failed\n",0
000180  5f696e70
000184  75743a20
000188  6d6f7669
00018c  6e672072
000190  2d3e7061
000194  796c6f61
000198  6420746f
00019c  2069636d
0001a0  70206865
0001a4  61646572
0001a8  20666169
0001ac  6c65640a
0001b0  00      
0001b1  00                DCB      0
0001b2  00                DCB      0
0001b3  00                DCB      0
                  |L2.436|
0001b4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001b8  7274696f
0001bc  6e202225
0001c0  73222066
0001c4  61696c65
0001c8  64206174
0001cc  206c696e
0001d0  65202564
0001d4  20696e20
0001d8  25730a00
                  |L2.476|
0001dc  69636d70          DCB      "icmp_input: restoring original p->payload failed\n",0
0001e0  5f696e70
0001e4  75743a20
0001e8  72657374
0001ec  6f72696e
0001f0  67206f72
0001f4  6967696e
0001f8  616c2070
0001fc  2d3e7061
000200  796c6f61
000204  64206661
000208  696c6564
00020c  0a00    
00020e  00                DCB      0
00020f  00                DCB      0

                          AREA ||i.icmp_send_response||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  icmp_send_response PROC
;;;332    static void
;;;333    icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;334    {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
;;;335      struct pbuf *q;
;;;336      struct ip_hdr *iphdr;
;;;337      /* we can use the echo header here */
;;;338      struct icmp_echo_hdr *icmphdr;
;;;339      ip4_addr_t iphdr_src;
;;;340      struct netif *netif;
;;;341    
;;;342      /* increase number of messages attempted to send */
;;;343      MIB2_STATS_INC(mib2.icmpoutmsgs);
;;;344    
;;;345      /* ICMP header + IP header + 8 bytes of data */
;;;346      q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
00000a  2200              MOVS     r2,#0
00000c  2124              MOVS     r1,#0x24
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       pbuf_alloc
000014  4605              MOV      r5,r0
;;;347                     PBUF_RAM);
;;;348      if (q == NULL) {
000016  0028              MOVS     r0,r5
000018  d030              BEQ      |L3.124|
;;;349        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
;;;350        MIB2_STATS_INC(mib2.icmpouterrors);
;;;351        return;
;;;352      }
;;;353      LWIP_ASSERT("check that first pbuf can hold icmp message",
00001a  8968              LDRH     r0,[r5,#0xa]
00001c  2824              CMP      r0,#0x24
00001e  d206              BCS      |L3.46|
000020  a317              ADR      r3,|L3.128|
000022  f2401261          MOV      r2,#0x161
000026  a124              ADR      r1,|L3.184|
000028  a02e              ADR      r0,|L3.228|
00002a  f7fffffe          BL       __2printf
                  |L3.46|
;;;354                 (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));
;;;355    
;;;356      iphdr = (struct ip_hdr *)p->payload;
00002e  6877              LDR      r7,[r6,#4]
;;;357      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
;;;358      ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
;;;359      LWIP_DEBUGF(ICMP_DEBUG, (" to "));
;;;360      ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
;;;361      LWIP_DEBUGF(ICMP_DEBUG, ("\n"));
;;;362    
;;;363      icmphdr = (struct icmp_echo_hdr *)q->payload;
000030  686c              LDR      r4,[r5,#4]
;;;364      icmphdr->type = type;
000032  f8848000          STRB     r8,[r4,#0]
;;;365      icmphdr->code = code;
000036  f8849001          STRB     r9,[r4,#1]
;;;366      icmphdr->id = 0;
00003a  f04f0800          MOV      r8,#0
00003e  f8a48004          STRH     r8,[r4,#4]
;;;367      icmphdr->seqno = 0;
000042  f8a48006          STRH     r8,[r4,#6]
;;;368    
;;;369      /* copy fields from original packet */
;;;370      SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
000046  6868              LDR      r0,[r5,#4]
000048  6871              LDR      r1,[r6,#4]
00004a  3008              ADDS     r0,r0,#8
00004c  221c              MOVS     r2,#0x1c
00004e  f7fffffe          BL       __aeabi_memcpy
;;;371              IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
;;;372    
;;;373      ip4_addr_copy(iphdr_src, iphdr->src);
000052  68f8              LDR      r0,[r7,#0xc]
000054  9003              STR      r0,[sp,#0xc]
;;;374    #ifdef LWIP_HOOK_IP4_ROUTE_SRC
;;;375      {
;;;376        ip4_addr_t iphdr_dst;
;;;377        ip4_addr_copy(iphdr_dst, iphdr->dest);
;;;378        netif = ip4_route_src(&iphdr_src, &iphdr_dst);
;;;379      }
;;;380    #else
;;;381      netif = ip4_route(&iphdr_src);
000056  a803              ADD      r0,sp,#0xc
000058  f7fffffe          BL       ip4_route
;;;382    #endif
;;;383      if (netif != NULL) {
00005c  b158              CBZ      r0,|L3.118|
;;;384        /* calculate checksum */
;;;385        icmphdr->chksum = 0;
00005e  f8a48002          STRH     r8,[r4,#2]
;;;386    #if CHECKSUM_GEN_ICMP
;;;387        IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
;;;388          icmphdr->chksum = inet_chksum(icmphdr, q->len);
;;;389        }
;;;390    #endif
;;;391        ICMP_STATS_INC(icmp.xmit);
;;;392        ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
000062  2101              MOVS     r1,#1
000064  e9cd8100          STRD     r8,r1,[sp,#0]
000068  9002              STR      r0,[sp,#8]
00006a  23ff              MOVS     r3,#0xff
00006c  aa03              ADD      r2,sp,#0xc
00006e  2100              MOVS     r1,#0
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       ip4_output_if
                  |L3.118|
;;;393      }
;;;394      pbuf_free(q);
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       pbuf_free
                  |L3.124|
;;;395    }
00007c  e8bd87ff          POP      {r0-r10,pc}
;;;396    
                          ENDP

                  |L3.128|
000080  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ic"
000084  6964646c
000088  65776172
00008c  65735c54
000090  68697264
000094  5f506172
000098  74795c4c
00009c  7749505c
0000a0  7372635c
0000a4  636f7265
0000a8  5c697076
0000ac  345c6963
0000b0  6d702e63          DCB      "mp.c",0
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L3.184|
0000b8  63686563          DCB      "check that first pbuf can hold icmp message",0
0000bc  6b207468
0000c0  61742066
0000c4  69727374
0000c8  20706275
0000cc  66206361
0000d0  6e20686f
0000d4  6c642069
0000d8  636d7020
0000dc  6d657373
0000e0  61676500
                  |L3.228|
0000e4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000e8  7274696f
0000ec  6e202225
0000f0  73222066
0000f4  61696c65
0000f8  64206174
0000fc  206c696e
000100  65202564
000104  20696e20
000108  25730a00

                          AREA ||i.icmp_time_exceeded||, CODE, READONLY, ALIGN=1

                  icmp_time_exceeded PROC
;;;315    void
;;;316    icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
000000  460a              MOV      r2,r1
;;;317    {
;;;318      MIB2_STATS_INC(mib2.icmpouttimeexcds);
;;;319      icmp_send_response(p, ICMP_TE, t);
000002  210b              MOVS     r1,#0xb
000004  f7ffbffe          B.W      icmp_send_response
;;;320    }
;;;321    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\icmp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_icmp_c_efc2e004____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_icmp_c_efc2e004____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_icmp_c_efc2e004____REVSH|
#line 478
|__asm___6_icmp_c_efc2e004____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_icmp_c_efc2e004____RRX|
#line 665
|__asm___6_icmp_c_efc2e004____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
