; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\icmp.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\icmp.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\icmp.crf ..\Middlewares\Third_Party\LwIP\src\core\ipv4\icmp.c]
                          THUMB

                          AREA ||i.icmp_dest_unreach||, CODE, READONLY, ALIGN=1

                  icmp_dest_unreach PROC
;;;307    void
;;;308    icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
000000  460a              MOV      r2,r1
;;;309    {
;;;310      MIB2_STATS_INC(mib2.icmpoutdestunreachs);
;;;311      icmp_send_response(p, ICMP_DUR, t);
000002  2103              MOVS     r1,#3
000004  f7ffbffe          B.W      icmp_send_response
;;;312    }
;;;313    
                          ENDP


                          AREA ||i.icmp_input||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  icmp_input PROC
;;;79     void
;;;80     icmp_input(struct pbuf *p, struct netif *inp)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;81     {
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;82       u8_t type;
;;;83     #ifdef LWIP_DEBUG
;;;84       u8_t code;
;;;85     #endif /* LWIP_DEBUG */
;;;86       struct icmp_echo_hdr *iecho;
;;;87       const struct ip_hdr *iphdr_in;
;;;88       u16_t hlen;
;;;89       const ip4_addr_t *src;
;;;90     
;;;91       ICMP_STATS_INC(icmp.recv);
;;;92       MIB2_STATS_INC(mib2.icmpinmsgs);
;;;93     
;;;94       iphdr_in = ip4_current_header();
000008  4f4d              LDR      r7,|L2.320|
00000a  f8d7a008          LDR      r10,[r7,#8]  ; ip_data
;;;95       hlen = IPH_HL_BYTES(iphdr_in);
00000e  f89a0000          LDRB     r0,[r10,#0]
000012  0700              LSLS     r0,r0,#28
000014  0e86              LSRS     r6,r0,#26
;;;96       if (hlen < IP_HLEN) {
000016  2e14              CMP      r6,#0x14
                  |L2.24|
000018  d37e              BCC      |L2.280|
;;;97         LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short IP header (%"S16_F" bytes) received\n", hlen));
;;;98         goto lenerr;
;;;99       }
;;;100      if (p->len < sizeof(u16_t) * 2) {
00001a  8960              LDRH     r0,[r4,#0xa]
00001c  2804              CMP      r0,#4
00001e  d3fb              BCC      |L2.24|
;;;101        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
;;;102        goto lenerr;
;;;103      }
;;;104    
;;;105      type = *((u8_t *)p->payload);
000020  6860              LDR      r0,[r4,#4]
000022  7801              LDRB     r1,[r0,#0]
;;;106    #ifdef LWIP_DEBUG
;;;107      code = *(((u8_t *)p->payload) + 1);
;;;108      /* if debug is enabled but debug statement below is somehow disabled: */
;;;109      LWIP_UNUSED_ARG(code);
;;;110    #endif /* LWIP_DEBUG */
;;;111      switch (type) {
000024  2900              CMP      r1,#0
000026  d078              BEQ      |L2.282|
000028  2908              CMP      r1,#8
00002a  d17f              BNE      |L2.300|
;;;112        case ICMP_ER:
;;;113          /* This is OK, echo reply might have been parsed by a raw PCB
;;;114             (as obviously, an echo request has been sent, too). */
;;;115          MIB2_STATS_INC(mib2.icmpinechoreps);
;;;116          break;
;;;117        case ICMP_ECHO:
;;;118          MIB2_STATS_INC(mib2.icmpinechos);
;;;119          src = ip4_current_dest_addr();
00002c  f1070914          ADD      r9,r7,#0x14
;;;120          /* multicast destination address? */
;;;121          if (ip4_addr_ismulticast(ip4_current_dest_addr())) {
000030  6978              LDR      r0,[r7,#0x14]  ; ip_data
000032  f3c01103          UBFX     r1,r0,#4,#4
000036  290e              CMP      r1,#0xe
000038  d054              BEQ      |L2.228|
;;;122    #if LWIP_MULTICAST_PING
;;;123            /* For multicast, use address of receiving interface as source address */
;;;124            src = netif_ip4_addr(inp);
;;;125    #else /* LWIP_MULTICAST_PING */
;;;126            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast pings\n"));
;;;127            goto icmperr;
;;;128    #endif /* LWIP_MULTICAST_PING */
;;;129          }
;;;130          /* broadcast destination address? */
;;;131          if (ip4_addr_isbroadcast(ip4_current_dest_addr(), ip_current_netif())) {
00003a  6839              LDR      r1,[r7,#0]  ; ip_data
00003c  f7fffffe          BL       ip4_addr_isbroadcast_u32
000040  2800              CMP      r0,#0
000042  d14f              BNE      |L2.228|
;;;132    #if LWIP_BROADCAST_PING
;;;133            /* For broadcast, use address of receiving interface as source address */
;;;134            src = netif_ip4_addr(inp);
;;;135    #else /* LWIP_BROADCAST_PING */
;;;136            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to broadcast pings\n"));
;;;137            goto icmperr;
;;;138    #endif /* LWIP_BROADCAST_PING */
;;;139          }
;;;140          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
;;;141          if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
000044  8920              LDRH     r0,[r4,#8]
000046  2808              CMP      r0,#8
000048  d375              BCC      |L2.310|
;;;142            LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
;;;143            goto lenerr;
;;;144          }
;;;145    #if CHECKSUM_CHECK_ICMP
;;;146          IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_CHECK_ICMP) {
;;;147            if (inet_chksum_pbuf(p) != 0) {
;;;148              LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
;;;149              pbuf_free(p);
;;;150              ICMP_STATS_INC(icmp.chkerr);
;;;151              MIB2_STATS_INC(mib2.icmpinerrors);
;;;152              return;
;;;153            }
;;;154          }
;;;155    #endif
;;;156    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN
;;;157          if (pbuf_add_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
00004a  f106010e          ADD      r1,r6,#0xe
00004e  460d              MOV      r5,r1
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       pbuf_add_header
000056  2800              CMP      r0,#0
000058  d038              BEQ      |L2.204|
;;;158            /* p is not big enough to contain link headers
;;;159             * allocate a new one and copy p into it
;;;160             */
;;;161            struct pbuf *r;
;;;162            u16_t alloc_len = (u16_t)(p->tot_len + hlen);
00005a  8920              LDRH     r0,[r4,#8]
00005c  1981              ADDS     r1,r0,r6
00005e  b289              UXTH     r1,r1
;;;163            if (alloc_len < p->tot_len) {
000060  4288              CMP      r0,r1
000062  d83f              BHI      |L2.228|
;;;164              LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed (tot_len overflow)\n"));
;;;165              goto icmperr;
;;;166            }
;;;167            /* allocate new packet buffer with space for link headers */
;;;168            r = pbuf_alloc(PBUF_LINK, alloc_len, PBUF_RAM);
000064  f44f7220          MOV      r2,#0x280
000068  200e              MOVS     r0,#0xe
00006a  f7fffffe          BL       pbuf_alloc
00006e  4605              MOV      r5,r0
;;;169            if (r == NULL) {
000070  2d00              CMP      r5,#0
000072  d037              BEQ      |L2.228|
;;;170              LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
;;;171              goto icmperr;
;;;172            }
;;;173            if (r->len < hlen + sizeof(struct icmp_echo_hdr)) {
000074  8969              LDRH     r1,[r5,#0xa]
000076  f1060008          ADD      r0,r6,#8
00007a  4281              CMP      r1,r0
00007c  d203              BCS      |L2.134|
;;;174              LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("first pbuf cannot hold the ICMP header"));
;;;175              pbuf_free(r);
00007e  4628              MOV      r0,r5
000080  f7fffffe          BL       pbuf_free
;;;176              goto icmperr;
000084  e02e              B        |L2.228|
                  |L2.134|
;;;177            }
;;;178            /* copy the ip header */
;;;179            MEMCPY(r->payload, iphdr_in, hlen);
000086  4632              MOV      r2,r6
000088  4651              MOV      r1,r10
00008a  6868              LDR      r0,[r5,#4]
00008c  f7fffffe          BL       __aeabi_memcpy
;;;180            /* switch r->payload back to icmp header (cannot fail) */
;;;181            if (pbuf_remove_header(r, hlen)) {
000090  4631              MOV      r1,r6
000092  4628              MOV      r0,r5
000094  f7fffffe          BL       pbuf_remove_header
000098  2800              CMP      r0,#0
00009a  d009              BEQ      |L2.176|
;;;182              LWIP_ASSERT("icmp_input: moving r->payload to icmp header failed\n", 0);
00009c  a329              ADR      r3,|L2.324|
00009e  22b6              MOVS     r2,#0xb6
0000a0  a136              ADR      r1,|L2.380|
0000a2  a044              ADR      r0,|L2.436|
0000a4  f7fffffe          BL       __2printf
;;;183              pbuf_free(r);
0000a8  4628              MOV      r0,r5
0000aa  f7fffffe          BL       pbuf_free
;;;184              goto icmperr;
0000ae  e019              B        |L2.228|
                  |L2.176|
;;;185            }
;;;186            /* copy the rest of the packet without ip header */
;;;187            if (pbuf_copy(r, p) != ERR_OK) {
0000b0  4621              MOV      r1,r4
0000b2  4628              MOV      r0,r5
0000b4  f7fffffe          BL       pbuf_copy
0000b8  b118              CBZ      r0,|L2.194|
;;;188              LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("icmp_input: copying to new pbuf failed"));
;;;189              pbuf_free(r);
0000ba  4628              MOV      r0,r5
0000bc  f7fffffe          BL       pbuf_free
;;;190              goto icmperr;
0000c0  e010              B        |L2.228|
                  |L2.194|
;;;191            }
;;;192            /* free the original p */
;;;193            pbuf_free(p);
0000c2  4620              MOV      r0,r4
0000c4  f7fffffe          BL       pbuf_free
;;;194            /* we now have an identical copy of p that has room for link headers */
;;;195            p = r;
0000c8  462c              MOV      r4,r5
;;;196          } else {
0000ca  e010              B        |L2.238|
                  |L2.204|
;;;197            /* restore p->payload to point to icmp header (cannot fail) */
;;;198            if (pbuf_remove_header(p, hlen + PBUF_LINK_HLEN + PBUF_LINK_ENCAPSULATION_HLEN)) {
0000cc  4629              MOV      r1,r5
0000ce  4620              MOV      r0,r4
0000d0  f7fffffe          BL       pbuf_remove_header
0000d4  2800              CMP      r0,#0
0000d6  d00a              BEQ      |L2.238|
;;;199              LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
0000d8  a31a              ADR      r3,|L2.324|
0000da  22c7              MOVS     r2,#0xc7
0000dc  a13f              ADR      r1,|L2.476|
0000de  a035              ADR      r0,|L2.436|
0000e0  f7fffffe          BL       __2printf
                  |L2.228|
;;;200              goto icmperr;
;;;201            }
;;;202          }
;;;203    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN */
;;;204          /* At this point, all checks are OK. */
;;;205          /* We generate an answer by switching the dest and src ip addresses,
;;;206           * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
;;;207          iecho = (struct icmp_echo_hdr *)p->payload;
;;;208          if (pbuf_add_header(p, hlen)) {
;;;209            LWIP_DEBUGF(ICMP_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("Can't move over header in packet"));
;;;210          } else {
;;;211            err_t ret;
;;;212            struct ip_hdr *iphdr = (struct ip_hdr *)p->payload;
;;;213            ip4_addr_copy(iphdr->src, *src);
;;;214            ip4_addr_copy(iphdr->dest, *ip4_current_src_addr());
;;;215            ICMPH_TYPE_SET(iecho, ICMP_ER);
;;;216    #if CHECKSUM_GEN_ICMP
;;;217            IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_ICMP) {
;;;218              /* adjust the checksum */
;;;219              if (iecho->chksum > PP_HTONS(0xffffU - (ICMP_ECHO << 8))) {
;;;220                iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS((u16_t)(ICMP_ECHO << 8)) + 1);
;;;221              } else {
;;;222                iecho->chksum = (u16_t)(iecho->chksum + PP_HTONS(ICMP_ECHO << 8));
;;;223              }
;;;224            }
;;;225    #if LWIP_CHECKSUM_CTRL_PER_NETIF
;;;226            else {
;;;227              iecho->chksum = 0;
;;;228            }
;;;229    #endif /* LWIP_CHECKSUM_CTRL_PER_NETIF */
;;;230    #else /* CHECKSUM_GEN_ICMP */
;;;231            iecho->chksum = 0;
;;;232    #endif /* CHECKSUM_GEN_ICMP */
;;;233    
;;;234            /* Set the correct TTL and recalculate the header checksum. */
;;;235            IPH_TTL_SET(iphdr, ICMP_TTL);
;;;236            IPH_CHKSUM_SET(iphdr, 0);
;;;237    #if CHECKSUM_GEN_IP
;;;238            IF__NETIF_CHECKSUM_ENABLED(inp, NETIF_CHECKSUM_GEN_IP) {
;;;239              IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, hlen));
;;;240            }
;;;241    #endif /* CHECKSUM_GEN_IP */
;;;242    
;;;243            ICMP_STATS_INC(icmp.xmit);
;;;244            /* increase number of messages attempted to send */
;;;245            MIB2_STATS_INC(mib2.icmpoutmsgs);
;;;246            /* increase number of echo replies attempted to send */
;;;247            MIB2_STATS_INC(mib2.icmpoutechoreps);
;;;248    
;;;249            /* send an ICMP packet */
;;;250            ret = ip4_output_if(p, src, LWIP_IP_HDRINCL,
;;;251                                ICMP_TTL, 0, IP_PROTO_ICMP, inp);
;;;252            if (ret != ERR_OK) {
;;;253              LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ip_output_if returned an error: %s\n", lwip_strerr(ret)));
;;;254            }
;;;255          }
;;;256          break;
;;;257        default:
;;;258          if (type == ICMP_DUR) {
;;;259            MIB2_STATS_INC(mib2.icmpindestunreachs);
;;;260          } else if (type == ICMP_TE) {
;;;261            MIB2_STATS_INC(mib2.icmpintimeexcds);
;;;262          } else if (type == ICMP_PP) {
;;;263            MIB2_STATS_INC(mib2.icmpinparmprobs);
;;;264          } else if (type == ICMP_SQ) {
;;;265            MIB2_STATS_INC(mib2.icmpinsrcquenchs);
;;;266          } else if (type == ICMP_RD) {
;;;267            MIB2_STATS_INC(mib2.icmpinredirects);
;;;268          } else if (type == ICMP_TS) {
;;;269            MIB2_STATS_INC(mib2.icmpintimestamps);
;;;270          } else if (type == ICMP_TSR) {
;;;271            MIB2_STATS_INC(mib2.icmpintimestampreps);
;;;272          } else if (type == ICMP_AM) {
;;;273            MIB2_STATS_INC(mib2.icmpinaddrmasks);
;;;274          } else if (type == ICMP_AMR) {
;;;275            MIB2_STATS_INC(mib2.icmpinaddrmaskreps);
;;;276          }
;;;277          LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n",
;;;278                                   (s16_t)type, (s16_t)code));
;;;279          ICMP_STATS_INC(icmp.proterr);
;;;280          ICMP_STATS_INC(icmp.drop);
;;;281      }
;;;282      pbuf_free(p);
;;;283      return;
;;;284    lenerr:
;;;285      pbuf_free(p);
;;;286      ICMP_STATS_INC(icmp.lenerr);
;;;287      MIB2_STATS_INC(mib2.icmpinerrors);
;;;288      return;
;;;289    #if LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING
;;;290    icmperr:
;;;291      pbuf_free(p);
0000e4  4620              MOV      r0,r4
0000e6  e8bd4ffe          POP      {r1-r11,lr}
0000ea  f7ffbffe          B.W      pbuf_free
                  |L2.238|
0000ee  6865              LDR      r5,[r4,#4]            ;207
0000f0  4631              MOV      r1,r6                 ;208
0000f2  4620              MOV      r0,r4                 ;208
0000f4  f7fffffe          BL       pbuf_add_header
0000f8  b978              CBNZ     r0,|L2.282|
0000fa  6860              LDR      r0,[r4,#4]            ;212
0000fc  f8d91000          LDR      r1,[r9,#0]            ;213
000100  60c1              STR      r1,[r0,#0xc]          ;213
000102  6939              LDR      r1,[r7,#0x10]         ;214  ; ip_data
000104  6101              STR      r1,[r0,#0x10]         ;214
000106  2100              MOVS     r1,#0                 ;215
000108  7029              STRB     r1,[r5,#0]            ;215
00010a  8069              STRH     r1,[r5,#2]            ;231
00010c  22ff              MOVS     r2,#0xff              ;235
00010e  7202              STRB     r2,[r0,#8]            ;235
000110  8141              STRH     r1,[r0,#0xa]          ;236
000112  2001              MOVS     r0,#1                 ;250
000114  23ff              MOVS     r3,#0xff              ;250
000116  e001              B        |L2.284|
                  |L2.280|
000118  e00d              B        |L2.310|
                  |L2.282|
00011a  e007              B        |L2.300|
                  |L2.284|
00011c  e9cd0801          STRD     r0,r8,[sp,#4]         ;250
000120  9100              STR      r1,[sp,#0]            ;250
000122  2200              MOVS     r2,#0                 ;250
000124  4649              MOV      r1,r9                 ;250
000126  4620              MOV      r0,r4                 ;250
000128  f7fffffe          BL       ip4_output_if
                  |L2.300|
00012c  4620              MOV      r0,r4                 ;282
00012e  e8bd4ffe          POP      {r1-r11,lr}           ;282
000132  f7ffbffe          B.W      pbuf_free
                  |L2.310|
000136  4620              MOV      r0,r4                 ;285
000138  e8bd4ffe          POP      {r1-r11,lr}           ;285
00013c  f7ffbffe          B.W      pbuf_free
;;;292      ICMP_STATS_INC(icmp.err);
;;;293      MIB2_STATS_INC(mib2.icmpinerrors);
;;;294      return;
;;;295    #endif /* LWIP_ICMP_ECHO_CHECK_INPUT_PBUF_LEN || !LWIP_MULTICAST_PING || !LWIP_BROADCAST_PING */
;;;296    }
;;;297    
                          ENDP

                  |L2.320|
                          DCD      ip_data
                  |L2.324|
000144  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ic"
000148  6964646c
00014c  65776172
000150  65735c54
000154  68697264
000158  5f506172
00015c  74795c4c
000160  7749505c
000164  7372635c
000168  636f7265
00016c  5c697076
000170  345c6963
000174  6d702e63          DCB      "mp.c",0
000178  00      
000179  00                DCB      0
00017a  00                DCB      0
00017b  00                DCB      0
                  |L2.380|
00017c  69636d70          DCB      "icmp_input: moving r->payload to icmp header failed\n",0
000180  5f696e70
000184  75743a20
000188  6d6f7669
00018c  6e672072
000190  2d3e7061
000194  796c6f61
000198  6420746f
00019c  2069636d
0001a0  70206865
0001a4  61646572
0001a8  20666169
0001ac  6c65640a
0001b0  00      
0001b1  00                DCB      0
0001b2  00                DCB      0
0001b3  00                DCB      0
                  |L2.436|
0001b4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001b8  7274696f
0001bc  6e202225
0001c0  73222066
0001c4  61696c65
0001c8  64206174
0001cc  206c696e
0001d0  65202564
0001d4  20696e20
0001d8  25730a00
                  |L2.476|
0001dc  69636d70          DCB      "icmp_input: restoring original p->payload failed\n",0
0001e0  5f696e70
0001e4  75743a20
0001e8  72657374
0001ec  6f72696e
0001f0  67206f72
0001f4  6967696e
0001f8  616c2070
0001fc  2d3e7061
000200  796c6f61
000204  64206661
000208  696c6564
00020c  0a00    
00020e  00                DCB      0
00020f  00                DCB      0

                          AREA ||i.icmp_send_response||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  icmp_send_response PROC
;;;339    static void
;;;340    icmp_send_response(struct pbuf *p, u8_t type, u8_t code)
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;341    {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
;;;342      struct pbuf *q;
;;;343      struct ip_hdr *iphdr;
;;;344      /* we can use the echo header here */
;;;345      struct icmp_echo_hdr *icmphdr;
;;;346      ip4_addr_t iphdr_src;
;;;347      struct netif *netif;
;;;348    
;;;349      /* increase number of messages attempted to send */
;;;350      MIB2_STATS_INC(mib2.icmpoutmsgs);
;;;351    
;;;352      /* ICMP header + IP header + 8 bytes of data */
;;;353      q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
00000a  f44f7220          MOV      r2,#0x280
00000e  2124              MOVS     r1,#0x24
000010  2022              MOVS     r0,#0x22
000012  f7fffffe          BL       pbuf_alloc
000016  4605              MOV      r5,r0
;;;354                     PBUF_RAM);
;;;355      if (q == NULL) {
000018  0028              MOVS     r0,r5
00001a  d030              BEQ      |L3.126|
;;;356        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
;;;357        MIB2_STATS_INC(mib2.icmpouterrors);
;;;358        return;
;;;359      }
;;;360      LWIP_ASSERT("check that first pbuf can hold icmp message",
00001c  8968              LDRH     r0,[r5,#0xa]
00001e  2824              CMP      r0,#0x24
000020  d206              BCS      |L3.48|
000022  a318              ADR      r3,|L3.132|
000024  f44f72b4          MOV      r2,#0x168
000028  a124              ADR      r1,|L3.188|
00002a  a02f              ADR      r0,|L3.232|
00002c  f7fffffe          BL       __2printf
                  |L3.48|
;;;361                  (q->len >= (sizeof(struct icmp_echo_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));
;;;362    
;;;363      iphdr = (struct ip_hdr *)p->payload;
000030  6877              LDR      r7,[r6,#4]
;;;364      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded from "));
;;;365      ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->src);
;;;366      LWIP_DEBUGF(ICMP_DEBUG, (" to "));
;;;367      ip4_addr_debug_print_val(ICMP_DEBUG, iphdr->dest);
;;;368      LWIP_DEBUGF(ICMP_DEBUG, ("\n"));
;;;369    
;;;370      icmphdr = (struct icmp_echo_hdr *)q->payload;
000032  686c              LDR      r4,[r5,#4]
;;;371      icmphdr->type = type;
000034  f8848000          STRB     r8,[r4,#0]
;;;372      icmphdr->code = code;
000038  f8849001          STRB     r9,[r4,#1]
;;;373      icmphdr->id = 0;
00003c  f04f0800          MOV      r8,#0
000040  f8a48004          STRH     r8,[r4,#4]
;;;374      icmphdr->seqno = 0;
000044  f8a48006          STRH     r8,[r4,#6]
;;;375    
;;;376      /* copy fields from original packet */
;;;377      SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_echo_hdr), (u8_t *)p->payload,
000048  6868              LDR      r0,[r5,#4]
00004a  6871              LDR      r1,[r6,#4]
00004c  3008              ADDS     r0,r0,#8
00004e  221c              MOVS     r2,#0x1c
000050  f7fffffe          BL       __aeabi_memcpy
;;;378              IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
;;;379    
;;;380      ip4_addr_copy(iphdr_src, iphdr->src);
000054  68f8              LDR      r0,[r7,#0xc]
000056  9003              STR      r0,[sp,#0xc]
;;;381    #ifdef LWIP_HOOK_IP4_ROUTE_SRC
;;;382      {
;;;383        ip4_addr_t iphdr_dst;
;;;384        ip4_addr_copy(iphdr_dst, iphdr->dest);
;;;385        netif = ip4_route_src(&iphdr_dst, &iphdr_src);
;;;386      }
;;;387    #else
;;;388      netif = ip4_route(&iphdr_src);
000058  a803              ADD      r0,sp,#0xc
00005a  f7fffffe          BL       ip4_route
;;;389    #endif
;;;390      if (netif != NULL) {
00005e  b158              CBZ      r0,|L3.120|
;;;391        /* calculate checksum */
;;;392        icmphdr->chksum = 0;
000060  f8a48002          STRH     r8,[r4,#2]
;;;393    #if CHECKSUM_GEN_ICMP
;;;394        IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_ICMP) {
;;;395          icmphdr->chksum = inet_chksum(icmphdr, q->len);
;;;396        }
;;;397    #endif
;;;398        ICMP_STATS_INC(icmp.xmit);
;;;399        ip4_output_if(q, NULL, &iphdr_src, ICMP_TTL, 0, IP_PROTO_ICMP, netif);
000064  2101              MOVS     r1,#1
000066  e9cd8100          STRD     r8,r1,[sp,#0]
00006a  9002              STR      r0,[sp,#8]
00006c  23ff              MOVS     r3,#0xff
00006e  aa03              ADD      r2,sp,#0xc
000070  2100              MOVS     r1,#0
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       ip4_output_if
                  |L3.120|
;;;400      }
;;;401      pbuf_free(q);
000078  4628              MOV      r0,r5
00007a  f7fffffe          BL       pbuf_free
                  |L3.126|
;;;402    }
00007e  e8bd87ff          POP      {r0-r10,pc}
;;;403    
                          ENDP

000082  0000              DCW      0x0000
                  |L3.132|
000084  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ic"
000088  6964646c
00008c  65776172
000090  65735c54
000094  68697264
000098  5f506172
00009c  74795c4c
0000a0  7749505c
0000a4  7372635c
0000a8  636f7265
0000ac  5c697076
0000b0  345c6963
0000b4  6d702e63          DCB      "mp.c",0
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L3.188|
0000bc  63686563          DCB      "check that first pbuf can hold icmp message",0
0000c0  6b207468
0000c4  61742066
0000c8  69727374
0000cc  20706275
0000d0  66206361
0000d4  6e20686f
0000d8  6c642069
0000dc  636d7020
0000e0  6d657373
0000e4  61676500
                  |L3.232|
0000e8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000ec  7274696f
0000f0  6e202225
0000f4  73222066
0000f8  61696c65
0000fc  64206174
000100  206c696e
000104  65202564
000108  20696e20
00010c  25730a00

                          AREA ||i.icmp_time_exceeded||, CODE, READONLY, ALIGN=1

                  icmp_time_exceeded PROC
;;;322    void
;;;323    icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
000000  460a              MOV      r2,r1
;;;324    {
;;;325      MIB2_STATS_INC(mib2.icmpouttimeexcds);
;;;326      icmp_send_response(p, ICMP_TE, t);
000002  210b              MOVS     r1,#0xb
000004  f7ffbffe          B.W      icmp_send_response
;;;327    }
;;;328    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\icmp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_icmp_c_efc2e004____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_icmp_c_efc2e004____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_icmp_c_efc2e004____REVSH|
#line 478
|__asm___6_icmp_c_efc2e004____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_icmp_c_efc2e004____RRX|
#line 665
|__asm___6_icmp_c_efc2e004____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
