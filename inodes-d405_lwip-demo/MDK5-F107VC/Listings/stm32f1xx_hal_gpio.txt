; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\stm32f1xx_hal_gpio.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f1xx_hal_gpio.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\system\arch -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Inc -I..\Middlewares\Third_Party\LwIP\src\include -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\stm32f1xx_hal_gpio.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_gpio.c]
                          THUMB

                          AREA ||i.HAL_GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_DeInit PROC
;;;350      */
;;;351    void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;352    {
;;;353      uint32_t position = 0x00u;
000004  2200              MOVS     r2,#0
;;;354      uint32_t iocurrent;
;;;355      uint32_t tmp;
;;;356      __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
;;;357      uint32_t registeroffset;
;;;358    
;;;359      /* Check the parameters */
;;;360      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;361      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;362    
;;;363      /* Configure the port pins */
;;;364      while ((GPIO_Pin >> position) != 0u)
;;;365      {
;;;366        /* Get current io position */
;;;367        iocurrent = (GPIO_Pin) & (1uL << position);
;;;368    
;;;369        if (iocurrent)
;;;370        {
;;;371          /*------------------------- EXTI Mode Configuration --------------------*/
;;;372          /* Clear the External Interrupt or Event for the current IO */
;;;373    
;;;374          tmp = AFIO->EXTICR[position >> 2u];
000006  f8df80c8          LDR      r8,|L1.208|
;;;375          tmp &= 0x0FuL << (4u * (position & 0x03u));
00000a  f04f0c0f          MOV      r12,#0xf
00000e  e05a              B        |L1.198|
                  |L1.16|
000010  2301              MOVS     r3,#1                 ;367
000012  4093              LSLS     r3,r3,r2              ;367
000014  400b              ANDS     r3,r3,r1              ;367
000016  b3cb              CBZ      r3,|L1.140|
000018  f0220403          BIC      r4,r2,#3              ;374
00001c  eb040508          ADD      r5,r4,r8              ;374
000020  68ac              LDR      r4,[r5,#8]            ;374
000022  0796              LSLS     r6,r2,#30
000024  0f37              LSRS     r7,r6,#28
000026  fa0cf607          LSL      r6,r12,r7
00002a  ea060904          AND      r9,r6,r4
;;;376          if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
00002e  4c29              LDR      r4,|L1.212|
000030  42a0              CMP      r0,r4
000032  d101              BNE      |L1.56|
000034  2400              MOVS     r4,#0
000036  e00f              B        |L1.88|
                  |L1.56|
000038  4c27              LDR      r4,|L1.216|
00003a  42a0              CMP      r0,r4
00003c  d101              BNE      |L1.66|
00003e  2401              MOVS     r4,#1
000040  e00a              B        |L1.88|
                  |L1.66|
000042  4c26              LDR      r4,|L1.220|
000044  42a0              CMP      r0,r4
000046  d101              BNE      |L1.76|
000048  2402              MOVS     r4,#2
00004a  e005              B        |L1.88|
                  |L1.76|
00004c  4c24              LDR      r4,|L1.224|
00004e  42a0              CMP      r0,r4
000050  d101              BNE      |L1.86|
000052  2403              MOVS     r4,#3
000054  e000              B        |L1.88|
                  |L1.86|
000056  2404              MOVS     r4,#4
                  |L1.88|
000058  40bc              LSLS     r4,r4,r7
00005a  454c              CMP      r4,r9
00005c  d112              BNE      |L1.132|
;;;377          {
;;;378            tmp = 0x0FuL << (4u * (position & 0x03u));
;;;379            CLEAR_BIT(AFIO->EXTICR[position >> 2u], tmp);
00005e  68ac              LDR      r4,[r5,#8]
000060  43b4              BICS     r4,r4,r6
000062  60ac              STR      r4,[r5,#8]
;;;380    
;;;381            /* Clear EXTI line configuration */
;;;382            CLEAR_BIT(EXTI->IMR, (uint32_t)iocurrent);
000064  4c1f              LDR      r4,|L1.228|
000066  6825              LDR      r5,[r4,#0]
000068  439d              BICS     r5,r5,r3
00006a  6025              STR      r5,[r4,#0]
;;;383            CLEAR_BIT(EXTI->EMR, (uint32_t)iocurrent);
00006c  1d24              ADDS     r4,r4,#4
00006e  6825              LDR      r5,[r4,#0]
000070  439d              BICS     r5,r5,r3
000072  6025              STR      r5,[r4,#0]
;;;384    
;;;385            /* Clear Rising Falling edge configuration */
;;;386            CLEAR_BIT(EXTI->RTSR, (uint32_t)iocurrent);
000074  1d24              ADDS     r4,r4,#4
000076  6825              LDR      r5,[r4,#0]
000078  439d              BICS     r5,r5,r3
00007a  6025              STR      r5,[r4,#0]
;;;387            CLEAR_BIT(EXTI->FTSR, (uint32_t)iocurrent);
00007c  1d24              ADDS     r4,r4,#4
00007e  6825              LDR      r5,[r4,#0]
000080  439d              BICS     r5,r5,r3
000082  6025              STR      r5,[r4,#0]
                  |L1.132|
;;;388          }
;;;389          /*------------------------- GPIO Mode Configuration --------------------*/
;;;390          /* Check if the current bit belongs to first half or last half of the pin count number
;;;391           in order to address CRH or CRL register */
;;;392          configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
000084  2bff              CMP      r3,#0xff
000086  d802              BHI      |L1.142|
000088  4604              MOV      r4,r0
00008a  e002              B        |L1.146|
                  |L1.140|
00008c  e019              B        |L1.194|
                  |L1.142|
00008e  f1000404          ADD      r4,r0,#4
                  |L1.146|
;;;393          registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
000092  d802              BHI      |L1.154|
000094  ea4f0582          LSL      r5,r2,#2
000098  e003              B        |L1.162|
                  |L1.154|
00009a  f1a20508          SUB      r5,r2,#8
00009e  ea4f0585          LSL      r5,r5,#2
                  |L1.162|
;;;394    
;;;395          /* CRL/CRH default value is floating input(0x04) shifted to correct position */
;;;396          MODIFY_REG(*configregister, ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), GPIO_CRL_CNF0_0 << registeroffset);
0000a2  6826              LDR      r6,[r4,#0]
0000a4  fa0cf705          LSL      r7,r12,r5
0000a8  ea260607          BIC      r6,r6,r7
0000ac  f04f0704          MOV      r7,#4
0000b0  fa07f705          LSL      r7,r7,r5
0000b4  ea460607          ORR      r6,r6,r7
0000b8  6026              STR      r6,[r4,#0]
;;;397    
;;;398          /* ODR default value is 0 */
;;;399          CLEAR_BIT(GPIOx->ODR, iocurrent);
0000ba  68c4              LDR      r4,[r0,#0xc]
0000bc  ea240403          BIC      r4,r4,r3
0000c0  60c4              STR      r4,[r0,#0xc]
                  |L1.194|
;;;400        }
;;;401    
;;;402        position++;
0000c2  f1020201          ADD      r2,r2,#1
                  |L1.198|
0000c6  fa31f302          LSRS     r3,r1,r2              ;364
0000ca  d1a1              BNE      |L1.16|
;;;403      }
;;;404    }
0000cc  e8bd83f0          POP      {r4-r9,pc}
;;;405    
                          ENDP

                  |L1.208|
                          DCD      0x40010000
                  |L1.212|
                          DCD      0x40010800
                  |L1.216|
                          DCD      0x40010c00
                  |L1.220|
                          DCD      0x40011000
                  |L1.224|
                          DCD      0x40011400
                  |L1.228|
                          DCD      0x40010400

                          AREA ||i.HAL_GPIO_EXTI_Callback||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_EXTI_Callback PROC
;;;561      */
;;;562    __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
000000  4770              BX       lr
;;;563    {
;;;564      /* Prevent unused argument(s) compilation warning */
;;;565      UNUSED(GPIO_Pin);
;;;566      /* NOTE: This function Should not be modified, when the callback is needed,
;;;567               the HAL_GPIO_EXTI_Callback could be implemented in the user file
;;;568       */
;;;569    }
;;;570    
                          ENDP


                          AREA ||i.HAL_GPIO_EXTI_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_EXTI_IRQHandler PROC
;;;546      */
;;;547    void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
000000  b510              PUSH     {r4,lr}
;;;548    {
;;;549      /* EXTI line interrupt detected */
;;;550      if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
000002  4904              LDR      r1,|L3.20|
000004  680a              LDR      r2,[r1,#0]
000006  4202              TST      r2,r0
000008  d002              BEQ      |L3.16|
;;;551      {
;;;552        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
00000a  6008              STR      r0,[r1,#0]
;;;553        HAL_GPIO_EXTI_Callback(GPIO_Pin);
00000c  f7fffffe          BL       HAL_GPIO_EXTI_Callback
                  |L3.16|
;;;554      }
;;;555    }
000010  bd10              POP      {r4,pc}
;;;556    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40010414

                          AREA ||i.HAL_GPIO_Init||, CODE, READONLY, ALIGN=2

                  HAL_GPIO_Init PROC
;;;177      */
;;;178    void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;179    {
;;;180      uint32_t position = 0x00u;
000004  2400              MOVS     r4,#0
;;;181      uint32_t ioposition;
;;;182      uint32_t iocurrent;
;;;183      uint32_t temp;
;;;184      uint32_t config = 0x00u;
000006  2300              MOVS     r3,#0
;;;185      __IO uint32_t *configregister; /* Store the address of CRL or CRH register based on pin number */
;;;186      uint32_t registeroffset;       /* offset used during computation of CNF and MODE bits placement inside CRL or CRH register */
;;;187    
;;;188      /* Check the parameters */
;;;189      assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
;;;190      assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
;;;191      assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
;;;192    
;;;193      /* Configure the port pins */
;;;194      while (((GPIO_Init->Pin) >> position) != 0x00u)
;;;195      {
;;;196        /* Get the IO position */
;;;197        ioposition = (0x01uL << position);
;;;198    
;;;199        /* Get the current IO position */
;;;200        iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
;;;201    
;;;202        if (iocurrent == ioposition)
;;;203        {
;;;204          /* Check the Alternate function parameters */
;;;205          assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
;;;206    
;;;207          /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
;;;208          switch (GPIO_Init->Mode)
;;;209          {
;;;210            /* If we are configuring the pin in OUTPUT push-pull mode */
;;;211            case GPIO_MODE_OUTPUT_PP:
;;;212              /* Check the GPIO speed parameter */
;;;213              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;214              config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
;;;215              break;
;;;216    
;;;217            /* If we are configuring the pin in OUTPUT open-drain mode */
;;;218            case GPIO_MODE_OUTPUT_OD:
;;;219              /* Check the GPIO speed parameter */
;;;220              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;221              config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
;;;222              break;
;;;223    
;;;224            /* If we are configuring the pin in ALTERNATE FUNCTION push-pull mode */
;;;225            case GPIO_MODE_AF_PP:
;;;226              /* Check the GPIO speed parameter */
;;;227              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;228              config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
;;;229              break;
;;;230    
;;;231            /* If we are configuring the pin in ALTERNATE FUNCTION open-drain mode */
;;;232            case GPIO_MODE_AF_OD:
;;;233              /* Check the GPIO speed parameter */
;;;234              assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
;;;235              config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
;;;236              break;
;;;237    
;;;238            /* If we are configuring the pin in INPUT (also applicable to EVENT and IT mode) */
;;;239            case GPIO_MODE_INPUT:
;;;240            case GPIO_MODE_IT_RISING:
;;;241            case GPIO_MODE_IT_FALLING:
;;;242            case GPIO_MODE_IT_RISING_FALLING:
;;;243            case GPIO_MODE_EVT_RISING:
;;;244            case GPIO_MODE_EVT_FALLING:
;;;245            case GPIO_MODE_EVT_RISING_FALLING:
;;;246              /* Check the GPIO pull parameter */
;;;247              assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
;;;248              if (GPIO_Init->Pull == GPIO_NOPULL)
;;;249              {
;;;250                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
;;;251              }
;;;252              else if (GPIO_Init->Pull == GPIO_PULLUP)
;;;253              {
;;;254                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
;;;255    
;;;256                /* Set the corresponding ODR bit */
;;;257                GPIOx->BSRR = ioposition;
;;;258              }
;;;259              else /* GPIO_PULLDOWN */
;;;260              {
;;;261                config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
;;;262    
;;;263                /* Reset the corresponding ODR bit */
;;;264                GPIOx->BRR = ioposition;
;;;265              }
;;;266              break;
;;;267    
;;;268            /* If we are configuring the pin in INPUT analog mode */
;;;269            case GPIO_MODE_ANALOG:
;;;270              config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
;;;271              break;
;;;272    
;;;273            /* Parameters are checked with assert_param */
;;;274            default:
;;;275              break;
;;;276          }
;;;277    
;;;278          /* Check if the current bit belongs to first half or last half of the pin count number
;;;279           in order to address CRH or CRL register*/
;;;280          configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
;;;281          registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
;;;282    
;;;283          /* Apply the new configuration of the pin to the register */
;;;284          MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
;;;285    
;;;286          /*--------------------- EXTI Mode Configuration ------------------------*/
;;;287          /* Configure the External Interrupt or event for the current IO */
;;;288          if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
;;;289          {
;;;290            /* Enable AFIO Clock */
;;;291            __HAL_RCC_AFIO_CLK_ENABLE();
;;;292            temp = AFIO->EXTICR[position >> 2u];
;;;293            CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
;;;294            SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
;;;295            AFIO->EXTICR[position >> 2u] = temp;
;;;296    
;;;297    
;;;298            /* Configure the interrupt mask */
;;;299            if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
;;;300            {
;;;301              SET_BIT(EXTI->IMR, iocurrent);
000008  f8df91c4          LDR      r9,|L4.464|
00000c  f04f080f          MOV      r8,#0xf               ;284
;;;302            }
;;;303            else
;;;304            {
;;;305              CLEAR_BIT(EXTI->IMR, iocurrent);
;;;306            }
;;;307    
;;;308            /* Configure the event mask */
;;;309            if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
;;;310            {
;;;311              SET_BIT(EXTI->EMR, iocurrent);
000010  f1090a04          ADD      r10,r9,#4
;;;312            }
;;;313            else
;;;314            {
;;;315              CLEAR_BIT(EXTI->EMR, iocurrent);
;;;316            }
;;;317    
;;;318            /* Enable or disable the rising trigger */
;;;319            if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
;;;320            {
;;;321              SET_BIT(EXTI->RTSR, iocurrent);
000014  f10a0b04          ADD      r11,r10,#4
;;;322            }
;;;323            else
;;;324            {
;;;325              CLEAR_BIT(EXTI->RTSR, iocurrent);
;;;326            }
;;;327    
;;;328            /* Enable or disable the falling trigger */
;;;329            if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
;;;330            {
;;;331              SET_BIT(EXTI->FTSR, iocurrent);
000018  f10b0e04          ADD      lr,r11,#4
00001c  e0d1              B        |L4.450|
                  |L4.30|
00001e  2701              MOVS     r7,#1                 ;197
000020  40a7              LSLS     r7,r7,r4              ;197
000022  403a              ANDS     r2,r2,r7              ;200
000024  42ba              CMP      r2,r7                 ;202
000026  d175              BNE      |L4.276|
000028  f8dfc1a8          LDR      r12,|L4.468|
00002c  684d              LDR      r5,[r1,#4]            ;208
00002e  eba5060c          SUB      r6,r5,r12             ;208
000032  4565              CMP      r5,r12                ;208
000034  d02b              BEQ      |L4.142|
000036  dc0d              BGT      |L4.84|
000038  2d03              CMP      r5,#3                 ;208
00003a  d034              BEQ      |L4.166|
00003c  dc05              BGT      |L4.74|
00003e  b335              CBZ      r5,|L4.142|
000040  2d01              CMP      r5,#1                 ;208
000042  d019              BEQ      |L4.120|
000044  2d02              CMP      r5,#2                 ;208
000046  d12f              BNE      |L4.168|
000048  e01b              B        |L4.130|
                  |L4.74|
00004a  2d11              CMP      r5,#0x11              ;208
00004c  d016              BEQ      |L4.124|
00004e  2d12              CMP      r5,#0x12              ;208
000050  d12a              BNE      |L4.168|
000052  e019              B        |L4.136|
                  |L4.84|
000054  f5b61f88          CMP      r6,#0x110000          ;208
000058  d019              BEQ      |L4.142|
00005a  dc06              BGT      |L4.106|
00005c  f5b63f80          CMP      r6,#0x10000           ;208
000060  d015              BEQ      |L4.142|
000062  f5b61f80          CMP      r6,#0x100000          ;208
000066  d11f              BNE      |L4.168|
000068  e011              B        |L4.142|
                  |L4.106|
00006a  f5b61f00          CMP      r6,#0x200000          ;208
00006e  d00e              BEQ      |L4.142|
000070  f5b61f04          CMP      r6,#0x210000          ;208
000074  d118              BNE      |L4.168|
000076  e00a              B        |L4.142|
                  |L4.120|
000078  68cb              LDR      r3,[r1,#0xc]          ;214
00007a  e015              B        |L4.168|
                  |L4.124|
00007c  68cb              LDR      r3,[r1,#0xc]          ;221
00007e  1d1b              ADDS     r3,r3,#4              ;221
000080  e012              B        |L4.168|
                  |L4.130|
000082  68cb              LDR      r3,[r1,#0xc]          ;228
000084  3308              ADDS     r3,r3,#8              ;228
000086  e00f              B        |L4.168|
                  |L4.136|
000088  68cb              LDR      r3,[r1,#0xc]          ;235
00008a  330c              ADDS     r3,r3,#0xc            ;235
00008c  e00c              B        |L4.168|
                  |L4.142|
00008e  688b              LDR      r3,[r1,#8]            ;248
000090  b123              CBZ      r3,|L4.156|
000092  2b01              CMP      r3,#1                 ;252
000094  d004              BEQ      |L4.160|
000096  2308              MOVS     r3,#8                 ;261
000098  6147              STR      r7,[r0,#0x14]         ;264
00009a  e005              B        |L4.168|
                  |L4.156|
00009c  2304              MOVS     r3,#4                 ;250
00009e  e003              B        |L4.168|
                  |L4.160|
0000a0  2308              MOVS     r3,#8                 ;254
0000a2  6107              STR      r7,[r0,#0x10]         ;257
0000a4  e000              B        |L4.168|
                  |L4.166|
0000a6  2300              MOVS     r3,#0                 ;270
                  |L4.168|
0000a8  2aff              CMP      r2,#0xff              ;280
0000aa  d801              BHI      |L4.176|
0000ac  4605              MOV      r5,r0                 ;280
0000ae  e001              B        |L4.180|
                  |L4.176|
0000b0  f1000504          ADD      r5,r0,#4              ;280
                  |L4.180|
0000b4  d802              BHI      |L4.188|
0000b6  ea4f0684          LSL      r6,r4,#2              ;281
0000ba  e003              B        |L4.196|
                  |L4.188|
0000bc  f1a40608          SUB      r6,r4,#8              ;281
0000c0  ea4f0686          LSL      r6,r6,#2              ;281
                  |L4.196|
0000c4  682f              LDR      r7,[r5,#0]            ;284
0000c6  fa08fc06          LSL      r12,r8,r6             ;284
0000ca  ea27070c          BIC      r7,r7,r12             ;284
0000ce  fa03f606          LSL      r6,r3,r6              ;284
0000d2  ea470706          ORR      r7,r7,r6              ;284
0000d6  602f              STR      r7,[r5,#0]            ;284
0000d8  684d              LDR      r5,[r1,#4]            ;288
0000da  00ed              LSLS     r5,r5,#3              ;288
0000dc  d570              BPL      |L4.448|
0000de  4d3e              LDR      r5,|L4.472|
0000e0  69ae              LDR      r6,[r5,#0x18]         ;291
0000e2  f0460601          ORR      r6,r6,#1              ;291
0000e6  61ae              STR      r6,[r5,#0x18]         ;291
0000e8  69ad              LDR      r5,[r5,#0x18]         ;291
0000ea  f0050501          AND      r5,r5,#1              ;291
0000ee  9500              STR      r5,[sp,#0]            ;291
0000f0  4d3a              LDR      r5,|L4.476|
0000f2  f0240603          BIC      r6,r4,#3              ;292
0000f6  1977              ADDS     r7,r6,r5              ;292
0000f8  68be              LDR      r6,[r7,#8]            ;292
0000fa  07a5              LSLS     r5,r4,#30             ;293
0000fc  0f2d              LSRS     r5,r5,#28             ;293
0000fe  fa08fc05          LSL      r12,r8,r5             ;293
000102  ea26060c          BIC      r6,r6,r12             ;293
000106  f8dfc0d8          LDR      r12,|L4.480|
00010a  4560              CMP      r0,r12                ;294
00010c  d103              BNE      |L4.278|
00010e  f04f0c00          MOV      r12,#0                ;294
000112  e017              B        |L4.324|
                  |L4.276|
000114  e054              B        |L4.448|
                  |L4.278|
000116  f8dfc0cc          LDR      r12,|L4.484|
00011a  4560              CMP      r0,r12                ;294
00011c  d102              BNE      |L4.292|
00011e  f04f0c01          MOV      r12,#1                ;294
000122  e00f              B        |L4.324|
                  |L4.292|
000124  f8dfc0c0          LDR      r12,|L4.488|
000128  4560              CMP      r0,r12                ;294
00012a  d102              BNE      |L4.306|
00012c  f04f0c02          MOV      r12,#2                ;294
000130  e008              B        |L4.324|
                  |L4.306|
000132  f8dfc0b8          LDR      r12,|L4.492|
000136  4560              CMP      r0,r12                ;294
000138  d102              BNE      |L4.320|
00013a  f04f0c03          MOV      r12,#3                ;294
00013e  e001              B        |L4.324|
                  |L4.320|
000140  f04f0c04          MOV      r12,#4                ;294
                  |L4.324|
000144  fa0cfc05          LSL      r12,r12,r5            ;294
000148  ea4c0c06          ORR      r12,r12,r6            ;294
00014c  f8c7c008          STR      r12,[r7,#8]           ;295
000150  684d              LDR      r5,[r1,#4]            ;299
000152  03ed              LSLS     r5,r5,#15             ;299
000154  d505              BPL      |L4.354|
000156  f8d95000          LDR      r5,[r9,#0]            ;301
00015a  4315              ORRS     r5,r5,r2              ;301
00015c  f8c95000          STR      r5,[r9,#0]            ;301
000160  e004              B        |L4.364|
                  |L4.354|
000162  f8d95000          LDR      r5,[r9,#0]            ;305
000166  4395              BICS     r5,r5,r2              ;305
000168  f8c95000          STR      r5,[r9,#0]            ;305
                  |L4.364|
00016c  684d              LDR      r5,[r1,#4]            ;309
00016e  03ad              LSLS     r5,r5,#14             ;309
000170  d505              BPL      |L4.382|
000172  f8da5000          LDR      r5,[r10,#0]           ;311
000176  4315              ORRS     r5,r5,r2              ;311
000178  f8ca5000          STR      r5,[r10,#0]           ;311
00017c  e004              B        |L4.392|
                  |L4.382|
00017e  f8da5000          LDR      r5,[r10,#0]           ;315
000182  4395              BICS     r5,r5,r2              ;315
000184  f8ca5000          STR      r5,[r10,#0]           ;315
                  |L4.392|
000188  684d              LDR      r5,[r1,#4]            ;319
00018a  02ed              LSLS     r5,r5,#11             ;319
00018c  d505              BPL      |L4.410|
00018e  f8db5000          LDR      r5,[r11,#0]           ;321
000192  4315              ORRS     r5,r5,r2              ;321
000194  f8cb5000          STR      r5,[r11,#0]           ;321
000198  e004              B        |L4.420|
                  |L4.410|
00019a  f8db5000          LDR      r5,[r11,#0]           ;325
00019e  4395              BICS     r5,r5,r2              ;325
0001a0  f8cb5000          STR      r5,[r11,#0]           ;325
                  |L4.420|
0001a4  684d              LDR      r5,[r1,#4]            ;329
0001a6  02ad              LSLS     r5,r5,#10             ;329
0001a8  d505              BPL      |L4.438|
0001aa  f8de5000          LDR      r5,[lr,#0]
0001ae  4315              ORRS     r5,r5,r2
0001b0  f8ce5000          STR      r5,[lr,#0]
0001b4  e004              B        |L4.448|
                  |L4.438|
;;;332            }
;;;333            else
;;;334            {
;;;335              CLEAR_BIT(EXTI->FTSR, iocurrent);
0001b6  f8de5000          LDR      r5,[lr,#0]
0001ba  4395              BICS     r5,r5,r2
0001bc  f8ce5000          STR      r5,[lr,#0]
                  |L4.448|
;;;336            }
;;;337          }
;;;338        }
;;;339    
;;;340    	position++;
0001c0  1c64              ADDS     r4,r4,#1
                  |L4.450|
0001c2  680a              LDR      r2,[r1,#0]            ;194
0001c4  fa32f504          LSRS     r5,r2,r4              ;194
0001c8  f47faf29          BNE      |L4.30|
;;;341      }
;;;342    }
0001cc  e8bd8ff8          POP      {r3-r11,pc}
;;;343    
                          ENDP

                  |L4.464|
                          DCD      0x40010400
                  |L4.468|
                          DCD      0x10110000
                  |L4.472|
                          DCD      0x40021000
                  |L4.476|
                          DCD      0x40010000
                  |L4.480|
                          DCD      0x40010800
                  |L4.484|
                          DCD      0x40010c00
                  |L4.488|
                          DCD      0x40011000
                  |L4.492|
                          DCD      0x40011400

                          AREA ||i.HAL_GPIO_LockPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_LockPin PROC
;;;511    */
;;;512    HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
000000  b508              PUSH     {r3,lr}
;;;513    {
;;;514      __IO uint32_t tmp = GPIO_LCKR_LCKK;
;;;515    
;;;516      /* Check the parameters */
;;;517      assert_param(IS_GPIO_LOCK_INSTANCE(GPIOx));
;;;518      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;519    
;;;520      /* Apply lock key write sequence */
;;;521      SET_BIT(tmp, GPIO_Pin);
000002  f4413280          ORR      r2,r1,#0x10000
000006  9200              STR      r2,[sp,#0]
;;;522      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;523      GPIOx->LCKR = tmp;
000008  9a00              LDR      r2,[sp,#0]
00000a  6182              STR      r2,[r0,#0x18]
;;;524      /* Reset LCKx bit(s): LCKK='0' + LCK[15-0] */
;;;525      GPIOx->LCKR = GPIO_Pin;
00000c  6181              STR      r1,[r0,#0x18]
;;;526      /* Set LCKx bit(s): LCKK='1' + LCK[15-0] */
;;;527      GPIOx->LCKR = tmp;
00000e  9900              LDR      r1,[sp,#0]
000010  6181              STR      r1,[r0,#0x18]
;;;528      /* Read LCKK register. This read is mandatory to complete key lock sequence */
;;;529      tmp = GPIOx->LCKR;
000012  6981              LDR      r1,[r0,#0x18]
000014  9100              STR      r1,[sp,#0]
;;;530    
;;;531      /* read again in order to confirm lock is active */
;;;532      if ((uint32_t)(GPIOx->LCKR & GPIO_LCKR_LCKK))
000016  6980              LDR      r0,[r0,#0x18]
000018  03c0              LSLS     r0,r0,#15
00001a  d501              BPL      |L5.32|
;;;533      {
;;;534        return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;535      }
;;;536      else
;;;537      {
;;;538        return HAL_ERROR;
;;;539      }
;;;540    }
00001e  bd08              POP      {r3,pc}
                  |L5.32|
000020  2001              MOVS     r0,#1                 ;538
000022  bd08              POP      {r3,pc}
;;;541    
                          ENDP


                          AREA ||i.HAL_GPIO_ReadPin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_ReadPin PROC
;;;430      */
;;;431    GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
000000  6880              LDR      r0,[r0,#8]
;;;432    {
;;;433      GPIO_PinState bitstatus;
;;;434    
;;;435      /* Check the parameters */
;;;436      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;437    
;;;438      if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
000002  4208              TST      r0,r1
000004  d001              BEQ      |L6.10|
;;;439      {
;;;440        bitstatus = GPIO_PIN_SET;
000006  2001              MOVS     r0,#1
;;;441      }
;;;442      else
;;;443      {
;;;444        bitstatus = GPIO_PIN_RESET;
;;;445      }
;;;446      return bitstatus;
;;;447    }
000008  4770              BX       lr
                  |L6.10|
00000a  2000              MOVS     r0,#0                 ;444
00000c  4770              BX       lr
;;;448    
                          ENDP


                          AREA ||i.HAL_GPIO_TogglePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_TogglePin PROC
;;;486      */
;;;487    void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
000000  68c2              LDR      r2,[r0,#0xc]
;;;488    {
;;;489      /* Check the parameters */
;;;490      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;491    
;;;492      if ((GPIOx->ODR & GPIO_Pin) != 0x00u)
000002  420a              TST      r2,r1
000004  d001              BEQ      |L7.10|
;;;493      {
;;;494        GPIOx->BRR = (uint32_t)GPIO_Pin;
000006  6141              STR      r1,[r0,#0x14]
;;;495      }
;;;496      else
;;;497      {
;;;498        GPIOx->BSRR = (uint32_t)GPIO_Pin;
;;;499      }
;;;500    }
000008  4770              BX       lr
                  |L7.10|
00000a  6101              STR      r1,[r0,#0x10]         ;498
00000c  4770              BX       lr
;;;501    
                          ENDP


                          AREA ||i.HAL_GPIO_WritePin||, CODE, READONLY, ALIGN=1

                  HAL_GPIO_WritePin PROC
;;;464      */
;;;465    void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
000000  2a00              CMP      r2,#0
;;;466    {
000002  d001              BEQ      |L8.8|
;;;467      /* Check the parameters */
;;;468      assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;469      assert_param(IS_GPIO_PIN_ACTION(PinState));
;;;470    
;;;471      if (PinState != GPIO_PIN_RESET)
;;;472      {
;;;473        GPIOx->BSRR = GPIO_Pin;
000004  6101              STR      r1,[r0,#0x10]
;;;474      }
;;;475      else
;;;476      {
;;;477        GPIOx->BSRR = (uint32_t)GPIO_Pin << 16u;
;;;478      }
;;;479    }
000006  4770              BX       lr
                  |L8.8|
000008  0409              LSLS     r1,r1,#16             ;477
00000a  6101              STR      r1,[r0,#0x10]         ;477
00000c  4770              BX       lr
;;;480    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____REVSH|
#line 478
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_gpio_c_ea787061____RRX|
#line 665
|__asm___20_stm32f1xx_hal_gpio_c_ea787061____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
