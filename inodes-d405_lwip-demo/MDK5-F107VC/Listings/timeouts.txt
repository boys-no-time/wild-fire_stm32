; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\timeouts.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\timeouts.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\system\arch -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Inc -I..\Middlewares\Third_Party\LwIP\src\include -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\timeouts.crf ..\Middlewares\Third_Party\LwIP\src\core\timeouts.c]
                          THUMB

                          AREA ||i.cyclic_timer||, CODE, READONLY, ALIGN=2

                  cyclic_timer PROC
;;;163    static void
;;;164    cyclic_timer(void *arg)
000000  b510              PUSH     {r4,lr}
;;;165    {
000002  4604              MOV      r4,r0
;;;166      const struct lwip_cyclic_timer* cyclic = (const struct lwip_cyclic_timer*)arg;
;;;167    #if LWIP_DEBUG_TIMERNAMES
;;;168      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: %s()\n", cyclic->handler_name));
;;;169    #endif
;;;170      cyclic->handler();
000004  6860              LDR      r0,[r4,#4]
000006  4780              BLX      r0
;;;171      sys_timeout(cyclic->interval_ms, cyclic_timer, arg);
000008  4622              MOV      r2,r4
00000a  6820              LDR      r0,[r4,#0]
00000c  e8bd4010          POP      {r4,lr}
000010  4901              LDR      r1,|L1.24|
000012  f7ffbffe          B.W      sys_timeout
;;;172    }
;;;173    
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      cyclic_timer

                          AREA ||i.sys_check_timeouts||, CODE, READONLY, ALIGN=2

                  sys_check_timeouts PROC
;;;312    void
;;;313    sys_check_timeouts(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;314    {
;;;315      if (next_timeout) {
000004  4f14              LDR      r7,|L2.88|
000006  6838              LDR      r0,[r7,#0]  ; next_timeout
000008  2800              CMP      r0,#0
00000a  d022              BEQ      |L2.82|
;;;316        struct sys_timeo *tmptimeout;
;;;317        u32_t diff;
;;;318        sys_timeout_handler handler;
;;;319        void *arg;
;;;320        u8_t had_one;
;;;321        u32_t now;
;;;322    
;;;323        now = sys_now();
00000c  f7fffffe          BL       sys_now
;;;324        /* this cares for wraparounds */
;;;325        diff = now - timeouts_last_time;
000010  6879              LDR      r1,[r7,#4]  ; timeouts_last_time
000012  1a44              SUBS     r4,r0,r1
;;;326        do {
;;;327          PBUF_CHECK_FREE_OOSEQ();
000014  f8df8044          LDR      r8,|L2.92|
                  |L2.24|
000018  f8980000          LDRB     r0,[r8,#0]  ; pbuf_free_ooseq_pending
00001c  b108              CBZ      r0,|L2.34|
00001e  f7fffffe          BL       pbuf_free_ooseq
                  |L2.34|
;;;328          had_one = 0;
000022  2500              MOVS     r5,#0
;;;329          tmptimeout = next_timeout;
000024  6839              LDR      r1,[r7,#0]  ; next_timeout
;;;330          if (tmptimeout && (tmptimeout->time <= diff)) {
000026  b191              CBZ      r1,|L2.78|
000028  6848              LDR      r0,[r1,#4]
00002a  42a0              CMP      r0,r4
00002c  d80f              BHI      |L2.78|
;;;331            /* timeout has expired */
;;;332            had_one = 1;
00002e  2501              MOVS     r5,#1
;;;333            timeouts_last_time += tmptimeout->time;
000030  687a              LDR      r2,[r7,#4]  ; timeouts_last_time
000032  4402              ADD      r2,r2,r0
000034  607a              STR      r2,[r7,#4]  ; timeouts_last_time
;;;334            diff -= tmptimeout->time;
000036  1a24              SUBS     r4,r4,r0
;;;335            next_timeout = tmptimeout->next;
000038  6808              LDR      r0,[r1,#0]
00003a  6038              STR      r0,[r7,#0]  ; next_timeout
;;;336            handler = tmptimeout->h;
00003c  688e              LDR      r6,[r1,#8]
;;;337            arg = tmptimeout->arg;
00003e  f8d1900c          LDR      r9,[r1,#0xc]
;;;338    #if LWIP_DEBUG_TIMERNAMES
;;;339            if (handler != NULL) {
;;;340              LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s arg=%p\n",
;;;341                tmptimeout->handler_name, arg));
;;;342            }
;;;343    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;344            memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
000042  2006              MOVS     r0,#6
000044  f7fffffe          BL       memp_free
;;;345            if (handler != NULL) {
000048  b10e              CBZ      r6,|L2.78|
;;;346    #if !NO_SYS
;;;347              /* For LWIP_TCPIP_CORE_LOCKING, lock the core before calling the
;;;348                 timeout handler function. */
;;;349              LOCK_TCPIP_CORE();
;;;350    #endif /* !NO_SYS */
;;;351              handler(arg);
00004a  4648              MOV      r0,r9
00004c  47b0              BLX      r6
                  |L2.78|
;;;352    #if !NO_SYS
;;;353              UNLOCK_TCPIP_CORE();
;;;354    #endif /* !NO_SYS */
;;;355            }
;;;356            LWIP_TCPIP_THREAD_ALIVE();
;;;357          }
;;;358        /* repeat until all expired timers have been called */
;;;359        } while (had_one);
00004e  2d00              CMP      r5,#0
000050  d1e2              BNE      |L2.24|
                  |L2.82|
;;;360      }
;;;361    }
000052  e8bd87f0          POP      {r4-r10,pc}
;;;362    
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      ||.data||
                  |L2.92|
                          DCD      pbuf_free_ooseq_pending

                          AREA ||i.sys_restart_timeouts||, CODE, READONLY, ALIGN=2

                  sys_restart_timeouts PROC
;;;368    void
;;;369    sys_restart_timeouts(void)
000000  b510              PUSH     {r4,lr}
;;;370    {
;;;371      timeouts_last_time = sys_now();
000002  f7fffffe          BL       sys_now
000006  4901              LDR      r1,|L3.12|
000008  6048              STR      r0,[r1,#4]  ; timeouts_last_time
;;;372    }
00000a  bd10              POP      {r4,pc}
;;;373    
                          ENDP

                  |L3.12|
                          DCD      ||.data||

                          AREA ||i.sys_timeout||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  sys_timeout PROC
;;;203    void
;;;204    sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;205    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;206    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;207      struct sys_timeo *timeout, *t;
;;;208      u32_t now, diff;
;;;209    
;;;210      timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
00000a  2006              MOVS     r0,#6
00000c  f7fffffe          BL       memp_malloc
000010  4604              MOV      r4,r0
;;;211      if (timeout == NULL) {
000012  0020              MOVS     r0,r4
000014  d015              BEQ      |L4.66|
;;;212        LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
;;;213        return;
;;;214      }
;;;215    
;;;216      now = sys_now();
000016  f7fffffe          BL       sys_now
;;;217      if (next_timeout == NULL) {
00001a  4924              LDR      r1,|L4.172|
00001c  680b              LDR      r3,[r1,#0]  ; next_timeout
00001e  2b00              CMP      r3,#0
000020  d018              BEQ      |L4.84|
;;;218        diff = 0;
;;;219        timeouts_last_time = now;
;;;220      } else {
;;;221        diff = now - timeouts_last_time;
000022  684a              LDR      r2,[r1,#4]  ; timeouts_last_time
000024  eba00602          SUB      r6,r0,r2
                  |L4.40|
;;;222      }
;;;223    
;;;224      timeout->next = NULL;
000028  f04f0000          MOV      r0,#0
00002c  6020              STR      r0,[r4,#0]
;;;225      timeout->h = handler;
00002e  60a7              STR      r7,[r4,#8]
;;;226      timeout->arg = arg;
000030  f8c4800c          STR      r8,[r4,#0xc]
;;;227      timeout->time = msecs + diff;
000034  eb050006          ADD      r0,r5,r6
000038  6060              STR      r0,[r4,#4]
;;;228    #if LWIP_DEBUG_TIMERNAMES
;;;229      timeout->handler_name = handler_name;
;;;230      LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" handler=%s arg=%p\n",
;;;231        (void *)timeout, msecs, handler_name, (void *)arg));
;;;232    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;233    
;;;234      if (next_timeout == NULL) {
00003a  d10f              BNE      |L4.92|
;;;235        next_timeout = timeout;
00003c  600c              STR      r4,[r1,#0]  ; next_timeout
                  |L4.62|
;;;236        return;
;;;237      }
;;;238    
;;;239      if (next_timeout->time > msecs) {
;;;240        next_timeout->time -= msecs;
;;;241        timeout->next = next_timeout;
;;;242        next_timeout = timeout;
;;;243      } else {
;;;244        for (t = next_timeout; t != NULL; t = t->next) {
;;;245          timeout->time -= t->time;
;;;246          if (t->next == NULL || t->next->time > timeout->time) {
;;;247            if (t->next != NULL) {
;;;248              t->next->time -= timeout->time;
;;;249            } else if (timeout->time > msecs) {
;;;250              /* If this is the case, 'timeouts_last_time' and 'now' differs too much.
;;;251                 This can be due to sys_check_timeouts() not being called at the right
;;;252                 times, but also when stopping in a breakpoint. Anyway, let's assume
;;;253                 this is not wanted, so add the first timer's time instead of 'diff' */
;;;254              timeout->time = msecs + next_timeout->time;
;;;255            }
;;;256            timeout->next = t->next;
;;;257            t->next = timeout;
;;;258            break;
;;;259          }
;;;260        }
;;;261      }
;;;262    }
00003e  e8bd81f0          POP      {r4-r8,pc}
                  |L4.66|
000042  e8bd41f0          POP      {r4-r8,lr}            ;212
000046  a31a              ADR      r3,|L4.176|
000048  f04f02d4          MOV      r2,#0xd4              ;212
00004c  a125              ADR      r1,|L4.228|
00004e  a035              ADR      r0,|L4.292|
000050  f7ffbffe          B.W      __2printf
                  |L4.84|
000054  f04f0600          MOV      r6,#0                 ;218
000058  6048              STR      r0,[r1,#4]            ;219  ; timeouts_last_time
00005a  e7e5              B        |L4.40|
                  |L4.92|
00005c  6858              LDR      r0,[r3,#4]            ;239
00005e  42a8              CMP      r0,r5                 ;239
000060  d904              BLS      |L4.108|
000062  1b40              SUBS     r0,r0,r5              ;240
000064  6058              STR      r0,[r3,#4]            ;240
000066  6023              STR      r3,[r4,#0]            ;241
000068  600c              STR      r4,[r1,#0]            ;242  ; next_timeout
00006a  e7e8              B        |L4.62|
                  |L4.108|
00006c  4618              MOV      r0,r3                 ;244
00006e  e014              B        |L4.154|
                  |L4.112|
000070  684e              LDR      r6,[r1,#4]            ;246
000072  4296              CMP      r6,r2                 ;246
000074  d910              BLS      |L4.152|
                  |L4.118|
000076  6802              LDR      r2,[r0,#0]            ;247
000078  b122              CBZ      r2,|L4.132|
00007a  684a              LDR      r2,[r1,#4]            ;248
00007c  6863              LDR      r3,[r4,#4]            ;248
00007e  1ad2              SUBS     r2,r2,r3              ;248
000080  604a              STR      r2,[r1,#4]            ;248
000082  e005              B        |L4.144|
                  |L4.132|
000084  6861              LDR      r1,[r4,#4]            ;249
000086  42a9              CMP      r1,r5                 ;249
000088  d902              BLS      |L4.144|
00008a  6859              LDR      r1,[r3,#4]            ;254
00008c  4429              ADD      r1,r1,r5              ;254
00008e  6061              STR      r1,[r4,#4]            ;254
                  |L4.144|
000090  6801              LDR      r1,[r0,#0]            ;256
000092  6021              STR      r1,[r4,#0]            ;256
000094  6004              STR      r4,[r0,#0]            ;257
000096  e7d2              B        |L4.62|
                  |L4.152|
000098  4608              MOV      r0,r1                 ;244
                  |L4.154|
00009a  6861              LDR      r1,[r4,#4]            ;245
00009c  6842              LDR      r2,[r0,#4]            ;245
00009e  1a8a              SUBS     r2,r1,r2              ;245
0000a0  6062              STR      r2,[r4,#4]            ;245
0000a2  6801              LDR      r1,[r0,#0]            ;244
0000a4  2900              CMP      r1,#0                 ;244
0000a6  d0e6              BEQ      |L4.118|
0000a8  e7e2              B        |L4.112|
;;;263    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L4.172|
                          DCD      ||.data||
                  |L4.176|
0000b0  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\timeouts"
0000b4  6964646c
0000b8  65776172
0000bc  65735c54
0000c0  68697264
0000c4  5f506172
0000c8  74795c4c
0000cc  7749505c
0000d0  7372635c
0000d4  636f7265
0000d8  5c74696d
0000dc  656f7574
0000e0  73      
0000e1  2e6300            DCB      ".c",0
                  |L4.228|
0000e4  7379735f          DCB      "sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is "
0000e8  74696d65
0000ec  6f75743a
0000f0  2074696d
0000f4  656f7574
0000f8  20213d20
0000fc  4e554c4c
000100  2c20706f
000104  6f6c204d
000108  454d505f
00010c  5359535f
000110  54494d45
000114  4f555420
000118  697320  
00011b  656d7074          DCB      "empty",0
00011f  7900    
000121  00                DCB      0
000122  00                DCB      0
000123  00                DCB      0
                  |L4.292|
000124  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000128  7274696f
00012c  6e202225
000130  73222066
000134  61696c65
000138  64206174
00013c  206c696e
000140  65202564
000144  20696e20
000148  25730a00

                          AREA ||i.sys_timeouts_init||, CODE, READONLY, ALIGN=2

                  sys_timeouts_init PROC
;;;174    /** Initialize this module */
;;;175    void sys_timeouts_init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;176    {
;;;177      size_t i;
;;;178      /* tcp_tmr() at index 0 is started on demand */
;;;179      for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
000002  2401              MOVS     r4,#1
;;;180        /* we have to cast via size_t to get rid of const warning
;;;181          (this is OK as cyclic_timer() casts back to const* */
;;;182        sys_timeout(lwip_cyclic_timers[i].interval_ms, cyclic_timer, LWIP_CONST_CAST(void*, &lwip_cyclic_timers[i]));
000004  4d07              LDR      r5,|L5.36|
                  |L5.6|
000006  4908              LDR      r1,|L5.40|
000008  eb0502c4          ADD      r2,r5,r4,LSL #3
00000c  f8550034          LDR      r0,[r5,r4,LSL #3]
000010  f7fffffe          BL       sys_timeout
000014  1c64              ADDS     r4,r4,#1              ;179
000016  2c05              CMP      r4,#5                 ;179
000018  d3f5              BCC      |L5.6|
;;;183      }
;;;184    
;;;185      /* Initialise timestamp for sys_check_timeouts */
;;;186      timeouts_last_time = sys_now();
00001a  f7fffffe          BL       sys_now
00001e  4903              LDR      r1,|L5.44|
000020  6048              STR      r0,[r1,#4]  ; timeouts_last_time
;;;187    }
000022  bd70              POP      {r4-r6,pc}
;;;188    
                          ENDP

                  |L5.36|
                          DCD      ||.constdata||
                  |L5.40|
                          DCD      cyclic_timer
                  |L5.44|
                          DCD      ||.data||

                          AREA ||i.sys_timeouts_sleeptime||, CODE, READONLY, ALIGN=2

                  sys_timeouts_sleeptime PROC
;;;380    u32_t
;;;381    sys_timeouts_sleeptime(void)
000000  b510              PUSH     {r4,lr}
;;;382    {
;;;383      u32_t diff;
;;;384      if (next_timeout == NULL) {
000002  4c09              LDR      r4,|L6.40|
000004  6820              LDR      r0,[r4,#0]  ; next_timeout
000006  2800              CMP      r0,#0
000008  d009              BEQ      |L6.30|
;;;385        return 0xffffffff;
;;;386      }
;;;387      diff = sys_now() - timeouts_last_time;
00000a  f7fffffe          BL       sys_now
00000e  6861              LDR      r1,[r4,#4]  ; timeouts_last_time
000010  1a40              SUBS     r0,r0,r1
;;;388      if (diff > next_timeout->time) {
000012  6821              LDR      r1,[r4,#0]  ; next_timeout
000014  6849              LDR      r1,[r1,#4]
000016  4281              CMP      r1,r0
000018  d204              BCS      |L6.36|
;;;389        return 0;
00001a  2000              MOVS     r0,#0
;;;390      } else {
;;;391        return next_timeout->time - diff;
;;;392      }
;;;393    }
00001c  bd10              POP      {r4,pc}
                  |L6.30|
00001e  f04f30ff          MOV      r0,#0xffffffff        ;385
000022  bd10              POP      {r4,pc}
                  |L6.36|
000024  1a08              SUBS     r0,r1,r0              ;391
000026  bd10              POP      {r4,pc}
;;;394    
                          ENDP

                  |L6.40|
                          DCD      ||.data||

                          AREA ||i.sys_untimeout||, CODE, READONLY, ALIGN=2

                  sys_untimeout PROC
;;;272    void
;;;273    sys_untimeout(sys_timeout_handler handler, void *arg)
000000  b430              PUSH     {r4,r5}
;;;274    {
000002  460b              MOV      r3,r1
;;;275      struct sys_timeo *prev_t, *t;
;;;276    
;;;277      if (next_timeout == NULL) {
000004  4d10              LDR      r5,|L7.72|
000006  6829              LDR      r1,[r5,#0]  ; next_timeout
000008  2900              CMP      r1,#0
00000a  d01b              BEQ      |L7.68|
;;;278        return;
;;;279      }
;;;280    
;;;281      for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
00000c  2200              MOVS     r2,#0
00000e  e017              B        |L7.64|
                  |L7.16|
;;;282        if ((t->h == handler) && (t->arg == arg)) {
000010  688c              LDR      r4,[r1,#8]
000012  4284              CMP      r4,r0
000014  d112              BNE      |L7.60|
000016  68cc              LDR      r4,[r1,#0xc]
000018  429c              CMP      r4,r3
00001a  d10f              BNE      |L7.60|
;;;283          /* We have a match */
;;;284          /* Unlink from previous in list */
;;;285          if (prev_t == NULL) {
00001c  b15a              CBZ      r2,|L7.54|
;;;286            next_timeout = t->next;
;;;287          } else {
;;;288            prev_t->next = t->next;
00001e  6808              LDR      r0,[r1,#0]
000020  6010              STR      r0,[r2,#0]
                  |L7.34|
;;;289          }
;;;290          /* If not the last one, add time of this one back to next */
;;;291          if (t->next != NULL) {
000022  6808              LDR      r0,[r1,#0]
000024  b118              CBZ      r0,|L7.46|
;;;292            t->next->time += t->time;
000026  6842              LDR      r2,[r0,#4]
000028  684b              LDR      r3,[r1,#4]
00002a  441a              ADD      r2,r2,r3
00002c  6042              STR      r2,[r0,#4]
                  |L7.46|
;;;293          }
;;;294          memp_free(MEMP_SYS_TIMEOUT, t);
00002e  bc30              POP      {r4,r5}
000030  2006              MOVS     r0,#6
000032  f7ffbffe          B.W      memp_free
                  |L7.54|
000036  6808              LDR      r0,[r1,#0]            ;286
000038  6028              STR      r0,[r5,#0]            ;286  ; next_timeout
00003a  e7f2              B        |L7.34|
                  |L7.60|
00003c  460a              MOV      r2,r1                 ;281
00003e  6809              LDR      r1,[r1,#0]            ;281
                  |L7.64|
000040  2900              CMP      r1,#0                 ;281
000042  d1e5              BNE      |L7.16|
                  |L7.68|
;;;295          return;
;;;296        }
;;;297      }
;;;298      return;
;;;299    }
000044  bc30              POP      {r4,r5}
000046  4770              BX       lr
;;;300    
                          ENDP

                  |L7.72|
                          DCD      ||.data||

                          AREA ||i.tcp_timer_needed||, CODE, READONLY, ALIGN=2

                  tcp_timer_needed PROC
;;;146    void
;;;147    tcp_timer_needed(void)
000000  4808              LDR      r0,|L8.36|
;;;148    {
;;;149      /* timer is off but needed again? */
;;;150      if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
000002  6881              LDR      r1,[r0,#8]  ; tcpip_tcp_timer_active
000004  2900              CMP      r1,#0
000006  d10c              BNE      |L8.34|
000008  4907              LDR      r1,|L8.40|
00000a  4a08              LDR      r2,|L8.44|
00000c  6809              LDR      r1,[r1,#0]  ; tcp_active_pcbs
00000e  6812              LDR      r2,[r2,#0]  ; tcp_tw_pcbs
000010  4311              ORRS     r1,r1,r2
000012  d006              BEQ      |L8.34|
;;;151        /* enable and start timer */
;;;152        tcpip_tcp_timer_active = 1;
000014  2101              MOVS     r1,#1
000016  6081              STR      r1,[r0,#8]  ; tcpip_tcp_timer_active
;;;153        sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
000018  2200              MOVS     r2,#0
00001a  4905              LDR      r1,|L8.48|
00001c  20fa              MOVS     r0,#0xfa
00001e  f7ffbffe          B.W      sys_timeout
                  |L8.34|
;;;154      }
;;;155    }
000022  4770              BX       lr
;;;156    #endif /* LWIP_TCP */
                          ENDP

                  |L8.36|
                          DCD      ||.data||
                  |L8.40|
                          DCD      tcp_active_pcbs
                  |L8.44|
                          DCD      tcp_tw_pcbs
                  |L8.48|
                          DCD      tcpip_tcp_timer

                          AREA ||i.tcpip_tcp_timer||, CODE, READONLY, ALIGN=2

                  tcpip_tcp_timer PROC
;;;124    static void
;;;125    tcpip_tcp_timer(void *arg)
000000  b510              PUSH     {r4,lr}
;;;126    {
;;;127      LWIP_UNUSED_ARG(arg);
;;;128    
;;;129      /* call TCP timer handler */
;;;130      tcp_tmr();
000002  f7fffffe          BL       tcp_tmr
;;;131      /* timer still needed? */
;;;132      if (tcp_active_pcbs || tcp_tw_pcbs) {
000006  4808              LDR      r0,|L9.40|
000008  4908              LDR      r1,|L9.44|
00000a  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
00000c  6809              LDR      r1,[r1,#0]  ; tcp_tw_pcbs
00000e  4308              ORRS     r0,r0,r1
000010  d006              BEQ      |L9.32|
;;;133        /* restart timer */
;;;134        sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
000012  2200              MOVS     r2,#0
000014  e8bd4010          POP      {r4,lr}
000018  4905              LDR      r1,|L9.48|
00001a  20fa              MOVS     r0,#0xfa
00001c  f7ffbffe          B.W      sys_timeout
                  |L9.32|
;;;135      } else {
;;;136        /* disable timer */
;;;137        tcpip_tcp_timer_active = 0;
000020  4904              LDR      r1,|L9.52|
000022  2000              MOVS     r0,#0
000024  6088              STR      r0,[r1,#8]  ; tcpip_tcp_timer_active
;;;138      }
;;;139    }
000026  bd10              POP      {r4,pc}
;;;140    
                          ENDP

                  |L9.40|
                          DCD      tcp_active_pcbs
                  |L9.44|
                          DCD      tcp_tw_pcbs
                  |L9.48|
                          DCD      tcpip_tcp_timer
                  |L9.52|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  lwip_cyclic_timers
                          DCD      0x000000fa
                          DCD      tcp_tmr
                          DCD      0x000003e8
                          DCD      ip_reass_tmr
                          DCD      0x000003e8
                          DCD      etharp_tmr
                          DCD      0x0000ea60
                          DCD      dhcp_coarse_tmr
                          DCD      0x000001f4
                          DCD      dhcp_fine_tmr

                          AREA ||.data||, DATA, ALIGN=2

                  next_timeout
                          DCD      0x00000000
                  timeouts_last_time
                          DCD      0x00000000
                  tcpip_tcp_timer_active
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\timeouts.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_timeouts_c_6f3cbd76____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_timeouts_c_6f3cbd76____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_timeouts_c_6f3cbd76____REVSH|
#line 478
|__asm___10_timeouts_c_6f3cbd76____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_timeouts_c_6f3cbd76____RRX|
#line 665
|__asm___10_timeouts_c_6f3cbd76____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
