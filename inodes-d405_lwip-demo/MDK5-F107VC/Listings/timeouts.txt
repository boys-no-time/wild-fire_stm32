; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\timeouts.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\timeouts.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\timeouts.crf ..\Middlewares\Third_Party\LwIP\src\core\timeouts.c]
                          THUMB

                          AREA ||i.lwip_cyclic_timer||, CODE, READONLY, ALIGN=2

                  lwip_cyclic_timer PROC
;;;231    void
;;;232    lwip_cyclic_timer(void *arg)
000000  b510              PUSH     {r4,lr}
;;;233    {
000002  4604              MOV      r4,r0
;;;234      u32_t now;
;;;235      u32_t next_timeout_time;
;;;236      const struct lwip_cyclic_timer *cyclic = (const struct lwip_cyclic_timer *)arg;
;;;237    
;;;238    #if LWIP_DEBUG_TIMERNAMES
;;;239      LWIP_DEBUGF(TIMERS_DEBUG, ("tcpip: %s()\n", cyclic->handler_name));
;;;240    #endif
;;;241      cyclic->handler();
000004  6860              LDR      r0,[r4,#4]
000006  4780              BLX      r0
;;;242    
;;;243      now = sys_now();
000008  f7fffffe          BL       sys_now
;;;244      next_timeout_time = (u32_t)(current_timeout_due_time + cyclic->interval_ms);  /* overflow handled by TIME_LESS_THAN macro */ 
00000c  4a0a              LDR      r2,|L1.56|
00000e  6821              LDR      r1,[r4,#0]
000010  6852              LDR      r2,[r2,#4]  ; current_timeout_due_time
000012  188b              ADDS     r3,r1,r2
;;;245      if (TIME_LESS_THAN(next_timeout_time, now)) {
000014  1a1a              SUBS     r2,r3,r0
000016  f1b24f00          CMP      r2,#0x80000000
00001a  d306              BCC      |L1.42|
;;;246        /* timer would immediately expire again -> "overload" -> restart without any correction */
;;;247    #if LWIP_DEBUG_TIMERNAMES
;;;248        sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg, cyclic->handler_name);
;;;249    #else
;;;250        sys_timeout_abs((u32_t)(now + cyclic->interval_ms), lwip_cyclic_timer, arg);
00001c  4622              MOV      r2,r4
00001e  4408              ADD      r0,r0,r1
000020  e8bd4010          POP      {r4,lr}
000024  4905              LDR      r1,|L1.60|
000026  f7ffbffe          B.W      sys_timeout_abs
                  |L1.42|
;;;251    #endif
;;;252    
;;;253      } else {
;;;254        /* correct cyclic interval with handler execution delay and sys_check_timeouts jitter */
;;;255    #if LWIP_DEBUG_TIMERNAMES
;;;256        sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg, cyclic->handler_name);
;;;257    #else
;;;258        sys_timeout_abs(next_timeout_time, lwip_cyclic_timer, arg);
00002a  4622              MOV      r2,r4
00002c  e8bd4010          POP      {r4,lr}
000030  4902              LDR      r1,|L1.60|
000032  4618              MOV      r0,r3
000034  f7ffbffe          B.W      sys_timeout_abs
;;;259    #endif
;;;260      }
;;;261    }
;;;262    
                          ENDP

                  |L1.56|
                          DCD      ||.data||
                  |L1.60|
                          DCD      lwip_cyclic_timer

                          AREA ||i.sys_check_timeouts||, CODE, READONLY, ALIGN=2

                  sys_check_timeouts PROC
;;;351    void
;;;352    sys_check_timeouts(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;353    {
;;;354      u32_t now;
;;;355    
;;;356      LWIP_ASSERT_CORE_LOCKED();
;;;357    
;;;358      /* Process only timers expired at the start of the function. */
;;;359      now = sys_now();
000004  f7fffffe          BL       sys_now
000008  4606              MOV      r6,r0
;;;360    
;;;361      do {
;;;362        struct sys_timeo *tmptimeout;
;;;363        sys_timeout_handler handler;
;;;364        void *arg;
;;;365    
;;;366        PBUF_CHECK_FREE_OOSEQ();
00000a  4f0f              LDR      r7,|L2.72|
;;;367    
;;;368        tmptimeout = next_timeout;
00000c  4d0f              LDR      r5,|L2.76|
                  |L2.14|
00000e  7838              LDRB     r0,[r7,#0]            ;366  ; pbuf_free_ooseq_pending
000010  b108              CBZ      r0,|L2.22|
000012  f7fffffe          BL       pbuf_free_ooseq
                  |L2.22|
000016  6829              LDR      r1,[r5,#0]  ; next_timeout
;;;369        if (tmptimeout == NULL) {
000018  2900              CMP      r1,#0
00001a  d012              BEQ      |L2.66|
;;;370          return;
;;;371        }
;;;372    
;;;373        if (TIME_LESS_THAN(now, tmptimeout->time)) {
00001c  684a              LDR      r2,[r1,#4]
00001e  1ab0              SUBS     r0,r6,r2
000020  f1b04f00          CMP      r0,#0x80000000
000024  d20d              BCS      |L2.66|
;;;374          return;
;;;375        }
;;;376    
;;;377        /* Timeout has expired */
;;;378        next_timeout = tmptimeout->next;
000026  6808              LDR      r0,[r1,#0]
000028  6028              STR      r0,[r5,#0]  ; next_timeout
;;;379        handler = tmptimeout->h;
00002a  688c              LDR      r4,[r1,#8]
;;;380        arg = tmptimeout->arg;
00002c  f8d1800c          LDR      r8,[r1,#0xc]
;;;381        current_timeout_due_time = tmptimeout->time;
000030  606a              STR      r2,[r5,#4]  ; current_timeout_due_time
;;;382    #if LWIP_DEBUG_TIMERNAMES
;;;383        if (handler != NULL) {
;;;384          LWIP_DEBUGF(TIMERS_DEBUG, ("sct calling h=%s t=%"U32_F" arg=%p\n",
;;;385                                     tmptimeout->handler_name, sys_now() - tmptimeout->time, arg));
;;;386        }
;;;387    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;388        memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
000032  2006              MOVS     r0,#6
000034  f7fffffe          BL       memp_free
;;;389        if (handler != NULL) {
000038  2c00              CMP      r4,#0
00003a  d0e8              BEQ      |L2.14|
;;;390          handler(arg);
00003c  4640              MOV      r0,r8
00003e  47a0              BLX      r4
000040  e7e5              B        |L2.14|
                  |L2.66|
;;;391        }
;;;392        LWIP_TCPIP_THREAD_ALIVE();
;;;393    
;;;394        /* Repeat until all expired timers have been called */
;;;395      } while (1);
;;;396    }
000042  e8bd81f0          POP      {r4-r8,pc}
;;;397    
                          ENDP

000046  0000              DCW      0x0000
                  |L2.72|
                          DCD      pbuf_free_ooseq_pending
                  |L2.76|
                          DCD      ||.data||

                          AREA ||i.sys_restart_timeouts||, CODE, READONLY, ALIGN=2

                  sys_restart_timeouts PROC
;;;403    void
;;;404    sys_restart_timeouts(void)
000000  b510              PUSH     {r4,lr}
;;;405    {
;;;406      u32_t now;
;;;407      u32_t base;
;;;408      struct sys_timeo *t;
;;;409    
;;;410      if (next_timeout == NULL) {
000002  4c08              LDR      r4,|L3.36|
000004  6820              LDR      r0,[r4,#0]  ; next_timeout
000006  2800              CMP      r0,#0
000008  d00b              BEQ      |L3.34|
;;;411        return;
;;;412      }
;;;413    
;;;414      now = sys_now();
00000a  f7fffffe          BL       sys_now
;;;415      base = next_timeout->time;
00000e  6821              LDR      r1,[r4,#0]  ; next_timeout
000010  684a              LDR      r2,[r1,#4]
;;;416    
;;;417      for (t = next_timeout; t != NULL; t = t->next) {
000012  e004              B        |L3.30|
                  |L3.20|
;;;418        t->time = (t->time - base) + now;
000014  684b              LDR      r3,[r1,#4]
000016  1a9b              SUBS     r3,r3,r2
000018  4403              ADD      r3,r3,r0
00001a  604b              STR      r3,[r1,#4]
00001c  6809              LDR      r1,[r1,#0]            ;417
                  |L3.30|
00001e  2900              CMP      r1,#0                 ;417
000020  d1f8              BNE      |L3.20|
                  |L3.34|
;;;419      }
;;;420    }
000022  bd10              POP      {r4,pc}
;;;421    
                          ENDP

                  |L3.36|
                          DCD      ||.data||

                          AREA ||i.sys_timeout||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  sys_timeout PROC
;;;289    void
;;;290    sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;291    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;292    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;293      u32_t next_timeout_time;
;;;294    
;;;295      LWIP_ASSERT_CORE_LOCKED();
;;;296    
;;;297      LWIP_ASSERT("Timeout time too long, max is LWIP_UINT32_MAX/4 msecs", msecs <= (LWIP_UINT32_MAX / 4));
000008  f1b44f80          CMP      r4,#0x40000000
00000c  d306              BCC      |L4.28|
00000e  a308              ADR      r3,|L4.48|
000010  f2401229          MOV      r2,#0x129
000014  a113              ADR      r1,|L4.100|
000016  a021              ADR      r0,|L4.156|
000018  f7fffffe          BL       __2printf
                  |L4.28|
;;;298    
;;;299      next_timeout_time = (u32_t)(sys_now() + msecs); /* overflow handled by TIME_LESS_THAN macro */ 
00001c  f7fffffe          BL       sys_now
000020  4420              ADD      r0,r0,r4
;;;300    
;;;301    #if LWIP_DEBUG_TIMERNAMES
;;;302      sys_timeout_abs(next_timeout_time, handler, arg, handler_name);
;;;303    #else
;;;304      sys_timeout_abs(next_timeout_time, handler, arg);
000022  4632              MOV      r2,r6
000024  4629              MOV      r1,r5
000026  e8bd4070          POP      {r4-r6,lr}
00002a  f7ffbffe          B.W      sys_timeout_abs
;;;305    #endif
;;;306    }
;;;307    
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
000030  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\timeouts"
000034  6964646c
000038  65776172
00003c  65735c54
000040  68697264
000044  5f506172
000048  74795c4c
00004c  7749505c
000050  7372635c
000054  636f7265
000058  5c74696d
00005c  656f7574
000060  73      
000061  2e6300            DCB      ".c",0
                  |L4.100|
000064  54696d65          DCB      "Timeout time too long, max is LWIP_UINT32_MAX/4 msecs",0
000068  6f757420
00006c  74696d65
000070  20746f6f
000074  206c6f6e
000078  672c206d
00007c  61782069
000080  73204c57
000084  49505f55
000088  494e5433
00008c  325f4d41
000090  582f3420
000094  6d736563
000098  7300    
00009a  00                DCB      0
00009b  00                DCB      0
                  |L4.156|
00009c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000a0  7274696f
0000a4  6e202225
0000a8  73222066
0000ac  61696c65
0000b0  64206174
0000b4  206c696e
0000b8  65202564
0000bc  20696e20
0000c0  25730a00

                          AREA ||i.sys_timeout_abs||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  sys_timeout_abs PROC
;;;182    #else /* LWIP_DEBUG_TIMERNAMES */
;;;183    sys_timeout_abs(u32_t abs_time, sys_timeout_handler handler, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;184    #endif
;;;185    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;186      struct sys_timeo *timeout, *t;
;;;187    
;;;188      timeout = (struct sys_timeo *)memp_malloc(MEMP_SYS_TIMEOUT);
000008  2006              MOVS     r0,#6
00000a  f7fffffe          BL       memp_malloc
;;;189      if (timeout == NULL) {
00000e  b188              CBZ      r0,|L5.52|
;;;190        LWIP_ASSERT("sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is empty", timeout != NULL);
;;;191        return;
;;;192      }
;;;193    
;;;194      timeout->next = NULL;
000010  2200              MOVS     r2,#0
000012  6002              STR      r2,[r0,#0]
;;;195      timeout->h = handler;
000014  6085              STR      r5,[r0,#8]
;;;196      timeout->arg = arg;
000016  60c6              STR      r6,[r0,#0xc]
;;;197      timeout->time = abs_time;
000018  6044              STR      r4,[r0,#4]
;;;198    
;;;199    #if LWIP_DEBUG_TIMERNAMES
;;;200      timeout->handler_name = handler_name;
;;;201      LWIP_DEBUGF(TIMERS_DEBUG, ("sys_timeout: %p abs_time=%"U32_F" handler=%s arg=%p\n",
;;;202                                 (void *)timeout, abs_time, handler_name, (void *)arg));
;;;203    #endif /* LWIP_DEBUG_TIMERNAMES */
;;;204    
;;;205      if (next_timeout == NULL) {
00001a  4a12              LDR      r2,|L5.100|
00001c  6811              LDR      r1,[r2,#0]  ; next_timeout
00001e  2900              CMP      r1,#0
000020  d010              BEQ      |L5.68|
;;;206        next_timeout = timeout;
;;;207        return;
;;;208      }
;;;209      if (TIME_LESS_THAN(timeout->time, next_timeout->time)) {
000022  684b              LDR      r3,[r1,#4]
000024  f04f4500          MOV      r5,#0x80000000
000028  1ae3              SUBS     r3,r4,r3
00002a  42ab              CMP      r3,r5
00002c  d315              BCC      |L5.90|
;;;210        timeout->next = next_timeout;
00002e  6001              STR      r1,[r0,#0]
;;;211        next_timeout = timeout;
000030  6010              STR      r0,[r2,#0]  ; next_timeout
;;;212      } else {
;;;213        for (t = next_timeout; t != NULL; t = t->next) {
;;;214          if ((t->next == NULL) || TIME_LESS_THAN(timeout->time, t->next->time)) {
;;;215            timeout->next = t->next;
;;;216            t->next = timeout;
;;;217            break;
;;;218          }
;;;219        }
;;;220      }
;;;221    }
000032  bd70              POP      {r4-r6,pc}
                  |L5.52|
000034  e8bd4070          POP      {r4-r6,lr}            ;190
000038  a30b              ADR      r3,|L5.104|
00003a  22be              MOVS     r2,#0xbe              ;190
00003c  a117              ADR      r1,|L5.156|
00003e  a027              ADR      r0,|L5.220|
000040  f7ffbffe          B.W      __2printf
                  |L5.68|
000044  6010              STR      r0,[r2,#0]            ;206  ; next_timeout
000046  bd70              POP      {r4-r6,pc}
                  |L5.72|
000048  6853              LDR      r3,[r2,#4]            ;214
00004a  1ae3              SUBS     r3,r4,r3              ;214
00004c  42ab              CMP      r3,r5                 ;214
00004e  d303              BCC      |L5.88|
                  |L5.80|
000050  680a              LDR      r2,[r1,#0]            ;215
000052  6002              STR      r2,[r0,#0]            ;215
000054  6008              STR      r0,[r1,#0]            ;216
000056  bd70              POP      {r4-r6,pc}
                  |L5.88|
000058  4611              MOV      r1,r2                 ;213
                  |L5.90|
00005a  680a              LDR      r2,[r1,#0]            ;214
00005c  2a00              CMP      r2,#0                 ;213
00005e  d0f7              BEQ      |L5.80|
000060  e7f2              B        |L5.72|
;;;222    
                          ENDP

000062  0000              DCW      0x0000
                  |L5.100|
                          DCD      ||.data||
                  |L5.104|
000068  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\timeouts"
00006c  6964646c
000070  65776172
000074  65735c54
000078  68697264
00007c  5f506172
000080  74795c4c
000084  7749505c
000088  7372635c
00008c  636f7265
000090  5c74696d
000094  656f7574
000098  73      
000099  2e6300            DCB      ".c",0
                  |L5.156|
00009c  7379735f          DCB      "sys_timeout: timeout != NULL, pool MEMP_SYS_TIMEOUT is "
0000a0  74696d65
0000a4  6f75743a
0000a8  2074696d
0000ac  656f7574
0000b0  20213d20
0000b4  4e554c4c
0000b8  2c20706f
0000bc  6f6c204d
0000c0  454d505f
0000c4  5359535f
0000c8  54494d45
0000cc  4f555420
0000d0  697320  
0000d3  656d7074          DCB      "empty",0
0000d7  7900    
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L5.220|
0000dc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000e0  7274696f
0000e4  6e202225
0000e8  73222066
0000ec  61696c65
0000f0  64206174
0000f4  206c696e
0000f8  65202564
0000fc  20696e20
000100  25730a00

                          AREA ||i.sys_timeouts_init||, CODE, READONLY, ALIGN=2

                  sys_timeouts_init PROC
;;;263    /** Initialize this module */
;;;264    void sys_timeouts_init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;265    {
;;;266      size_t i;
;;;267      /* tcp_tmr() at index 0 is started on demand */
;;;268      for (i = (LWIP_TCP ? 1 : 0); i < LWIP_ARRAYSIZE(lwip_cyclic_timers); i++) {
000002  2401              MOVS     r4,#1
;;;269        /* we have to cast via size_t to get rid of const warning
;;;270          (this is OK as cyclic_timer() casts back to const* */
;;;271        sys_timeout(lwip_cyclic_timers[i].interval_ms, lwip_cyclic_timer, LWIP_CONST_CAST(void *, &lwip_cyclic_timers[i]));
000004  4d05              LDR      r5,|L6.28|
                  |L6.6|
000006  4906              LDR      r1,|L6.32|
000008  eb0502c4          ADD      r2,r5,r4,LSL #3
00000c  f8550034          LDR      r0,[r5,r4,LSL #3]
000010  f7fffffe          BL       sys_timeout
000014  1c64              ADDS     r4,r4,#1              ;268
000016  2c06              CMP      r4,#6                 ;268
000018  d3f5              BCC      |L6.6|
;;;272      }
;;;273    }
00001a  bd70              POP      {r4-r6,pc}
;;;274    
                          ENDP

                  |L6.28|
                          DCD      ||.constdata||
                  |L6.32|
                          DCD      lwip_cyclic_timer

                          AREA ||i.sys_timeouts_sleeptime||, CODE, READONLY, ALIGN=2

                  sys_timeouts_sleeptime PROC
;;;425    u32_t
;;;426    sys_timeouts_sleeptime(void)
000000  b510              PUSH     {r4,lr}
;;;427    {
;;;428      u32_t now;
;;;429    
;;;430      LWIP_ASSERT_CORE_LOCKED();
;;;431    
;;;432      if (next_timeout == NULL) {
000002  4c08              LDR      r4,|L7.36|
000004  6820              LDR      r0,[r4,#0]  ; next_timeout
000006  2800              CMP      r0,#0
000008  d009              BEQ      |L7.30|
;;;433        return SYS_TIMEOUTS_SLEEPTIME_INFINITE;
;;;434      }
;;;435      now = sys_now();
00000a  f7fffffe          BL       sys_now
;;;436      if (TIME_LESS_THAN(next_timeout->time, now)) {
00000e  6821              LDR      r1,[r4,#0]  ; next_timeout
000010  6849              LDR      r1,[r1,#4]
000012  1a08              SUBS     r0,r1,r0
000014  f1b04f00          CMP      r0,#0x80000000
000018  d300              BCC      |L7.28|
;;;437        return 0;
00001a  2000              MOVS     r0,#0
                  |L7.28|
;;;438      } else {
;;;439        u32_t ret = (u32_t)(next_timeout->time - now);
;;;440        LWIP_ASSERT("invalid sleeptime", ret <= LWIP_MAX_TIMEOUT);
;;;441        return ret;
;;;442      }
;;;443    }
00001c  bd10              POP      {r4,pc}
                  |L7.30|
00001e  f04f30ff          MOV      r0,#0xffffffff        ;433
000022  bd10              POP      {r4,pc}
;;;444    
                          ENDP

                  |L7.36|
                          DCD      ||.data||

                          AREA ||i.sys_untimeout||, CODE, READONLY, ALIGN=2

                  sys_untimeout PROC
;;;316    void
;;;317    sys_untimeout(sys_timeout_handler handler, void *arg)
000000  b430              PUSH     {r4,r5}
;;;318    {
000002  460b              MOV      r3,r1
;;;319      struct sys_timeo *prev_t, *t;
;;;320    
;;;321      LWIP_ASSERT_CORE_LOCKED();
;;;322    
;;;323      if (next_timeout == NULL) {
000004  4d0d              LDR      r5,|L8.60|
000006  6829              LDR      r1,[r5,#0]  ; next_timeout
000008  2900              CMP      r1,#0
00000a  d015              BEQ      |L8.56|
;;;324        return;
;;;325      }
;;;326    
;;;327      for (t = next_timeout, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
00000c  2200              MOVS     r2,#0
00000e  e011              B        |L8.52|
                  |L8.16|
;;;328        if ((t->h == handler) && (t->arg == arg)) {
000010  688c              LDR      r4,[r1,#8]
000012  4284              CMP      r4,r0
000014  d10c              BNE      |L8.48|
000016  68cc              LDR      r4,[r1,#0xc]
000018  429c              CMP      r4,r3
00001a  d109              BNE      |L8.48|
;;;329          /* We have a match */
;;;330          /* Unlink from previous in list */
;;;331          if (prev_t == NULL) {
00001c  b12a              CBZ      r2,|L8.42|
;;;332            next_timeout = t->next;
;;;333          } else {
;;;334            prev_t->next = t->next;
00001e  6808              LDR      r0,[r1,#0]
000020  6010              STR      r0,[r2,#0]
                  |L8.34|
;;;335          }
;;;336          memp_free(MEMP_SYS_TIMEOUT, t);
000022  bc30              POP      {r4,r5}
000024  2006              MOVS     r0,#6
000026  f7ffbffe          B.W      memp_free
                  |L8.42|
00002a  6808              LDR      r0,[r1,#0]            ;332
00002c  6028              STR      r0,[r5,#0]            ;332  ; next_timeout
00002e  e7f8              B        |L8.34|
                  |L8.48|
000030  460a              MOV      r2,r1                 ;327
000032  6809              LDR      r1,[r1,#0]            ;327
                  |L8.52|
000034  2900              CMP      r1,#0                 ;327
000036  d1eb              BNE      |L8.16|
                  |L8.56|
;;;337          return;
;;;338        }
;;;339      }
;;;340      return;
;;;341    }
000038  bc30              POP      {r4,r5}
00003a  4770              BX       lr
;;;342    
                          ENDP

                  |L8.60|
                          DCD      ||.data||

                          AREA ||i.tcp_timer_needed||, CODE, READONLY, ALIGN=2

                  tcp_timer_needed PROC
;;;165    void
;;;166    tcp_timer_needed(void)
000000  4808              LDR      r0,|L9.36|
;;;167    {
;;;168      LWIP_ASSERT_CORE_LOCKED();
;;;169    
;;;170      /* timer is off but needed again? */
;;;171      if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
000002  6881              LDR      r1,[r0,#8]  ; tcpip_tcp_timer_active
000004  2900              CMP      r1,#0
000006  d10c              BNE      |L9.34|
000008  4907              LDR      r1,|L9.40|
00000a  4a08              LDR      r2,|L9.44|
00000c  6809              LDR      r1,[r1,#0]  ; tcp_active_pcbs
00000e  6812              LDR      r2,[r2,#0]  ; tcp_tw_pcbs
000010  4311              ORRS     r1,r1,r2
000012  d006              BEQ      |L9.34|
;;;172        /* enable and start timer */
;;;173        tcpip_tcp_timer_active = 1;
000014  2101              MOVS     r1,#1
000016  6081              STR      r1,[r0,#8]  ; tcpip_tcp_timer_active
;;;174        sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
000018  2200              MOVS     r2,#0
00001a  4905              LDR      r1,|L9.48|
00001c  20fa              MOVS     r0,#0xfa
00001e  f7ffbffe          B.W      sys_timeout
                  |L9.34|
;;;175      }
;;;176    }
000022  4770              BX       lr
;;;177    #endif /* LWIP_TCP */
                          ENDP

                  |L9.36|
                          DCD      ||.data||
                  |L9.40|
                          DCD      tcp_active_pcbs
                  |L9.44|
                          DCD      tcp_tw_pcbs
                  |L9.48|
                          DCD      tcpip_tcp_timer

                          AREA ||i.tcpip_tcp_timer||, CODE, READONLY, ALIGN=2

                  tcpip_tcp_timer PROC
;;;143    static void
;;;144    tcpip_tcp_timer(void *arg)
000000  b510              PUSH     {r4,lr}
;;;145    {
;;;146      LWIP_UNUSED_ARG(arg);
;;;147    
;;;148      /* call TCP timer handler */
;;;149      tcp_tmr();
000002  f7fffffe          BL       tcp_tmr
;;;150      /* timer still needed? */
;;;151      if (tcp_active_pcbs || tcp_tw_pcbs) {
000006  4808              LDR      r0,|L10.40|
000008  4908              LDR      r1,|L10.44|
00000a  6800              LDR      r0,[r0,#0]  ; tcp_active_pcbs
00000c  6809              LDR      r1,[r1,#0]  ; tcp_tw_pcbs
00000e  4308              ORRS     r0,r0,r1
000010  d006              BEQ      |L10.32|
;;;152        /* restart timer */
;;;153        sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
000012  2200              MOVS     r2,#0
000014  e8bd4010          POP      {r4,lr}
000018  4905              LDR      r1,|L10.48|
00001a  20fa              MOVS     r0,#0xfa
00001c  f7ffbffe          B.W      sys_timeout
                  |L10.32|
;;;154      } else {
;;;155        /* disable timer */
;;;156        tcpip_tcp_timer_active = 0;
000020  4904              LDR      r1,|L10.52|
000022  2000              MOVS     r0,#0
000024  6088              STR      r0,[r1,#8]  ; tcpip_tcp_timer_active
;;;157      }
;;;158    }
000026  bd10              POP      {r4,pc}
;;;159    
                          ENDP

                  |L10.40|
                          DCD      tcp_active_pcbs
                  |L10.44|
                          DCD      tcp_tw_pcbs
                  |L10.48|
                          DCD      tcpip_tcp_timer
                  |L10.52|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  lwip_cyclic_timers
                          DCD      0x000000fa
                          DCD      tcp_tmr
                          DCD      0x000003e8
                          DCD      ip_reass_tmr
                          DCD      0x000003e8
                          DCD      etharp_tmr
                          DCD      0x0000ea60
                          DCD      dhcp_coarse_tmr
                          DCD      0x000001f4
                          DCD      dhcp_fine_tmr
                          DCD      0x000003e8
                          DCD      dns_tmr

                          AREA ||area_number.14||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.constdata||
                  lwip_num_cyclic_timers
                          DCD      0x00000006

                          AREA ||.data||, DATA, ALIGN=2

                  next_timeout
                          DCD      0x00000000
                  current_timeout_due_time
                          DCD      0x00000000
                  tcpip_tcp_timer_active
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\timeouts.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_timeouts_c_6f3cbd76____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_timeouts_c_6f3cbd76____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_timeouts_c_6f3cbd76____REVSH|
#line 478
|__asm___10_timeouts_c_6f3cbd76____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_timeouts_c_6f3cbd76____RRX|
#line 665
|__asm___10_timeouts_c_6f3cbd76____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
