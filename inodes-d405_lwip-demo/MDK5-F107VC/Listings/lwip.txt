; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\lwip.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\lwip.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\lwip.crf ..\Src\lwip.c]
                          THUMB

                          AREA ||i.MX_LWIP_Init||, CODE, READONLY, ALIGN=2

                  MX_LWIP_Init PROC
;;;60       */
;;;61     void MX_LWIP_Init(void)
000000  b53e              PUSH     {r1-r5,lr}
;;;62     {
;;;63       /* Initilialize the LwIP stack without RTOS */
;;;64       lwip_init();
000002  f7fffffe          BL       lwip_init
;;;65     
;;;66       /* IP addresses initialization with DHCP (IPv4) */
;;;67       ipaddr.addr = 0;
000006  4818              LDR      r0,|L1.104|
000008  2400              MOVS     r4,#0
00000a  6004              STR      r4,[r0,#0]  ; ipaddr
;;;68       netmask.addr = 0;
00000c  1d00              ADDS     r0,r0,#4
00000e  6004              STR      r4,[r0,#0]  ; netmask
;;;69       gw.addr = 0;
000010  1d00              ADDS     r0,r0,#4
000012  6004              STR      r4,[r0,#0]  ; gw
;;;70     
;;;71       printf(" netif_add start ! \r\n");
000014  a015              ADR      r0,|L1.108|
000016  f7fffffe          BL       __2printf
;;;72       /* add the network interface (IPv4/IPv6) without RTOS */
;;;73       netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &ethernet_input);
00001a  491b              LDR      r1,|L1.136|
00001c  4b12              LDR      r3,|L1.104|
00001e  e9cd4100          STRD     r4,r1,[sp,#0]
000022  4818              LDR      r0,|L1.132|
000024  3308              ADDS     r3,r3,#8
000026  1f1a              SUBS     r2,r3,#4
000028  9002              STR      r0,[sp,#8]
00002a  1f11              SUBS     r1,r2,#4
00002c  4817              LDR      r0,|L1.140|
00002e  f7fffffe          BL       netif_add
;;;74     
;;;75       printf(" netif_add sucess ! \r\n");
000032  a017              ADR      r0,|L1.144|
000034  f7fffffe          BL       __2printf
;;;76       /* Registers the default network interface */
;;;77       netif_set_default(&gnetif);
000038  4814              LDR      r0,|L1.140|
00003a  f7fffffe          BL       netif_set_default
;;;78     
;;;79       if (netif_is_link_up(&gnetif))
00003e  4813              LDR      r0,|L1.140|
000040  f8900035          LDRB     r0,[r0,#0x35]  ; gnetif
000044  0740              LSLS     r0,r0,#29
000046  d503              BPL      |L1.80|
;;;80       {
;;;81         /* When the netif is fully configured this function must be called */
;;;82         netif_set_up(&gnetif);
000048  4810              LDR      r0,|L1.140|
00004a  f7fffffe          BL       netif_set_up
00004e  e002              B        |L1.86|
                  |L1.80|
;;;83       }
;;;84       else
;;;85       {
;;;86         /* When the netif link is down this function must be called */
;;;87         netif_set_down(&gnetif);
000050  480e              LDR      r0,|L1.140|
000052  f7fffffe          BL       netif_set_down
                  |L1.86|
;;;88       }
;;;89     
;;;90       /* Set the link callback function, this function is called on change of link status*/
;;;91       netif_set_link_callback(&gnetif, ethernetif_update_config);
000056  4914              LDR      r1,|L1.168|
000058  480c              LDR      r0,|L1.140|
00005a  f7fffffe          BL       netif_set_link_callback
;;;92     
;;;93       /* Create the Ethernet link handler thread */
;;;94     
;;;95       /* Start DHCP negotiation for a network interface (IPv4) */
;;;96       dhcp_start(&gnetif);
00005e  e8bd403e          POP      {r1-r5,lr}
000062  480a              LDR      r0,|L1.140|
000064  f7ffbffe          B.W      dhcp_start
;;;97     
;;;98     /* USER CODE BEGIN 3 */
;;;99     
;;;100    /* USER CODE END 3 */
;;;101    }
;;;102    
                          ENDP

                  |L1.104|
                          DCD      ||area_number.12||
                  |L1.108|
00006c  206e6574          DCB      " netif_add start ! \r\n",0
000070  69665f61
000074  64642073
000078  74617274
00007c  2021200d
000080  0a00    
000082  00                DCB      0
000083  00                DCB      0
                  |L1.132|
                          DCD      ethernet_input
                  |L1.136|
                          DCD      ethernetif_init
                  |L1.140|
                          DCD      ||.bss||
                  |L1.144|
000090  206e6574          DCB      " netif_add sucess ! \r\n",0
000094  69665f61
000098  64642073
00009c  75636573
0000a0  73202120
0000a4  0d0a00  
0000a7  00                DCB      0
                  |L1.168|
                          DCD      ethernetif_update_config

                          AREA ||i.MX_LWIP_Process||, CODE, READONLY, ALIGN=2

                  MX_LWIP_Process PROC
;;;120     */
;;;121    void MX_LWIP_Process(void)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123    /* USER CODE BEGIN 4_1 */
;;;124    /* USER CODE END 4_1 */
;;;125      ethernetif_input(&gnetif);
000002  4803              LDR      r0,|L2.16|
000004  f7fffffe          BL       ethernetif_input
;;;126    
;;;127    /* USER CODE BEGIN 4_2 */
;;;128    /* USER CODE END 4_2 */
;;;129      /* Handle timeouts */
;;;130      sys_check_timeouts();
000008  e8bd4010          POP      {r4,lr}
00000c  f7ffbffe          B.W      sys_check_timeouts
;;;131    
;;;132    /* USER CODE BEGIN 4_3 */
;;;133    /* USER CODE END 4_3 */
;;;134    }
;;;135    
                          ENDP

                  |L2.16|
                          DCD      ||.bss||

                          AREA ||i.sio_open||, CODE, READONLY, ALIGN=1

                  sio_open PROC
;;;142     */
;;;143    sio_fd_t sio_open(u8_t devnum)
000000  2000              MOVS     r0,#0
;;;144    {
;;;145      sio_fd_t sd;
;;;146    
;;;147    /* USER CODE BEGIN 7 */
;;;148      sd = 0; // dummy code
;;;149    /* USER CODE END 7 */
;;;150    
;;;151      return sd;
;;;152    }
000002  4770              BX       lr
;;;153    
                          ENDP


                          AREA ||i.sio_read||, CODE, READONLY, ALIGN=1

                  sio_read PROC
;;;178     */
;;;179    u32_t sio_read(sio_fd_t fd, u8_t *data, u32_t len)
000000  2000              MOVS     r0,#0
;;;180    {
;;;181      u32_t recved_bytes;
;;;182    
;;;183    /* USER CODE BEGIN 9 */
;;;184      recved_bytes = 0; // dummy code
;;;185    /* USER CODE END 9 */
;;;186      return recved_bytes;
;;;187    }
000002  4770              BX       lr
;;;188    
                          ENDP


                          AREA ||i.sio_send||, CODE, READONLY, ALIGN=1

                  sio_send PROC
;;;161     */
;;;162    void sio_send(u8_t c, sio_fd_t fd)
000000  4770              BX       lr
;;;163    {
;;;164    /* USER CODE BEGIN 8 */
;;;165    /* USER CODE END 8 */
;;;166    }
;;;167    
                          ENDP


                          AREA ||i.sio_tryread||, CODE, READONLY, ALIGN=1

                  sio_tryread PROC
;;;197     */
;;;198    u32_t sio_tryread(sio_fd_t fd, u8_t *data, u32_t len)
000000  2000              MOVS     r0,#0
;;;199    {
;;;200      u32_t recved_bytes;
;;;201    
;;;202    /* USER CODE BEGIN 10 */
;;;203      recved_bytes = 0; // dummy code
;;;204    /* USER CODE END 10 */
;;;205      return recved_bytes;
;;;206    }
000002  4770              BX       lr
;;;207    #endif /* MDK ARM Compiler */
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  gnetif
                          %        60

                          AREA ||.data||, DATA, ALIGN=2

                  DHCPfineTimer
                          DCD      0x00000000

                          AREA ||area_number.11||, DATA, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.data||
                  DHCPcoarseTimer
                          DCD      0x00000000

                          AREA ||area_number.12||, DATA, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.data||
                  ipaddr
                          DCD      0x00000000
                  netmask
                          DCD      0x00000000
                  ||gw||
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Src\\lwip.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_lwip_c_bccf69fb____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_lwip_c_bccf69fb____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_lwip_c_bccf69fb____REVSH|
#line 478
|__asm___6_lwip_c_bccf69fb____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_lwip_c_bccf69fb____RRX|
#line 665
|__asm___6_lwip_c_bccf69fb____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
