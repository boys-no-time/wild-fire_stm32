; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\stm32f1xx_hal.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f1xx_hal.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\stm32f1xx_hal.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal.c]
                          THUMB

                          AREA ||i.HAL_DBGMCU_DisableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGSleepMode PROC
;;;505      */
;;;506    void HAL_DBGMCU_DisableDBGSleepMode(void)
000000  4802              LDR      r0,|L1.12|
;;;507    {
;;;508      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6841              LDR      r1,[r0,#4]
000004  f0210101          BIC      r1,r1,#1
000008  6041              STR      r1,[r0,#4]
;;;509    }
00000a  4770              BX       lr
;;;510    
                          ENDP

                  |L1.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStandbyMode PROC
;;;583      */
;;;584    void HAL_DBGMCU_DisableDBGStandbyMode(void)
000000  4802              LDR      r0,|L2.12|
;;;585    {
;;;586      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6841              LDR      r1,[r0,#4]
000004  f0210104          BIC      r1,r1,#4
000008  6041              STR      r1,[r0,#4]
;;;587    }
00000a  4770              BX       lr
;;;588    
                          ENDP

                  |L2.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_DisableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_DisableDBGStopMode PROC
;;;551      */
;;;552    void HAL_DBGMCU_DisableDBGStopMode(void)
000000  4802              LDR      r0,|L3.12|
;;;553    {
;;;554      CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  f0210102          BIC      r1,r1,#2
000008  6041              STR      r1,[r0,#4]
;;;555    }
00000a  4770              BX       lr
;;;556    
                          ENDP

                  |L3.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGSleepMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGSleepMode PROC
;;;489      */
;;;490    void HAL_DBGMCU_EnableDBGSleepMode(void)
000000  4802              LDR      r0,|L4.12|
;;;491    {
;;;492      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_SLEEP);
000002  6841              LDR      r1,[r0,#4]
000004  f0410101          ORR      r1,r1,#1
000008  6041              STR      r1,[r0,#4]
;;;493    }
00000a  4770              BX       lr
;;;494    
                          ENDP

                  |L4.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStandbyMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStandbyMode PROC
;;;567      */
;;;568    void HAL_DBGMCU_EnableDBGStandbyMode(void)
000000  4802              LDR      r0,|L5.12|
;;;569    {
;;;570      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STANDBY);
000002  6841              LDR      r1,[r0,#4]
000004  f0410104          ORR      r1,r1,#4
000008  6041              STR      r1,[r0,#4]
;;;571    }
00000a  4770              BX       lr
;;;572    
                          ENDP

                  |L5.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DBGMCU_EnableDBGStopMode||, CODE, READONLY, ALIGN=2

                  HAL_DBGMCU_EnableDBGStopMode PROC
;;;535      */
;;;536    void HAL_DBGMCU_EnableDBGStopMode(void)
000000  4802              LDR      r0,|L6.12|
;;;537    {
;;;538      SET_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
000002  6841              LDR      r1,[r0,#4]
000004  f0410102          ORR      r1,r1,#2
000008  6041              STR      r1,[r0,#4]
;;;539    }
00000a  4770              BX       lr
;;;540    
                          ENDP

                  |L6.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_DeInit PROC
;;;174      */
;;;175    HAL_StatusTypeDef HAL_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;176    {
;;;177      /* Reset of all peripherals */
;;;178      __HAL_RCC_APB1_FORCE_RESET();
000002  4807              LDR      r0,|L7.32|
000004  f04f31ff          MOV      r1,#0xffffffff
000008  60c1              STR      r1,[r0,#0xc]
;;;179      __HAL_RCC_APB1_RELEASE_RESET();
00000a  2200              MOVS     r2,#0
00000c  6102              STR      r2,[r0,#0x10]
;;;180    
;;;181      __HAL_RCC_APB2_FORCE_RESET();
00000e  60c1              STR      r1,[r0,#0xc]
;;;182      __HAL_RCC_APB2_RELEASE_RESET();
000010  60c2              STR      r2,[r0,#0xc]
;;;183    
;;;184    #if defined(STM32F105xC) || defined(STM32F107xC)
;;;185      __HAL_RCC_AHB_FORCE_RESET();
000012  6281              STR      r1,[r0,#0x28]
;;;186      __HAL_RCC_AHB_RELEASE_RESET();
000014  6282              STR      r2,[r0,#0x28]
;;;187    #endif
;;;188    
;;;189      /* De-Init the low level hardware */
;;;190      HAL_MspDeInit();
000016  f7fffffe          BL       HAL_MspDeInit
;;;191    
;;;192      /* Return function status */
;;;193      return HAL_OK;
00001a  2000              MOVS     r0,#0
;;;194    }
00001c  bd10              POP      {r4,pc}
;;;195    
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      0x40021000

                          AREA ||i.HAL_Delay||, CODE, READONLY, ALIGN=2

                  HAL_Delay PROC
;;;369      */
;;;370    __weak void HAL_Delay(uint32_t Delay)
000000  b570              PUSH     {r4-r6,lr}
;;;371    {
000002  4604              MOV      r4,r0
;;;372      uint32_t tickstart = HAL_GetTick();
000004  f7fffffe          BL       HAL_GetTick
000008  4605              MOV      r5,r0
;;;373      uint32_t wait = Delay;
;;;374    
;;;375      /* Add a freq to guarantee minimum wait */
;;;376      if (wait < HAL_MAX_DELAY)
00000a  1c60              ADDS     r0,r4,#1
00000c  d002              BEQ      |L8.20|
;;;377      {
;;;378        wait += (uint32_t)(uwTickFreq);
00000e  4804              LDR      r0,|L8.32|
000010  7800              LDRB     r0,[r0,#0]  ; uwTickFreq
000012  4404              ADD      r4,r4,r0
                  |L8.20|
;;;379      }
;;;380    
;;;381      while ((HAL_GetTick() - tickstart) < wait)
000014  f7fffffe          BL       HAL_GetTick
000018  1b40              SUBS     r0,r0,r5
00001a  42a0              CMP      r0,r4
00001c  d3fa              BCC      |L8.20|
;;;382      {
;;;383      }
;;;384    }
00001e  bd70              POP      {r4-r6,pc}
;;;385    
                          ENDP

                  |L8.32|
                          DCD      ||.data||

                          AREA ||i.HAL_GetDEVID||, CODE, READONLY, ALIGN=2

                  HAL_GetDEVID PROC
;;;453      */
;;;454    uint32_t HAL_GetDEVID(void)
000000  4802              LDR      r0,|L9.12|
;;;455    {
;;;456      return ((DBGMCU->IDCODE) & IDCODE_DEVID_MASK);
000002  6800              LDR      r0,[r0,#0]
000004  f3c0000b          UBFX     r0,r0,#0,#12
;;;457    }
000008  4770              BX       lr
;;;458    
                          ENDP

00000a  0000              DCW      0x0000
                  |L9.12|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetHalVersion||, CODE, READONLY, ALIGN=2

                  HAL_GetHalVersion PROC
;;;421      */
;;;422    uint32_t HAL_GetHalVersion(void)
000000  4800              LDR      r0,|L10.4|
;;;423    {
;;;424      return __STM32F1xx_HAL_VERSION;
;;;425    }
000002  4770              BX       lr
;;;426    
                          ENDP

                  |L10.4|
                          DCD      0x01010600

                          AREA ||i.HAL_GetREVID||, CODE, READONLY, ALIGN=2

                  HAL_GetREVID PROC
;;;437      */
;;;438    uint32_t HAL_GetREVID(void)
000000  4801              LDR      r0,|L11.8|
;;;439    {
;;;440      return ((DBGMCU->IDCODE) >> DBGMCU_IDCODE_REV_ID_Pos);
000002  6800              LDR      r0,[r0,#0]
000004  0c00              LSRS     r0,r0,#16
;;;441    }
000006  4770              BX       lr
;;;442    
                          ENDP

                  |L11.8|
                          DCD      0xe0042000

                          AREA ||i.HAL_GetTick||, CODE, READONLY, ALIGN=2

                  HAL_GetTick PROC
;;;303      */
;;;304    __weak uint32_t HAL_GetTick(void)
000000  4801              LDR      r0,|L12.8|
;;;305    {
;;;306      return uwTick;
000002  6880              LDR      r0,[r0,#8]  ; uwTick
;;;307    }
000004  4770              BX       lr
;;;308    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetTickFreq||, CODE, READONLY, ALIGN=2

                  HAL_GetTickFreq PROC
;;;353      */
;;;354    HAL_TickFreqTypeDef HAL_GetTickFreq(void)
000000  4801              LDR      r0,|L13.8|
;;;355    {
;;;356      return uwTickFreq;
000002  7800              LDRB     r0,[r0,#0]  ; uwTickFreq
;;;357    }
000004  4770              BX       lr
;;;358    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetTickPrio||, CODE, READONLY, ALIGN=2

                  HAL_GetTickPrio PROC
;;;312      */
;;;313    uint32_t HAL_GetTickPrio(void)
000000  4801              LDR      r0,|L14.8|
;;;314    {
;;;315      return uwTickPrio;
000002  6840              LDR      r0,[r0,#4]  ; uwTickPrio
;;;316    }
000004  4770              BX       lr
;;;317    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      ||.data||

                          AREA ||i.HAL_GetUIDw0||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw0 PROC
;;;462      */
;;;463    uint32_t HAL_GetUIDw0(void)
000000  4801              LDR      r0,|L15.8|
;;;464    {
;;;465       return(READ_REG(*((uint32_t *)UID_BASE)));
000002  6800              LDR      r0,[r0,#0]
;;;466    }
000004  4770              BX       lr
;;;467    
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      0x1ffff7e8

                          AREA ||i.HAL_GetUIDw1||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw1 PROC
;;;471      */
;;;472    uint32_t HAL_GetUIDw1(void)
000000  4801              LDR      r0,|L16.8|
;;;473    {
;;;474       return(READ_REG(*((uint32_t *)(UID_BASE + 4U))));
000002  6800              LDR      r0,[r0,#0]
;;;475    }
000004  4770              BX       lr
;;;476    
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      0x1ffff7ec

                          AREA ||i.HAL_GetUIDw2||, CODE, READONLY, ALIGN=2

                  HAL_GetUIDw2 PROC
;;;480      */
;;;481    uint32_t HAL_GetUIDw2(void)
000000  4801              LDR      r0,|L17.8|
;;;482    {
;;;483       return(READ_REG(*((uint32_t *)(UID_BASE + 8U))));
000002  6800              LDR      r0,[r0,#0]
;;;484    }
000004  4770              BX       lr
;;;485    
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x1ffff7f0

                          AREA ||i.HAL_IncTick||, CODE, READONLY, ALIGN=2

                  HAL_IncTick PROC
;;;292      */
;;;293    __weak void HAL_IncTick(void)
000000  4802              LDR      r0,|L18.12|
;;;294    {
;;;295      uwTick += uwTickFreq;
000002  6881              LDR      r1,[r0,#8]  ; uwTick
000004  7802              LDRB     r2,[r0,#0]  ; uwTickFreq
000006  4411              ADD      r1,r1,r2
000008  6081              STR      r1,[r0,#8]  ; uwTick
;;;296    }
00000a  4770              BX       lr
;;;297    
                          ENDP

                  |L18.12|
                          DCD      ||.data||

                          AREA ||i.HAL_Init||, CODE, READONLY, ALIGN=2

                  HAL_Init PROC
;;;141      */
;;;142    HAL_StatusTypeDef HAL_Init(void)
000000  b510              PUSH     {r4,lr}
;;;143    {
;;;144      /* Configure Flash prefetch */
;;;145    #if (PREFETCH_ENABLE != 0)
;;;146    #if defined(STM32F101x6) || defined(STM32F101xB) || defined(STM32F101xE) || defined(STM32F101xG) || \
;;;147        defined(STM32F102x6) || defined(STM32F102xB) || \
;;;148        defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
;;;149        defined(STM32F105xC) || defined(STM32F107xC)
;;;150    
;;;151      /* Prefetch buffer is not available on value line devices */
;;;152      __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
000002  4807              LDR      r0,|L19.32|
000004  6801              LDR      r1,[r0,#0]
000006  f0410110          ORR      r1,r1,#0x10
00000a  6001              STR      r1,[r0,#0]
;;;153    #endif
;;;154    #endif /* PREFETCH_ENABLE */
;;;155    
;;;156      /* Set Interrupt Group Priority */
;;;157      HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
00000c  2003              MOVS     r0,#3
00000e  f7fffffe          BL       HAL_NVIC_SetPriorityGrouping
;;;158    
;;;159      /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
;;;160      HAL_InitTick(TICK_INT_PRIORITY);
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       HAL_InitTick
;;;161    
;;;162      /* Init the low level hardware */
;;;163      HAL_MspInit();
000018  f7fffffe          BL       HAL_MspInit
;;;164    
;;;165      /* Return function status */
;;;166      return HAL_OK;
00001c  2000              MOVS     r0,#0
;;;167    }
00001e  bd10              POP      {r4,pc}
;;;168    
                          ENDP

                  |L19.32|
                          DCD      0x40022000

                          AREA ||i.HAL_InitTick||, CODE, READONLY, ALIGN=2

                  HAL_InitTick PROC
;;;233      */
;;;234    __weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
000000  b570              PUSH     {r4-r6,lr}
;;;235    {
000002  4604              MOV      r4,r0
;;;236      /* Configure the SysTick to have interrupt in 1ms time basis*/
;;;237      if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
000004  4d0d              LDR      r5,|L20.60|
000006  f44f717a          MOV      r1,#0x3e8
00000a  7828              LDRB     r0,[r5,#0]  ; uwTickFreq
00000c  fbb1f0f0          UDIV     r0,r1,r0
000010  490b              LDR      r1,|L20.64|
000012  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000014  fbb1f0f0          UDIV     r0,r1,r0
000018  f7fffffe          BL       HAL_SYSTICK_Config
00001c  b108              CBZ      r0,|L20.34|
;;;238      {
;;;239        return HAL_ERROR;
00001e  2001              MOVS     r0,#1
;;;240      }
;;;241    
;;;242      /* Configure the SysTick IRQ priority */
;;;243      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
;;;244      {
;;;245        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
;;;246        uwTickPrio = TickPriority;
;;;247      }
;;;248      else
;;;249      {
;;;250        return HAL_ERROR;
;;;251      }
;;;252    
;;;253      /* Return function status */
;;;254      return HAL_OK;
;;;255    }
000020  bd70              POP      {r4-r6,pc}
                  |L20.34|
000022  2c10              CMP      r4,#0x10              ;243
000024  d207              BCS      |L20.54|
000026  2200              MOVS     r2,#0                 ;245
000028  4621              MOV      r1,r4                 ;245
00002a  1e50              SUBS     r0,r2,#1              ;245
00002c  f7fffffe          BL       HAL_NVIC_SetPriority
000030  606c              STR      r4,[r5,#4]            ;246  ; uwTickPrio
000032  2000              MOVS     r0,#0                 ;254
000034  bd70              POP      {r4-r6,pc}
                  |L20.54|
000036  2001              MOVS     r0,#1                 ;250
000038  bd70              POP      {r4-r6,pc}
;;;256    
                          ENDP

00003a  0000              DCW      0x0000
                  |L20.60|
                          DCD      ||.data||
                  |L20.64|
                          DCD      SystemCoreClock

                          AREA ||i.HAL_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_MspDeInit PROC
;;;210      */
;;;211    __weak void HAL_MspDeInit(void)
000000  4770              BX       lr
;;;212    {
;;;213      /* NOTE : This function should not be modified, when the callback is needed,
;;;214                the HAL_MspDeInit could be implemented in the user file
;;;215       */
;;;216    }
;;;217    
                          ENDP


                          AREA ||i.HAL_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_MspInit PROC
;;;199      */
;;;200    __weak void HAL_MspInit(void)
000000  4770              BX       lr
;;;201    {
;;;202      /* NOTE : This function should not be modified, when the callback is needed,
;;;203                the HAL_MspInit could be implemented in the user file
;;;204       */
;;;205    }
;;;206    
                          ENDP


                          AREA ||i.HAL_ResumeTick||, CODE, READONLY, ALIGN=1

                  HAL_ResumeTick PROC
;;;411      */
;;;412    __weak void HAL_ResumeTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;413    {
;;;414      /* Enable SysTick Interrupt */
;;;415      SET_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
000004  6901              LDR      r1,[r0,#0x10]
000006  f0410102          ORR      r1,r1,#2
00000a  6101              STR      r1,[r0,#0x10]
;;;416    }
00000c  4770              BX       lr
;;;417    
                          ENDP


                          AREA ||i.HAL_SetTickFreq||, CODE, READONLY, ALIGN=2

                  HAL_SetTickFreq PROC
;;;321      */
;;;322    HAL_StatusTypeDef HAL_SetTickFreq(HAL_TickFreqTypeDef Freq)
000000  b570              PUSH     {r4-r6,lr}
;;;323    {
000002  4601              MOV      r1,r0
;;;324      HAL_StatusTypeDef status  = HAL_OK;
000004  2000              MOVS     r0,#0
;;;325      HAL_TickFreqTypeDef prevTickFreq;
;;;326    
;;;327      assert_param(IS_TICKFREQ(Freq));
;;;328    
;;;329      if (uwTickFreq != Freq)
000006  4d06              LDR      r5,|L24.32|
000008  782c              LDRB     r4,[r5,#0]  ; uwTickFreq
00000a  428c              CMP      r4,r1
00000c  d006              BEQ      |L24.28|
;;;330      {
;;;331        /* Back up uwTickFreq frequency */
;;;332        prevTickFreq = uwTickFreq;
;;;333    
;;;334        /* Update uwTickFreq global variable used by HAL_InitTick() */
;;;335        uwTickFreq = Freq;
00000e  7029              STRB     r1,[r5,#0]
;;;336    
;;;337        /* Apply the new tick Freq  */
;;;338        status = HAL_InitTick(uwTickPrio);
000010  6868              LDR      r0,[r5,#4]  ; uwTickPrio
000012  f7fffffe          BL       HAL_InitTick
;;;339    
;;;340        if (status != HAL_OK)
000016  2800              CMP      r0,#0
000018  d000              BEQ      |L24.28|
;;;341        {
;;;342          /* Restore previous tick frequency */
;;;343          uwTickFreq = prevTickFreq;
00001a  702c              STRB     r4,[r5,#0]
                  |L24.28|
;;;344        }
;;;345      }
;;;346    
;;;347      return status;
;;;348    }
00001c  bd70              POP      {r4-r6,pc}
;;;349    
                          ENDP

00001e  0000              DCW      0x0000
                  |L24.32|
                          DCD      ||.data||

                          AREA ||i.HAL_SuspendTick||, CODE, READONLY, ALIGN=1

                  HAL_SuspendTick PROC
;;;395      */
;;;396    __weak void HAL_SuspendTick(void)
000000  f04f20e0          MOV      r0,#0xe000e000
;;;397    {
;;;398      /* Disable SysTick Interrupt */
;;;399      CLEAR_BIT(SysTick->CTRL, SysTick_CTRL_TICKINT_Msk);
000004  6901              LDR      r1,[r0,#0x10]
000006  f0210102          BIC      r1,r1,#2
00000a  6101              STR      r1,[r0,#0x10]
;;;400    }
00000c  4770              BX       lr
;;;401    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  uwTickFreq
000000  01000000          DCB      0x01,0x00,0x00,0x00
                  uwTickPrio
                          DCD      0x00000010
                  uwTick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f1xx_hal_c_3da258af____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_stm32f1xx_hal_c_3da258af____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f1xx_hal_c_3da258af____REVSH|
#line 478
|__asm___15_stm32f1xx_hal_c_3da258af____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f1xx_hal_c_3da258af____RRX|
#line 665
|__asm___15_stm32f1xx_hal_c_3da258af____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
