; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\def.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\def.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\def.crf ..\Middlewares\Third_Party\LwIP\src\core\def.c]
                          THUMB

                          AREA ||i.lwip_htonl||, CODE, READONLY, ALIGN=1

                  lwip_htonl PROC
;;;89     u32_t
;;;90     lwip_htonl(u32_t n)
000000  0601              LSLS     r1,r0,#24
;;;91     {
;;;92       return PP_HTONL(n);
000002  f400427f          AND      r2,r0,#0xff00
000006  ea412102          ORR      r1,r1,r2,LSL #8
00000a  f400027f          AND      r2,r0,#0xff0000
00000e  ea412112          ORR      r1,r1,r2,LSR #8
000012  ea416010          ORR      r0,r1,r0,LSR #24
;;;93     }
000016  4770              BX       lr
;;;94     #endif /* lwip_htonl */
                          ENDP


                          AREA ||i.lwip_htons||, CODE, READONLY, ALIGN=1

                  lwip_htons PROC
;;;75     u16_t
;;;76     lwip_htons(u16_t n)
000000  0601              LSLS     r1,r0,#24
;;;77     {
;;;78       return PP_HTONS(n);
000002  0c09              LSRS     r1,r1,#16
000004  ea412010          ORR      r0,r1,r0,LSR #8
;;;79     }
000008  4770              BX       lr
;;;80     #endif /* lwip_htons */
                          ENDP


                          AREA ||i.lwip_itoa||, CODE, READONLY, ALIGN=1

                  lwip_itoa PROC
;;;198    void
;;;199    lwip_itoa(char *result, size_t bufsize, int number)
000000  b4f0              PUSH     {r4-r7}
;;;200    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;201      char *res = result;
000006  4620              MOV      r0,r4
;;;202      char *tmp = result + bufsize - 1;
000008  1967              ADDS     r7,r4,r5
00000a  1e79              SUBS     r1,r7,#1
;;;203      int n = (number >= 0) ? number : -number;
00000c  2a00              CMP      r2,#0
00000e  db01              BLT      |L3.20|
000010  4613              MOV      r3,r2
000012  e000              B        |L3.22|
                  |L3.20|
000014  4253              RSBS     r3,r2,#0
                  |L3.22|
;;;204    
;;;205      /* handle invalid bufsize */
;;;206      if (bufsize < 2) {
000016  2600              MOVS     r6,#0
000018  2d02              CMP      r5,#2
00001a  d204              BCS      |L3.38|
;;;207        if (bufsize == 1) {
00001c  2d01              CMP      r5,#1
00001e  d100              BNE      |L3.34|
;;;208          *result = 0;
000020  7026              STRB     r6,[r4,#0]
                  |L3.34|
;;;209        }
;;;210        return;
;;;211      }
;;;212    
;;;213      /* First, add sign */
;;;214      if (number < 0) {
;;;215        *res++ = '-';
;;;216      }
;;;217      /* Then create the string from the end and stop if buffer full,
;;;218         and ensure output string is zero terminated */
;;;219      *tmp = 0;
;;;220      while ((n != 0) && (tmp > res)) {
;;;221        char val = (char)('0' + (n % 10));
;;;222        tmp--;
;;;223        *tmp = val;
;;;224        n = n / 10;
;;;225      }
;;;226      if (n) {
;;;227        /* buffer is too small */
;;;228        *result = 0;
;;;229        return;
;;;230      }
;;;231      if (*tmp == 0) {
;;;232        /* Nothing added? */
;;;233        *res++ = '0';
;;;234        *res++ = 0;
;;;235        return;
;;;236      }
;;;237      /* move from temporary buffer to output buffer (sign is not moved) */
;;;238      memmove(res, tmp, (size_t)((result + bufsize) - tmp));
;;;239    }
000022  bcf0              POP      {r4-r7}
000024  4770              BX       lr
                  |L3.38|
000026  2a00              CMP      r2,#0                 ;214
000028  da02              BGE      |L3.48|
00002a  222d              MOVS     r2,#0x2d              ;215
00002c  f8002b01          STRB     r2,[r0],#1            ;215
                  |L3.48|
000030  700e              STRB     r6,[r1,#0]            ;219
000032  220a              MOVS     r2,#0xa               ;221
000034  e008              B        |L3.72|
                  |L3.54|
000036  fb93f5f2          SDIV     r5,r3,r2              ;221
00003a  fb023515          MLS      r5,r2,r5,r3           ;221
00003e  3530              ADDS     r5,r5,#0x30           ;221
000040  1e49              SUBS     r1,r1,#1              ;222
000042  700d              STRB     r5,[r1,#0]            ;223
000044  fb93f3f2          SDIV     r3,r3,r2              ;224
                  |L3.72|
000048  b10b              CBZ      r3,|L3.78|
00004a  4281              CMP      r1,r0                 ;220
00004c  d8f3              BHI      |L3.54|
                  |L3.78|
00004e  b10b              CBZ      r3,|L3.84|
000050  7026              STRB     r6,[r4,#0]            ;228
000052  e7e6              B        |L3.34|
                  |L3.84|
000054  780a              LDRB     r2,[r1,#0]            ;231
000056  b11a              CBZ      r2,|L3.96|
000058  1a7a              SUBS     r2,r7,r1              ;238
00005a  bcf0              POP      {r4-r7}               ;238
00005c  f7ffbffe          B.W      __aeabi_memmove
                  |L3.96|
000060  2130              MOVS     r1,#0x30              ;233
000062  7001              STRB     r1,[r0,#0]            ;233
000064  7046              STRB     r6,[r0,#1]            ;234
000066  e7dc              B        |L3.34|
;;;240    #endif
                          ENDP


                          AREA ||i.lwip_stricmp||, CODE, READONLY, ALIGN=1

                  lwip_stricmp PROC
;;;127    int
;;;128    lwip_stricmp(const char *str1, const char *str2)
000000  b530              PUSH     {r4,r5,lr}
                  |L4.2|
;;;129    {
;;;130      char c1, c2;
;;;131    
;;;132      do {
;;;133        c1 = *str1++;
000002  f8102b01          LDRB     r2,[r0],#1
;;;134        c2 = *str2++;
000006  f8113b01          LDRB     r3,[r1],#1
;;;135        if (c1 != c2) {
00000a  429a              CMP      r2,r3
00000c  d00d              BEQ      |L4.42|
;;;136          char c1_upc = c1 | 0x20;
00000e  f0420420          ORR      r4,r2,#0x20
;;;137          if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
000012  f1a40561          SUB      r5,r4,#0x61
000016  2d19              CMP      r5,#0x19
000018  d805              BHI      |L4.38|
;;;138            /* characters are not equal an one is in the alphabet range:
;;;139            downcase both chars and check again */
;;;140            char c2_upc = c2 | 0x20;
00001a  f0430320          ORR      r3,r3,#0x20
;;;141            if (c1_upc != c2_upc) {
00001e  429c              CMP      r4,r3
000020  d003              BEQ      |L4.42|
;;;142              /* still not equal */
;;;143              /* don't care for < or > */
;;;144              return 1;
000022  2001              MOVS     r0,#1
;;;145            }
;;;146          } else {
;;;147            /* characters are not equal but none is in the alphabet range */
;;;148            return 1;
;;;149          }
;;;150        }
;;;151      } while (c1 != 0);
;;;152      return 0;
;;;153    }
000024  bd30              POP      {r4,r5,pc}
                  |L4.38|
000026  2001              MOVS     r0,#1                 ;148
000028  bd30              POP      {r4,r5,pc}
                  |L4.42|
00002a  2a00              CMP      r2,#0                 ;151
00002c  d1e9              BNE      |L4.2|
00002e  2000              MOVS     r0,#0                 ;152
000030  bd30              POP      {r4,r5,pc}
;;;154    #endif
                          ENDP


                          AREA ||i.lwip_strnicmp||, CODE, READONLY, ALIGN=1

                  lwip_strnicmp PROC
;;;162    int
;;;163    lwip_strnicmp(const char *str1, const char *str2, size_t len)
000000  b570              PUSH     {r4-r6,lr}
                  |L5.2|
;;;164    {
;;;165      char c1, c2;
;;;166    
;;;167      do {
;;;168        c1 = *str1++;
000002  f8103b01          LDRB     r3,[r0],#1
;;;169        c2 = *str2++;
000006  f8115b01          LDRB     r5,[r1],#1
;;;170        if (c1 != c2) {
00000a  42ab              CMP      r3,r5
00000c  d00d              BEQ      |L5.42|
;;;171          char c1_upc = c1 | 0x20;
00000e  f0430420          ORR      r4,r3,#0x20
;;;172          if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
000012  f1a40661          SUB      r6,r4,#0x61
000016  2e19              CMP      r6,#0x19
000018  d805              BHI      |L5.38|
;;;173            /* characters are not equal an one is in the alphabet range:
;;;174            downcase both chars and check again */
;;;175            char c2_upc = c2 | 0x20;
00001a  f0450520          ORR      r5,r5,#0x20
;;;176            if (c1_upc != c2_upc) {
00001e  42ac              CMP      r4,r5
000020  d003              BEQ      |L5.42|
;;;177              /* still not equal */
;;;178              /* don't care for < or > */
;;;179              return 1;
000022  2001              MOVS     r0,#1
;;;180            }
;;;181          } else {
;;;182            /* characters are not equal but none is in the alphabet range */
;;;183            return 1;
;;;184          }
;;;185        }
;;;186        len--;
;;;187      } while ((len != 0) && (c1 != 0));
;;;188      return 0;
;;;189    }
000024  bd70              POP      {r4-r6,pc}
                  |L5.38|
000026  2001              MOVS     r0,#1                 ;183
000028  bd70              POP      {r4-r6,pc}
                  |L5.42|
00002a  1e52              SUBS     r2,r2,#1              ;186
00002c  b10a              CBZ      r2,|L5.50|
00002e  2b00              CMP      r3,#0                 ;187
000030  d1e7              BNE      |L5.2|
                  |L5.50|
000032  2000              MOVS     r0,#0                 ;188
000034  bd70              POP      {r4-r6,pc}
;;;190    #endif
                          ENDP


                          AREA ||i.lwip_strnstr||, CODE, READONLY, ALIGN=1

                  lwip_strnstr PROC
;;;104    char *
;;;105    lwip_strnstr(const char *buffer, const char *token, size_t n)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;106    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;107      const char *p;
;;;108      size_t tokenlen = strlen(token);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       strlen
000010  4605              MOV      r5,r0
;;;109      if (tokenlen == 0) {
000012  b10d              CBZ      r5,|L6.24|
;;;110        return LWIP_CONST_CAST(char *, buffer);
;;;111      }
;;;112      for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
000014  4426              ADD      r6,r6,r4
000016  e00c              B        |L6.50|
                  |L6.24|
000018  4620              MOV      r0,r4                 ;110
                  |L6.26|
;;;113        if ((*p == *token) && (strncmp(p, token, tokenlen) == 0)) {
;;;114          return LWIP_CONST_CAST(char *, p);
;;;115        }
;;;116      }
;;;117      return NULL;
;;;118    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L6.30|
00001e  7839              LDRB     r1,[r7,#0]            ;113
000020  4288              CMP      r0,r1                 ;113
000022  d105              BNE      |L6.48|
000024  462a              MOV      r2,r5                 ;113
000026  4639              MOV      r1,r7                 ;113
000028  4620              MOV      r0,r4                 ;113
00002a  f7fffffe          BL       strncmp
00002e  b138              CBZ      r0,|L6.64|
                  |L6.48|
000030  1c64              ADDS     r4,r4,#1              ;112
                  |L6.50|
000032  7820              LDRB     r0,[r4,#0]            ;112
000034  b110              CBZ      r0,|L6.60|
000036  1961              ADDS     r1,r4,r5              ;112
000038  42b1              CMP      r1,r6                 ;112
00003a  d9f0              BLS      |L6.30|
                  |L6.60|
00003c  2000              MOVS     r0,#0                 ;117
00003e  e7ec              B        |L6.26|
                  |L6.64|
000040  4620              MOV      r0,r4                 ;114
000042  e7ea              B        |L6.26|
;;;119    #endif
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\def.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_def_c_5e6112f8____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_def_c_5e6112f8____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_def_c_5e6112f8____REVSH|
#line 478
|__asm___5_def_c_5e6112f8____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_def_c_5e6112f8____RRX|
#line 665
|__asm___5_def_c_5e6112f8____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
