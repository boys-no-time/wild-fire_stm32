; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\def.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\def.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\def.crf ..\Middlewares\Third_Party\LwIP\src\core\def.c]
                          THUMB

                          AREA ||i.lwip_htonl||, CODE, READONLY, ALIGN=1

                  lwip_htonl PROC
;;;89     u32_t
;;;90     lwip_htonl(u32_t n)
000000  0601              LSLS     r1,r0,#24
;;;91     {
;;;92       return (u32_t)PP_HTONL(n);
000002  f400427f          AND      r2,r0,#0xff00
000006  ea412102          ORR      r1,r1,r2,LSL #8
00000a  f400027f          AND      r2,r0,#0xff0000
00000e  ea412112          ORR      r1,r1,r2,LSR #8
000012  ea416010          ORR      r0,r1,r0,LSR #24
;;;93     }
000016  4770              BX       lr
;;;94     #endif /* lwip_htonl */
                          ENDP


                          AREA ||i.lwip_htons||, CODE, READONLY, ALIGN=1

                  lwip_htons PROC
;;;75     u16_t
;;;76     lwip_htons(u16_t n)
000000  0601              LSLS     r1,r0,#24
;;;77     {
;;;78       return (u16_t)PP_HTONS(n);
000002  0c09              LSRS     r1,r1,#16
000004  ea412010          ORR      r0,r1,r0,LSR #8
;;;79     }
000008  4770              BX       lr
;;;80     #endif /* lwip_htons */
                          ENDP


                          AREA ||i.lwip_itoa||, CODE, READONLY, ALIGN=2

                  lwip_itoa PROC
;;;197    void
;;;198    lwip_itoa(char* result, size_t bufsize, int number)
000000  b570              PUSH     {r4-r6,lr}
;;;199    {
;;;200      const int base = 10;
;;;201      char* ptr = result, *ptr1 = result, tmp_char;
000002  4601              MOV      r1,r0
000004  250a              MOVS     r5,#0xa               ;200
                  |L3.6|
;;;202      int tmp_value;
;;;203      LWIP_UNUSED_ARG(bufsize);
;;;204    
;;;205      do {
;;;206        tmp_value = number;
000006  4614              MOV      r4,r2
;;;207        number /= base;
000008  fb92f2f5          SDIV     r2,r2,r5
;;;208        *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz"[35 + (tmp_value - number * base)];
00000c  4253              RSBS     r3,r2,#0
00000e  eb030383          ADD      r3,r3,r3,LSL #2
000012  4e0e              LDR      r6,|L3.76|
000014  eb040343          ADD      r3,r4,r3,LSL #1
000018  4433              ADD      r3,r3,r6
00001a  f8933023          LDRB     r3,[r3,#0x23]
00001e  f8003b01          STRB     r3,[r0],#1
;;;209      } while(number);
000022  2a00              CMP      r2,#0
000024  d1ef              BNE      |L3.6|
;;;210    
;;;211       /* Apply negative sign */
;;;212      if (tmp_value < 0) {
000026  2c00              CMP      r4,#0
000028  da02              BGE      |L3.48|
;;;213         *ptr++ = '-';
00002a  222d              MOVS     r2,#0x2d
00002c  f8002b01          STRB     r2,[r0],#1
                  |L3.48|
;;;214      }
;;;215      *ptr-- = '\0';
000030  2200              MOVS     r2,#0
000032  f8002901          STRB     r2,[r0],#-1
;;;216      while(ptr1 < ptr) {
000036  e005              B        |L3.68|
                  |L3.56|
;;;217        tmp_char = *ptr;
000038  7802              LDRB     r2,[r0,#0]
;;;218        *ptr--= *ptr1;
00003a  780b              LDRB     r3,[r1,#0]
00003c  f8003901          STRB     r3,[r0],#-1
;;;219        *ptr1++ = tmp_char;
000040  f8012b01          STRB     r2,[r1],#1
                  |L3.68|
000044  4281              CMP      r1,r0                 ;216
000046  d3f7              BCC      |L3.56|
;;;220      }
;;;221    }
000048  bd70              POP      {r4-r6,pc}
;;;222    #endif
                          ENDP

00004a  0000              DCW      0x0000
                  |L3.76|
                          DCD      ||.conststring||

                          AREA ||i.lwip_stricmp||, CODE, READONLY, ALIGN=1

                  lwip_stricmp PROC
;;;127    int
;;;128    lwip_stricmp(const char* str1, const char* str2)
000000  b530              PUSH     {r4,r5,lr}
                  |L4.2|
;;;129    {
;;;130      char c1, c2;
;;;131    
;;;132      do {
;;;133        c1 = *str1++;
000002  f8102b01          LDRB     r2,[r0],#1
;;;134        c2 = *str2++;
000006  f8113b01          LDRB     r3,[r1],#1
;;;135        if (c1 != c2) {
00000a  429a              CMP      r2,r3
00000c  d00d              BEQ      |L4.42|
;;;136          char c1_upc = c1 | 0x20;
00000e  f0420420          ORR      r4,r2,#0x20
;;;137          if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
000012  f1a40561          SUB      r5,r4,#0x61
000016  2d19              CMP      r5,#0x19
000018  d805              BHI      |L4.38|
;;;138            /* characters are not equal an one is in the alphabet range:
;;;139            downcase both chars and check again */
;;;140            char c2_upc = c2 | 0x20;
00001a  f0430320          ORR      r3,r3,#0x20
;;;141            if (c1_upc != c2_upc) {
00001e  429c              CMP      r4,r3
000020  d003              BEQ      |L4.42|
;;;142              /* still not equal */
;;;143              /* don't care for < or > */
;;;144              return 1;
000022  2001              MOVS     r0,#1
;;;145            }
;;;146          } else {
;;;147            /* characters are not equal but none is in the alphabet range */
;;;148            return 1;
;;;149          }
;;;150        }
;;;151      } while (c1 != 0);
;;;152      return 0;
;;;153    }
000024  bd30              POP      {r4,r5,pc}
                  |L4.38|
000026  2001              MOVS     r0,#1                 ;148
000028  bd30              POP      {r4,r5,pc}
                  |L4.42|
00002a  2a00              CMP      r2,#0                 ;151
00002c  d1e9              BNE      |L4.2|
00002e  2000              MOVS     r0,#0                 ;152
000030  bd30              POP      {r4,r5,pc}
;;;154    #endif
                          ENDP


                          AREA ||i.lwip_strnicmp||, CODE, READONLY, ALIGN=1

                  lwip_strnicmp PROC
;;;162    int
;;;163    lwip_strnicmp(const char* str1, const char* str2, size_t len)
000000  b570              PUSH     {r4-r6,lr}
                  |L5.2|
;;;164    {
;;;165      char c1, c2;
;;;166    
;;;167      do {
;;;168        c1 = *str1++;
000002  f8103b01          LDRB     r3,[r0],#1
;;;169        c2 = *str2++;
000006  f8115b01          LDRB     r5,[r1],#1
;;;170        if (c1 != c2) {
00000a  42ab              CMP      r3,r5
00000c  d00d              BEQ      |L5.42|
;;;171          char c1_upc = c1 | 0x20;
00000e  f0430420          ORR      r4,r3,#0x20
;;;172          if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
000012  f1a40661          SUB      r6,r4,#0x61
000016  2e19              CMP      r6,#0x19
000018  d805              BHI      |L5.38|
;;;173            /* characters are not equal an one is in the alphabet range:
;;;174            downcase both chars and check again */
;;;175            char c2_upc = c2 | 0x20;
00001a  f0450520          ORR      r5,r5,#0x20
;;;176            if (c1_upc != c2_upc) {
00001e  42ac              CMP      r4,r5
000020  d003              BEQ      |L5.42|
;;;177              /* still not equal */
;;;178              /* don't care for < or > */
;;;179              return 1;
000022  2001              MOVS     r0,#1
;;;180            }
;;;181          } else {
;;;182            /* characters are not equal but none is in the alphabet range */
;;;183            return 1;
;;;184          }
;;;185        }
;;;186      } while (len-- && c1 != 0);
;;;187      return 0;
;;;188    }
000024  bd70              POP      {r4-r6,pc}
                  |L5.38|
000026  2001              MOVS     r0,#1                 ;183
000028  bd70              POP      {r4-r6,pc}
                  |L5.42|
00002a  1e52              SUBS     r2,r2,#1              ;186
00002c  1c54              ADDS     r4,r2,#1              ;186
00002e  d001              BEQ      |L5.52|
000030  2b00              CMP      r3,#0                 ;186
000032  d1e6              BNE      |L5.2|
                  |L5.52|
000034  2000              MOVS     r0,#0                 ;187
000036  bd70              POP      {r4-r6,pc}
;;;189    #endif
                          ENDP


                          AREA ||i.lwip_strnstr||, CODE, READONLY, ALIGN=1

                  lwip_strnstr PROC
;;;104    char*
;;;105    lwip_strnstr(const char* buffer, const char* token, size_t n)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;106    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;107      const char* p;
;;;108      size_t tokenlen = strlen(token);
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       strlen
000010  4605              MOV      r5,r0
;;;109      if (tokenlen == 0) {
000012  b10d              CBZ      r5,|L6.24|
;;;110        return LWIP_CONST_CAST(char *, buffer);
;;;111      }
;;;112      for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
000014  4426              ADD      r6,r6,r4
000016  e00c              B        |L6.50|
                  |L6.24|
000018  4620              MOV      r0,r4                 ;110
                  |L6.26|
;;;113        if ((*p == *token) && (strncmp(p, token, tokenlen) == 0)) {
;;;114          return LWIP_CONST_CAST(char *, p);
;;;115        }
;;;116      }
;;;117      return NULL;
;;;118    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L6.30|
00001e  7839              LDRB     r1,[r7,#0]            ;113
000020  4288              CMP      r0,r1                 ;113
000022  d105              BNE      |L6.48|
000024  462a              MOV      r2,r5                 ;113
000026  4639              MOV      r1,r7                 ;113
000028  4620              MOV      r0,r4                 ;113
00002a  f7fffffe          BL       strncmp
00002e  b138              CBZ      r0,|L6.64|
                  |L6.48|
000030  1c64              ADDS     r4,r4,#1              ;112
                  |L6.50|
000032  7820              LDRB     r0,[r4,#0]            ;112
000034  b110              CBZ      r0,|L6.60|
000036  1961              ADDS     r1,r4,r5              ;112
000038  42b1              CMP      r1,r6                 ;112
00003a  d9f0              BLS      |L6.30|
                  |L6.60|
00003c  2000              MOVS     r0,#0                 ;117
00003e  e7ec              B        |L6.26|
                  |L6.64|
000040  4620              MOV      r0,r4                 ;114
000042  e7ea              B        |L6.26|
;;;119    #endif
                          ENDP


                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  7a797877          DCB      "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghij"
000004  76757473
000008  7271706f
00000c  6e6d6c6b
000010  6a696867
000014  66656463
000018  62613938
00001c  37363534
000020  33323130
000024  31323334
000028  35363738
00002c  39616263
000030  64656667
000034  68696a  
000037  6b6c6d6e          DCB      "klmnopqrstuvwxyz",0
00003b  6f707172
00003f  73747576
000043  7778797a
000047  00      

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\def.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_def_c_5e6112f8____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_def_c_5e6112f8____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_def_c_5e6112f8____REVSH|
#line 478
|__asm___5_def_c_5e6112f8____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_def_c_5e6112f8____RRX|
#line 665
|__asm___5_def_c_5e6112f8____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
