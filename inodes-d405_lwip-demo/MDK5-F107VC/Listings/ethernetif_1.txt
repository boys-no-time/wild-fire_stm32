; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ethernetif_1.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ethernetif_1.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\system\arch -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Inc -I..\Middlewares\Third_Party\LwIP\src\include -I..\App -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\ethernetif_1.crf ..\Src\ethernetif.c]
                          THUMB

                          AREA ||i.HAL_ETH_MspDeInit||, CODE, READONLY, ALIGN=2

                  HAL_ETH_MspDeInit PROC
;;;136    
;;;137    void HAL_ETH_MspDeInit(ETH_HandleTypeDef* ethHandle)
000000  b510              PUSH     {r4,lr}
;;;138    {
;;;139      if(ethHandle->Instance==ETH)
000002  6800              LDR      r0,[r0,#0]
000004  490f              LDR      r1,|L1.68|
000006  4288              CMP      r0,r1
000008  d11b              BNE      |L1.66|
;;;140      {
;;;141      /* USER CODE BEGIN ETH_MspDeInit 0 */
;;;142    
;;;143      /* USER CODE END ETH_MspDeInit 0 */
;;;144        /* Disable Peripheral clock */
;;;145        __HAL_RCC_ETH_CLK_DISABLE();
00000a  480f              LDR      r0,|L1.72|
00000c  6941              LDR      r1,[r0,#0x14]
00000e  f4214100          BIC      r1,r1,#0x8000
000012  6141              STR      r1,[r0,#0x14]
000014  6941              LDR      r1,[r0,#0x14]
000016  f4213180          BIC      r1,r1,#0x10000
00001a  6141              STR      r1,[r0,#0x14]
00001c  6941              LDR      r1,[r0,#0x14]
00001e  f4214180          BIC      r1,r1,#0x4000
000022  6141              STR      r1,[r0,#0x14]
;;;146    
;;;147        /**ETH GPIO Configuration
;;;148        PC1     ------> ETH_MDC
;;;149        PA1     ------> ETH_REF_CLK
;;;150        PA2     ------> ETH_MDIO
;;;151        PA7     ------> ETH_CRS_DV
;;;152        PC4     ------> ETH_RXD0
;;;153        PC5     ------> ETH_RXD1
;;;154        PB11     ------> ETH_TX_EN
;;;155        PB12     ------> ETH_TXD0
;;;156        PB13     ------> ETH_TXD1
;;;157        */
;;;158        HAL_GPIO_DeInit(GPIOC, GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5);
000024  2132              MOVS     r1,#0x32
000026  4809              LDR      r0,|L1.76|
000028  f7fffffe          BL       HAL_GPIO_DeInit
;;;159    
;;;160        HAL_GPIO_DeInit(GPIOA, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_7);
00002c  2186              MOVS     r1,#0x86
00002e  4808              LDR      r0,|L1.80|
000030  f7fffffe          BL       HAL_GPIO_DeInit
;;;161    
;;;162        HAL_GPIO_DeInit(GPIOB, GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13);
000034  e8bd4010          POP      {r4,lr}
000038  f44f5160          MOV      r1,#0x3800
00003c  4805              LDR      r0,|L1.84|
00003e  f7ffbffe          B.W      HAL_GPIO_DeInit
                  |L1.66|
;;;163    
;;;164      /* USER CODE BEGIN ETH_MspDeInit 1 */
;;;165    
;;;166      /* USER CODE END ETH_MspDeInit 1 */
;;;167      }
;;;168    }
000042  bd10              POP      {r4,pc}
;;;169    
                          ENDP

                  |L1.68|
                          DCD      0x40028000
                  |L1.72|
                          DCD      0x40021000
                  |L1.76|
                          DCD      0x40011000
                  |L1.80|
                          DCD      0x40010800
                  |L1.84|
                          DCD      0x40010c00

                          AREA ||i.HAL_ETH_MspInit||, CODE, READONLY, ALIGN=2

                  HAL_ETH_MspInit PROC
;;;80     
;;;81     void HAL_ETH_MspInit(ETH_HandleTypeDef* ethHandle)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;82     {
000004  b086              SUB      sp,sp,#0x18
;;;83       GPIO_InitTypeDef GPIO_InitStruct = {0};
000006  2400              MOVS     r4,#0
000008  9402              STR      r4,[sp,#8]
00000a  9403              STR      r4,[sp,#0xc]
00000c  9404              STR      r4,[sp,#0x10]
00000e  9405              STR      r4,[sp,#0x14]
;;;84       if(ethHandle->Instance==ETH)
000010  6800              LDR      r0,[r0,#0]
000012  4932              LDR      r1,|L2.220|
000014  4288              CMP      r0,r1
000016  d15d              BNE      |L2.212|
;;;85       {
;;;86       /* USER CODE BEGIN ETH_MspInit 0 */
;;;87     
;;;88       /* USER CODE END ETH_MspInit 0 */
;;;89         /* Enable Peripheral clock */
;;;90         __HAL_RCC_ETH_CLK_ENABLE();
000018  4831              LDR      r0,|L2.224|
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f4414180          ORR      r1,r1,#0x4000
000020  6141              STR      r1,[r0,#0x14]
000022  6941              LDR      r1,[r0,#0x14]
000024  f4014180          AND      r1,r1,#0x4000
000028  9101              STR      r1,[sp,#4]
00002a  6941              LDR      r1,[r0,#0x14]
00002c  f4414100          ORR      r1,r1,#0x8000
000030  6141              STR      r1,[r0,#0x14]
000032  6941              LDR      r1,[r0,#0x14]
000034  f4014100          AND      r1,r1,#0x8000
000038  9101              STR      r1,[sp,#4]
00003a  6941              LDR      r1,[r0,#0x14]
00003c  f4413180          ORR      r1,r1,#0x10000
000040  6141              STR      r1,[r0,#0x14]
000042  6941              LDR      r1,[r0,#0x14]
000044  f4013180          AND      r1,r1,#0x10000
000048  9101              STR      r1,[sp,#4]
;;;91     
;;;92         __HAL_RCC_GPIOC_CLK_ENABLE();
00004a  6981              LDR      r1,[r0,#0x18]
00004c  f0410110          ORR      r1,r1,#0x10
000050  6181              STR      r1,[r0,#0x18]
000052  6981              LDR      r1,[r0,#0x18]
000054  f0010110          AND      r1,r1,#0x10
000058  9101              STR      r1,[sp,#4]
;;;93         __HAL_RCC_GPIOA_CLK_ENABLE();
00005a  6981              LDR      r1,[r0,#0x18]
00005c  f0410104          ORR      r1,r1,#4
000060  6181              STR      r1,[r0,#0x18]
000062  6981              LDR      r1,[r0,#0x18]
000064  f0010104          AND      r1,r1,#4
000068  9101              STR      r1,[sp,#4]
;;;94         __HAL_RCC_GPIOB_CLK_ENABLE();
00006a  6981              LDR      r1,[r0,#0x18]
00006c  f0410108          ORR      r1,r1,#8
000070  6181              STR      r1,[r0,#0x18]
000072  6980              LDR      r0,[r0,#0x18]
000074  f0000008          AND      r0,r0,#8
000078  9001              STR      r0,[sp,#4]
;;;95         /**ETH GPIO Configuration
;;;96         PC1     ------> ETH_MDC
;;;97         PA1     ------> ETH_REF_CLK
;;;98         PA2     ------> ETH_MDIO
;;;99         PA7     ------> ETH_CRS_DV
;;;100        PC4     ------> ETH_RXD0
;;;101        PC5     ------> ETH_RXD1
;;;102        PB11     ------> ETH_TX_EN
;;;103        PB12     ------> ETH_TXD0
;;;104        PB13     ------> ETH_TXD1
;;;105        */
;;;106        GPIO_InitStruct.Pin = GPIO_PIN_1;
00007a  2502              MOVS     r5,#2
00007c  9502              STR      r5,[sp,#8]
;;;107        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
00007e  9503              STR      r5,[sp,#0xc]
;;;108        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
000080  2603              MOVS     r6,#3
000082  9605              STR      r6,[sp,#0x14]
;;;109        HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
000084  4f17              LDR      r7,|L2.228|
000086  a902              ADD      r1,sp,#8
000088  4638              MOV      r0,r7
00008a  f7fffffe          BL       HAL_GPIO_Init
;;;110    
;;;111        GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_7;
00008e  2082              MOVS     r0,#0x82
000090  9002              STR      r0,[sp,#8]
;;;112        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
000092  9403              STR      r4,[sp,#0xc]
;;;113        GPIO_InitStruct.Pull = GPIO_NOPULL;
000094  9404              STR      r4,[sp,#0x10]
;;;114        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
000096  f8df8050          LDR      r8,|L2.232|
00009a  a902              ADD      r1,sp,#8
00009c  4640              MOV      r0,r8
00009e  f7fffffe          BL       HAL_GPIO_Init
;;;115    
;;;116        GPIO_InitStruct.Pin = GPIO_PIN_2;
0000a2  2004              MOVS     r0,#4
0000a4  9002              STR      r0,[sp,#8]
;;;117        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
0000a6  9503              STR      r5,[sp,#0xc]
;;;118        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
0000a8  9605              STR      r6,[sp,#0x14]
;;;119        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
0000aa  a902              ADD      r1,sp,#8
0000ac  4640              MOV      r0,r8
0000ae  f7fffffe          BL       HAL_GPIO_Init
;;;120    
;;;121        GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5;
0000b2  2030              MOVS     r0,#0x30
0000b4  9002              STR      r0,[sp,#8]
;;;122        GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
0000b6  9403              STR      r4,[sp,#0xc]
;;;123        GPIO_InitStruct.Pull = GPIO_NOPULL;
0000b8  9404              STR      r4,[sp,#0x10]
;;;124        HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
0000ba  a902              ADD      r1,sp,#8
0000bc  4638              MOV      r0,r7
0000be  f7fffffe          BL       HAL_GPIO_Init
;;;125    
;;;126        GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13;
0000c2  f44f5060          MOV      r0,#0x3800
0000c6  9002              STR      r0,[sp,#8]
;;;127        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
0000c8  9503              STR      r5,[sp,#0xc]
;;;128        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
0000ca  9605              STR      r6,[sp,#0x14]
;;;129        HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
0000cc  a902              ADD      r1,sp,#8
0000ce  4807              LDR      r0,|L2.236|
0000d0  f7fffffe          BL       HAL_GPIO_Init
                  |L2.212|
;;;130    
;;;131      /* USER CODE BEGIN ETH_MspInit 1 */
;;;132    
;;;133      /* USER CODE END ETH_MspInit 1 */
;;;134      }
;;;135    }
0000d4  b006              ADD      sp,sp,#0x18
0000d6  e8bd81f0          POP      {r4-r8,pc}
;;;136    
                          ENDP

0000da  0000              DCW      0x0000
                  |L2.220|
                          DCD      0x40028000
                  |L2.224|
                          DCD      0x40021000
                  |L2.228|
                          DCD      0x40011000
                  |L2.232|
                          DCD      0x40010800
                  |L2.236|
                          DCD      0x40010c00

                          AREA ||i.ethernetif_init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  ethernetif_init PROC
;;;507     */
;;;508    err_t ethernetif_init(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;509    {
000002  4604              MOV      r4,r0
;;;510      LWIP_ASSERT("netif != NULL", (netif != NULL));
000004  2c00              CMP      r4,#0
000006  d106              BNE      |L3.22|
000008  a30a              ADR      r3,|L3.52|
00000a  f44f72ff          MOV      r2,#0x1fe
00000e  a10e              ADR      r1,|L3.72|
000010  a011              ADR      r0,|L3.88|
000012  f7fffffe          BL       __2printf
                  |L3.22|
;;;511    
;;;512    #if LWIP_NETIF_HOSTNAME
;;;513      /* Initialize interface hostname */
;;;514      netif->hostname = "lwip";
;;;515    #endif /* LWIP_NETIF_HOSTNAME */
;;;516    
;;;517      netif->name[0] = IFNAME0;
000016  2073              MOVS     r0,#0x73
000018  f8840038          STRB     r0,[r4,#0x38]
;;;518      netif->name[1] = IFNAME1;
00001c  2074              MOVS     r0,#0x74
00001e  f8840039          STRB     r0,[r4,#0x39]
;;;519      /* We directly use etharp_output() here to save a function call.
;;;520       * You can instead declare your own function an call etharp_output()
;;;521       * from it if you have to do some checks before sending (e.g. if link
;;;522       * is available...) */
;;;523    
;;;524    #if LWIP_IPV4
;;;525    #if LWIP_ARP || LWIP_ETHERNET
;;;526    #if LWIP_ARP
;;;527      netif->output = etharp_output;
000022  4817              LDR      r0,|L3.128|
000024  6160              STR      r0,[r4,#0x14]
;;;528    #else
;;;529      /* The user should write ist own code in low_level_output_arp_off function */
;;;530      netif->output = low_level_output_arp_off;
;;;531    #endif /* LWIP_ARP */
;;;532    #endif /* LWIP_ARP || LWIP_ETHERNET */
;;;533    #endif /* LWIP_IPV4 */
;;;534    
;;;535    #if LWIP_IPV6
;;;536      netif->output_ip6 = ethip6_output;
;;;537    #endif /* LWIP_IPV6 */
;;;538    
;;;539      netif->linkoutput = low_level_output;
000026  4817              LDR      r0,|L3.132|
000028  61a0              STR      r0,[r4,#0x18]
;;;540    
;;;541      /* initialize the hardware */
;;;542      low_level_init(netif);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       low_level_init
;;;543    
;;;544      return ERR_OK;
000030  2000              MOVS     r0,#0
;;;545    }
000032  bd10              POP      {r4,pc}
;;;546    
                          ENDP

                  |L3.52|
000034  2e2e5c53          DCB      "..\\Src\\ethernetif.c",0
000038  72635c65
00003c  74686572
000040  6e657469
000044  662e6300
                  |L3.72|
000048  6e657469          DCB      "netif != NULL",0
00004c  6620213d
000050  204e554c
000054  4c00    
000056  00                DCB      0
000057  00                DCB      0
                  |L3.88|
000058  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
00005c  7274696f
000060  6e202225
000064  73222066
000068  61696c65
00006c  64206174
000070  206c696e
000074  65202564
000078  20696e20
00007c  25730a00
                  |L3.128|
                          DCD      etharp_output
                  |L3.132|
                          DCD      low_level_output

                          AREA ||i.ethernetif_input||, CODE, READONLY, ALIGN=1

                  ethernetif_input PROC
;;;452     */
;;;453    void ethernetif_input(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;454    {
000002  4605              MOV      r5,r0
;;;455      err_t err;
;;;456      struct pbuf *p;
;;;457    
;;;458      /* move received packet into a new pbuf */
;;;459      p = low_level_input(netif);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       low_level_input
00000a  4604              MOV      r4,r0
;;;460    
;;;461      /* no packet could be read, silently ignore this */
;;;462      if (p == NULL) return;
00000c  2c00              CMP      r4,#0
00000e  d00a              BEQ      |L4.38|
;;;463    
;;;464      /* entry point to the LwIP stack */
;;;465      err = netif->input(p, netif);
000010  692a              LDR      r2,[r5,#0x10]
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  4790              BLX      r2
;;;466    
;;;467      if (err != ERR_OK)
000018  2800              CMP      r0,#0
00001a  d004              BEQ      |L4.38|
;;;468      {
;;;469        LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
;;;470        pbuf_free(p);
00001c  4620              MOV      r0,r4
00001e  e8bd4070          POP      {r4-r6,lr}
000022  f7ffbffe          B.W      pbuf_free
                  |L4.38|
;;;471        p = NULL;
;;;472      }
;;;473    }
000026  bd70              POP      {r4-r6,pc}
;;;474    
                          ENDP


                          AREA ||i.ethernetif_notify_conn_changed||, CODE, READONLY, ALIGN=1

                  ethernetif_notify_conn_changed PROC
;;;707      */
;;;708    __weak void ethernetif_notify_conn_changed(struct netif *netif)
000000  4770              BX       lr
;;;709    {
;;;710      /* NOTE : This is function could be implemented in user file
;;;711                when the callback is needed,
;;;712      */
;;;713    
;;;714    }
;;;715    /* USER CODE END 8 */
                          ENDP


                          AREA ||i.ethernetif_set_link||, CODE, READONLY, ALIGN=2

                  ethernetif_set_link PROC
;;;581    
;;;582    void ethernetif_set_link(struct netif *netif)
000000  b538              PUSH     {r3-r5,lr}
;;;583    {
000002  4605              MOV      r5,r0
;;;584      uint32_t regvalue = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;585      /* Ethernet Link every 200ms */
;;;586      if (HAL_GetTick() - EthernetLinkTimer >= 200)
000008  f7fffffe          BL       HAL_GetTick
00000c  4c10              LDR      r4,|L6.80|
00000e  6821              LDR      r1,[r4,#0]  ; EthernetLinkTimer
000010  1a40              SUBS     r0,r0,r1
000012  28c8              CMP      r0,#0xc8
000014  d313              BCC      |L6.62|
;;;587      {
;;;588        EthernetLinkTimer = HAL_GetTick();
000016  f7fffffe          BL       HAL_GetTick
00001a  6020              STR      r0,[r4,#0]  ; EthernetLinkTimer
;;;589    
;;;590        /* Read PHY_BSR*/
;;;591        HAL_ETH_ReadPHYRegister(&heth, PHY_BSR, &regvalue);
00001c  466a              MOV      r2,sp
00001e  2101              MOVS     r1,#1
000020  480c              LDR      r0,|L6.84|
000022  f7fffffe          BL       HAL_ETH_ReadPHYRegister
;;;592    
;;;593        regvalue &= PHY_LINKED_STATUS;
000026  9800              LDR      r0,[sp,#0]
000028  f0000004          AND      r0,r0,#4
00002c  9000              STR      r0,[sp,#0]
;;;594    
;;;595        /* Check whether the netif link down and the PHY link is up */
;;;596        if(!netif_is_link_up(netif) && (regvalue))
00002e  f8951037          LDRB     r1,[r5,#0x37]
000032  074a              LSLS     r2,r1,#29
000034  d404              BMI      |L6.64|
000036  b118              CBZ      r0,|L6.64|
;;;597        {
;;;598          /* network cable is connected */
;;;599          netif_set_link_up(netif);
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       netif_set_link_up
                  |L6.62|
;;;600        }
;;;601        else if(netif_is_link_up(netif) && (!regvalue))
;;;602        {
;;;603          /* network cable is disconnected */
;;;604          netif_set_link_down(netif);
;;;605        }
;;;606      }
;;;607    }
00003e  bd38              POP      {r3-r5,pc}
                  |L6.64|
000040  0749              LSLS     r1,r1,#29             ;601
000042  d5fc              BPL      |L6.62|
000044  2800              CMP      r0,#0                 ;601
000046  d1fa              BNE      |L6.62|
000048  4628              MOV      r0,r5                 ;604
00004a  f7fffffe          BL       netif_set_link_down
00004e  bd38              POP      {r3-r5,pc}
;;;608    
                          ENDP

                  |L6.80|
                          DCD      ||.data||
                  |L6.84|
                          DCD      ||.bss||+0x4830

                          AREA ||i.ethernetif_update_config||, CODE, READONLY, ALIGN=2

                  ethernetif_update_config PROC
;;;619      */
;;;620    void ethernetif_update_config(struct netif *netif)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;621    {
000004  4607              MOV      r7,r0
;;;622      __IO uint32_t tickstart = 0;
000006  2500              MOVS     r5,#0
000008  9501              STR      r5,[sp,#4]
;;;623      uint32_t regvalue = 0;
00000a  9500              STR      r5,[sp,#0]
;;;624    
;;;625      if(netif_is_link_up(netif))
00000c  f8970037          LDRB     r0,[r7,#0x37]
000010  0740              LSLS     r0,r0,#29
000012  d543              BPL      |L7.156|
;;;626      {
;;;627        /* Restart the auto-negotiation */
;;;628        if(heth.Init.AutoNegotiation != ETH_AUTONEGOTIATION_DISABLE)
000014  4c25              LDR      r4,|L7.172|
000016  6860              LDR      r0,[r4,#4]  ; heth
000018  b368              CBZ      r0,|L7.118|
;;;629        {
;;;630          /* Enable Auto-Negotiation */
;;;631          HAL_ETH_WritePHYRegister(&heth, PHY_BCR, PHY_AUTONEGOTIATION);
00001a  f44f5280          MOV      r2,#0x1000
00001e  2100              MOVS     r1,#0
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       HAL_ETH_WritePHYRegister
;;;632    
;;;633          /* Get tick */
;;;634          tickstart = HAL_GetTick();
000026  f7fffffe          BL       HAL_GetTick
00002a  9001              STR      r0,[sp,#4]
;;;635    
;;;636          /* Wait until the auto-negotiation will be completed */
;;;637          do
;;;638          {
;;;639            HAL_ETH_ReadPHYRegister(&heth, PHY_BSR, &regvalue);
;;;640    
;;;641            /* Check for the Timeout ( 1s ) */
;;;642            if((HAL_GetTick() - tickstart ) > 1000)
00002c  f44f767a          MOV      r6,#0x3e8
                  |L7.48|
000030  466a              MOV      r2,sp                 ;639
000032  2101              MOVS     r1,#1                 ;639
000034  481d              LDR      r0,|L7.172|
000036  f7fffffe          BL       HAL_ETH_ReadPHYRegister
00003a  f7fffffe          BL       HAL_GetTick
00003e  9901              LDR      r1,[sp,#4]
000040  1a40              SUBS     r0,r0,r1
000042  42b0              CMP      r0,r6
000044  d817              BHI      |L7.118|
;;;643            {
;;;644              /* In case of timeout */
;;;645              goto error;
;;;646            }
;;;647          } while (((regvalue & PHY_AUTONEGO_COMPLETE) != PHY_AUTONEGO_COMPLETE));
000046  9800              LDR      r0,[sp,#0]
000048  0680              LSLS     r0,r0,#26
00004a  d5f1              BPL      |L7.48|
;;;648    
;;;649          /* Read the result of the auto-negotiation */
;;;650          HAL_ETH_ReadPHYRegister(&heth, PHY_SR, &regvalue);
00004c  466a              MOV      r2,sp
00004e  2131              MOVS     r1,#0x31
000050  4816              LDR      r0,|L7.172|
000052  f7fffffe          BL       HAL_ETH_ReadPHYRegister
;;;651    
;;;652          /* Configure the MAC with the Duplex Mode fixed by the auto-negotiation process */
;;;653          if((regvalue & PHY_DUPLEX_STATUS) != (uint32_t)RESET)
000056  9800              LDR      r0,[sp,#0]
000058  06c1              LSLS     r1,r0,#27
00005a  d503              BPL      |L7.100|
;;;654          {
;;;655            /* Set Ethernet duplex mode to Full-duplex following the auto-negotiation */
;;;656            heth.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
00005c  f44f6100          MOV      r1,#0x800
000060  60e1              STR      r1,[r4,#0xc]  ; heth
000062  e000              B        |L7.102|
                  |L7.100|
;;;657          }
;;;658          else
;;;659          {
;;;660            /* Set Ethernet duplex mode to Half-duplex following the auto-negotiation */
;;;661            heth.Init.DuplexMode = ETH_MODE_HALFDUPLEX;
000064  60e5              STR      r5,[r4,#0xc]  ; heth
                  |L7.102|
;;;662          }
;;;663          /* Configure the MAC with the speed fixed by the auto-negotiation process */
;;;664          if(regvalue & PHY_SPEED_STATUS)
000066  0740              LSLS     r0,r0,#29
000068  d501              BPL      |L7.110|
;;;665          {
;;;666            /* Set Ethernet speed to 10M following the auto-negotiation */
;;;667            heth.Init.Speed = ETH_SPEED_10M;
00006a  60a5              STR      r5,[r4,#8]  ; heth
00006c  e00e              B        |L7.140|
                  |L7.110|
;;;668          }
;;;669          else
;;;670          {
;;;671            /* Set Ethernet speed to 100M following the auto-negotiation */
;;;672            heth.Init.Speed = ETH_SPEED_100M;
00006e  f44f4080          MOV      r0,#0x4000
000072  60a0              STR      r0,[r4,#8]  ; heth
000074  e00a              B        |L7.140|
                  |L7.118|
;;;673          }
;;;674        }
;;;675        else /* AutoNegotiation Disable */
;;;676        {
;;;677        error :
;;;678          /* Check parameters */
;;;679          assert_param(IS_ETH_SPEED(heth.Init.Speed));
;;;680          assert_param(IS_ETH_DUPLEX_MODE(heth.Init.DuplexMode));
;;;681    
;;;682          /* Set MAC Speed and Duplex Mode to PHY */
;;;683          HAL_ETH_WritePHYRegister(&heth, PHY_BCR, ((uint16_t)(heth.Init.DuplexMode >> 3) |
000076  68e0              LDR      r0,[r4,#0xc]  ; heth
000078  2100              MOVS     r1,#0
00007a  f3c002cf          UBFX     r2,r0,#3,#16
00007e  68a0              LDR      r0,[r4,#8]  ; heth
000080  f3c0004f          UBFX     r0,r0,#1,#16
000084  4302              ORRS     r2,r2,r0
000086  4809              LDR      r0,|L7.172|
000088  f7fffffe          BL       HAL_ETH_WritePHYRegister
                  |L7.140|
;;;684                                                         (uint16_t)(heth.Init.Speed >> 1)));
;;;685        }
;;;686    
;;;687        /* ETHERNET MAC Re-Configuration */
;;;688        HAL_ETH_ConfigMAC(&heth, (ETH_MACInitTypeDef *) NULL);
00008c  2100              MOVS     r1,#0
00008e  4807              LDR      r0,|L7.172|
000090  f7fffffe          BL       HAL_ETH_ConfigMAC
;;;689    
;;;690        /* Restart MAC interface */
;;;691        HAL_ETH_Start(&heth);
000094  4805              LDR      r0,|L7.172|
000096  f7fffffe          BL       HAL_ETH_Start
00009a  e002              B        |L7.162|
                  |L7.156|
;;;692      }
;;;693      else
;;;694      {
;;;695        /* Stop MAC interface */
;;;696        HAL_ETH_Stop(&heth);
00009c  4803              LDR      r0,|L7.172|
00009e  f7fffffe          BL       HAL_ETH_Stop
                  |L7.162|
;;;697      }
;;;698    
;;;699      ethernetif_notify_conn_changed(netif);
0000a2  4638              MOV      r0,r7
0000a4  f7fffffe          BL       ethernetif_notify_conn_changed
;;;700    }
0000a8  e8bd81fc          POP      {r2-r8,pc}
;;;701    
                          ENDP

                  |L7.172|
                          DCD      ||.bss||+0x4830

                          AREA ||i.low_level_init||, CODE, READONLY, ALIGN=2

                  low_level_init PROC
;;;183     */
;;;184    static void low_level_init(struct netif *netif)
000000  b57c              PUSH     {r2-r6,lr}
;;;185    {
000002  4604              MOV      r4,r0
;;;186      HAL_StatusTypeDef hal_eth_init_status;
;;;187    
;;;188    /* Init ETH */
;;;189    
;;;190       uint8_t MACAddr[6] ;
;;;191      heth.Instance = ETH;
000004  4d2a              LDR      r5,|L8.176|
000006  4829              LDR      r0,|L8.172|
000008  6028              STR      r0,[r5,#0]  ; heth
;;;192      heth.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
00000a  2001              MOVS     r0,#1
00000c  6068              STR      r0,[r5,#4]  ; heth
;;;193      heth.Init.PhyAddress = LAN8720A_PHY_ADDRESS;
00000e  2000              MOVS     r0,#0
000010  8228              STRH     r0,[r5,#0x10]
;;;194      MACAddr[0] = 0x00;
000012  f88d0000          STRB     r0,[sp,#0]
;;;195      MACAddr[1] = 0x80;
000016  2180              MOVS     r1,#0x80
000018  f88d1001          STRB     r1,[sp,#1]
;;;196      MACAddr[2] = 0xE1;
00001c  21e1              MOVS     r1,#0xe1
00001e  f88d1002          STRB     r1,[sp,#2]
;;;197      MACAddr[3] = 0x00;
000022  f88d0003          STRB     r0,[sp,#3]
;;;198      MACAddr[4] = 0x00;
000026  f88d0004          STRB     r0,[sp,#4]
;;;199      MACAddr[5] = 0x00;
00002a  f88d0005          STRB     r0,[sp,#5]
;;;200      heth.Init.MACAddr = &MACAddr[0];
00002e  f8c5d014          STR      sp,[r5,#0x14]  ; heth
;;;201      heth.Init.RxMode = ETH_RXPOLLING_MODE;
000032  61a8              STR      r0,[r5,#0x18]  ; heth
;;;202      heth.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
000034  61e8              STR      r0,[r5,#0x1c]  ; heth
;;;203      heth.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
000036  f44f0000          MOV      r0,#0x800000
00003a  6228              STR      r0,[r5,#0x20]  ; heth
;;;204    
;;;205      /* USER CODE BEGIN MACADDRESS */
;;;206    
;;;207      /* USER CODE END MACADDRESS */
;;;208    
;;;209      hal_eth_init_status = HAL_ETH_Init(&heth);
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       HAL_ETH_Init
;;;210    
;;;211      if (hal_eth_init_status == HAL_OK)
000042  b928              CBNZ     r0,|L8.80|
;;;212      {
;;;213        /* Set netif link flag */
;;;214        netif->flags |= NETIF_FLAG_LINK_UP;
000044  f8940037          LDRB     r0,[r4,#0x37]
000048  f0400004          ORR      r0,r0,#4
00004c  f8840037          STRB     r0,[r4,#0x37]
                  |L8.80|
;;;215      }
;;;216      /* Initialize Tx Descriptors list: Chain Mode */
;;;217      HAL_ETH_DMATxDescListInit(&heth, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
000050  2304              MOVS     r3,#4
000052  4a18              LDR      r2,|L8.180|
000054  4918              LDR      r1,|L8.184|
000056  4816              LDR      r0,|L8.176|
000058  f7fffffe          BL       HAL_ETH_DMATxDescListInit
;;;218    
;;;219      /* Initialize Rx Descriptors list: Chain Mode  */
;;;220      HAL_ETH_DMARxDescListInit(&heth, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
00005c  4a16              LDR      r2,|L8.184|
00005e  2308              MOVS     r3,#8
000060  3240              ADDS     r2,r2,#0x40
000062  f1a201c0          SUB      r1,r2,#0xc0
000066  4812              LDR      r0,|L8.176|
000068  f7fffffe          BL       HAL_ETH_DMARxDescListInit
;;;221    
;;;222    #if LWIP_ARP || LWIP_ETHERNET
;;;223    
;;;224      /* set MAC hardware address length */
;;;225      netif->hwaddr_len = ETH_HWADDR_LEN;
00006c  2006              MOVS     r0,#6
00006e  342e              ADDS     r4,r4,#0x2e
000070  70a0              STRB     r0,[r4,#2]
;;;226    
;;;227      /* set MAC hardware address */
;;;228      netif->hwaddr[0] =  heth.Init.MACAddr[0];
000072  6968              LDR      r0,[r5,#0x14]  ; heth
000074  7800              LDRB     r0,[r0,#0]
000076  70e0              STRB     r0,[r4,#3]
;;;229      netif->hwaddr[1] =  heth.Init.MACAddr[1];
000078  6968              LDR      r0,[r5,#0x14]  ; heth
00007a  7840              LDRB     r0,[r0,#1]
00007c  7120              STRB     r0,[r4,#4]
;;;230      netif->hwaddr[2] =  heth.Init.MACAddr[2];
00007e  6968              LDR      r0,[r5,#0x14]  ; heth
000080  7880              LDRB     r0,[r0,#2]
000082  7160              STRB     r0,[r4,#5]
;;;231      netif->hwaddr[3] =  heth.Init.MACAddr[3];
000084  6968              LDR      r0,[r5,#0x14]  ; heth
000086  78c0              LDRB     r0,[r0,#3]
000088  71a0              STRB     r0,[r4,#6]
;;;232      netif->hwaddr[4] =  heth.Init.MACAddr[4];
00008a  6968              LDR      r0,[r5,#0x14]  ; heth
00008c  7900              LDRB     r0,[r0,#4]
00008e  71e0              STRB     r0,[r4,#7]
;;;233      netif->hwaddr[5] =  heth.Init.MACAddr[5];
000090  6968              LDR      r0,[r5,#0x14]  ; heth
000092  7940              LDRB     r0,[r0,#5]
000094  7220              STRB     r0,[r4,#8]
;;;234    
;;;235      /* maximum transfer unit */
;;;236      netif->mtu = 1500;
000096  f24050dc          MOV      r0,#0x5dc
00009a  8020              STRH     r0,[r4,#0]
;;;237    
;;;238      /* Accept broadcast address and ARP traffic */
;;;239      /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
;;;240      #if LWIP_ARP
;;;241        netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP;
00009c  7a60              LDRB     r0,[r4,#9]
00009e  f040000a          ORR      r0,r0,#0xa
0000a2  7260              STRB     r0,[r4,#9]
;;;242      #else
;;;243        netif->flags |= NETIF_FLAG_BROADCAST;
;;;244      #endif /* LWIP_ARP */
;;;245    
;;;246      /* Enable MAC and DMA transmission and reception */
;;;247      HAL_ETH_Start(&heth);
0000a4  4802              LDR      r0,|L8.176|
0000a6  f7fffffe          BL       HAL_ETH_Start
;;;248    
;;;249    /* USER CODE BEGIN PHY_PRE_CONFIG */
;;;250    
;;;251    /* USER CODE END PHY_PRE_CONFIG */
;;;252    
;;;253    /* USER CODE BEGIN PHY_POST_CONFIG */
;;;254    
;;;255    /* USER CODE END PHY_POST_CONFIG */
;;;256    
;;;257    #endif /* LWIP_ARP || LWIP_ETHERNET */
;;;258    
;;;259    /* USER CODE BEGIN LOW_LEVEL_INIT */
;;;260    
;;;261    /* USER CODE END LOW_LEVEL_INIT */
;;;262    }
0000aa  bd7c              POP      {r2-r6,pc}
;;;263    
                          ENDP

                  |L8.172|
                          DCD      0x40028000
                  |L8.176|
                          DCD      ||.bss||+0x4830
                  |L8.180|
                          DCD      ||.bss||+0x3060
                  |L8.184|
                          DCD      ||.bss||+0x80

                          AREA ||i.low_level_input||, CODE, READONLY, ALIGN=2

                  low_level_input PROC
;;;363       */
;;;364    static struct pbuf * low_level_input(struct netif *netif)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;365    {
;;;366      struct pbuf *p = NULL;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;367      struct pbuf *q = NULL;
;;;368      uint16_t len = 0;
;;;369      uint8_t *buffer;
;;;370      __IO ETH_DMADescTypeDef *dmarxdesc;
;;;371      uint32_t bufferoffset = 0;
000008  2400              MOVS     r4,#0
;;;372      uint32_t payloadoffset = 0;
;;;373      uint32_t byteslefttocopy = 0;
;;;374      uint32_t i=0;
;;;375    
;;;376      /* get received frame */
;;;377      if (HAL_ETH_GetReceivedFrame(&heth) != HAL_OK)
00000a  482d              LDR      r0,|L9.192|
00000c  f7fffffe          BL       HAL_ETH_GetReceivedFrame
000010  b110              CBZ      r0,|L9.24|
;;;378    
;;;379        return NULL;
000012  2000              MOVS     r0,#0
                  |L9.20|
;;;380    
;;;381      /* Obtain the size of the packet and put it into the "len" variable. */
;;;382      len = heth.RxFrameInfos.length;
;;;383      buffer = (uint8_t *)heth.RxFrameInfos.buffer;
;;;384    
;;;385      if (len > 0)
;;;386      {
;;;387        /* We allocate a pbuf chain of pbufs from the Lwip buffer pool */
;;;388        p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
;;;389      }
;;;390    
;;;391      if (p != NULL)
;;;392      {
;;;393        dmarxdesc = heth.RxFrameInfos.FSRxDesc;
;;;394        bufferoffset = 0;
;;;395        for(q = p; q != NULL; q = q->next)
;;;396        {
;;;397          byteslefttocopy = q->len;
;;;398          payloadoffset = 0;
;;;399    
;;;400          /* Check if the length of bytes to copy in current pbuf is bigger than Rx buffer size*/
;;;401          while( (byteslefttocopy + bufferoffset) > ETH_RX_BUF_SIZE )
;;;402          {
;;;403            /* Copy data to pbuf */
;;;404            memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), (ETH_RX_BUF_SIZE - bufferoffset));
;;;405    
;;;406            /* Point to next descriptor */
;;;407            dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
;;;408            buffer = (uint8_t *)(dmarxdesc->Buffer1Addr);
;;;409    
;;;410            byteslefttocopy = byteslefttocopy - (ETH_RX_BUF_SIZE - bufferoffset);
;;;411            payloadoffset = payloadoffset + (ETH_RX_BUF_SIZE - bufferoffset);
;;;412            bufferoffset = 0;
;;;413          }
;;;414          /* Copy remaining data in pbuf */
;;;415          memcpy( (uint8_t*)((uint8_t*)q->payload + payloadoffset), (uint8_t*)((uint8_t*)buffer + bufferoffset), byteslefttocopy);
;;;416          bufferoffset = bufferoffset + byteslefttocopy;
;;;417        }
;;;418      }
;;;419    
;;;420        /* Release descriptors to DMA */
;;;421        /* Point to first descriptor */
;;;422        dmarxdesc = heth.RxFrameInfos.FSRxDesc;
;;;423        /* Set Own bit in Rx descriptors: gives the buffers back to DMA */
;;;424        for (i=0; i< heth.RxFrameInfos.SegCount; i++)
;;;425        {
;;;426          dmarxdesc->Status |= ETH_DMARXDESC_OWN;
;;;427          dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
;;;428        }
;;;429    
;;;430        /* Clear Segment_Count */
;;;431        heth.RxFrameInfos.SegCount =0;
;;;432    
;;;433      /* When Rx Buffer unavailable flag is set: clear it and resume reception */
;;;434      if ((heth.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)
;;;435      {
;;;436        /* Clear RBUS ETHERNET DMA flag */
;;;437        heth.Instance->DMASR = ETH_DMASR_RBUS;
;;;438        /* Resume DMA reception */
;;;439        heth.Instance->DMARPDR = 0;
;;;440      }
;;;441      return p;
;;;442    }
000014  e8bd8ff8          POP      {r3-r11,pc}
                  |L9.24|
000018  4829              LDR      r0,|L9.192|
00001a  8f81              LDRH     r1,[r0,#0x3c]         ;382  ; heth
00001c  b289              UXTH     r1,r1                 ;382
00001e  f8d09040          LDR      r9,[r0,#0x40]         ;383  ; heth
000022  b121              CBZ      r1,|L9.46|
000024  2203              MOVS     r2,#3                 ;388
000026  2004              MOVS     r0,#4                 ;388
000028  f7fffffe          BL       pbuf_alloc
00002c  9000              STR      r0,[sp,#0]            ;388
                  |L9.46|
00002e  9800              LDR      r0,[sp,#0]            ;391
000030  b358              CBZ      r0,|L9.138|
000032  4823              LDR      r0,|L9.192|
000034  f8d08030          LDR      r8,[r0,#0x30]         ;393  ; heth
000038  9d00              LDR      r5,[sp,#0]            ;395
00003a  e024              B        |L9.134|
                  |L9.60|
00003c  896f              LDRH     r7,[r5,#0xa]          ;397
00003e  2600              MOVS     r6,#0                 ;398
000040  f2405bf4          MOV      r11,#0x5f4            ;401
000044  e012              B        |L9.108|
                  |L9.70|
000046  6868              LDR      r0,[r5,#4]            ;404
000048  f2a452f4          SUB      r2,r4,#0x5f4          ;404
00004c  eb090104          ADD      r1,r9,r4              ;404
000050  4430              ADD      r0,r0,r6              ;404
000052  4252              RSBS     r2,r2,#0              ;404
000054  f7fffffe          BL       __aeabi_memcpy
000058  f8d8800c          LDR      r8,[r8,#0xc]          ;407
00005c  f8d89008          LDR      r9,[r8,#8]            ;408
000060  f2aa57f4          SUB      r7,r10,#0x5f4         ;410
000064  1b36              SUBS     r6,r6,r4              ;411
000066  f20656f4          ADD      r6,r6,#0x5f4          ;411
00006a  2400              MOVS     r4,#0                 ;412
                  |L9.108|
00006c  eb070a04          ADD      r10,r7,r4             ;401
000070  45da              CMP      r10,r11               ;401
000072  d8e8              BHI      |L9.70|
000074  6868              LDR      r0,[r5,#4]            ;415
000076  eb090104          ADD      r1,r9,r4              ;415
00007a  4430              ADD      r0,r0,r6              ;415
00007c  463a              MOV      r2,r7                 ;415
00007e  f7fffffe          BL       __aeabi_memcpy
000082  443c              ADD      r4,r4,r7              ;416
000084  682d              LDR      r5,[r5,#0]            ;395
                  |L9.134|
000086  2d00              CMP      r5,#0                 ;395
000088  d1d8              BNE      |L9.60|
                  |L9.138|
00008a  4a0d              LDR      r2,|L9.192|
00008c  6b10              LDR      r0,[r2,#0x30]         ;422  ; heth
00008e  2100              MOVS     r1,#0                 ;424
000090  e005              B        |L9.158|
                  |L9.146|
000092  6803              LDR      r3,[r0,#0]            ;426
000094  f0434300          ORR      r3,r3,#0x80000000     ;426
000098  6003              STR      r3,[r0,#0]            ;426
00009a  68c0              LDR      r0,[r0,#0xc]          ;427
00009c  1c49              ADDS     r1,r1,#1              ;424
                  |L9.158|
00009e  6b93              LDR      r3,[r2,#0x38]         ;424  ; heth
0000a0  428b              CMP      r3,r1                 ;424
0000a2  d8f6              BHI      |L9.146|
0000a4  2100              MOVS     r1,#0                 ;431
0000a6  6391              STR      r1,[r2,#0x38]         ;431  ; heth
0000a8  6810              LDR      r0,[r2,#0]            ;434  ; heth
0000aa  f5005080          ADD      r0,r0,#0x1000         ;434
0000ae  6942              LDR      r2,[r0,#0x14]         ;434
0000b0  0612              LSLS     r2,r2,#24             ;434
0000b2  d502              BPL      |L9.186|
0000b4  2280              MOVS     r2,#0x80              ;437
0000b6  6142              STR      r2,[r0,#0x14]         ;437
0000b8  6081              STR      r1,[r0,#8]            ;439
                  |L9.186|
0000ba  9800              LDR      r0,[sp,#0]            ;441
0000bc  e7aa              B        |L9.20|
;;;443    
                          ENDP

0000be  0000              DCW      0x0000
                  |L9.192|
                          DCD      ||.bss||+0x4830

                          AREA ||i.low_level_output||, CODE, READONLY, ALIGN=2

                  low_level_output PROC
;;;279    
;;;280    static err_t low_level_output(struct netif *netif, struct pbuf *p)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;281    {
000004  460e              MOV      r6,r1
;;;282      err_t errval;
;;;283      struct pbuf *q;
;;;284      uint8_t *buffer = (uint8_t *)(heth.TxDesc->Buffer1Addr);
000006  4829              LDR      r0,|L10.172|
000008  6ac5              LDR      r5,[r0,#0x2c]  ; heth
00000a  f8d5a008          LDR      r10,[r5,#8]
;;;285      __IO ETH_DMADescTypeDef *DmaTxDesc;
;;;286      uint32_t framelength = 0;
00000e  f04f0900          MOV      r9,#0
;;;287      uint32_t bufferoffset = 0;
000012  2400              MOVS     r4,#0
000014  e035              B        |L10.130|
                  |L10.22|
;;;288      uint32_t byteslefttocopy = 0;
;;;289      uint32_t payloadoffset = 0;
;;;290      DmaTxDesc = heth.TxDesc;
;;;291      bufferoffset = 0;
;;;292    
;;;293      /* copy frame from pbufs to driver buffers */
;;;294      for(q = p; q != NULL; q = q->next)
;;;295        {
;;;296          /* Is this buffer available? If not, goto error */
;;;297          if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
000016  6828              LDR      r0,[r5,#0]
000018  2800              CMP      r0,#0
00001a  da02              BGE      |L10.34|
;;;298          {
;;;299            errval = ERR_USE;
00001c  f06f0007          MVN      r0,#7
;;;300            goto error;
000020  e036              B        |L10.144|
                  |L10.34|
;;;301          }
;;;302    
;;;303          /* Get bytes in current lwIP buffer */
;;;304          byteslefttocopy = q->len;
000022  f8b6800a          LDRH     r8,[r6,#0xa]
;;;305          payloadoffset = 0;
000026  2700              MOVS     r7,#0
;;;306    
;;;307          /* Check if the length of data to copy is bigger than Tx buffer size*/
;;;308          while( (byteslefttocopy + bufferoffset) > ETH_TX_BUF_SIZE )
000028  e01b              B        |L10.98|
                  |L10.42|
;;;309          {
;;;310            /* Copy data to Tx buffer*/
;;;311            memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), (ETH_TX_BUF_SIZE - bufferoffset) );
00002a  6870              LDR      r0,[r6,#4]
00002c  f2a452f4          SUB      r2,r4,#0x5f4
000030  19c1              ADDS     r1,r0,r7
000032  eb0a0004          ADD      r0,r10,r4
000036  4252              RSBS     r2,r2,#0
000038  f7fffffe          BL       __aeabi_memcpy
;;;312    
;;;313            /* Point to next descriptor */
;;;314            DmaTxDesc = (ETH_DMADescTypeDef *)(DmaTxDesc->Buffer2NextDescAddr);
00003c  68ed              LDR      r5,[r5,#0xc]
;;;315    
;;;316            /* Check if the buffer is available */
;;;317            if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET)
00003e  6828              LDR      r0,[r5,#0]
000040  2800              CMP      r0,#0
000042  da02              BGE      |L10.74|
;;;318            {
;;;319              errval = ERR_USE;
000044  f06f0007          MVN      r0,#7
;;;320              goto error;
000048  e022              B        |L10.144|
                  |L10.74|
;;;321            }
;;;322    
;;;323            buffer = (uint8_t *)(DmaTxDesc->Buffer1Addr);
00004a  f8d5a008          LDR      r10,[r5,#8]
;;;324    
;;;325            byteslefttocopy = byteslefttocopy - (ETH_TX_BUF_SIZE - bufferoffset);
00004e  f2ab58f4          SUB      r8,r11,#0x5f4
;;;326            payloadoffset = payloadoffset + (ETH_TX_BUF_SIZE - bufferoffset);
000052  1b3f              SUBS     r7,r7,r4
000054  f20757f4          ADD      r7,r7,#0x5f4
;;;327            framelength = framelength + (ETH_TX_BUF_SIZE - bufferoffset);
000058  eba90904          SUB      r9,r9,r4
00005c  f20959f4          ADD      r9,r9,#0x5f4
;;;328            bufferoffset = 0;
000060  2400              MOVS     r4,#0
                  |L10.98|
000062  eb080b04          ADD      r11,r8,r4             ;308
000066  f24050f4          MOV      r0,#0x5f4             ;308
00006a  4583              CMP      r11,r0                ;308
00006c  d8dd              BHI      |L10.42|
;;;329          }
;;;330    
;;;331          /* Copy the remaining bytes */
;;;332          memcpy( (uint8_t*)((uint8_t*)buffer + bufferoffset), (uint8_t*)((uint8_t*)q->payload + payloadoffset), byteslefttocopy );
00006e  6870              LDR      r0,[r6,#4]
000070  4642              MOV      r2,r8
000072  19c1              ADDS     r1,r0,r7
000074  eb0a0004          ADD      r0,r10,r4
000078  f7fffffe          BL       __aeabi_memcpy
;;;333          bufferoffset = bufferoffset + byteslefttocopy;
00007c  4444              ADD      r4,r4,r8
;;;334          framelength = framelength + byteslefttocopy;
00007e  44c1              ADD      r9,r9,r8
000080  6836              LDR      r6,[r6,#0]            ;294
                  |L10.130|
000082  2e00              CMP      r6,#0                 ;294
000084  d1c7              BNE      |L10.22|
;;;335        }
;;;336    
;;;337      /* Prepare transmit descriptors to give to DMA */
;;;338      HAL_ETH_TransmitFrame(&heth, framelength);
000086  4649              MOV      r1,r9
000088  4808              LDR      r0,|L10.172|
00008a  f7fffffe          BL       HAL_ETH_TransmitFrame
;;;339    
;;;340      errval = ERR_OK;
00008e  2000              MOVS     r0,#0
                  |L10.144|
;;;341    
;;;342    error:
;;;343    
;;;344      /* When Transmit Underflow flag is set, clear it and issue a Transmit Poll Demand to resume transmission */
;;;345      if ((heth.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET)
000090  4906              LDR      r1,|L10.172|
000092  6809              LDR      r1,[r1,#0]  ; heth
000094  f5015180          ADD      r1,r1,#0x1000
000098  694a              LDR      r2,[r1,#0x14]
00009a  0692              LSLS     r2,r2,#26
00009c  d503              BPL      |L10.166|
;;;346      {
;;;347        /* Clear TUS ETHERNET DMA flag */
;;;348        heth.Instance->DMASR = ETH_DMASR_TUS;
00009e  2220              MOVS     r2,#0x20
0000a0  614a              STR      r2,[r1,#0x14]
;;;349    
;;;350        /* Resume DMA transmission*/
;;;351        heth.Instance->DMATPDR = 0;
0000a2  2200              MOVS     r2,#0
0000a4  604a              STR      r2,[r1,#4]
                  |L10.166|
;;;352      }
;;;353      return errval;
;;;354    }
0000a6  e8bd9ff0          POP      {r4-r12,pc}
;;;355    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L10.172|
                          DCD      ||.bss||+0x4830

                          AREA ||i.sys_jiffies||, CODE, READONLY, ALIGN=1

                  sys_jiffies PROC
;;;554    */
;;;555    u32_t sys_jiffies(void)
000000  f7ffbffe          B.W      HAL_GetTick
;;;556    {
;;;557      return HAL_GetTick();
;;;558    }
;;;559    
                          ENDP


                          AREA ||i.sys_now||, CODE, READONLY, ALIGN=1

                  sys_now PROC
;;;565    */
;;;566    u32_t sys_now(void)
000000  f7ffbffe          B.W      HAL_GetTick
;;;567    {
;;;568      return HAL_GetTick();
;;;569    }
;;;570    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  DMARxDscrTab
                          %        128
                  DMATxDscrTab
                          %        64
                  Rx_Buff
                          %        12192
                  Tx_Buff
                          %        6096
                  heth
                          %        72

                          AREA ||.data||, DATA, ALIGN=2

                  EthernetLinkTimer
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Src\\ethernetif.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_ethernetif_c_8fd98312____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___12_ethernetif_c_8fd98312____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_ethernetif_c_8fd98312____REVSH|
#line 478
|__asm___12_ethernetif_c_8fd98312____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_ethernetif_c_8fd98312____RRX|
#line 665
|__asm___12_ethernetif_c_8fd98312____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
