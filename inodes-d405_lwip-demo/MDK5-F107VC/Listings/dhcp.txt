; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\dhcp.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\dhcp.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\dhcp.crf ..\Middlewares\Third_Party\LwIP\src\core\ipv4\dhcp.c]
                          THUMB

                          AREA ||i.dhcp_arp_reply||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dhcp_arp_reply PROC
;;;902    void
;;;903    dhcp_arp_reply(struct netif *netif, const ip4_addr_t *addr)
000000  2800              CMP      r0,#0
;;;904    {
000002  d00b              BEQ      |L1.28|
;;;905      struct dhcp *dhcp;
;;;906    
;;;907      LWIP_ERROR("netif != NULL", (netif != NULL), return;);
;;;908      dhcp = netif_dhcp_data(netif);
000004  6a82              LDR      r2,[r0,#0x28]
;;;909      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_arp_reply()\n"));
;;;910      /* is a DHCP client doing an ARP check? */
;;;911      if ((dhcp != NULL) && (dhcp->state == DHCP_STATE_CHECKING)) {
000006  2a00              CMP      r2,#0
000008  d00f              BEQ      |L1.42|
00000a  7953              LDRB     r3,[r2,#5]
00000c  2b08              CMP      r3,#8
00000e  d10c              BNE      |L1.42|
;;;912        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n",
;;;913                    ip4_addr_get_u32(addr)));
;;;914        /* did a host respond with the address we
;;;915           were offered by the DHCP server? */
;;;916        if (ip4_addr_cmp(addr, &dhcp->offered_ip_addr)) {
000010  6809              LDR      r1,[r1,#0]
000012  69d2              LDR      r2,[r2,#0x1c]
000014  4291              CMP      r1,r2
000016  d108              BNE      |L1.42|
;;;917          /* we will not accept the offered address */
;;;918          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | LWIP_DBG_LEVEL_WARNING,
;;;919                      ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
;;;920          dhcp_decline(netif);
000018  f7ffbffe          B.W      dhcp_decline
                  |L1.28|
00001c  a303              ADR      r3,|L1.44|
00001e  f240328b          MOV      r2,#0x38b             ;907
000022  a110              ADR      r1,|L1.100|
000024  a013              ADR      r0,|L1.116|
000026  f7ffbffe          B.W      __2printf
                  |L1.42|
;;;921        }
;;;922      }
;;;923    }
00002a  4770              BX       lr
;;;924    
                          ENDP

                  |L1.44|
00002c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
000030  6964646c
000034  65776172
000038  65735c54
00003c  68697264
000040  5f506172
000044  74795c4c
000048  7749505c
00004c  7372635c
000050  636f7265
000054  5c697076
000058  345c6468
00005c  63702e63          DCB      "cp.c",0
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0
                  |L1.100|
000064  6e657469          DCB      "netif != NULL",0
000068  6620213d
00006c  204e554c
000070  4c00    
000072  00                DCB      0
000073  00                DCB      0
                  |L1.116|
000074  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000078  7274696f
00007c  6e202225
000080  73222066
000084  61696c65
000088  64206174
00008c  206c696e
000090  65202564
000094  20696e20
000098  25730a00

                          AREA ||i.dhcp_bind||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  dhcp_bind PROC
;;;1039   static void
;;;1040   dhcp_bind(struct netif *netif)
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;1041   {
000004  4605              MOV      r5,r0
;;;1042     u32_t timeout;
;;;1043     struct dhcp *dhcp;
;;;1044     ip4_addr_t sn_mask, gw_addr;
;;;1045     LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
000006  2d00              CMP      r5,#0
000008  d01a              BEQ      |L2.64|
;;;1046     dhcp = netif_dhcp_data(netif);
00000a  6aac              LDR      r4,[r5,#0x28]
;;;1047     LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
00000c  2c00              CMP      r4,#0
00000e  d020              BEQ      |L2.82|
;;;1048     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
;;;1049   
;;;1050     /* reset time used of lease */
;;;1051     dhcp->lease_used = 0;
000010  2700              MOVS     r7,#0
000012  8267              STRH     r7,[r4,#0x12]
;;;1052   
;;;1053     if (dhcp->offered_t0_lease != 0xffffffffUL) {
000014  6aa3              LDR      r3,[r4,#0x28]
;;;1054       /* set renewal period timer */
;;;1055       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t0 renewal timer %"U32_F" secs\n", dhcp->offered_t0_lease));
;;;1056       timeout = (dhcp->offered_t0_lease + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
000016  f04f023c          MOV      r2,#0x3c
00001a  1c58              ADDS     r0,r3,#1              ;1053
;;;1057       if (timeout > 0xffff) {
00001c  f44f3880          MOV      r8,#0x10000
;;;1058         timeout = 0xffff;
;;;1059       }
;;;1060       dhcp->t0_timeout = (u16_t)timeout;
;;;1061       if (dhcp->t0_timeout == 0) {
;;;1062         dhcp->t0_timeout = 1;
000020  f04f0c01          MOV      r12,#1
000024  f64f76ff          MOV      r6,#0xffff            ;1058
000028  d01d              BEQ      |L2.102|
00002a  331e              ADDS     r3,r3,#0x1e           ;1056
00002c  fbb3f0f2          UDIV     r0,r3,r2              ;1056
000030  4540              CMP      r0,r8                 ;1057
000032  d300              BCC      |L2.54|
000034  4630              MOV      r0,r6                 ;1058
                  |L2.54|
000036  b283              UXTH     r3,r0                 ;1060
000038  82a3              STRH     r3,[r4,#0x14]         ;1060
00003a  2b00              CMP      r3,#0                 ;1061
00003c  d011              BEQ      |L2.98|
00003e  e012              B        |L2.102|
                  |L2.64|
000040  a32f              ADR      r3,|L2.256|
000042  f2404215          MOV      r2,#0x415             ;1045
000046  a13c              ADR      r1,|L2.312|
000048  a042              ADR      r0,|L2.340|
00004a  f7fffffe          BL       __2printf
                  |L2.78|
;;;1063       }
;;;1064       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t0_lease * 1000));
;;;1065     }
;;;1066   
;;;1067     /* temporary DHCP lease? */
;;;1068     if (dhcp->offered_t1_renew != 0xffffffffUL) {
;;;1069       /* set renewal period timer */
;;;1070       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
;;;1071       timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
;;;1072       if (timeout > 0xffff) {
;;;1073         timeout = 0xffff;
;;;1074       }
;;;1075       dhcp->t1_timeout = (u16_t)timeout;
;;;1076       if (dhcp->t1_timeout == 0) {
;;;1077         dhcp->t1_timeout = 1;
;;;1078       }
;;;1079       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew * 1000));
;;;1080       dhcp->t1_renew_time = dhcp->t1_timeout;
;;;1081     }
;;;1082     /* set renewal period timer */
;;;1083     if (dhcp->offered_t2_rebind != 0xffffffffUL) {
;;;1084       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
;;;1085       timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
;;;1086       if (timeout > 0xffff) {
;;;1087         timeout = 0xffff;
;;;1088       }
;;;1089       dhcp->t2_timeout = (u16_t)timeout;
;;;1090       if (dhcp->t2_timeout == 0) {
;;;1091         dhcp->t2_timeout = 1;
;;;1092       }
;;;1093       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind * 1000));
;;;1094       dhcp->t2_rebind_time = dhcp->t2_timeout;
;;;1095     }
;;;1096   
;;;1097     /* If we have sub 1 minute lease, t2 and t1 will kick in at the same time. */
;;;1098     if ((dhcp->t1_timeout >= dhcp->t2_timeout) && (dhcp->t2_timeout > 0)) {
;;;1099       dhcp->t1_timeout = 0;
;;;1100     }
;;;1101   
;;;1102     if (dhcp->subnet_mask_given) {
;;;1103       /* copy offered network mask */
;;;1104       ip4_addr_copy(sn_mask, dhcp->offered_sn_mask);
;;;1105     } else {
;;;1106       /* subnet mask not given, choose a safe subnet mask given the network class */
;;;1107       u8_t first_octet = ip4_addr1(&dhcp->offered_ip_addr);
;;;1108       if (first_octet <= 127) {
;;;1109         ip4_addr_set_u32(&sn_mask, PP_HTONL(0xff000000UL));
;;;1110       } else if (first_octet >= 192) {
;;;1111         ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffffff00UL));
;;;1112       } else {
;;;1113         ip4_addr_set_u32(&sn_mask, PP_HTONL(0xffff0000UL));
;;;1114       }
;;;1115     }
;;;1116   
;;;1117     ip4_addr_copy(gw_addr, dhcp->offered_gw_addr);
;;;1118     /* gateway address not given? */
;;;1119     if (ip4_addr_isany_val(gw_addr)) {
;;;1120       /* copy network address */
;;;1121       ip4_addr_get_network(&gw_addr, &dhcp->offered_ip_addr, &sn_mask);
;;;1122       /* use first host address on network as gateway */
;;;1123       ip4_addr_set_u32(&gw_addr, ip4_addr_get_u32(&gw_addr) | PP_HTONL(0x00000001UL));
;;;1124     }
;;;1125   
;;;1126   #if LWIP_DHCP_AUTOIP_COOP
;;;1127     if (dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
;;;1128       autoip_stop(netif);
;;;1129       dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
;;;1130     }
;;;1131   #endif /* LWIP_DHCP_AUTOIP_COOP */
;;;1132   
;;;1133     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F" SN: 0x%08"X32_F" GW: 0x%08"X32_F"\n",
;;;1134                 ip4_addr_get_u32(&dhcp->offered_ip_addr), ip4_addr_get_u32(&sn_mask), ip4_addr_get_u32(&gw_addr)));
;;;1135     /* netif is now bound to DHCP leased address - set this before assigning the address
;;;1136        to ensure the callback can use dhcp_supplied_address() */
;;;1137     dhcp_set_state(dhcp, DHCP_STATE_BOUND);
;;;1138   
;;;1139     netif_set_addr(netif, &dhcp->offered_ip_addr, &sn_mask, &gw_addr);
;;;1140     /* interface is used by routing now that an address is set */
;;;1141   }
00004e  e8bd81fc          POP      {r2-r8,pc}
                  |L2.82|
000052  a32b              ADR      r3,|L2.256|
000054  f2404217          MOV      r2,#0x417             ;1047
000058  a148              ADR      r1,|L2.380|
00005a  a03e              ADR      r0,|L2.340|
00005c  f7fffffe          BL       __2printf
000060  e7f5              B        |L2.78|
                  |L2.98|
000062  f8a4c014          STRH     r12,[r4,#0x14]        ;1062
                  |L2.102|
000066  6ae3              LDR      r3,[r4,#0x2c]         ;1068
000068  1c58              ADDS     r0,r3,#1              ;1068
00006a  d00c              BEQ      |L2.134|
00006c  331e              ADDS     r3,r3,#0x1e           ;1071
00006e  fbb3f1f2          UDIV     r1,r3,r2              ;1071
000072  4541              CMP      r1,r8                 ;1072
000074  d300              BCC      |L2.120|
000076  4631              MOV      r1,r6                 ;1073
                  |L2.120|
000078  b28b              UXTH     r3,r1                 ;1075
00007a  8163              STRH     r3,[r4,#0xa]          ;1075
00007c  b90b              CBNZ     r3,|L2.130|
00007e  f8a4c00a          STRH     r12,[r4,#0xa]         ;1077
                  |L2.130|
000082  8960              LDRH     r0,[r4,#0xa]          ;1080
000084  81e0              STRH     r0,[r4,#0xe]          ;1080
                  |L2.134|
000086  6b23              LDR      r3,[r4,#0x30]         ;1083
000088  1c58              ADDS     r0,r3,#1              ;1083
00008a  d00c              BEQ      |L2.166|
00008c  331e              ADDS     r3,r3,#0x1e           ;1085
00008e  fbb3f2f2          UDIV     r2,r3,r2              ;1085
000092  4542              CMP      r2,r8                 ;1086
000094  d300              BCC      |L2.152|
000096  4632              MOV      r2,r6                 ;1087
                  |L2.152|
000098  b293              UXTH     r3,r2                 ;1089
00009a  81a3              STRH     r3,[r4,#0xc]          ;1089
00009c  b90b              CBNZ     r3,|L2.162|
00009e  f8a4c00c          STRH     r12,[r4,#0xc]         ;1091
                  |L2.162|
0000a2  89a0              LDRH     r0,[r4,#0xc]          ;1094
0000a4  8220              STRH     r0,[r4,#0x10]         ;1094
                  |L2.166|
0000a6  8960              LDRH     r0,[r4,#0xa]          ;1098
0000a8  89a3              LDRH     r3,[r4,#0xc]          ;1098
0000aa  4298              CMP      r0,r3                 ;1098
0000ac  d301              BCC      |L2.178|
0000ae  b103              CBZ      r3,|L2.178|
0000b0  8167              STRH     r7,[r4,#0xa]          ;1099
                  |L2.178|
0000b2  79e0              LDRB     r0,[r4,#7]            ;1102
0000b4  b110              CBZ      r0,|L2.188|
0000b6  6a20              LDR      r0,[r4,#0x20]         ;1104
0000b8  9001              STR      r0,[sp,#4]            ;1104
0000ba  e00c              B        |L2.214|
                  |L2.188|
0000bc  7f23              LDRB     r3,[r4,#0x1c]         ;1107
0000be  2b7f              CMP      r3,#0x7f              ;1108
0000c0  d802              BHI      |L2.200|
0000c2  20ff              MOVS     r0,#0xff              ;1109
0000c4  9001              STR      r0,[sp,#4]            ;1109
0000c6  e006              B        |L2.214|
                  |L2.200|
0000c8  2bc0              CMP      r3,#0xc0              ;1110
0000ca  d303              BCC      |L2.212|
0000cc  f06f407f          MVN      r0,#0xff000000        ;1111
0000d0  9001              STR      r0,[sp,#4]            ;1111
0000d2  e000              B        |L2.214|
                  |L2.212|
0000d4  9601              STR      r6,[sp,#4]            ;1113
                  |L2.214|
0000d6  6a60              LDR      r0,[r4,#0x24]         ;1117
0000d8  9000              STR      r0,[sp,#0]            ;1117
0000da  b928              CBNZ     r0,|L2.232|
0000dc  69e0              LDR      r0,[r4,#0x1c]         ;1121
0000de  9901              LDR      r1,[sp,#4]            ;1121
0000e0  4008              ANDS     r0,r0,r1              ;1121
0000e2  f0407080          ORR      r0,r0,#0x1000000      ;1123
0000e6  9000              STR      r0,[sp,#0]            ;1123
                  |L2.232|
0000e8  210a              MOVS     r1,#0xa               ;1137
0000ea  4620              MOV      r0,r4                 ;1137
0000ec  f7fffffe          BL       dhcp_set_state
0000f0  466b              MOV      r3,sp                 ;1139
0000f2  aa01              ADD      r2,sp,#4              ;1139
0000f4  f104011c          ADD      r1,r4,#0x1c           ;1139
0000f8  4628              MOV      r0,r5                 ;1139
0000fa  f7fffffe          BL       netif_set_addr
0000fe  e7a6              B        |L2.78|
;;;1142   
                          ENDP

                  |L2.256|
000100  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
000104  6964646c
000108  65776172
00010c  65735c54
000110  68697264
000114  5f506172
000118  74795c4c
00011c  7749505c
000120  7372635c
000124  636f7265
000128  5c697076
00012c  345c6468
000130  63702e63          DCB      "cp.c",0
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0
                  |L2.312|
000138  64686370          DCB      "dhcp_bind: netif != NULL",0
00013c  5f62696e
000140  643a206e
000144  65746966
000148  20213d20
00014c  4e554c4c
000150  00      
000151  00                DCB      0
000152  00                DCB      0
000153  00                DCB      0
                  |L2.340|
000154  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000158  7274696f
00015c  6e202225
000160  73222066
000164  61696c65
000168  64206174
00016c  206c696e
000170  65202564
000174  20696e20
000178  25730a00
                  |L2.380|
00017c  64686370          DCB      "dhcp_bind: dhcp != NULL",0
000180  5f62696e
000184  643a2064
000188  68637020
00018c  213d204e
000190  554c4c00

                          AREA ||i.dhcp_check||, CODE, READONLY, ALIGN=1

                  dhcp_check PROC
;;;302    static void
;;;303    dhcp_check(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;304    {
000002  4605              MOV      r5,r0
;;;305      struct dhcp *dhcp = netif_dhcp_data(netif);
000004  6aac              LDR      r4,[r5,#0x28]
;;;306      err_t result;
;;;307      u16_t msecs;
;;;308      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
;;;309                  (s16_t)netif->name[1]));
;;;310      dhcp_set_state(dhcp, DHCP_STATE_CHECKING);
000006  2108              MOVS     r1,#8
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       dhcp_set_state
;;;311      /* create an ARP query for the offered IP address, expecting that no host
;;;312         responds, as the IP address should not be in use. */
;;;313      result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
00000e  2200              MOVS     r2,#0
000010  f104011c          ADD      r1,r4,#0x1c
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       etharp_query
;;;314      if (result != ERR_OK) {
;;;315        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_check: could not perform ARP query\n"));
;;;316      }
;;;317      if (dhcp->tries < 255) {
00001a  79a0              LDRB     r0,[r4,#6]
00001c  28ff              CMP      r0,#0xff
00001e  d201              BCS      |L3.36|
;;;318        dhcp->tries++;
000020  1c40              ADDS     r0,r0,#1
000022  71a0              STRB     r0,[r4,#6]
                  |L3.36|
;;;319      }
;;;320      msecs = 500;
000024  f44f70fa          MOV      r0,#0x1f4
;;;321      dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
000028  f24031e7          MOV      r1,#0x3e7
00002c  fbb1f0f0          UDIV     r0,r1,r0
000030  8120              STRH     r0,[r4,#8]
;;;322      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
;;;323    }
000032  bd70              POP      {r4-r6,pc}
;;;324    #endif /* DHCP_DOES_ARP_CHECK */
                          ENDP


                          AREA ||i.dhcp_cleanup||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dhcp_cleanup PROC
;;;711     */
;;;712    void dhcp_cleanup(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;713    {
000002  4604              MOV      r4,r0
;;;714      LWIP_ASSERT_CORE_LOCKED();
;;;715      LWIP_ASSERT("netif != NULL", netif != NULL);
000004  2c00              CMP      r4,#0
000006  d106              BNE      |L4.22|
000008  a307              ADR      r3,|L4.40|
00000a  f24022cb          MOV      r2,#0x2cb
00000e  a114              ADR      r1,|L4.96|
000010  a017              ADR      r0,|L4.112|
000012  f7fffffe          BL       __2printf
                  |L4.22|
;;;716    
;;;717      if (netif_dhcp_data(netif) != NULL) {
000016  6aa0              LDR      r0,[r4,#0x28]
000018  2800              CMP      r0,#0
00001a  d003              BEQ      |L4.36|
;;;718        mem_free(netif_dhcp_data(netif));
00001c  f7fffffe          BL       mem_free
;;;719        netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, NULL);
000020  2000              MOVS     r0,#0
000022  62a0              STR      r0,[r4,#0x28]
                  |L4.36|
;;;720      }
;;;721    }
000024  bd10              POP      {r4,pc}
;;;722    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
000028  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
00002c  6964646c
000030  65776172
000034  65735c54
000038  68697264
00003c  5f506172
000040  74795c4c
000044  7749505c
000048  7372635c
00004c  636f7265
000050  5c697076
000054  345c6468
000058  63702e63          DCB      "cp.c",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0
                  |L4.96|
000060  6e657469          DCB      "netif != NULL",0
000064  6620213d
000068  204e554c
00006c  4c00    
00006e  00                DCB      0
00006f  00                DCB      0
                  |L4.112|
000070  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000074  7274696f
000078  6e202225
00007c  73222066
000080  61696c65
000084  64206174
000088  206c696e
00008c  65202564
000090  20696e20
000094  25730a00

                          AREA ||i.dhcp_coarse_tmr||, CODE, READONLY, ALIGN=2

                  dhcp_coarse_tmr PROC
;;;429    void
;;;430    dhcp_coarse_tmr(void)
000000  b510              PUSH     {r4,lr}
;;;431    {
;;;432      struct netif *netif;
;;;433      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
;;;434      /* iterate through all network interfaces */
;;;435      NETIF_FOREACH(netif) {
000002  4817              LDR      r0,|L5.96|
000004  6804              LDR      r4,[r0,#0]  ; netif_list
000006  e028              B        |L5.90|
                  |L5.8|
;;;436        /* only act on DHCP configured interfaces */
;;;437        struct dhcp *dhcp = netif_dhcp_data(netif);
000008  6aa1              LDR      r1,[r4,#0x28]
;;;438        if ((dhcp != NULL) && (dhcp->state != DHCP_STATE_OFF)) {
00000a  b309              CBZ      r1,|L5.80|
00000c  7948              LDRB     r0,[r1,#5]
00000e  b1f8              CBZ      r0,|L5.80|
;;;439          /* compare lease time to expire timeout */
;;;440          if (dhcp->t0_timeout && (++dhcp->lease_used == dhcp->t0_timeout)) {
000010  8a88              LDRH     r0,[r1,#0x14]
000012  b168              CBZ      r0,|L5.48|
000014  8a48              LDRH     r0,[r1,#0x12]
000016  1c40              ADDS     r0,r0,#1
000018  b280              UXTH     r0,r0
00001a  8248              STRH     r0,[r1,#0x12]
00001c  8a8a              LDRH     r2,[r1,#0x14]
00001e  4290              CMP      r0,r2
000020  d106              BNE      |L5.48|
;;;441            LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t0 timeout\n"));
;;;442            /* this clients' lease time has expired */
;;;443            dhcp_release_and_stop(netif);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       dhcp_release_and_stop
;;;444            dhcp_start(netif);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       dhcp_start
00002e  e013              B        |L5.88|
                  |L5.48|
;;;445            /* timer is active (non zero), and triggers (zeroes) now? */
;;;446          } else if (dhcp->t2_rebind_time && (dhcp->t2_rebind_time-- == 1)) {
000030  8a08              LDRH     r0,[r1,#0x10]
000032  b118              CBZ      r0,|L5.60|
000034  1e42              SUBS     r2,r0,#1
000036  820a              STRH     r2,[r1,#0x10]
000038  2801              CMP      r0,#1
00003a  d006              BEQ      |L5.74|
                  |L5.60|
;;;447            LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
;;;448            /* this clients' rebind timeout triggered */
;;;449            dhcp_t2_timeout(netif);
;;;450            /* timer is active (non zero), and triggers (zeroes) now */
;;;451          } else if (dhcp->t1_renew_time && (dhcp->t1_renew_time-- == 1)) {
00003c  89c8              LDRH     r0,[r1,#0xe]
00003e  b138              CBZ      r0,|L5.80|
000040  1e42              SUBS     r2,r0,#1
000042  81ca              STRH     r2,[r1,#0xe]
000044  2801              CMP      r0,#1
000046  d004              BEQ      |L5.82|
000048  e006              B        |L5.88|
                  |L5.74|
00004a  4620              MOV      r0,r4                 ;449
00004c  f7fffffe          BL       dhcp_t2_timeout
                  |L5.80|
000050  e002              B        |L5.88|
                  |L5.82|
;;;452            LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t1 timeout\n"));
;;;453            /* this clients' renewal timeout triggered */
;;;454            dhcp_t1_timeout(netif);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       dhcp_t1_timeout
                  |L5.88|
000058  6824              LDR      r4,[r4,#0]            ;435
                  |L5.90|
00005a  2c00              CMP      r4,#0                 ;435
00005c  d1d4              BNE      |L5.8|
;;;455          }
;;;456        }
;;;457      }
;;;458    }
00005e  bd10              POP      {r4,pc}
;;;459    
                          ENDP

                  |L5.96|
                          DCD      netif_list

                          AREA ||i.dhcp_create_msg||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  dhcp_create_msg PROC
;;;1873   static struct pbuf *
;;;1874   dhcp_create_msg(struct netif *netif, struct dhcp *dhcp, u8_t message_type, u16_t *options_out_len)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1875   {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  4699              MOV      r9,r3
;;;1876     u16_t i;
;;;1877     struct pbuf *p_out;
;;;1878     struct dhcp_msg *msg_out;
;;;1879     u16_t options_out_len_loc;
;;;1880   
;;;1881   #ifndef DHCP_GLOBAL_XID
;;;1882     /** default global transaction identifier starting value (easy to match
;;;1883      *  with a packet analyser). We simply increment for each new request.
;;;1884      *  Predefine DHCP_GLOBAL_XID to a better value or a function call to generate one
;;;1885      *  at runtime, any supporting function prototypes can be defined in DHCP_GLOBAL_XID_HEADER */
;;;1886   #if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
;;;1887     static u32_t xid;
;;;1888   #else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
;;;1889     static u32_t xid = 0xABCD0000;
;;;1890   #endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
;;;1891   #else
;;;1892     if (!xid_initialised) {
;;;1893       xid = DHCP_GLOBAL_XID;
;;;1894       xid_initialised = !xid_initialised;
;;;1895     }
;;;1896   #endif
;;;1897     LWIP_ERROR("dhcp_create_msg: netif != NULL", (netif != NULL), return NULL;);
00000c  2f00              CMP      r7,#0
00000e  d01b              BEQ      |L6.72|
;;;1898     LWIP_ERROR("dhcp_create_msg: dhcp != NULL", (dhcp != NULL), return NULL;);
000010  2c00              CMP      r4,#0
000012  d023              BEQ      |L6.92|
;;;1899     p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
000014  f44f7a9a          MOV      r10,#0x134
000018  f44f7220          MOV      r2,#0x280
00001c  4651              MOV      r1,r10
00001e  2036              MOVS     r0,#0x36
000020  f7fffffe          BL       pbuf_alloc
000024  4680              MOV      r8,r0
;;;1900     if (p_out == NULL) {
000026  ea5f0008          MOVS     r0,r8
00002a  d020              BEQ      |L6.110|
;;;1901       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
;;;1902                   ("dhcp_create_msg(): could not allocate pbuf\n"));
;;;1903       return NULL;
;;;1904     }
;;;1905     LWIP_ASSERT("dhcp_create_msg: check that first pbuf can hold struct dhcp_msg",
00002c  f8b8000a          LDRH     r0,[r8,#0xa]
000030  4550              CMP      r0,r10
000032  d206              BCS      |L6.66|
000034  a334              ADR      r3,|L6.264|
000036  f2407271          MOV      r2,#0x771
00003a  a141              ADR      r1,|L6.320|
00003c  a050              ADR      r0,|L6.384|
00003e  f7fffffe          BL       __2printf
                  |L6.66|
;;;1906                 (p_out->len >= sizeof(struct dhcp_msg)));
;;;1907   
;;;1908     /* DHCP_REQUEST should reuse 'xid' from DHCPOFFER */
;;;1909     if ((message_type != DHCP_REQUEST) || (dhcp->state == DHCP_STATE_REBOOTING)) {
000042  2e03              CMP      r6,#3
000044  d118              BNE      |L6.120|
000046  e014              B        |L6.114|
                  |L6.72|
000048  a32f              ADR      r3,|L6.264|
00004a  f2407269          MOV      r2,#0x769             ;1897
00004e  a156              ADR      r1,|L6.424|
000050  a04b              ADR      r0,|L6.384|
000052  f7fffffe          BL       __2printf
000056  2000              MOVS     r0,#0                 ;1897
                  |L6.88|
;;;1910       /* reuse transaction identifier in retransmissions */
;;;1911       if (dhcp->tries == 0) {
;;;1912   #if DHCP_CREATE_RAND_XID && defined(LWIP_RAND)
;;;1913         xid = LWIP_RAND();
;;;1914   #else /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
;;;1915         xid++;
;;;1916   #endif /* DHCP_CREATE_RAND_XID && defined(LWIP_RAND) */
;;;1917       }
;;;1918       dhcp->xid = xid;
;;;1919     }
;;;1920     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE,
;;;1921                 ("transaction id xid(%"X32_F")\n", xid));
;;;1922   
;;;1923     msg_out = (struct dhcp_msg *)p_out->payload;
;;;1924     memset(msg_out, 0, sizeof(struct dhcp_msg));
;;;1925   
;;;1926     msg_out->op = DHCP_BOOTREQUEST;
;;;1927     /* @todo: make link layer independent */
;;;1928     msg_out->htype = LWIP_IANA_HWTYPE_ETHERNET;
;;;1929     msg_out->hlen = netif->hwaddr_len;
;;;1930     msg_out->xid = lwip_htonl(dhcp->xid);
;;;1931     /* we don't need the broadcast flag since we can receive unicast traffic
;;;1932        before being fully configured! */
;;;1933     /* set ciaddr to netif->ip_addr based on message_type and state */
;;;1934     if ((message_type == DHCP_INFORM) || (message_type == DHCP_DECLINE) || (message_type == DHCP_RELEASE) ||
;;;1935         ((message_type == DHCP_REQUEST) && /* DHCP_STATE_BOUND not used for sending! */
;;;1936          ((dhcp->state == DHCP_STATE_RENEWING) || dhcp->state == DHCP_STATE_REBINDING))) {
;;;1937       ip4_addr_copy(msg_out->ciaddr, *netif_ip4_addr(netif));
;;;1938     }
;;;1939     for (i = 0; i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
;;;1940       /* copy netif hardware address (padded with zeroes through memset already) */
;;;1941       msg_out->chaddr[i] = netif->hwaddr[i];
;;;1942     }
;;;1943     msg_out->cookie = PP_HTONL(DHCP_MAGIC_COOKIE);
;;;1944     /* Add option MESSAGE_TYPE */
;;;1945     options_out_len_loc = dhcp_option(0, msg_out->options, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
;;;1946     options_out_len_loc = dhcp_option_byte(options_out_len_loc, msg_out->options, message_type);
;;;1947     if (options_out_len) {
;;;1948       *options_out_len = options_out_len_loc;
;;;1949     }
;;;1950     return p_out;
;;;1951   }
000058  e8bd87f0          POP      {r4-r10,pc}
                  |L6.92|
00005c  a32a              ADR      r3,|L6.264|
00005e  f240726a          MOV      r2,#0x76a             ;1898
000062  a159              ADR      r1,|L6.456|
000064  a046              ADR      r0,|L6.384|
000066  f7fffffe          BL       __2printf
00006a  2000              MOVS     r0,#0                 ;1898
00006c  e7f4              B        |L6.88|
                  |L6.110|
00006e  2000              MOVS     r0,#0                 ;1903
000070  e7f2              B        |L6.88|
                  |L6.114|
000072  7960              LDRB     r0,[r4,#5]            ;1909
000074  2803              CMP      r0,#3                 ;1909
000076  d107              BNE      |L6.136|
                  |L6.120|
000078  79a0              LDRB     r0,[r4,#6]            ;1911
00007a  4d5b              LDR      r5,|L6.488|
00007c  b910              CBNZ     r0,|L6.132|
00007e  f7fffffe          BL       rand
000082  60a8              STR      r0,[r5,#8]            ;1913  ; xid
                  |L6.132|
000084  68a8              LDR      r0,[r5,#8]            ;1918  ; xid
000086  6020              STR      r0,[r4,#0]            ;1918
                  |L6.136|
000088  f8d85004          LDR      r5,[r8,#4]            ;1923
00008c  4651              MOV      r1,r10                ;1924
00008e  4628              MOV      r0,r5                 ;1924
000090  f7fffffe          BL       __aeabi_memclr
000094  2001              MOVS     r0,#1                 ;1926
000096  7028              STRB     r0,[r5,#0]            ;1926
000098  7068              STRB     r0,[r5,#1]            ;1928
00009a  f8970034          LDRB     r0,[r7,#0x34]         ;1929
00009e  70a8              STRB     r0,[r5,#2]            ;1929
0000a0  6820              LDR      r0,[r4,#0]            ;1930
0000a2  f7fffffe          BL       lwip_htonl
0000a6  6068              STR      r0,[r5,#4]            ;1930
0000a8  2e08              CMP      r6,#8                 ;1934
0000aa  d00a              BEQ      |L6.194|
0000ac  2e04              CMP      r6,#4                 ;1934
0000ae  d008              BEQ      |L6.194|
0000b0  2e07              CMP      r6,#7                 ;1934
0000b2  d006              BEQ      |L6.194|
0000b4  2e03              CMP      r6,#3                 ;1935
0000b6  d106              BNE      |L6.198|
0000b8  7960              LDRB     r0,[r4,#5]            ;1936
0000ba  2805              CMP      r0,#5                 ;1936
0000bc  d001              BEQ      |L6.194|
0000be  2804              CMP      r0,#4                 ;1936
0000c0  d101              BNE      |L6.198|
                  |L6.194|
0000c2  6878              LDR      r0,[r7,#4]            ;1937
0000c4  60e8              STR      r0,[r5,#0xc]          ;1937
                  |L6.198|
0000c6  2400              MOVS     r4,#0                 ;1939
                  |L6.200|
0000c8  1938              ADDS     r0,r7,r4              ;1941
0000ca  1929              ADDS     r1,r5,r4              ;1941
0000cc  f890002e          LDRB     r0,[r0,#0x2e]         ;1941
0000d0  7708              STRB     r0,[r1,#0x1c]         ;1941
0000d2  1c64              ADDS     r4,r4,#1              ;1939
0000d4  b2a4              UXTH     r4,r4                 ;1939
0000d6  2c06              CMP      r4,#6                 ;1939
0000d8  d3f6              BCC      |L6.200|
0000da  4844              LDR      r0,|L6.492|
0000dc  f8c500ec          STR      r0,[r5,#0xec]         ;1943
0000e0  f10501f0          ADD      r1,r5,#0xf0           ;1945
0000e4  2301              MOVS     r3,#1                 ;1945
0000e6  2235              MOVS     r2,#0x35              ;1945
0000e8  460c              MOV      r4,r1                 ;1945
0000ea  2000              MOVS     r0,#0                 ;1945
0000ec  f7fffffe          BL       dhcp_option
0000f0  4632              MOV      r2,r6                 ;1946
0000f2  4621              MOV      r1,r4                 ;1946
0000f4  f7fffffe          BL       dhcp_option_byte
0000f8  f1b90f00          CMP      r9,#0                 ;1947
0000fc  d001              BEQ      |L6.258|
0000fe  f8a90000          STRH     r0,[r9,#0]            ;1948
                  |L6.258|
000102  4640              MOV      r0,r8                 ;1950
000104  e7a8              B        |L6.88|
;;;1952   
                          ENDP

000106  0000              DCW      0x0000
                  |L6.264|
000108  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
00010c  6964646c
000110  65776172
000114  65735c54
000118  68697264
00011c  5f506172
000120  74795c4c
000124  7749505c
000128  7372635c
00012c  636f7265
000130  5c697076
000134  345c6468
000138  63702e63          DCB      "cp.c",0
00013c  00      
00013d  00                DCB      0
00013e  00                DCB      0
00013f  00                DCB      0
                  |L6.320|
000140  64686370          DCB      "dhcp_create_msg: check that first pbuf can hold struct "
000144  5f637265
000148  6174655f
00014c  6d73673a
000150  20636865
000154  636b2074
000158  68617420
00015c  66697273
000160  74207062
000164  75662063
000168  616e2068
00016c  6f6c6420
000170  73747275
000174  637420  
000177  64686370          DCB      "dhcp_msg",0
00017b  5f6d7367
00017f  00      
                  |L6.384|
000180  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000184  7274696f
000188  6e202225
00018c  73222066
000190  61696c65
000194  64206174
000198  206c696e
00019c  65202564
0001a0  20696e20
0001a4  25730a00
                  |L6.424|
0001a8  64686370          DCB      "dhcp_create_msg: netif != NULL",0
0001ac  5f637265
0001b0  6174655f
0001b4  6d73673a
0001b8  206e6574
0001bc  69662021
0001c0  3d204e55
0001c4  4c4c00  
0001c7  00                DCB      0
                  |L6.456|
0001c8  64686370          DCB      "dhcp_create_msg: dhcp != NULL",0
0001cc  5f637265
0001d0  6174655f
0001d4  6d73673a
0001d8  20646863
0001dc  7020213d
0001e0  204e554c
0001e4  4c00    
0001e6  00                DCB      0
0001e7  00                DCB      0
                  |L6.488|
                          DCD      ||.data||
                  |L6.492|
                          DCD      0x63538263

                          AREA ||i.dhcp_dec_pcb_refcount||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dhcp_dec_pcb_refcount PROC
;;;252    static void
;;;253    dhcp_dec_pcb_refcount(void)
000000  b510              PUSH     {r4,lr}
;;;254    {
;;;255      LWIP_ASSERT("dhcp_pcb_refcount(): refcount error", (dhcp_pcb_refcount > 0));
000002  4c0b              LDR      r4,|L7.48|
000004  7820              LDRB     r0,[r4,#0]  ; dhcp_pcb_refcount
000006  2800              CMP      r0,#0
000008  d105              BNE      |L7.22|
00000a  a30a              ADR      r3,|L7.52|
00000c  22ff              MOVS     r2,#0xff
00000e  a117              ADR      r1,|L7.108|
000010  a01f              ADR      r0,|L7.144|
000012  f7fffffe          BL       __2printf
                  |L7.22|
;;;256      dhcp_pcb_refcount--;
000016  7820              LDRB     r0,[r4,#0]  ; dhcp_pcb_refcount
000018  1e40              SUBS     r0,r0,#1
00001a  b2c0              UXTB     r0,r0
00001c  7020              STRB     r0,[r4,#0]
;;;257    
;;;258      if (dhcp_pcb_refcount == 0) {
00001e  2800              CMP      r0,#0
000020  d104              BNE      |L7.44|
;;;259        udp_remove(dhcp_pcb);
000022  68e0              LDR      r0,[r4,#0xc]  ; dhcp_pcb
000024  f7fffffe          BL       udp_remove
;;;260        dhcp_pcb = NULL;
000028  2000              MOVS     r0,#0
00002a  60e0              STR      r0,[r4,#0xc]  ; dhcp_pcb
                  |L7.44|
;;;261      }
;;;262    }
00002c  bd10              POP      {r4,pc}
;;;263    
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      ||.data||
                  |L7.52|
000034  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
000038  6964646c
00003c  65776172
000040  65735c54
000044  68697264
000048  5f506172
00004c  74795c4c
000050  7749505c
000054  7372635c
000058  636f7265
00005c  5c697076
000060  345c6468
000064  63702e63          DCB      "cp.c",0
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
                  |L7.108|
00006c  64686370          DCB      "dhcp_pcb_refcount(): refcount error",0
000070  5f706362
000074  5f726566
000078  636f756e
00007c  7428293a
000080  20726566
000084  636f756e
000088  74206572
00008c  726f7200
                  |L7.144|
000090  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000094  7274696f
000098  6e202225
00009c  73222066
0000a0  61696c65
0000a4  64206174
0000a8  206c696e
0000ac  65202564
0000b0  20696e20
0000b4  25730a00

                          AREA ||i.dhcp_decline||, CODE, READONLY, ALIGN=2

                  dhcp_decline PROC
;;;934    static err_t
;;;935    dhcp_decline(struct netif *netif)
000000  b5fe              PUSH     {r1-r7,lr}
;;;936    {
000002  4606              MOV      r6,r0
;;;937      struct dhcp *dhcp = netif_dhcp_data(netif);
000004  6ab4              LDR      r4,[r6,#0x28]
;;;938      err_t result;
;;;939      u16_t msecs;
;;;940      struct pbuf *p_out;
;;;941      u16_t options_out_len;
;;;942    
;;;943      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline()\n"));
;;;944      dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
000006  210c              MOVS     r1,#0xc
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       dhcp_set_state
;;;945      /* create and initialize the DHCP message header */
;;;946      p_out = dhcp_create_msg(netif, dhcp, DHCP_DECLINE, &options_out_len);
00000e  ab02              ADD      r3,sp,#8
000010  2204              MOVS     r2,#4
000012  4621              MOV      r1,r4
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       dhcp_create_msg
00001a  4605              MOV      r5,r0
;;;947      if (p_out != NULL) {
00001c  0028              MOVS     r0,r5
00001e  d026              BEQ      |L8.110|
;;;948        struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
000020  6869              LDR      r1,[r5,#4]
;;;949        options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
000022  2304              MOVS     r3,#4
000024  31f0              ADDS     r1,r1,#0xf0
000026  2232              MOVS     r2,#0x32
000028  460f              MOV      r7,r1
00002a  f8bd0008          LDRH     r0,[sp,#8]
00002e  f7fffffe          BL       dhcp_option
000032  9002              STR      r0,[sp,#8]
;;;950        options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
000034  69e0              LDR      r0,[r4,#0x1c]
000036  f7fffffe          BL       lwip_htonl
00003a  4602              MOV      r2,r0
00003c  4639              MOV      r1,r7
00003e  f8bd0008          LDRH     r0,[sp,#8]
000042  f7fffffe          BL       dhcp_option_long
000046  9002              STR      r0,[sp,#8]
;;;951    
;;;952        LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_BACKING_OFF, msg_out, DHCP_DECLINE, &options_out_len);
;;;953        dhcp_option_trailer(options_out_len, msg_out->options, p_out);
000048  462a              MOV      r2,r5
00004a  4639              MOV      r1,r7
00004c  f7fffffe          BL       dhcp_option_trailer
;;;954    
;;;955        /* per section 4.4.4, broadcast DECLINE messages */
;;;956        result = udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
000050  480f              LDR      r0,|L8.144|
000052  2343              MOVS     r3,#0x43
000054  e9cd6000          STRD     r6,r0,[sp,#0]
000058  480f              LDR      r0,|L8.152|
00005a  4a0e              LDR      r2,|L8.148|
00005c  4629              MOV      r1,r5
00005e  68c0              LDR      r0,[r0,#0xc]  ; dhcp_pcb
000060  f7fffffe          BL       udp_sendto_if_src
000064  4606              MOV      r6,r0
;;;957        pbuf_free(p_out);
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       pbuf_free
;;;958        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
;;;959      } else {
00006c  e001              B        |L8.114|
                  |L8.110|
;;;960        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
;;;961                    ("dhcp_decline: could not allocate DHCP request\n"));
;;;962        result = ERR_MEM;
00006e  f04f36ff          MOV      r6,#0xffffffff
                  |L8.114|
;;;963      }
;;;964      if (dhcp->tries < 255) {
000072  79a0              LDRB     r0,[r4,#6]
000074  28ff              CMP      r0,#0xff
000076  d201              BCS      |L8.124|
;;;965        dhcp->tries++;
000078  1c40              ADDS     r0,r0,#1
00007a  71a0              STRB     r0,[r4,#6]
                  |L8.124|
;;;966      }
;;;967      msecs = 10 * 1000;
;;;968      dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
00007c  f6421003          MOV      r0,#0x2903
000080  f44f71fa          MOV      r1,#0x1f4
000084  fbb0f0f1          UDIV     r0,r0,r1
000088  8120              STRH     r0,[r4,#8]
;;;969      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_decline(): set request timeout %"U16_F" msecs\n", msecs));
;;;970      return result;
00008a  4630              MOV      r0,r6
;;;971    }
00008c  bdfe              POP      {r1-r7,pc}
;;;972    #endif /* DHCP_DOES_ARP_CHECK */
                          ENDP

00008e  0000              DCW      0x0000
                  |L8.144|
                          DCD      ip_addr_any
                  |L8.148|
                          DCD      ip_addr_broadcast
                  |L8.152|
                          DCD      ||.data||

                          AREA ||i.dhcp_discover||, CODE, READONLY, ALIGN=2

                  dhcp_discover PROC
;;;980    static err_t
;;;981    dhcp_discover(struct netif *netif)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;982    {
000004  4607              MOV      r7,r0
;;;983      struct dhcp *dhcp = netif_dhcp_data(netif);
000006  6abd              LDR      r5,[r7,#0x28]
;;;984      err_t result = ERR_OK;
000008  f04f0900          MOV      r9,#0
;;;985      u16_t msecs;
;;;986      u8_t i;
;;;987      struct pbuf *p_out;
;;;988      u16_t options_out_len;
;;;989    
;;;990      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover()\n"));
;;;991    
;;;992      ip4_addr_set_any(&dhcp->offered_ip_addr);
00000c  2000              MOVS     r0,#0
00000e  61e8              STR      r0,[r5,#0x1c]
;;;993      dhcp_set_state(dhcp, DHCP_STATE_SELECTING);
000010  2106              MOVS     r1,#6
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       dhcp_set_state
;;;994      /* create and initialize the DHCP message header */
;;;995      p_out = dhcp_create_msg(netif, dhcp, DHCP_DISCOVER, &options_out_len);
000018  ab02              ADD      r3,sp,#8
00001a  2201              MOVS     r2,#1
00001c  4629              MOV      r1,r5
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       dhcp_create_msg
000024  4606              MOV      r6,r0
;;;996      if (p_out != NULL) {
000026  0030              MOVS     r0,r6
000028  d037              BEQ      |L9.154|
;;;997        struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
00002a  6871              LDR      r1,[r6,#4]
;;;998        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
;;;999    
;;;1000       options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
00002c  2302              MOVS     r3,#2
00002e  31f0              ADDS     r1,r1,#0xf0
000030  2239              MOVS     r2,#0x39
000032  468a              MOV      r10,r1
000034  f8bd0008          LDRH     r0,[sp,#8]
000038  f7fffffe          BL       dhcp_option
00003c  9002              STR      r0,[sp,#8]
;;;1001       options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
00003e  8dba              LDRH     r2,[r7,#0x2c]
000040  4651              MOV      r1,r10
000042  f7fffffe          BL       dhcp_option_short
000046  9002              STR      r0,[sp,#8]
;;;1002   
;;;1003       options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
000048  2304              MOVS     r3,#4
00004a  2237              MOVS     r2,#0x37
00004c  4651              MOV      r1,r10
00004e  f7fffffe          BL       dhcp_option
000052  9002              STR      r0,[sp,#8]
;;;1004       for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
000054  2400              MOVS     r4,#0
;;;1005         options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
000056  f8df8080          LDR      r8,|L9.216|
                  |L9.90|
00005a  4651              MOV      r1,r10
00005c  f8bd0008          LDRH     r0,[sp,#8]
000060  f8182004          LDRB     r2,[r8,r4]
000064  f7fffffe          BL       dhcp_option_byte
000068  9002              STR      r0,[sp,#8]
00006a  1c64              ADDS     r4,r4,#1              ;1004
00006c  b2e4              UXTB     r4,r4                 ;1004
00006e  2c04              CMP      r4,#4                 ;1004
000070  d3f3              BCC      |L9.90|
;;;1006       }
;;;1007       LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_SELECTING, msg_out, DHCP_DISCOVER, &options_out_len);
;;;1008       dhcp_option_trailer(options_out_len, msg_out->options, p_out);
000072  4632              MOV      r2,r6
000074  4651              MOV      r1,r10
000076  f8bd0008          LDRH     r0,[sp,#8]
00007a  f7fffffe          BL       dhcp_option_trailer
;;;1009   
;;;1010       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER)\n"));
;;;1011       udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
00007e  4817              LDR      r0,|L9.220|
000080  2343              MOVS     r3,#0x43
000082  e9cd7000          STRD     r7,r0,[sp,#0]
000086  4814              LDR      r0,|L9.216|
000088  4a15              LDR      r2,|L9.224|
00008a  1e40              SUBS     r0,r0,#1
00008c  4631              MOV      r1,r6
00008e  68c0              LDR      r0,[r0,#0xc]  ; dhcp_pcb
000090  f7fffffe          BL       udp_sendto_if_src
;;;1012       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
;;;1013       pbuf_free(p_out);
000094  4630              MOV      r0,r6
000096  f7fffffe          BL       pbuf_free
                  |L9.154|
;;;1014       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
;;;1015     } else {
;;;1016       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_discover: could not allocate DHCP request\n"));
;;;1017     }
;;;1018     if (dhcp->tries < 255) {
00009a  79a8              LDRB     r0,[r5,#6]
00009c  28ff              CMP      r0,#0xff
00009e  d201              BCS      |L9.164|
;;;1019       dhcp->tries++;
0000a0  1c40              ADDS     r0,r0,#1
0000a2  71a8              STRB     r0,[r5,#6]
                  |L9.164|
;;;1020     }
;;;1021   #if LWIP_DHCP_AUTOIP_COOP
;;;1022     if (dhcp->tries >= LWIP_DHCP_AUTOIP_COOP_TRIES && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
;;;1023       dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
;;;1024       autoip_start(netif);
;;;1025     }
;;;1026   #endif /* LWIP_DHCP_AUTOIP_COOP */
;;;1027     msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
0000a4  79a9              LDRB     r1,[r5,#6]
0000a6  2906              CMP      r1,#6
0000a8  d202              BCS      |L9.176|
0000aa  2001              MOVS     r0,#1
0000ac  4088              LSLS     r0,r0,r1
0000ae  e000              B        |L9.178|
                  |L9.176|
0000b0  203c              MOVS     r0,#0x3c
                  |L9.178|
0000b2  eb000140          ADD      r1,r0,r0,LSL #1
0000b6  ebc110c0          RSB      r0,r1,r0,LSL #7
0000ba  f64f71ff          MOV      r1,#0xffff
0000be  ea0100c0          AND      r0,r1,r0,LSL #3
;;;1028     dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
0000c2  f20010f3          ADD      r0,r0,#0x1f3
0000c6  f44f71fa          MOV      r1,#0x1f4
0000ca  fbb0f0f1          UDIV     r0,r0,r1
0000ce  8128              STRH     r0,[r5,#8]
;;;1029     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
;;;1030     return result;
0000d0  4648              MOV      r0,r9
;;;1031   }
0000d2  e8bd8ffe          POP      {r1-r11,pc}
;;;1032   
                          ENDP

0000d6  0000              DCW      0x0000
                  |L9.216|
                          DCD      ||.data||+0x1
                  |L9.220|
                          DCD      ip_addr_any
                  |L9.224|
                          DCD      ip_addr_broadcast

                          AREA ||i.dhcp_fine_tmr||, CODE, READONLY, ALIGN=2

                  dhcp_fine_tmr PROC
;;;467    void
;;;468    dhcp_fine_tmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;469    {
;;;470      struct netif *netif;
;;;471      /* loop through netif's */
;;;472      NETIF_FOREACH(netif) {
000002  480b              LDR      r0,|L10.48|
000004  6804              LDR      r4,[r0,#0]  ; netif_list
000006  2500              MOVS     r5,#0
000008  e00e              B        |L10.40|
                  |L10.10|
;;;473        struct dhcp *dhcp = netif_dhcp_data(netif);
00000a  6aa1              LDR      r1,[r4,#0x28]
;;;474        /* only act on DHCP configured interfaces */
;;;475        if (dhcp != NULL) {
00000c  b159              CBZ      r1,|L10.38|
;;;476          /* timer is active (non zero), and is about to trigger now */
;;;477          if (dhcp->request_timeout > 1) {
00000e  8908              LDRH     r0,[r1,#8]
000010  2801              CMP      r0,#1
000012  d903              BLS      |L10.28|
;;;478            dhcp->request_timeout--;
000014  f1a00001          SUB      r0,r0,#1
000018  8108              STRH     r0,[r1,#8]
00001a  e004              B        |L10.38|
                  |L10.28|
;;;479          } else if (dhcp->request_timeout == 1) {
00001c  d103              BNE      |L10.38|
;;;480            dhcp->request_timeout--;
00001e  810d              STRH     r5,[r1,#8]
;;;481            /* { dhcp->request_timeout == 0 } */
;;;482            LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_fine_tmr(): request timeout\n"));
;;;483            /* this client's request timeout triggered */
;;;484            dhcp_timeout(netif);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       dhcp_timeout
                  |L10.38|
000026  6824              LDR      r4,[r4,#0]            ;472
                  |L10.40|
000028  2c00              CMP      r4,#0                 ;472
00002a  d1ee              BNE      |L10.10|
;;;485          }
;;;486        }
;;;487      }
;;;488    }
00002c  bd70              POP      {r4-r6,pc}
;;;489    
                          ENDP

00002e  0000              DCW      0x0000
                  |L10.48|
                          DCD      netif_list

                          AREA ||i.dhcp_handle_ack||, CODE, READONLY, ALIGN=2

                  dhcp_handle_ack PROC
;;;598    static void
;;;599    dhcp_handle_ack(struct netif *netif, struct dhcp_msg *msg_in)
000000  b5f8              PUSH     {r3-r7,lr}
;;;600    {
;;;601      struct dhcp *dhcp = netif_dhcp_data(netif);
000002  6a84              LDR      r4,[r0,#0x28]
;;;602    
;;;603    #if LWIP_DHCP_PROVIDE_DNS_SERVERS || LWIP_DHCP_GET_NTP_SRV
;;;604      u8_t n;
;;;605    #endif /* LWIP_DHCP_PROVIDE_DNS_SERVERS || LWIP_DHCP_GET_NTP_SRV */
;;;606    #if LWIP_DHCP_GET_NTP_SRV
;;;607      ip4_addr_t ntp_server_addrs[LWIP_DHCP_MAX_NTP_SERVERS];
;;;608    #endif
;;;609    
;;;610      /* clear options we might not get from the ACK */
;;;611      ip4_addr_set_zero(&dhcp->offered_sn_mask);
000004  2200              MOVS     r2,#0
000006  6222              STR      r2,[r4,#0x20]
;;;612      ip4_addr_set_zero(&dhcp->offered_gw_addr);
000008  6262              STR      r2,[r4,#0x24]
;;;613    #if LWIP_DHCP_BOOTP_FILE
;;;614      ip4_addr_set_zero(&dhcp->offered_si_addr);
;;;615    #endif /* LWIP_DHCP_BOOTP_FILE */
;;;616    
;;;617      /* lease time given? */
;;;618      if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_LEASE_TIME)) {
00000a  4e21              LDR      r6,|L11.144|
;;;619        /* remember offered lease time */
;;;620        dhcp->offered_t0_lease = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_LEASE_TIME);
00000c  f1a60528          SUB      r5,r6,#0x28
000010  78f0              LDRB     r0,[r6,#3]            ;618  ; dhcp_rx_options_given
000012  2800              CMP      r0,#0                 ;618
000014  d001              BEQ      |L11.26|
000016  68e8              LDR      r0,[r5,#0xc]  ; dhcp_rx_options_val
000018  62a0              STR      r0,[r4,#0x28]
                  |L11.26|
;;;621      }
;;;622      /* renewal period given? */
;;;623      if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T1)) {
00001a  7930              LDRB     r0,[r6,#4]  ; dhcp_rx_options_given
00001c  b110              CBZ      r0,|L11.36|
;;;624        /* remember given renewal period */
;;;625        dhcp->offered_t1_renew = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T1);
00001e  6928              LDR      r0,[r5,#0x10]  ; dhcp_rx_options_val
000020  62e0              STR      r0,[r4,#0x2c]
000022  e002              B        |L11.42|
                  |L11.36|
;;;626      } else {
;;;627        /* calculate safe periods for renewal */
;;;628        dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
000024  6aa0              LDR      r0,[r4,#0x28]
000026  0840              LSRS     r0,r0,#1
000028  62e0              STR      r0,[r4,#0x2c]
                  |L11.42|
;;;629      }
;;;630    
;;;631      /* renewal period given? */
;;;632      if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_T2)) {
00002a  7970              LDRB     r0,[r6,#5]  ; dhcp_rx_options_given
00002c  b110              CBZ      r0,|L11.52|
;;;633        /* remember given rebind period */
;;;634        dhcp->offered_t2_rebind = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_T2);
00002e  6968              LDR      r0,[r5,#0x14]  ; dhcp_rx_options_val
000030  6320              STR      r0,[r4,#0x30]
000032  e004              B        |L11.62|
                  |L11.52|
;;;635      } else {
;;;636        /* calculate safe periods for rebinding (offered_t0_lease * 0.875 -> 87.5%)*/
;;;637        dhcp->offered_t2_rebind = (dhcp->offered_t0_lease * 7U) / 8U;
000034  6aa0              LDR      r0,[r4,#0x28]
000036  ebc000c0          RSB      r0,r0,r0,LSL #3
00003a  08c0              LSRS     r0,r0,#3
00003c  6320              STR      r0,[r4,#0x30]
                  |L11.62|
;;;638      }
;;;639    
;;;640      /* (y)our internet address */
;;;641      ip4_addr_copy(dhcp->offered_ip_addr, msg_in->yiaddr);
00003e  6908              LDR      r0,[r1,#0x10]
000040  61e0              STR      r0,[r4,#0x1c]
;;;642    
;;;643    #if LWIP_DHCP_BOOTP_FILE
;;;644      /* copy boot server address,
;;;645         boot file name copied in dhcp_parse_reply if not overloaded */
;;;646      ip4_addr_copy(dhcp->offered_si_addr, msg_in->siaddr);
;;;647    #endif /* LWIP_DHCP_BOOTP_FILE */
;;;648    
;;;649      /* subnet mask given? */
;;;650      if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)) {
000042  79b0              LDRB     r0,[r6,#6]  ; dhcp_rx_options_given
000044  b130              CBZ      r0,|L11.84|
;;;651        /* remember given subnet mask */
;;;652        ip4_addr_set_u32(&dhcp->offered_sn_mask, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SUBNET_MASK)));
000046  69a8              LDR      r0,[r5,#0x18]  ; dhcp_rx_options_val
000048  f7fffffe          BL       lwip_htonl
00004c  6220              STR      r0,[r4,#0x20]
;;;653        dhcp->subnet_mask_given = 1;
00004e  2001              MOVS     r0,#1
000050  71e0              STRB     r0,[r4,#7]
000052  e000              B        |L11.86|
                  |L11.84|
;;;654      } else {
;;;655        dhcp->subnet_mask_given = 0;
000054  71e2              STRB     r2,[r4,#7]
                  |L11.86|
;;;656      }
;;;657    
;;;658      /* gateway router */
;;;659      if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_ROUTER)) {
000056  79f0              LDRB     r0,[r6,#7]  ; dhcp_rx_options_given
000058  b118              CBZ      r0,|L11.98|
;;;660        ip4_addr_set_u32(&dhcp->offered_gw_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_ROUTER)));
00005a  69e8              LDR      r0,[r5,#0x1c]  ; dhcp_rx_options_val
00005c  f7fffffe          BL       lwip_htonl
000060  6260              STR      r0,[r4,#0x24]
                  |L11.98|
;;;661      }
;;;662    
;;;663    #if LWIP_DHCP_GET_NTP_SRV
;;;664      /* NTP servers */
;;;665      for (n = 0; (n < LWIP_DHCP_MAX_NTP_SERVERS) && dhcp_option_given(dhcp, DHCP_OPTION_IDX_NTP_SERVER + n); n++) {
;;;666        ip4_addr_set_u32(&ntp_server_addrs[n], lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_NTP_SERVER + n)));
;;;667      }
;;;668      dhcp_set_ntp_servers(n, ntp_server_addrs);
;;;669    #endif /* LWIP_DHCP_GET_NTP_SRV */
;;;670    
;;;671    #if LWIP_DHCP_PROVIDE_DNS_SERVERS
;;;672      /* DNS servers */
;;;673      for (n = 0; (n < LWIP_DHCP_PROVIDE_DNS_SERVERS) && dhcp_option_given(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n); n++) {
000062  2400              MOVS     r4,#0
000064  e00c              B        |L11.128|
                  |L11.102|
;;;674        ip_addr_t dns_addr;
;;;675        ip_addr_set_ip4_u32_val(dns_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_DNS_SERVER + n)));
000066  f1040008          ADD      r0,r4,#8
00006a  f8550020          LDR      r0,[r5,r0,LSL #2]
00006e  f7fffffe          BL       lwip_htonl
000072  9000              STR      r0,[sp,#0]
;;;676        dns_setserver(n, &dns_addr);
000074  4669              MOV      r1,sp
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       dns_setserver
00007c  1c64              ADDS     r4,r4,#1              ;673
00007e  b2e4              UXTB     r4,r4                 ;673
                  |L11.128|
000080  2c02              CMP      r4,#2                 ;673
000082  d203              BCS      |L11.140|
000084  1930              ADDS     r0,r6,r4              ;673
000086  7a00              LDRB     r0,[r0,#8]            ;673
000088  2800              CMP      r0,#0                 ;673
00008a  d1ec              BNE      |L11.102|
                  |L11.140|
;;;677      }
;;;678    #endif /* LWIP_DHCP_PROVIDE_DNS_SERVERS */
;;;679    }
00008c  bdf8              POP      {r3-r7,pc}
;;;680    
                          ENDP

00008e  0000              DCW      0x0000
                  |L11.144|
                          DCD      ||.bss||+0x28

                          AREA ||i.dhcp_handle_nak||, CODE, READONLY, ALIGN=2

                  dhcp_handle_nak PROC
;;;276    static void
;;;277    dhcp_handle_nak(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;278    {
000002  4604              MOV      r4,r0
;;;279      struct dhcp *dhcp = netif_dhcp_data(netif);
000004  6aa0              LDR      r0,[r4,#0x28]
;;;280    
;;;281      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n",
;;;282                  (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
;;;283      /* Change to a defined state - set this before assigning the address
;;;284         to ensure the callback can use dhcp_supplied_address() */
;;;285      dhcp_set_state(dhcp, DHCP_STATE_BACKING_OFF);
000006  210c              MOVS     r1,#0xc
000008  f7fffffe          BL       dhcp_set_state
;;;286      /* remove IP address from interface (must no longer be used, as per RFC2131) */
;;;287      netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
00000c  4b05              LDR      r3,|L12.36|
00000e  4620              MOV      r0,r4
000010  461a              MOV      r2,r3
000012  4611              MOV      r1,r2
000014  f7fffffe          BL       netif_set_addr
;;;288      /* We can immediately restart discovery */
;;;289      dhcp_discover(netif);
000018  4620              MOV      r0,r4
00001a  e8bd4010          POP      {r4,lr}
00001e  f7ffbffe          B.W      dhcp_discover
;;;290    }
;;;291    
                          ENDP

000022  0000              DCW      0x0000
                  |L12.36|
                          DCD      ip_addr_any

                          AREA ||i.dhcp_handle_offer||, CODE, READONLY, ALIGN=2

                  dhcp_handle_offer PROC
;;;331    static void
;;;332    dhcp_handle_offer(struct netif *netif, struct dhcp_msg *msg_in)
000000  b570              PUSH     {r4-r6,lr}
;;;333    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;334      struct dhcp *dhcp = netif_dhcp_data(netif);
000006  6aac              LDR      r4,[r5,#0x28]
;;;335    
;;;336      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
;;;337                  (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
;;;338      /* obtain the server address */
;;;339      if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_SERVER_ID)) {
000008  4809              LDR      r0,|L13.48|
00000a  7880              LDRB     r0,[r0,#2]  ; dhcp_rx_options_given
00000c  2800              CMP      r0,#0
00000e  d00e              BEQ      |L13.46|
;;;340        dhcp->request_timeout = 0; /* stop timer */
000010  2000              MOVS     r0,#0
000012  8120              STRH     r0,[r4,#8]
;;;341    
;;;342        ip_addr_set_ip4_u32(&dhcp->server_ip_addr, lwip_htonl(dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_SERVER_ID)));
000014  4806              LDR      r0,|L13.48|
000016  3828              SUBS     r0,r0,#0x28
000018  6880              LDR      r0,[r0,#8]  ; dhcp_rx_options_val
00001a  f7fffffe          BL       lwip_htonl
00001e  61a0              STR      r0,[r4,#0x18]
;;;343        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n",
;;;344                    ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));
;;;345        /* remember offered address */
;;;346        ip4_addr_copy(dhcp->offered_ip_addr, msg_in->yiaddr);
000020  6930              LDR      r0,[r6,#0x10]
000022  61e0              STR      r0,[r4,#0x1c]
;;;347        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n",
;;;348                    ip4_addr_get_u32(&dhcp->offered_ip_addr)));
;;;349    
;;;350        dhcp_select(netif);
000024  4628              MOV      r0,r5
000026  e8bd4070          POP      {r4-r6,lr}
00002a  f7ffbffe          B.W      dhcp_select
                  |L13.46|
;;;351      } else {
;;;352        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
;;;353                    ("dhcp_handle_offer(netif=%p) did not get server ID!\n", (void *)netif));
;;;354      }
;;;355    }
00002e  bd70              POP      {r4-r6,pc}
;;;356    
                          ENDP

                  |L13.48|
                          DCD      ||.bss||+0x28

                          AREA ||i.dhcp_inc_pcb_refcount||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dhcp_inc_pcb_refcount PROC
;;;225    static err_t
;;;226    dhcp_inc_pcb_refcount(void)
000000  b510              PUSH     {r4,lr}
;;;227    {
;;;228      if (dhcp_pcb_refcount == 0) {
000002  4c15              LDR      r4,|L14.88|
000004  7820              LDRB     r0,[r4,#0]  ; dhcp_pcb_refcount
000006  2800              CMP      r0,#0
000008  d11e              BNE      |L14.72|
;;;229        LWIP_ASSERT("dhcp_inc_pcb_refcount(): memory leak", dhcp_pcb == NULL);
00000a  68e0              LDR      r0,[r4,#0xc]  ; dhcp_pcb
00000c  2800              CMP      r0,#0
00000e  d005              BEQ      |L14.28|
000010  a312              ADR      r3,|L14.92|
000012  22e5              MOVS     r2,#0xe5
000014  a11f              ADR      r1,|L14.148|
000016  a029              ADR      r0,|L14.188|
000018  f7fffffe          BL       __2printf
                  |L14.28|
;;;230    
;;;231        /* allocate UDP PCB */
;;;232        dhcp_pcb = udp_new();
00001c  f7fffffe          BL       udp_new
000020  60e0              STR      r0,[r4,#0xc]  ; dhcp_pcb
;;;233    
;;;234        if (dhcp_pcb == NULL) {
000022  b1b0              CBZ      r0,|L14.82|
;;;235          return ERR_MEM;
;;;236        }
;;;237    
;;;238        ip_set_option(dhcp_pcb, SOF_BROADCAST);
000024  7a41              LDRB     r1,[r0,#9]
000026  f0410120          ORR      r1,r1,#0x20
00002a  7241              STRB     r1,[r0,#9]
;;;239    
;;;240        /* set up local and remote port for the pcb -> listen on all interfaces on all src/dest IPs */
;;;241        udp_bind(dhcp_pcb, IP4_ADDR_ANY, LWIP_IANA_PORT_DHCP_CLIENT);
00002c  2244              MOVS     r2,#0x44
00002e  492d              LDR      r1,|L14.228|
000030  f7fffffe          BL       udp_bind
;;;242        udp_connect(dhcp_pcb, IP4_ADDR_ANY, LWIP_IANA_PORT_DHCP_SERVER);
000034  2243              MOVS     r2,#0x43
000036  492b              LDR      r1,|L14.228|
000038  68e0              LDR      r0,[r4,#0xc]  ; dhcp_pcb
00003a  f7fffffe          BL       udp_connect
;;;243        udp_recv(dhcp_pcb, dhcp_recv, NULL);
00003e  2200              MOVS     r2,#0
000040  4929              LDR      r1,|L14.232|
000042  68e0              LDR      r0,[r4,#0xc]  ; dhcp_pcb
000044  f7fffffe          BL       udp_recv
                  |L14.72|
;;;244      }
;;;245    
;;;246      dhcp_pcb_refcount++;
000048  7820              LDRB     r0,[r4,#0]  ; dhcp_pcb_refcount
00004a  1c40              ADDS     r0,r0,#1
00004c  7020              STRB     r0,[r4,#0]
;;;247    
;;;248      return ERR_OK;
00004e  2000              MOVS     r0,#0
;;;249    }
000050  bd10              POP      {r4,pc}
                  |L14.82|
000052  f04f30ff          MOV      r0,#0xffffffff        ;235
000056  bd10              POP      {r4,pc}
;;;250    
                          ENDP

                  |L14.88|
                          DCD      ||.data||
                  |L14.92|
00005c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
000060  6964646c
000064  65776172
000068  65735c54
00006c  68697264
000070  5f506172
000074  74795c4c
000078  7749505c
00007c  7372635c
000080  636f7265
000084  5c697076
000088  345c6468
00008c  63702e63          DCB      "cp.c",0
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
                  |L14.148|
000094  64686370          DCB      "dhcp_inc_pcb_refcount(): memory leak",0
000098  5f696e63
00009c  5f706362
0000a0  5f726566
0000a4  636f756e
0000a8  7428293a
0000ac  206d656d
0000b0  6f727920
0000b4  6c65616b
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0
                  |L14.188|
0000bc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000c0  7274696f
0000c4  6e202225
0000c8  73222066
0000cc  61696c65
0000d0  64206174
0000d4  206c696e
0000d8  65202564
0000dc  20696e20
0000e0  25730a00
                  |L14.228|
                          DCD      ip_addr_any
                  |L14.232|
                          DCD      dhcp_recv

                          AREA ||i.dhcp_inform||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dhcp_inform PROC
;;;813    void
;;;814    dhcp_inform(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;815    {
000002  b090              SUB      sp,sp,#0x40
000004  4605              MOV      r5,r0
;;;816      struct dhcp dhcp;
;;;817      struct pbuf *p_out;
;;;818      u16_t options_out_len;
;;;819    
;;;820      LWIP_ASSERT_CORE_LOCKED();
;;;821      LWIP_ERROR("netif != NULL", (netif != NULL), return;);
000006  2d00              CMP      r5,#0
000008  d036              BEQ      |L15.120|
;;;822    
;;;823      if (dhcp_inc_pcb_refcount() != ERR_OK) { /* ensure DHCP PCB is allocated */
00000a  f7fffffe          BL       dhcp_inc_pcb_refcount
00000e  2800              CMP      r0,#0
000010  d130              BNE      |L15.116|
;;;824        return;
;;;825      }
;;;826    
;;;827      memset(&dhcp, 0, sizeof(struct dhcp));
000012  2134              MOVS     r1,#0x34
000014  a803              ADD      r0,sp,#0xc
000016  f7fffffe          BL       __aeabi_memclr4
;;;828      dhcp_set_state(&dhcp, DHCP_STATE_INFORMING);
00001a  2107              MOVS     r1,#7
00001c  a803              ADD      r0,sp,#0xc
00001e  f7fffffe          BL       dhcp_set_state
;;;829    
;;;830      /* create and initialize the DHCP message header */
;;;831      p_out = dhcp_create_msg(netif, &dhcp, DHCP_INFORM, &options_out_len);
000022  ab02              ADD      r3,sp,#8
000024  2208              MOVS     r2,#8
000026  a903              ADD      r1,sp,#0xc
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       dhcp_create_msg
00002e  4604              MOV      r4,r0
;;;832      if (p_out != NULL) {
000030  0020              MOVS     r0,r4
000032  d01d              BEQ      |L15.112|
;;;833        struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
000034  6861              LDR      r1,[r4,#4]
;;;834        options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
000036  2302              MOVS     r3,#2
000038  31f0              ADDS     r1,r1,#0xf0
00003a  2239              MOVS     r2,#0x39
00003c  460e              MOV      r6,r1
00003e  f8bd0008          LDRH     r0,[sp,#8]
000042  f7fffffe          BL       dhcp_option
000046  9002              STR      r0,[sp,#8]
;;;835        options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
000048  8daa              LDRH     r2,[r5,#0x2c]
00004a  4631              MOV      r1,r6
00004c  f7fffffe          BL       dhcp_option_short
000050  9002              STR      r0,[sp,#8]
;;;836    
;;;837        LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, &dhcp, DHCP_STATE_INFORMING, msg_out, DHCP_INFORM, &options_out_len);
;;;838        dhcp_option_trailer(options_out_len, msg_out->options, p_out);
000052  4622              MOV      r2,r4
000054  4631              MOV      r1,r6
000056  f7fffffe          BL       dhcp_option_trailer
;;;839    
;;;840        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
;;;841    
;;;842        udp_sendto_if(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif);
00005a  480c              LDR      r0,|L15.140|
00005c  9500              STR      r5,[sp,#0]
00005e  2343              MOVS     r3,#0x43
000060  4a09              LDR      r2,|L15.136|
000062  4621              MOV      r1,r4
000064  68c0              LDR      r0,[r0,#0xc]  ; dhcp_pcb
000066  f7fffffe          BL       udp_sendto_if
;;;843    
;;;844        pbuf_free(p_out);
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       pbuf_free
                  |L15.112|
;;;845      } else {
;;;846        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_inform: could not allocate DHCP request\n"));
;;;847      }
;;;848    
;;;849      dhcp_dec_pcb_refcount(); /* delete DHCP PCB if not needed any more */
000070  f7fffffe          BL       dhcp_dec_pcb_refcount
                  |L15.116|
;;;850    }
000074  b010              ADD      sp,sp,#0x40
000076  bd70              POP      {r4-r6,pc}
                  |L15.120|
000078  a305              ADR      r3,|L15.144|
00007a  f2403235          MOV      r2,#0x335             ;821
00007e  a112              ADR      r1,|L15.200|
000080  a015              ADR      r0,|L15.216|
000082  f7fffffe          BL       __2printf
000086  e7f5              B        |L15.116|
;;;851    
                          ENDP

                  |L15.136|
                          DCD      ip_addr_broadcast
                  |L15.140|
                          DCD      ||.data||
                  |L15.144|
000090  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
000094  6964646c
000098  65776172
00009c  65735c54
0000a0  68697264
0000a4  5f506172
0000a8  74795c4c
0000ac  7749505c
0000b0  7372635c
0000b4  636f7265
0000b8  5c697076
0000bc  345c6468
0000c0  63702e63          DCB      "cp.c",0
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L15.200|
0000c8  6e657469          DCB      "netif != NULL",0
0000cc  6620213d
0000d0  204e554c
0000d4  4c00    
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L15.216|
0000d8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000dc  7274696f
0000e0  6e202225
0000e4  73222066
0000e8  61696c65
0000ec  64206174
0000f0  206c696e
0000f4  65202564
0000f8  20696e20
0000fc  25730a00

                          AREA ||i.dhcp_network_changed||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dhcp_network_changed PROC
;;;857    void
;;;858    dhcp_network_changed(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;859    {
000002  4605              MOV      r5,r0
;;;860      struct dhcp *dhcp = netif_dhcp_data(netif);
000004  6aac              LDR      r4,[r5,#0x28]
;;;861    
;;;862      if (!dhcp) {
000006  2c00              CMP      r4,#0
000008  d022              BEQ      |L16.80|
;;;863        return;
;;;864      }
;;;865      switch (dhcp->state) {
00000a  7961              LDRB     r1,[r4,#5]
00000c  2600              MOVS     r6,#0
00000e  2904              CMP      r1,#4
000010  d018              BEQ      |L16.68|
000012  dc04              BGT      |L16.30|
000014  2900              CMP      r1,#0
000016  d01b              BEQ      |L16.80|
000018  2903              CMP      r1,#3
00001a  d104              BNE      |L16.38|
00001c  e012              B        |L16.68|
                  |L16.30|
00001e  2905              CMP      r1,#5
000020  d010              BEQ      |L16.68|
000022  290a              CMP      r1,#0xa
000024  d00e              BEQ      |L16.68|
                  |L16.38|
;;;866        case DHCP_STATE_REBINDING:
;;;867        case DHCP_STATE_RENEWING:
;;;868        case DHCP_STATE_BOUND:
;;;869        case DHCP_STATE_REBOOTING:
;;;870          dhcp->tries = 0;
;;;871          dhcp_reboot(netif);
;;;872          break;
;;;873        case DHCP_STATE_OFF:
;;;874          /* stay off */
;;;875          break;
;;;876        default:
;;;877          LWIP_ASSERT("invalid dhcp->state", dhcp->state <= DHCP_STATE_BACKING_OFF);
000026  290c              CMP      r1,#0xc
000028  d906              BLS      |L16.56|
00002a  a30a              ADR      r3,|L16.84|
00002c  f240326d          MOV      r2,#0x36d
000030  a116              ADR      r1,|L16.140|
000032  a01b              ADR      r0,|L16.160|
000034  f7fffffe          BL       __2printf
                  |L16.56|
;;;878          /* INIT/REQUESTING/CHECKING/BACKING_OFF restart with new 'rid' because the
;;;879             state changes, SELECTING: continue with current 'rid' as we stay in the
;;;880             same state */
;;;881    #if LWIP_DHCP_AUTOIP_COOP
;;;882          if (dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
;;;883            autoip_stop(netif);
;;;884            dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
;;;885          }
;;;886    #endif /* LWIP_DHCP_AUTOIP_COOP */
;;;887          /* ensure we start with short timeouts, even if already discovering */
;;;888          dhcp->tries = 0;
000038  71a6              STRB     r6,[r4,#6]
;;;889          dhcp_discover(netif);
00003a  4628              MOV      r0,r5
00003c  e8bd4070          POP      {r4-r6,lr}
000040  f7ffbffe          B.W      dhcp_discover
                  |L16.68|
000044  71a6              STRB     r6,[r4,#6]            ;870
000046  4628              MOV      r0,r5                 ;871
000048  e8bd4070          POP      {r4-r6,lr}            ;871
00004c  f7ffbffe          B.W      dhcp_reboot
                  |L16.80|
;;;890          break;
;;;891      }
;;;892    }
000050  bd70              POP      {r4-r6,pc}
;;;893    
                          ENDP

000052  0000              DCW      0x0000
                  |L16.84|
000054  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
000058  6964646c
00005c  65776172
000060  65735c54
000064  68697264
000068  5f506172
00006c  74795c4c
000070  7749505c
000074  7372635c
000078  636f7265
00007c  5c697076
000080  345c6468
000084  63702e63          DCB      "cp.c",0
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L16.140|
00008c  696e7661          DCB      "invalid dhcp->state",0
000090  6c696420
000094  64686370
000098  2d3e7374
00009c  61746500
                  |L16.160|
0000a0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000a4  7274696f
0000a8  6e202225
0000ac  73222066
0000b0  61696c65
0000b4  64206174
0000b8  206c696e
0000bc  65202564
0000c0  20696e20
0000c4  25730a00

                          AREA ||i.dhcp_option||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dhcp_option PROC
;;;1431   static u16_t
;;;1432   dhcp_option(u16_t options_out_len, u8_t *options, u8_t option_type, u8_t option_len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1433   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4690              MOV      r8,r2
00000a  461f              MOV      r7,r3
;;;1434     LWIP_ASSERT("dhcp_option: options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
00000c  19e0              ADDS     r0,r4,r7
00000e  1c80              ADDS     r0,r0,#2
000010  2844              CMP      r0,#0x44
000012  d906              BLS      |L17.34|
000014  a307              ADR      r3,|L17.52|
000016  f240529a          MOV      r2,#0x59a
00001a  4914              LDR      r1,|L17.108|
00001c  a014              ADR      r0,|L17.112|
00001e  f7fffffe          BL       __2printf
                  |L17.34|
;;;1435     options[options_out_len++] = option_type;
000022  1c60              ADDS     r0,r4,#1
000024  b285              UXTH     r5,r0
000026  f8068004          STRB     r8,[r6,r4]
;;;1436     options[options_out_len++] = option_len;
00002a  1c68              ADDS     r0,r5,#1
00002c  b280              UXTH     r0,r0
00002e  5577              STRB     r7,[r6,r5]
;;;1437     return options_out_len;
;;;1438   }
000030  e8bd81f0          POP      {r4-r8,pc}
;;;1439   /*
                          ENDP

                  |L17.52|
000034  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
000038  6964646c
00003c  65776172
000040  65735c54
000044  68697264
000048  5f506172
00004c  74795c4c
000050  7749505c
000054  7372635c
000058  636f7265
00005c  5c697076
000060  345c6468
000064  63702e63          DCB      "cp.c",0
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
                  |L17.108|
                          DCD      ||.conststring||
                  |L17.112|
000070  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000074  7274696f
000078  6e202225
00007c  73222066
000080  61696c65
000084  64206174
000088  206c696e
00008c  65202564
000090  20696e20
000094  25730a00

                          AREA ||i.dhcp_option_byte||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dhcp_option_byte PROC
;;;1443   static u16_t
;;;1444   dhcp_option_byte(u16_t options_out_len, u8_t *options, u8_t value)
000000  b570              PUSH     {r4-r6,lr}
;;;1445   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1446     LWIP_ASSERT("dhcp_option_byte: options_out_len < DHCP_OPTIONS_LEN", options_out_len < DHCP_OPTIONS_LEN);
000008  2c44              CMP      r4,#0x44
00000a  d306              BCC      |L18.26|
00000c  a305              ADR      r3,|L18.36|
00000e  f24052a6          MOV      r2,#0x5a6
000012  a112              ADR      r1,|L18.92|
000014  a01f              ADR      r0,|L18.148|
000016  f7fffffe          BL       __2printf
                  |L18.26|
;;;1447     options[options_out_len++] = value;
00001a  1c60              ADDS     r0,r4,#1
00001c  b280              UXTH     r0,r0
00001e  5535              STRB     r5,[r6,r4]
;;;1448     return options_out_len;
;;;1449   }
000020  bd70              POP      {r4-r6,pc}
;;;1450   
                          ENDP

000022  0000              DCW      0x0000
                  |L18.36|
000024  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
000028  6964646c
00002c  65776172
000030  65735c54
000034  68697264
000038  5f506172
00003c  74795c4c
000040  7749505c
000044  7372635c
000048  636f7265
00004c  5c697076
000050  345c6468
000054  63702e63          DCB      "cp.c",0
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L18.92|
00005c  64686370          DCB      "dhcp_option_byte: options_out_len < DHCP_OPTIONS_LEN",0
000060  5f6f7074
000064  696f6e5f
000068  62797465
00006c  3a206f70
000070  74696f6e
000074  735f6f75
000078  745f6c65
00007c  6e203c20
000080  44484350
000084  5f4f5054
000088  494f4e53
00008c  5f4c454e
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
                  |L18.148|
000094  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000098  7274696f
00009c  6e202225
0000a0  73222066
0000a4  61696c65
0000a8  64206174
0000ac  206c696e
0000b0  65202564
0000b4  20696e20
0000b8  25730a00

                          AREA ||i.dhcp_option_long||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dhcp_option_long PROC
;;;1460   static u16_t
;;;1461   dhcp_option_long(u16_t options_out_len, u8_t *options, u32_t value)
000000  b570              PUSH     {r4-r6,lr}
;;;1462   {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;1463     LWIP_ASSERT("dhcp_option_long: options_out_len + 4 <= DHCP_OPTIONS_LEN", options_out_len + 4U <= DHCP_OPTIONS_LEN);
000008  1d30              ADDS     r0,r6,#4
00000a  2844              CMP      r0,#0x44
00000c  d906              BLS      |L19.28|
00000e  a30b              ADR      r3,|L19.60|
000010  f24052b7          MOV      r2,#0x5b7
000014  a117              ADR      r1,|L19.116|
000016  a026              ADR      r0,|L19.176|
000018  f7fffffe          BL       __2printf
                  |L19.28|
;;;1464     options[options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
00001c  0e22              LSRS     r2,r4,#24
00001e  1c70              ADDS     r0,r6,#1
000020  b281              UXTH     r1,r0
000022  55aa              STRB     r2,[r5,r6]
;;;1465     options[options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
000024  0c22              LSRS     r2,r4,#16
000026  1c48              ADDS     r0,r1,#1
000028  b280              UXTH     r0,r0
00002a  546a              STRB     r2,[r5,r1]
;;;1466     options[options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
00002c  0a22              LSRS     r2,r4,#8
00002e  1c41              ADDS     r1,r0,#1
000030  b289              UXTH     r1,r1
000032  542a              STRB     r2,[r5,r0]
;;;1467     options[options_out_len++] = (u8_t)((value & 0x000000ffUL));
000034  1c48              ADDS     r0,r1,#1
000036  b280              UXTH     r0,r0
000038  546c              STRB     r4,[r5,r1]
;;;1468     return options_out_len;
;;;1469   }
00003a  bd70              POP      {r4-r6,pc}
;;;1470   
                          ENDP

                  |L19.60|
00003c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
000040  6964646c
000044  65776172
000048  65735c54
00004c  68697264
000050  5f506172
000054  74795c4c
000058  7749505c
00005c  7372635c
000060  636f7265
000064  5c697076
000068  345c6468
00006c  63702e63          DCB      "cp.c",0
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L19.116|
000074  64686370          DCB      "dhcp_option_long: options_out_len + 4 <= DHCP_OPTIONS_L"
000078  5f6f7074
00007c  696f6e5f
000080  6c6f6e67
000084  3a206f70
000088  74696f6e
00008c  735f6f75
000090  745f6c65
000094  6e202b20
000098  34203c3d
00009c  20444843
0000a0  505f4f50
0000a4  54494f4e
0000a8  535f4c  
0000ab  454e00            DCB      "EN",0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L19.176|
0000b0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000b4  7274696f
0000b8  6e202225
0000bc  73222066
0000c0  61696c65
0000c4  64206174
0000c8  206c696e
0000cc  65202564
0000d0  20696e20
0000d4  25730a00

                          AREA ||i.dhcp_option_short||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  dhcp_option_short PROC
;;;1451   static u16_t
;;;1452   dhcp_option_short(u16_t options_out_len, u8_t *options, u16_t value)
000000  b570              PUSH     {r4-r6,lr}
;;;1453   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;1454     LWIP_ASSERT("dhcp_option_short: options_out_len + 2 <= DHCP_OPTIONS_LEN", options_out_len + 2U <= DHCP_OPTIONS_LEN);
000008  1ca0              ADDS     r0,r4,#2
00000a  2844              CMP      r0,#0x44
00000c  d906              BLS      |L20.28|
00000e  a307              ADR      r3,|L20.44|
000010  f24052ae          MOV      r2,#0x5ae
000014  a113              ADR      r1,|L20.100|
000016  a022              ADR      r0,|L20.160|
000018  f7fffffe          BL       __2printf
                  |L20.28|
;;;1455     options[options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
00001c  0a29              LSRS     r1,r5,#8
00001e  1c60              ADDS     r0,r4,#1
000020  b283              UXTH     r3,r0
000022  5531              STRB     r1,[r6,r4]
;;;1456     options[options_out_len++] = (u8_t) (value & 0x00ffU);
000024  1c58              ADDS     r0,r3,#1
000026  b280              UXTH     r0,r0
000028  54f5              STRB     r5,[r6,r3]
;;;1457     return options_out_len;
;;;1458   }
00002a  bd70              POP      {r4-r6,pc}
;;;1459   
                          ENDP

                  |L20.44|
00002c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
000030  6964646c
000034  65776172
000038  65735c54
00003c  68697264
000040  5f506172
000044  74795c4c
000048  7749505c
00004c  7372635c
000050  636f7265
000054  5c697076
000058  345c6468
00005c  63702e63          DCB      "cp.c",0
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0
                  |L20.100|
000064  64686370          DCB      "dhcp_option_short: options_out_len + 2 <= DHCP_OPTIONS_"
000068  5f6f7074
00006c  696f6e5f
000070  73686f72
000074  743a206f
000078  7074696f
00007c  6e735f6f
000080  75745f6c
000084  656e202b
000088  2032203c
00008c  3d204448
000090  43505f4f
000094  5054494f
000098  4e535f  
00009b  4c454e00          DCB      "LEN",0
00009f  00                DCB      0
                  |L20.160|
0000a0  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000a4  7274696f
0000a8  6e202225
0000ac  73222066
0000b0  61696c65
0000b4  64206174
0000b8  206c696e
0000bc  65202564
0000c0  20696e20
0000c4  25730a00

                          AREA ||i.dhcp_option_trailer||, CODE, READONLY, ALIGN=1

                  dhcp_option_trailer PROC
;;;1959   static void
;;;1960   dhcp_option_trailer(u16_t options_out_len, u8_t *options, struct pbuf *p_out)
000000  b430              PUSH     {r4,r5}
;;;1961   {
000002  4604              MOV      r4,r0
000004  4610              MOV      r0,r2
;;;1962     options[options_out_len++] = DHCP_OPTION_END;
000006  25ff              MOVS     r5,#0xff
000008  1c62              ADDS     r2,r4,#1
00000a  b293              UXTH     r3,r2
00000c  550d              STRB     r5,[r1,r4]
;;;1963     /* packet is too small, or not 4 byte aligned? */
;;;1964     while (((options_out_len < DHCP_MIN_OPTIONS_LEN) || (options_out_len & 3)) &&
00000e  2400              MOVS     r4,#0
000010  e003              B        |L21.26|
                  |L21.18|
;;;1965            (options_out_len < DHCP_OPTIONS_LEN)) {
;;;1966       /* add a fill/padding byte */
;;;1967       options[options_out_len++] = 0;
000012  461d              MOV      r5,r3
000014  1c5b              ADDS     r3,r3,#1
000016  b29b              UXTH     r3,r3
000018  554c              STRB     r4,[r1,r5]
                  |L21.26|
00001a  2b44              CMP      r3,#0x44              ;1964
00001c  d301              BCC      |L21.34|
00001e  079d              LSLS     r5,r3,#30             ;1964
000020  d001              BEQ      |L21.38|
                  |L21.34|
000022  2b44              CMP      r3,#0x44              ;1965
000024  d3f5              BCC      |L21.18|
                  |L21.38|
;;;1968     }
;;;1969     /* shrink the pbuf to the actual content length */
;;;1970     pbuf_realloc(p_out, (u16_t)(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + options_out_len));
000026  33f0              ADDS     r3,r3,#0xf0
000028  bc30              POP      {r4,r5}
00002a  b299              UXTH     r1,r3
00002c  f7ffbffe          B.W      pbuf_realloc
;;;1971   }
;;;1972   
                          ENDP


                          AREA ||i.dhcp_parse_reply||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  dhcp_parse_reply PROC
;;;1506   static err_t
;;;1507   dhcp_parse_reply(struct pbuf *p, struct dhcp *dhcp)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;1508   {
000004  b085              SUB      sp,sp,#0x14
;;;1509     u8_t *options;
;;;1510     u16_t offset;
;;;1511     u16_t offset_max;
;;;1512     u16_t options_idx;
;;;1513     u16_t options_idx_max;
;;;1514     struct pbuf *q;
;;;1515     int parse_file_as_options = 0;
000006  2000              MOVS     r0,#0
000008  9004              STR      r0,[sp,#0x10]
;;;1516     int parse_sname_as_options = 0;
00000a  9003              STR      r0,[sp,#0xc]
;;;1517     struct dhcp_msg *msg_in;
;;;1518   #if LWIP_DHCP_BOOTP_FILE
;;;1519     int file_overloaded = 0;
;;;1520   #endif
;;;1521   
;;;1522     LWIP_UNUSED_ARG(dhcp);
;;;1523   
;;;1524     /* clear received options */
;;;1525     dhcp_clear_all_options(dhcp);
00000c  210a              MOVS     r1,#0xa
00000e  48e1              LDR      r0,|L22.916|
000010  f7fffffe          BL       __aeabi_memclr4
;;;1526     /* check that beginning of dhcp_msg (up to and including chaddr) is in first pbuf */
;;;1527     if (p->len < DHCP_SNAME_OFS) {
000014  9805              LDR      r0,[sp,#0x14]
000016  8940              LDRH     r0,[r0,#0xa]
000018  282c              CMP      r0,#0x2c
00001a  d204              BCS      |L22.38|
;;;1528       return ERR_BUF;
00001c  f06f0001          MVN      r0,#1
                  |L22.32|
;;;1529     }
;;;1530     msg_in = (struct dhcp_msg *)p->payload;
;;;1531   #if LWIP_DHCP_BOOTP_FILE
;;;1532     /* clear boot file name */
;;;1533     dhcp->boot_file_name[0] = 0;
;;;1534   #endif /* LWIP_DHCP_BOOTP_FILE */
;;;1535   
;;;1536     /* parse options */
;;;1537   
;;;1538     /* start with options field */
;;;1539     options_idx = DHCP_OPTIONS_OFS;
;;;1540     /* parse options to the end of the received packet */
;;;1541     options_idx_max = p->tot_len;
;;;1542   again:
;;;1543     q = p;
;;;1544     while ((q != NULL) && (options_idx >= q->len)) {
;;;1545       options_idx = (u16_t)(options_idx - q->len);
;;;1546       options_idx_max = (u16_t)(options_idx_max - q->len);
;;;1547       q = q->next;
;;;1548     }
;;;1549     if (q == NULL) {
;;;1550       return ERR_BUF;
;;;1551     }
;;;1552     offset = options_idx;
;;;1553     offset_max = options_idx_max;
;;;1554     options = (u8_t *)q->payload;
;;;1555     /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
;;;1556     while ((q != NULL) && (offset < offset_max) && (options[offset] != DHCP_OPTION_END)) {
;;;1557       u8_t op = options[offset];
;;;1558       u8_t len;
;;;1559       u8_t decode_len = 0;
;;;1560       int decode_idx = -1;
;;;1561       u16_t val_offset = (u16_t)(offset + 2);
;;;1562       if (val_offset < offset) {
;;;1563         /* overflow */
;;;1564         return ERR_BUF;
;;;1565       }
;;;1566       /* len byte might be in the next pbuf */
;;;1567       if ((offset + 1) < q->len) {
;;;1568         len = options[offset + 1];
;;;1569       } else {
;;;1570         len = (q->next != NULL ? ((u8_t *)q->next->payload)[0] : 0);
;;;1571       }
;;;1572       /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
;;;1573       decode_len = len;
;;;1574       switch (op) {
;;;1575         /* case(DHCP_OPTION_END): handled above */
;;;1576         case (DHCP_OPTION_PAD):
;;;1577           /* special option: no len encoded */
;;;1578           decode_len = len = 0;
;;;1579           /* will be increased below */
;;;1580           break;
;;;1581         case (DHCP_OPTION_SUBNET_MASK):
;;;1582           LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
;;;1583           decode_idx = DHCP_OPTION_IDX_SUBNET_MASK;
;;;1584           break;
;;;1585         case (DHCP_OPTION_ROUTER):
;;;1586           decode_len = 4; /* only copy the first given router */
;;;1587           LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
;;;1588           decode_idx = DHCP_OPTION_IDX_ROUTER;
;;;1589           break;
;;;1590   #if LWIP_DHCP_PROVIDE_DNS_SERVERS
;;;1591         case (DHCP_OPTION_DNS_SERVER):
;;;1592           /* special case: there might be more than one server */
;;;1593           LWIP_ERROR("len %% 4 == 0", len % 4 == 0, return ERR_VAL;);
;;;1594           /* limit number of DNS servers */
;;;1595           decode_len = LWIP_MIN(len, 4 * DNS_MAX_SERVERS);
;;;1596           LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
;;;1597           decode_idx = DHCP_OPTION_IDX_DNS_SERVER;
;;;1598           break;
;;;1599   #endif /* LWIP_DHCP_PROVIDE_DNS_SERVERS */
;;;1600         case (DHCP_OPTION_LEASE_TIME):
;;;1601           LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
;;;1602           decode_idx = DHCP_OPTION_IDX_LEASE_TIME;
;;;1603           break;
;;;1604   #if LWIP_DHCP_GET_NTP_SRV
;;;1605         case (DHCP_OPTION_NTP):
;;;1606           /* special case: there might be more than one server */
;;;1607           LWIP_ERROR("len %% 4 == 0", len % 4 == 0, return ERR_VAL;);
;;;1608           /* limit number of NTP servers */
;;;1609           decode_len = LWIP_MIN(len, 4 * LWIP_DHCP_MAX_NTP_SERVERS);
;;;1610           LWIP_ERROR("len >= decode_len", len >= decode_len, return ERR_VAL;);
;;;1611           decode_idx = DHCP_OPTION_IDX_NTP_SERVER;
;;;1612           break;
;;;1613   #endif /* LWIP_DHCP_GET_NTP_SRV*/
;;;1614         case (DHCP_OPTION_OVERLOAD):
;;;1615           LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
;;;1616           /* decode overload only in options, not in file/sname: invalid packet */
;;;1617           LWIP_ERROR("overload in file/sname", options_idx == DHCP_OPTIONS_OFS, return ERR_VAL;);
;;;1618           decode_idx = DHCP_OPTION_IDX_OVERLOAD;
;;;1619           break;
;;;1620         case (DHCP_OPTION_MESSAGE_TYPE):
;;;1621           LWIP_ERROR("len == 1", len == 1, return ERR_VAL;);
;;;1622           decode_idx = DHCP_OPTION_IDX_MSG_TYPE;
;;;1623           break;
;;;1624         case (DHCP_OPTION_SERVER_ID):
;;;1625           LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
;;;1626           decode_idx = DHCP_OPTION_IDX_SERVER_ID;
;;;1627           break;
;;;1628         case (DHCP_OPTION_T1):
;;;1629           LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
;;;1630           decode_idx = DHCP_OPTION_IDX_T1;
;;;1631           break;
;;;1632         case (DHCP_OPTION_T2):
;;;1633           LWIP_ERROR("len == 4", len == 4, return ERR_VAL;);
;;;1634           decode_idx = DHCP_OPTION_IDX_T2;
;;;1635           break;
;;;1636         default:
;;;1637           decode_len = 0;
;;;1638           LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", (u16_t)op));
;;;1639           LWIP_HOOK_DHCP_PARSE_OPTION(ip_current_netif(), dhcp, dhcp->state, msg_in,
;;;1640                                       dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE) ? (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE) : 0,
;;;1641                                       op, len, q, val_offset);
;;;1642           break;
;;;1643       }
;;;1644       if (op == DHCP_OPTION_PAD) {
;;;1645         offset++;
;;;1646       } else {
;;;1647         if (offset + len + 2 > 0xFFFF) {
;;;1648           /* overflow */
;;;1649           return ERR_BUF;
;;;1650         }
;;;1651         offset = (u16_t)(offset + len + 2);
;;;1652         if (decode_len > 0) {
;;;1653           u32_t value = 0;
;;;1654           u16_t copy_len;
;;;1655   decode_next:
;;;1656           LWIP_ASSERT("check decode_idx", decode_idx >= 0 && decode_idx < DHCP_OPTION_IDX_MAX);
;;;1657           if (!dhcp_option_given(dhcp, decode_idx)) {
;;;1658             copy_len = LWIP_MIN(decode_len, 4);
;;;1659             if (pbuf_copy_partial(q, &value, copy_len, val_offset) != copy_len) {
;;;1660               return ERR_BUF;
;;;1661             }
;;;1662             if (decode_len > 4) {
;;;1663               /* decode more than one u32_t */
;;;1664               u16_t next_val_offset;
;;;1665               LWIP_ERROR("decode_len %% 4 == 0", decode_len % 4 == 0, return ERR_VAL;);
;;;1666               dhcp_got_option(dhcp, decode_idx);
;;;1667               dhcp_set_option_value(dhcp, decode_idx, lwip_htonl(value));
;;;1668               decode_len = (u8_t)(decode_len - 4);
;;;1669               next_val_offset = (u16_t)(val_offset + 4);
;;;1670               if (next_val_offset < val_offset) {
;;;1671                 /* overflow */
;;;1672                 return ERR_BUF;
;;;1673               }
;;;1674               val_offset = next_val_offset;
;;;1675               decode_idx++;
;;;1676               goto decode_next;
;;;1677             } else if (decode_len == 4) {
;;;1678               value = lwip_ntohl(value);
;;;1679             } else {
;;;1680               LWIP_ERROR("invalid decode_len", decode_len == 1, return ERR_VAL;);
;;;1681               value = ((u8_t *)&value)[0];
;;;1682             }
;;;1683             dhcp_got_option(dhcp, decode_idx);
;;;1684             dhcp_set_option_value(dhcp, decode_idx, value);
;;;1685           }
;;;1686         }
;;;1687       }
;;;1688       if (offset >= q->len) {
;;;1689         offset = (u16_t)(offset - q->len);
;;;1690         offset_max = (u16_t)(offset_max - q->len);
;;;1691         if (offset < offset_max) {
;;;1692           q = q->next;
;;;1693           LWIP_ERROR("next pbuf was null", q != NULL, return ERR_VAL;);
;;;1694           options = (u8_t *)q->payload;
;;;1695         } else {
;;;1696           /* We've run out of bytes, probably no end marker. Don't proceed. */
;;;1697           return ERR_BUF;
;;;1698         }
;;;1699       }
;;;1700     }
;;;1701     /* is this an overloaded message? */
;;;1702     if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_OVERLOAD)) {
;;;1703       u32_t overload = dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_OVERLOAD);
;;;1704       dhcp_clear_option(dhcp, DHCP_OPTION_IDX_OVERLOAD);
;;;1705       if (overload == DHCP_OVERLOAD_FILE) {
;;;1706         parse_file_as_options = 1;
;;;1707         LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded file field\n"));
;;;1708       } else if (overload == DHCP_OVERLOAD_SNAME) {
;;;1709         parse_sname_as_options = 1;
;;;1710         LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname field\n"));
;;;1711       } else if (overload == DHCP_OVERLOAD_SNAME_FILE) {
;;;1712         parse_sname_as_options = 1;
;;;1713         parse_file_as_options = 1;
;;;1714         LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("overloaded sname and file field\n"));
;;;1715       } else {
;;;1716         LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("invalid overload option: %d\n", (int)overload));
;;;1717       }
;;;1718     }
;;;1719     if (parse_file_as_options) {
;;;1720       /* if both are overloaded, parse file first and then sname (RFC 2131 ch. 4.1) */
;;;1721       parse_file_as_options = 0;
;;;1722       options_idx = DHCP_FILE_OFS;
;;;1723       options_idx_max = DHCP_FILE_OFS + DHCP_FILE_LEN;
;;;1724   #if LWIP_DHCP_BOOTP_FILE
;;;1725       file_overloaded = 1;
;;;1726   #endif
;;;1727       goto again;
;;;1728     } else if (parse_sname_as_options) {
;;;1729       parse_sname_as_options = 0;
;;;1730       options_idx = DHCP_SNAME_OFS;
;;;1731       options_idx_max = DHCP_SNAME_OFS + DHCP_SNAME_LEN;
;;;1732       goto again;
;;;1733     }
;;;1734   #if LWIP_DHCP_BOOTP_FILE
;;;1735     if (!file_overloaded) {
;;;1736       /* only do this for ACK messages */
;;;1737       if (dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE) &&
;;;1738         (dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE) == DHCP_ACK))
;;;1739       /* copy bootp file name, don't care for sname (server hostname) */
;;;1740       if (pbuf_copy_partial(p, dhcp->boot_file_name, DHCP_FILE_LEN-1, DHCP_FILE_OFS) != (DHCP_FILE_LEN-1)) {
;;;1741         return ERR_BUF;
;;;1742       }
;;;1743       /* make sure the string is really NULL-terminated */
;;;1744       dhcp->boot_file_name[DHCP_FILE_LEN-1] = 0;
;;;1745     }
;;;1746   #endif /* LWIP_DHCP_BOOTP_FILE */ 
;;;1747     return ERR_OK;
;;;1748   }
000020  b007              ADD      sp,sp,#0x1c
000022  e8bd8ff0          POP      {r4-r11,pc}
                  |L22.38|
000026  f04f08f0          MOV      r8,#0xf0              ;1539
00002a  9805              LDR      r0,[sp,#0x14]         ;1541
00002c  f8b0a008          LDRH     r10,[r0,#8]           ;1541
                  |L22.48|
000030  9e05              LDR      r6,[sp,#0x14]         ;1543
000032  e008              B        |L22.70|
                  |L22.52|
000034  eba80100          SUB      r1,r8,r0              ;1545
000038  fa1ff881          UXTH     r8,r1                 ;1545
00003c  ebaa0000          SUB      r0,r10,r0             ;1546
000040  fa1ffa80          UXTH     r10,r0                ;1546
000044  6836              LDR      r6,[r6,#0]            ;1547
                  |L22.70|
000046  b116              CBZ      r6,|L22.78|
000048  8970              LDRH     r0,[r6,#0xa]          ;1544
00004a  4540              CMP      r0,r8                 ;1544
00004c  d9f2              BLS      |L22.52|
                  |L22.78|
00004e  b11e              CBZ      r6,|L22.88|
000050  4647              MOV      r7,r8                 ;1552
000052  f8d6b004          LDR      r11,[r6,#4]           ;1554
000056  e15c              B        |L22.786|
                  |L22.88|
000058  f06f0001          MVN      r0,#1                 ;1550
00005c  e7e0              B        |L22.32|
                  |L22.94|
00005e  f04f34ff          MOV      r4,#0xffffffff        ;1560
000062  1cb8              ADDS     r0,r7,#2              ;1561
000064  fa1ff980          UXTH     r9,r0                 ;1561
000068  45b9              CMP      r9,r7                 ;1562
00006a  d201              BCS      |L22.112|
00006c  0060              LSLS     r0,r4,#1              ;1564
00006e  e7d7              B        |L22.32|
                  |L22.112|
000070  8973              LDRH     r3,[r6,#0xa]          ;1567
000072  1c78              ADDS     r0,r7,#1              ;1567
000074  4602              MOV      r2,r0                 ;1567
000076  4283              CMP      r3,r0                 ;1567
000078  d903              BLS      |L22.130|
00007a  eb0b0007          ADD      r0,r11,r7             ;1568
00007e  7840              LDRB     r0,[r0,#1]            ;1568
000080  e005              B        |L22.142|
                  |L22.130|
000082  6830              LDR      r0,[r6,#0]            ;1570
000084  b110              CBZ      r0,|L22.140|
000086  6840              LDR      r0,[r0,#4]            ;1570
000088  7800              LDRB     r0,[r0,#0]            ;1570
00008a  e000              B        |L22.142|
                  |L22.140|
00008c  2000              MOVS     r0,#0                 ;1570
                  |L22.142|
00008e  4605              MOV      r5,r0                 ;1573
000090  2934              CMP      r1,#0x34              ;1574
000092  d06c              BEQ      |L22.366|
000094  dc0b              BGT      |L22.174|
000096  2903              CMP      r1,#3                 ;1574
000098  d02d              BEQ      |L22.246|
00009a  dc03              BGT      |L22.164|
00009c  b1d1              CBZ      r1,|L22.212|
00009e  2901              CMP      r1,#1                 ;1574
0000a0  d10d              BNE      |L22.190|
0000a2  e01a              B        |L22.218|
                  |L22.164|
0000a4  2906              CMP      r1,#6                 ;1574
0000a6  d035              BEQ      |L22.276|
0000a8  2933              CMP      r1,#0x33              ;1574
0000aa  d108              BNE      |L22.190|
0000ac  e051              B        |L22.338|
                  |L22.174|
0000ae  2935              CMP      r1,#0x35              ;1574
0000b0  d07e              BEQ      |L22.432|
0000b2  2936              CMP      r1,#0x36              ;1574
0000b4  d075              BEQ      |L22.418|
0000b6  293a              CMP      r1,#0x3a              ;1574
0000b8  d074              BEQ      |L22.420|
0000ba  293b              CMP      r1,#0x3b              ;1574
0000bc  d073              BEQ      |L22.422|
                  |L22.190|
0000be  2500              MOVS     r5,#0                 ;1637
                  |L22.192|
0000c0  2900              CMP      r1,#0                 ;1644
0000c2  d071              BEQ      |L22.424|
0000c4  4438              ADD      r0,r0,r7              ;1647
0000c6  1c80              ADDS     r0,r0,#2              ;1647
0000c8  f5b03f80          CMP      r0,#0x10000           ;1647
0000cc  d36d              BCC      |L22.426|
0000ce  f06f0001          MVN      r0,#1                 ;1649
0000d2  e7a5              B        |L22.32|
                  |L22.212|
0000d4  2000              MOVS     r0,#0                 ;1578
0000d6  4605              MOV      r5,r0                 ;1578
0000d8  e7f2              B        |L22.192|
                  |L22.218|
0000da  2804              CMP      r0,#4                 ;1582
0000dc  d009              BEQ      |L22.242|
0000de  a3ae              ADR      r3,|L22.920|
0000e0  f240622e          MOV      r2,#0x62e             ;1582
0000e4  a1ba              ADR      r1,|L22.976|
0000e6  a0bd              ADR      r0,|L22.988|
0000e8  f7fffffe          BL       __2printf
0000ec  f06f0005          MVN      r0,#5                 ;1582
0000f0  e796              B        |L22.32|
                  |L22.242|
0000f2  2406              MOVS     r4,#6                 ;1583
0000f4  e7e4              B        |L22.192|
                  |L22.246|
0000f6  2504              MOVS     r5,#4                 ;1586
0000f8  2804              CMP      r0,#4                 ;1587
0000fa  d209              BCS      |L22.272|
0000fc  a3a6              ADR      r3,|L22.920|
0000fe  f2406233          MOV      r2,#0x633             ;1587
000102  a1c0              ADR      r1,|L22.1028|
000104  a0b5              ADR      r0,|L22.988|
000106  f7fffffe          BL       __2printf
00010a  f06f0005          MVN      r0,#5                 ;1587
00010e  e787              B        |L22.32|
                  |L22.272|
000110  2407              MOVS     r4,#7                 ;1588
000112  e7d5              B        |L22.192|
                  |L22.276|
000114  0783              LSLS     r3,r0,#30             ;1593
000116  d009              BEQ      |L22.300|
000118  a39f              ADR      r3,|L22.920|
00011a  f2406239          MOV      r2,#0x639             ;1593
00011e  a1be              ADR      r1,|L22.1048|
000120  a0ae              ADR      r0,|L22.988|
000122  f7fffffe          BL       __2printf
000126  f06f0005          MVN      r0,#5                 ;1593
00012a  e779              B        |L22.32|
                  |L22.300|
00012c  2808              CMP      r0,#8                 ;1595
00012e  d201              BCS      |L22.308|
000130  4605              MOV      r5,r0                 ;1595
000132  e000              B        |L22.310|
                  |L22.308|
000134  2508              MOVS     r5,#8                 ;1595
                  |L22.310|
000136  42a8              CMP      r0,r5                 ;1596
000138  d209              BCS      |L22.334|
00013a  a397              ADR      r3,|L22.920|
00013c  f240623c          MOV      r2,#0x63c             ;1596
000140  a1b0              ADR      r1,|L22.1028|
000142  a0a6              ADR      r0,|L22.988|
000144  f7fffffe          BL       __2printf
000148  f06f0005          MVN      r0,#5                 ;1596
00014c  e768              B        |L22.32|
                  |L22.334|
00014e  2408              MOVS     r4,#8                 ;1597
000150  e7b6              B        |L22.192|
                  |L22.338|
000152  2804              CMP      r0,#4                 ;1601
000154  d009              BEQ      |L22.362|
000156  a390              ADR      r3,|L22.920|
000158  f2406241          MOV      r2,#0x641             ;1601
00015c  a19c              ADR      r1,|L22.976|
00015e  a09f              ADR      r0,|L22.988|
000160  f7fffffe          BL       __2printf
000164  f06f0005          MVN      r0,#5                 ;1601
000168  e75a              B        |L22.32|
                  |L22.362|
00016a  2403              MOVS     r4,#3                 ;1602
00016c  e7a8              B        |L22.192|
                  |L22.366|
00016e  2801              CMP      r0,#1                 ;1615
000170  d009              BEQ      |L22.390|
000172  a389              ADR      r3,|L22.920|
000174  f240624f          MOV      r2,#0x64f             ;1615
000178  a1ab              ADR      r1,|L22.1064|
00017a  a098              ADR      r0,|L22.988|
00017c  f7fffffe          BL       __2printf
000180  f06f0005          MVN      r0,#5                 ;1615
000184  e74c              B        |L22.32|
                  |L22.390|
000186  f1b80ff0          CMP      r8,#0xf0              ;1617
00018a  d00f              BEQ      |L22.428|
00018c  a382              ADR      r3,|L22.920|
00018e  f2406251          MOV      r2,#0x651             ;1617
000192  a1a8              ADR      r1,|L22.1076|
000194  a091              ADR      r0,|L22.988|
000196  f7fffffe          BL       __2printf
00019a  f06f0005          MVN      r0,#5                 ;1617
00019e  e73f              B        |L22.32|
0001a0  e006              B        |L22.432|
                  |L22.418|
0001a2  e013              B        |L22.460|
                  |L22.420|
0001a4  e020              B        |L22.488|
                  |L22.422|
0001a6  e02d              B        |L22.516|
                  |L22.424|
0001a8  e03a              B        |L22.544|
                  |L22.426|
0001aa  e03b              B        |L22.548|
                  |L22.428|
0001ac  2400              MOVS     r4,#0                 ;1618
0001ae  e787              B        |L22.192|
                  |L22.432|
0001b0  2801              CMP      r0,#1                 ;1621
0001b2  d009              BEQ      |L22.456|
0001b4  a378              ADR      r3,|L22.920|
0001b6  f2406255          MOV      r2,#0x655             ;1621
0001ba  a19b              ADR      r1,|L22.1064|
0001bc  a087              ADR      r0,|L22.988|
0001be  f7fffffe          BL       __2printf
0001c2  f06f0005          MVN      r0,#5                 ;1621
0001c6  e72b              B        |L22.32|
                  |L22.456|
0001c8  2401              MOVS     r4,#1                 ;1622
0001ca  e779              B        |L22.192|
                  |L22.460|
0001cc  2804              CMP      r0,#4                 ;1625
0001ce  d009              BEQ      |L22.484|
0001d0  a371              ADR      r3,|L22.920|
0001d2  f2406259          MOV      r2,#0x659             ;1625
0001d6  a17e              ADR      r1,|L22.976|
0001d8  a080              ADR      r0,|L22.988|
0001da  f7fffffe          BL       __2printf
0001de  f06f0005          MVN      r0,#5                 ;1625
0001e2  e71d              B        |L22.32|
                  |L22.484|
0001e4  2402              MOVS     r4,#2                 ;1626
0001e6  e76b              B        |L22.192|
                  |L22.488|
0001e8  2804              CMP      r0,#4                 ;1629
0001ea  d009              BEQ      |L22.512|
0001ec  a36a              ADR      r3,|L22.920|
0001ee  f240625d          MOV      r2,#0x65d             ;1629
0001f2  a177              ADR      r1,|L22.976|
0001f4  a079              ADR      r0,|L22.988|
0001f6  f7fffffe          BL       __2printf
0001fa  f06f0005          MVN      r0,#5                 ;1629
0001fe  e70f              B        |L22.32|
                  |L22.512|
000200  2404              MOVS     r4,#4                 ;1630
000202  e75d              B        |L22.192|
                  |L22.516|
000204  2804              CMP      r0,#4                 ;1633
000206  d009              BEQ      |L22.540|
000208  a363              ADR      r3,|L22.920|
00020a  f2406261          MOV      r2,#0x661             ;1633
00020e  a170              ADR      r1,|L22.976|
000210  a072              ADR      r0,|L22.988|
000212  f7fffffe          BL       __2printf
000216  f06f0005          MVN      r0,#5                 ;1633
00021a  e701              B        |L22.32|
                  |L22.540|
00021c  2405              MOVS     r4,#5                 ;1634
00021e  e74f              B        |L22.192|
                  |L22.544|
000220  b297              UXTH     r7,r2                 ;1645
000222  e067              B        |L22.756|
                  |L22.548|
000224  b287              UXTH     r7,r0                 ;1651
000226  2d00              CMP      r5,#0                 ;1652
000228  d064              BEQ      |L22.756|
00022a  2000              MOVS     r0,#0                 ;1653
00022c  9002              STR      r0,[sp,#8]            ;1653
                  |L22.558|
00022e  2c0a              CMP      r4,#0xa               ;1656
000230  d306              BCC      |L22.576|
000232  a359              ADR      r3,|L22.920|
000234  f44f62cf          MOV      r2,#0x678             ;1656
000238  a184              ADR      r1,|L22.1100|
00023a  a068              ADR      r0,|L22.988|
00023c  f7fffffe          BL       __2printf
                  |L22.576|
000240  4854              LDR      r0,|L22.916|
000242  5d00              LDRB     r0,[r0,r4]            ;1657
000244  2800              CMP      r0,#0                 ;1657
000246  d155              BNE      |L22.756|
000248  2d04              CMP      r5,#4                 ;1658
00024a  d201              BCS      |L22.592|
00024c  4628              MOV      r0,r5                 ;1658
00024e  e000              B        |L22.594|
                  |L22.592|
000250  2004              MOVS     r0,#4                 ;1658
                  |L22.594|
000252  9001              STR      r0,[sp,#4]            ;1658
000254  464b              MOV      r3,r9                 ;1659
000256  a902              ADD      r1,sp,#8              ;1659
000258  4630              MOV      r0,r6                 ;1659
00025a  9a01              LDR      r2,[sp,#4]            ;1659
00025c  f7fffffe          BL       pbuf_copy_partial
000260  4601              MOV      r1,r0                 ;1659
000262  9801              LDR      r0,[sp,#4]            ;1659
000264  4281              CMP      r1,r0                 ;1659
000266  d002              BEQ      |L22.622|
000268  f06f0001          MVN      r0,#1                 ;1660
00026c  e6d8              B        |L22.32|
                  |L22.622|
00026e  2d04              CMP      r5,#4                 ;1662
000270  d922              BLS      |L22.696|
000272  07a8              LSLS     r0,r5,#30             ;1665
000274  d009              BEQ      |L22.650|
000276  a348              ADR      r3,|L22.920|
000278  f2406281          MOV      r2,#0x681             ;1665
00027c  a178              ADR      r1,|L22.1120|
00027e  a057              ADR      r0,|L22.988|
000280  f7fffffe          BL       __2printf
000284  f06f0005          MVN      r0,#5                 ;1665
000288  e6ca              B        |L22.32|
                  |L22.650|
00028a  4842              LDR      r0,|L22.916|
00028c  2101              MOVS     r1,#1                 ;1666
00028e  5501              STRB     r1,[r0,r4]            ;1666
000290  9802              LDR      r0,[sp,#8]            ;1667
000292  f7fffffe          BL       lwip_htonl
000296  493f              LDR      r1,|L22.916|
000298  3928              SUBS     r1,r1,#0x28           ;1667
00029a  f8410024          STR      r0,[r1,r4,LSL #2]     ;1667
00029e  1f2d              SUBS     r5,r5,#4              ;1668
0002a0  b2ed              UXTB     r5,r5                 ;1668
0002a2  f1090004          ADD      r0,r9,#4              ;1669
0002a6  b280              UXTH     r0,r0                 ;1669
0002a8  4548              CMP      r0,r9                 ;1670
0002aa  d202              BCS      |L22.690|
0002ac  f06f0001          MVN      r0,#1                 ;1672
0002b0  e6b6              B        |L22.32|
                  |L22.690|
0002b2  4681              MOV      r9,r0                 ;1674
0002b4  1c64              ADDS     r4,r4,#1              ;1675
0002b6  e7ba              B        |L22.558|
                  |L22.696|
0002b8  2d04              CMP      r5,#4                 ;1677
0002ba  d00b              BEQ      |L22.724|
0002bc  2d01              CMP      r5,#1                 ;1680
0002be  d00e              BEQ      |L22.734|
0002c0  a335              ADR      r3,|L22.920|
0002c2  f44f62d2          MOV      r2,#0x690             ;1680
0002c6  a16c              ADR      r1,|L22.1144|
0002c8  a044              ADR      r0,|L22.988|
0002ca  f7fffffe          BL       __2printf
0002ce  f06f0005          MVN      r0,#5                 ;1680
0002d2  e6a5              B        |L22.32|
                  |L22.724|
0002d4  9802              LDR      r0,[sp,#8]            ;1678
0002d6  f7fffffe          BL       lwip_htonl
0002da  9002              STR      r0,[sp,#8]            ;1678
0002dc  e002              B        |L22.740|
                  |L22.734|
0002de  f89d0008          LDRB     r0,[sp,#8]            ;1681
0002e2  9002              STR      r0,[sp,#8]            ;1681
                  |L22.740|
0002e4  492b              LDR      r1,|L22.916|
0002e6  2001              MOVS     r0,#1                 ;1683
0002e8  5508              STRB     r0,[r1,r4]            ;1683
0002ea  482a              LDR      r0,|L22.916|
0002ec  9902              LDR      r1,[sp,#8]            ;1684
0002ee  3828              SUBS     r0,r0,#0x28           ;1684
0002f0  f8401024          STR      r1,[r0,r4,LSL #2]     ;1684
                  |L22.756|
0002f4  8970              LDRH     r0,[r6,#0xa]          ;1688
0002f6  42b8              CMP      r0,r7                 ;1688
0002f8  d80b              BHI      |L22.786|
0002fa  1a39              SUBS     r1,r7,r0              ;1689
0002fc  b28f              UXTH     r7,r1                 ;1689
0002fe  ebaa0000          SUB      r0,r10,r0             ;1690
000302  fa1ffa80          UXTH     r10,r0                ;1690
000306  4557              CMP      r7,r10                ;1691
000308  d224              BCS      |L22.852|
00030a  6836              LDR      r6,[r6,#0]            ;1692
00030c  b1c6              CBZ      r6,|L22.832|
00030e  f8d6b004          LDR      r11,[r6,#4]           ;1694
                  |L22.786|
000312  b136              CBZ      r6,|L22.802|
000314  4557              CMP      r7,r10                ;1556
000316  d204              BCS      |L22.802|
000318  f81b1007          LDRB     r1,[r11,r7]           ;1556
00031c  29ff              CMP      r1,#0xff              ;1556
00031e  f47fae9e          BNE      |L22.94|
                  |L22.802|
000322  4a1c              LDR      r2,|L22.916|
000324  7810              LDRB     r0,[r2,#0]            ;1702  ; dhcp_rx_options_given
000326  b308              CBZ      r0,|L22.876|
000328  f1a20028          SUB      r0,r2,#0x28           ;1703
00032c  6800              LDR      r0,[r0,#0]            ;1703  ; dhcp_rx_options_val
00032e  2100              MOVS     r1,#0                 ;1704
000330  7011              STRB     r1,[r2,#0]            ;1704
000332  2801              CMP      r0,#1                 ;1705
000334  d011              BEQ      |L22.858|
000336  2802              CMP      r0,#2                 ;1708
000338  d012              BEQ      |L22.864|
00033a  2803              CMP      r0,#3                 ;1711
00033c  d013              BEQ      |L22.870|
00033e  e015              B        |L22.876|
                  |L22.832|
000340  a315              ADR      r3,|L22.920|
000342  f240629d          MOV      r2,#0x69d             ;1693
000346  a151              ADR      r1,|L22.1164|
000348  a024              ADR      r0,|L22.988|
00034a  f7fffffe          BL       __2printf
00034e  f06f0005          MVN      r0,#5                 ;1693
000352  e665              B        |L22.32|
                  |L22.852|
000354  f06f0001          MVN      r0,#1                 ;1697
000358  e662              B        |L22.32|
                  |L22.858|
00035a  2001              MOVS     r0,#1                 ;1706
00035c  9004              STR      r0,[sp,#0x10]         ;1706
00035e  e005              B        |L22.876|
                  |L22.864|
000360  2001              MOVS     r0,#1                 ;1709
000362  9003              STR      r0,[sp,#0xc]          ;1709
000364  e002              B        |L22.876|
                  |L22.870|
000366  2001              MOVS     r0,#1                 ;1712
000368  9003              STR      r0,[sp,#0xc]          ;1712
00036a  9004              STR      r0,[sp,#0x10]         ;1713
                  |L22.876|
00036c  9804              LDR      r0,[sp,#0x10]         ;1719
00036e  b130              CBZ      r0,|L22.894|
000370  2000              MOVS     r0,#0                 ;1721
000372  9004              STR      r0,[sp,#0x10]         ;1721
000374  f04f086c          MOV      r8,#0x6c              ;1722
000378  f04f0aec          MOV      r10,#0xec             ;1723
00037c  e658              B        |L22.48|
                  |L22.894|
00037e  9803              LDR      r0,[sp,#0xc]          ;1728
000380  b130              CBZ      r0,|L22.912|
000382  2000              MOVS     r0,#0                 ;1729
000384  9003              STR      r0,[sp,#0xc]          ;1729
000386  f04f082c          MOV      r8,#0x2c              ;1730
00038a  f04f0a6c          MOV      r10,#0x6c             ;1731
00038e  e64f              B        |L22.48|
                  |L22.912|
000390  2000              MOVS     r0,#0                 ;1747
000392  e645              B        |L22.32|
;;;1749   
                          ENDP

                  |L22.916|
                          DCD      ||.bss||+0x28
                  |L22.920|
000398  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
00039c  6964646c
0003a0  65776172
0003a4  65735c54
0003a8  68697264
0003ac  5f506172
0003b0  74795c4c
0003b4  7749505c
0003b8  7372635c
0003bc  636f7265
0003c0  5c697076
0003c4  345c6468
0003c8  63702e63          DCB      "cp.c",0
0003cc  00      
0003cd  00                DCB      0
0003ce  00                DCB      0
0003cf  00                DCB      0
                  |L22.976|
0003d0  6c656e20          DCB      "len == 4",0
0003d4  3d3d2034
0003d8  00      
0003d9  00                DCB      0
0003da  00                DCB      0
0003db  00                DCB      0
                  |L22.988|
0003dc  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0003e0  7274696f
0003e4  6e202225
0003e8  73222066
0003ec  61696c65
0003f0  64206174
0003f4  206c696e
0003f8  65202564
0003fc  20696e20
000400  25730a00
                  |L22.1028|
000404  6c656e20          DCB      "len >= decode_len",0
000408  3e3d2064
00040c  65636f64
000410  655f6c65
000414  6e00    
000416  00                DCB      0
000417  00                DCB      0
                  |L22.1048|
000418  6c656e20          DCB      "len %% 4 == 0",0
00041c  25252034
000420  203d3d20
000424  3000    
000426  00                DCB      0
000427  00                DCB      0
                  |L22.1064|
000428  6c656e20          DCB      "len == 1",0
00042c  3d3d2031
000430  00      
000431  00                DCB      0
000432  00                DCB      0
000433  00                DCB      0
                  |L22.1076|
000434  6f766572          DCB      "overload in file/sname",0
000438  6c6f6164
00043c  20696e20
000440  66696c65
000444  2f736e61
000448  6d6500  
00044b  00                DCB      0
                  |L22.1100|
00044c  63686563          DCB      "check decode_idx",0
000450  6b206465
000454  636f6465
000458  5f696478
00045c  00      
00045d  00                DCB      0
00045e  00                DCB      0
00045f  00                DCB      0
                  |L22.1120|
000460  6465636f          DCB      "decode_len %% 4 == 0",0
000464  64655f6c
000468  656e2025
00046c  25203420
000470  3d3d2030
000474  00      
000475  00                DCB      0
000476  00                DCB      0
000477  00                DCB      0
                  |L22.1144|
000478  696e7661          DCB      "invalid decode_len",0
00047c  6c696420
000480  6465636f
000484  64655f6c
000488  656e00  
00048b  00                DCB      0
                  |L22.1164|
00048c  6e657874          DCB      "next pbuf was null",0
000490  20706275
000494  66207761
000498  73206e75
00049c  6c6c00  
00049f  00                DCB      0

                          AREA ||i.dhcp_rebind||, CODE, READONLY, ALIGN=2

                  dhcp_rebind PROC
;;;1205   static err_t
;;;1206   dhcp_rebind(struct netif *netif)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1207   {
000004  4680              MOV      r8,r0
;;;1208     struct dhcp *dhcp = netif_dhcp_data(netif);
000006  f8d85028          LDR      r5,[r8,#0x28]
;;;1209     err_t result;
;;;1210     u16_t msecs;
;;;1211     u8_t i;
;;;1212     struct pbuf *p_out;
;;;1213     u16_t options_out_len;
;;;1214   
;;;1215     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
;;;1216     dhcp_set_state(dhcp, DHCP_STATE_REBINDING);
00000a  2104              MOVS     r1,#4
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       dhcp_set_state
;;;1217   
;;;1218     /* create and initialize the DHCP message header */
;;;1219     p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
000012  ab01              ADD      r3,sp,#4
000014  2203              MOVS     r2,#3
000016  4629              MOV      r1,r5
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       dhcp_create_msg
00001e  4607              MOV      r7,r0
;;;1220     if (p_out != NULL) {
000020  0038              MOVS     r0,r7
000022  d037              BEQ      |L23.148|
;;;1221       struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
000024  6879              LDR      r1,[r7,#4]
;;;1222       options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
000026  2302              MOVS     r3,#2
000028  31f0              ADDS     r1,r1,#0xf0
00002a  2239              MOVS     r2,#0x39
00002c  4689              MOV      r9,r1
00002e  f8bd0004          LDRH     r0,[sp,#4]
000032  f7fffffe          BL       dhcp_option
000036  9001              STR      r0,[sp,#4]
;;;1223       options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
000038  f8b8202c          LDRH     r2,[r8,#0x2c]
00003c  4649              MOV      r1,r9
00003e  f7fffffe          BL       dhcp_option_short
000042  9001              STR      r0,[sp,#4]
;;;1224   
;;;1225       options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
000044  2304              MOVS     r3,#4
000046  2237              MOVS     r2,#0x37
000048  4649              MOV      r1,r9
00004a  f7fffffe          BL       dhcp_option
00004e  9001              STR      r0,[sp,#4]
;;;1226       for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
000050  2400              MOVS     r4,#0
;;;1227         options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
000052  4e1e              LDR      r6,|L23.204|
                  |L23.84|
000054  4649              MOV      r1,r9
000056  f8bd0004          LDRH     r0,[sp,#4]
00005a  5d32              LDRB     r2,[r6,r4]
00005c  f7fffffe          BL       dhcp_option_byte
000060  9001              STR      r0,[sp,#4]
000062  1c64              ADDS     r4,r4,#1              ;1226
000064  b2e4              UXTB     r4,r4                 ;1226
000066  2c04              CMP      r4,#4                 ;1226
000068  d3f4              BCC      |L23.84|
;;;1228       }
;;;1229   
;;;1230   #if LWIP_NETIF_HOSTNAME
;;;1231       options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
;;;1232   #endif /* LWIP_NETIF_HOSTNAME */
;;;1233   
;;;1234       LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_REBINDING, msg_out, DHCP_DISCOVER, &options_out_len);
;;;1235       dhcp_option_trailer(options_out_len, msg_out->options, p_out);
00006a  463a              MOV      r2,r7
00006c  4649              MOV      r1,r9
00006e  f8bd0004          LDRH     r0,[sp,#4]
000072  f7fffffe          BL       dhcp_option_trailer
;;;1236   
;;;1237       /* broadcast to server */
;;;1238       result = udp_sendto_if(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif);
000076  4815              LDR      r0,|L23.204|
000078  f8cd8000          STR      r8,[sp,#0]
00007c  1e40              SUBS     r0,r0,#1
00007e  2343              MOVS     r3,#0x43
000080  4a13              LDR      r2,|L23.208|
000082  4639              MOV      r1,r7
000084  68c0              LDR      r0,[r0,#0xc]  ; dhcp_pcb
000086  f7fffffe          BL       udp_sendto_if
00008a  4604              MOV      r4,r0
;;;1239       pbuf_free(p_out);
00008c  4638              MOV      r0,r7
00008e  f7fffffe          BL       pbuf_free
;;;1240       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
;;;1241     } else {
000092  e001              B        |L23.152|
                  |L23.148|
;;;1242       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_rebind: could not allocate DHCP request\n"));
;;;1243       result = ERR_MEM;
000094  f04f34ff          MOV      r4,#0xffffffff
                  |L23.152|
;;;1244     }
;;;1245     if (dhcp->tries < 255) {
000098  79a8              LDRB     r0,[r5,#6]
00009a  28ff              CMP      r0,#0xff
00009c  d201              BCS      |L23.162|
;;;1246       dhcp->tries++;
00009e  1c40              ADDS     r0,r0,#1
0000a0  71a8              STRB     r0,[r5,#6]
                  |L23.162|
;;;1247     }
;;;1248     msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000);
0000a2  79a8              LDRB     r0,[r5,#6]
0000a4  280a              CMP      r0,#0xa
0000a6  d203              BCS      |L23.176|
0000a8  f44f717a          MOV      r1,#0x3e8
0000ac  4348              MULS     r0,r1,r0
0000ae  e001              B        |L23.180|
                  |L23.176|
0000b0  f2427010          MOV      r0,#0x2710
                  |L23.180|
0000b4  b280              UXTH     r0,r0
;;;1249     dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
0000b6  f20010f3          ADD      r0,r0,#0x1f3
0000ba  f44f71fa          MOV      r1,#0x1f4
0000be  fbb0f0f1          UDIV     r0,r0,r1
0000c2  8128              STRH     r0,[r5,#8]
;;;1250     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
;;;1251     return result;
0000c4  4620              MOV      r0,r4
;;;1252   }
0000c6  e8bd87fc          POP      {r2-r10,pc}
;;;1253   
                          ENDP

0000ca  0000              DCW      0x0000
                  |L23.204|
                          DCD      ||.data||+0x1
                  |L23.208|
                          DCD      ip_addr_broadcast

                          AREA ||i.dhcp_reboot||, CODE, READONLY, ALIGN=2

                  dhcp_reboot PROC
;;;1259   static err_t
;;;1260   dhcp_reboot(struct netif *netif)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1261   {
000004  4680              MOV      r8,r0
;;;1262     struct dhcp *dhcp = netif_dhcp_data(netif);
000006  f8d85028          LDR      r5,[r8,#0x28]
;;;1263     err_t result;
;;;1264     u16_t msecs;
;;;1265     u8_t i;
;;;1266     struct pbuf *p_out;
;;;1267     u16_t options_out_len;
;;;1268   
;;;1269     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot()\n"));
;;;1270     dhcp_set_state(dhcp, DHCP_STATE_REBOOTING);
00000a  2103              MOVS     r1,#3
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       dhcp_set_state
;;;1271   
;;;1272     /* create and initialize the DHCP message header */
;;;1273     p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
000012  ab01              ADD      r3,sp,#4
000014  2203              MOVS     r2,#3
000016  4629              MOV      r1,r5
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       dhcp_create_msg
00001e  4607              MOV      r7,r0
;;;1274     if (p_out != NULL) {
000020  0038              MOVS     r0,r7
000022  d047              BEQ      |L24.180|
;;;1275       struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
000024  6879              LDR      r1,[r7,#4]
;;;1276       options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
000026  2302              MOVS     r3,#2
000028  31f0              ADDS     r1,r1,#0xf0
00002a  2239              MOVS     r2,#0x39
00002c  4689              MOV      r9,r1
00002e  f8bd0004          LDRH     r0,[sp,#4]
000032  f7fffffe          BL       dhcp_option
000036  9001              STR      r0,[sp,#4]
;;;1277       options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN_MIN_REQUIRED);
000038  f44f7210          MOV      r2,#0x240
00003c  4649              MOV      r1,r9
00003e  f7fffffe          BL       dhcp_option_short
000042  9001              STR      r0,[sp,#4]
;;;1278   
;;;1279       options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
000044  2304              MOVS     r3,#4
000046  2232              MOVS     r2,#0x32
000048  4649              MOV      r1,r9
00004a  f7fffffe          BL       dhcp_option
00004e  9001              STR      r0,[sp,#4]
;;;1280       options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
000050  69e8              LDR      r0,[r5,#0x1c]
000052  f7fffffe          BL       lwip_htonl
000056  4602              MOV      r2,r0
000058  4649              MOV      r1,r9
00005a  f8bd0004          LDRH     r0,[sp,#4]
00005e  f7fffffe          BL       dhcp_option_long
000062  9001              STR      r0,[sp,#4]
;;;1281   
;;;1282       options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
000064  2304              MOVS     r3,#4
000066  2237              MOVS     r2,#0x37
000068  4649              MOV      r1,r9
00006a  f7fffffe          BL       dhcp_option
00006e  9001              STR      r0,[sp,#4]
;;;1283       for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
000070  2400              MOVS     r4,#0
;;;1284         options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
000072  4e1e              LDR      r6,|L24.236|
                  |L24.116|
000074  4649              MOV      r1,r9
000076  f8bd0004          LDRH     r0,[sp,#4]
00007a  5d32              LDRB     r2,[r6,r4]
00007c  f7fffffe          BL       dhcp_option_byte
000080  9001              STR      r0,[sp,#4]
000082  1c64              ADDS     r4,r4,#1              ;1283
000084  b2e4              UXTB     r4,r4                 ;1283
000086  2c04              CMP      r4,#4                 ;1283
000088  d3f4              BCC      |L24.116|
;;;1285       }
;;;1286   
;;;1287   #if LWIP_NETIF_HOSTNAME
;;;1288       options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
;;;1289   #endif /* LWIP_NETIF_HOSTNAME */
;;;1290   
;;;1291       LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_REBOOTING, msg_out, DHCP_REQUEST, &options_out_len);
;;;1292       dhcp_option_trailer(options_out_len, msg_out->options, p_out);
00008a  463a              MOV      r2,r7
00008c  4649              MOV      r1,r9
00008e  f8bd0004          LDRH     r0,[sp,#4]
000092  f7fffffe          BL       dhcp_option_trailer
;;;1293   
;;;1294       /* broadcast to server */
;;;1295       result = udp_sendto_if(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif);
000096  4815              LDR      r0,|L24.236|
000098  f8cd8000          STR      r8,[sp,#0]
00009c  1e40              SUBS     r0,r0,#1
00009e  2343              MOVS     r3,#0x43
0000a0  4a13              LDR      r2,|L24.240|
0000a2  4639              MOV      r1,r7
0000a4  68c0              LDR      r0,[r0,#0xc]  ; dhcp_pcb
0000a6  f7fffffe          BL       udp_sendto_if
0000aa  4604              MOV      r4,r0
;;;1296       pbuf_free(p_out);
0000ac  4638              MOV      r0,r7
0000ae  f7fffffe          BL       pbuf_free
;;;1297       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot: REBOOTING\n"));
;;;1298     } else {
0000b2  e001              B        |L24.184|
                  |L24.180|
;;;1299       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_reboot: could not allocate DHCP request\n"));
;;;1300       result = ERR_MEM;
0000b4  f04f34ff          MOV      r4,#0xffffffff
                  |L24.184|
;;;1301     }
;;;1302     if (dhcp->tries < 255) {
0000b8  79a8              LDRB     r0,[r5,#6]
0000ba  28ff              CMP      r0,#0xff
0000bc  d201              BCS      |L24.194|
;;;1303       dhcp->tries++;
0000be  1c40              ADDS     r0,r0,#1
0000c0  71a8              STRB     r0,[r5,#6]
                  |L24.194|
;;;1304     }
;;;1305     msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000);
0000c2  79a8              LDRB     r0,[r5,#6]
0000c4  280a              CMP      r0,#0xa
0000c6  d203              BCS      |L24.208|
0000c8  f44f717a          MOV      r1,#0x3e8
0000cc  4348              MULS     r0,r1,r0
0000ce  e001              B        |L24.212|
                  |L24.208|
0000d0  f2427010          MOV      r0,#0x2710
                  |L24.212|
0000d4  b280              UXTH     r0,r0
;;;1306     dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
0000d6  f20010f3          ADD      r0,r0,#0x1f3
0000da  f44f71fa          MOV      r1,#0x1f4
0000de  fbb0f0f1          UDIV     r0,r0,r1
0000e2  8128              STRH     r0,[r5,#8]
;;;1307     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_reboot(): set request timeout %"U16_F" msecs\n", msecs));
;;;1308     return result;
0000e4  4620              MOV      r0,r4
;;;1309   }
0000e6  e8bd87fc          POP      {r2-r10,pc}
;;;1310   
                          ENDP

0000ea  0000              DCW      0x0000
                  |L24.236|
                          DCD      ||.data||+0x1
                  |L24.240|
                          DCD      ip_addr_broadcast

                          AREA ||i.dhcp_recv||, CODE, READONLY, ALIGN=2

                  dhcp_recv PROC
;;;1753   static void
;;;1754   dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1755   {
000004  4616              MOV      r6,r2
;;;1756     struct netif *netif = ip_current_input_netif();
000006  483a              LDR      r0,|L25.240|
000008  6845              LDR      r5,[r0,#4]  ; ip_data
;;;1757     struct dhcp *dhcp = netif_dhcp_data(netif);
00000a  6aac              LDR      r4,[r5,#0x28]
;;;1758     struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
00000c  6871              LDR      r1,[r6,#4]
;;;1759     u8_t msg_type;
;;;1760     u8_t i;
;;;1761     struct dhcp_msg *msg_in;
;;;1762   
;;;1763     LWIP_UNUSED_ARG(arg);
;;;1764   
;;;1765     /* Caught DHCP message from netif that does not have DHCP enabled? -> not interested */
;;;1766     if ((dhcp == NULL) || (dhcp->pcb_allocated == 0)) {
00000e  2c00              CMP      r4,#0
000010  d069              BEQ      |L25.230|
000012  7920              LDRB     r0,[r4,#4]
000014  2800              CMP      r0,#0
000016  d066              BEQ      |L25.230|
;;;1767       goto free_pbuf_and_return;
;;;1768     }
;;;1769   
;;;1770     LWIP_ASSERT("invalid server address type", IP_IS_V4(addr));
;;;1771   
;;;1772     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_recv(pbuf = %p) from DHCP server %"U16_F".%"U16_F".%"U16_F".%"U16_F" port %"U16_F"\n", (void *)p,
;;;1773                 ip4_addr1_16(ip_2_ip4(addr)), ip4_addr2_16(ip_2_ip4(addr)), ip4_addr3_16(ip_2_ip4(addr)), ip4_addr4_16(ip_2_ip4(addr)), port));
;;;1774     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->len = %"U16_F"\n", p->len));
;;;1775     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
;;;1776     /* prevent warnings about unused arguments */
;;;1777     LWIP_UNUSED_ARG(pcb);
;;;1778     LWIP_UNUSED_ARG(addr);
;;;1779     LWIP_UNUSED_ARG(port);
;;;1780   
;;;1781     if (p->len < DHCP_MIN_REPLY_LEN) {
000018  8970              LDRH     r0,[r6,#0xa]
00001a  282c              CMP      r0,#0x2c
00001c  d363              BCC      |L25.230|
;;;1782       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP reply message or pbuf too short\n"));
;;;1783       goto free_pbuf_and_return;
;;;1784     }
;;;1785   
;;;1786     if (reply_msg->op != DHCP_BOOTREPLY) {
00001e  7808              LDRB     r0,[r1,#0]
000020  2802              CMP      r0,#2
000022  d160              BNE      |L25.230|
;;;1787       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
;;;1788       goto free_pbuf_and_return;
;;;1789     }
;;;1790     /* iterate through hardware address and match against DHCP message */
;;;1791     for (i = 0; i < netif->hwaddr_len && i < LWIP_MIN(DHCP_CHADDR_LEN, NETIF_MAX_HWADDR_LEN); i++) {
000024  2000              MOVS     r0,#0
000026  f8952034          LDRB     r2,[r5,#0x34]
00002a  e008              B        |L25.62|
                  |L25.44|
;;;1792       if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
00002c  182b              ADDS     r3,r5,r0
00002e  180f              ADDS     r7,r1,r0
000030  f893302e          LDRB     r3,[r3,#0x2e]
000034  7f3f              LDRB     r7,[r7,#0x1c]
000036  42bb              CMP      r3,r7
000038  d155              BNE      |L25.230|
00003a  1c40              ADDS     r0,r0,#1              ;1791
00003c  b2c0              UXTB     r0,r0                 ;1791
                  |L25.62|
00003e  4282              CMP      r2,r0                 ;1791
000040  d901              BLS      |L25.70|
000042  2806              CMP      r0,#6                 ;1791
000044  d3f2              BCC      |L25.44|
                  |L25.70|
;;;1793         LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;1794                     ("netif->hwaddr[%"U16_F"]==%02"X16_F" != reply_msg->chaddr[%"U16_F"]==%02"X16_F"\n",
;;;1795                      (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
;;;1796         goto free_pbuf_and_return;
;;;1797       }
;;;1798     }
;;;1799     /* match transaction ID against what we expected */
;;;1800     if (lwip_ntohl(reply_msg->xid) != dhcp->xid) {
000046  6848              LDR      r0,[r1,#4]
000048  f7fffffe          BL       lwip_htonl
00004c  6821              LDR      r1,[r4,#0]
00004e  4288              CMP      r0,r1
000050  d149              BNE      |L25.230|
;;;1801       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING,
;;;1802                   ("transaction id mismatch reply_msg->xid(%"X32_F")!=dhcp->xid(%"X32_F")\n", lwip_ntohl(reply_msg->xid), dhcp->xid));
;;;1803       goto free_pbuf_and_return;
;;;1804     }
;;;1805     /* option fields could be unfold? */
;;;1806     if (dhcp_parse_reply(p, dhcp) != ERR_OK) {
000052  4621              MOV      r1,r4
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       dhcp_parse_reply
00005a  bb00              CBNZ     r0,|L25.158|
;;;1807       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS,
;;;1808                   ("problem unfolding DHCP message - too short on memory?\n"));
;;;1809       goto free_pbuf_and_return;
;;;1810     }
;;;1811   
;;;1812     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
;;;1813     /* obtain pointer to DHCP message type */
;;;1814     if (!dhcp_option_given(dhcp, DHCP_OPTION_IDX_MSG_TYPE)) {
00005c  4825              LDR      r0,|L25.244|
00005e  7840              LDRB     r0,[r0,#1]  ; dhcp_rx_options_given
000060  b1e8              CBZ      r0,|L25.158|
;;;1815       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
;;;1816       goto free_pbuf_and_return;
;;;1817     }
;;;1818   
;;;1819     msg_in = (struct dhcp_msg *)p->payload;
000062  6872              LDR      r2,[r6,#4]
;;;1820     /* read DHCP message type */
;;;1821     msg_type = (u8_t)dhcp_get_option_value(dhcp, DHCP_OPTION_IDX_MSG_TYPE);
000064  4823              LDR      r0,|L25.244|
000066  3828              SUBS     r0,r0,#0x28
000068  7900              LDRB     r0,[r0,#4]  ; dhcp_rx_options_val
;;;1822     /* message type is DHCP ACK? */
;;;1823     if (msg_type == DHCP_ACK) {
00006a  2805              CMP      r0,#5
00006c  d002              BEQ      |L25.116|
;;;1824       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_ACK received\n"));
;;;1825       /* in requesting state? */
;;;1826       if (dhcp->state == DHCP_STATE_REQUESTING) {
;;;1827         dhcp_handle_ack(netif, msg_in);
;;;1828   #if DHCP_DOES_ARP_CHECK
;;;1829         if ((netif->flags & NETIF_FLAG_ETHARP) != 0) {
;;;1830           /* check if the acknowledged lease address is already in use */
;;;1831           dhcp_check(netif);
;;;1832         } else {
;;;1833           /* bind interface to the acknowledged lease address */
;;;1834           dhcp_bind(netif);
;;;1835         }
;;;1836   #else
;;;1837         /* bind interface to the acknowledged lease address */
;;;1838         dhcp_bind(netif);
;;;1839   #endif
;;;1840       }
;;;1841       /* already bound to the given lease address? */
;;;1842       else if ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REBINDING) ||
;;;1843                (dhcp->state == DHCP_STATE_RENEWING)) {
;;;1844         dhcp_handle_ack(netif, msg_in);
;;;1845         dhcp_bind(netif);
;;;1846       }
;;;1847     }
;;;1848     /* received a DHCP_NAK in appropriate state? */
;;;1849     else if ((msg_type == DHCP_NAK) &&
00006e  2806              CMP      r0,#6
000070  d022              BEQ      |L25.184|
000072  e02a              B        |L25.202|
                  |L25.116|
000074  7960              LDRB     r0,[r4,#5]            ;1826
000076  2801              CMP      r0,#1                 ;1826
000078  d006              BEQ      |L25.136|
00007a  2803              CMP      r0,#3                 ;1842
00007c  d014              BEQ      |L25.168|
00007e  2804              CMP      r0,#4                 ;1842
000080  d012              BEQ      |L25.168|
000082  2805              CMP      r0,#5                 ;1843
000084  d010              BEQ      |L25.168|
000086  e02e              B        |L25.230|
                  |L25.136|
000088  4611              MOV      r1,r2                 ;1827
00008a  4628              MOV      r0,r5                 ;1827
00008c  f7fffffe          BL       dhcp_handle_ack
000090  f8950035          LDRB     r0,[r5,#0x35]         ;1829
000094  0700              LSLS     r0,r0,#28             ;1829
000096  d503              BPL      |L25.160|
000098  4628              MOV      r0,r5                 ;1831
00009a  f7fffffe          BL       dhcp_check
                  |L25.158|
00009e  e022              B        |L25.230|
                  |L25.160|
0000a0  4628              MOV      r0,r5                 ;1834
0000a2  f7fffffe          BL       dhcp_bind
0000a6  e01e              B        |L25.230|
                  |L25.168|
0000a8  4611              MOV      r1,r2                 ;1844
0000aa  4628              MOV      r0,r5                 ;1844
0000ac  f7fffffe          BL       dhcp_handle_ack
0000b0  4628              MOV      r0,r5                 ;1845
0000b2  f7fffffe          BL       dhcp_bind
0000b6  e016              B        |L25.230|
                  |L25.184|
;;;1850              ((dhcp->state == DHCP_STATE_REBOOTING) || (dhcp->state == DHCP_STATE_REQUESTING) ||
0000b8  7961              LDRB     r1,[r4,#5]
0000ba  2903              CMP      r1,#3
0000bc  d008              BEQ      |L25.208|
0000be  2901              CMP      r1,#1
0000c0  d006              BEQ      |L25.208|
;;;1851               (dhcp->state == DHCP_STATE_REBINDING) || (dhcp->state == DHCP_STATE_RENEWING  ))) {
0000c2  2904              CMP      r1,#4
0000c4  d004              BEQ      |L25.208|
0000c6  2905              CMP      r1,#5
0000c8  d002              BEQ      |L25.208|
                  |L25.202|
;;;1852       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_NAK received\n"));
;;;1853       dhcp_handle_nak(netif);
;;;1854     }
;;;1855     /* received a DHCP_OFFER in DHCP_STATE_SELECTING state? */
;;;1856     else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_STATE_SELECTING)) {
0000ca  2802              CMP      r0,#2
0000cc  d004              BEQ      |L25.216|
0000ce  e00a              B        |L25.230|
                  |L25.208|
0000d0  4628              MOV      r0,r5                 ;1853
0000d2  f7fffffe          BL       dhcp_handle_nak
0000d6  e006              B        |L25.230|
                  |L25.216|
0000d8  7960              LDRB     r0,[r4,#5]
0000da  2806              CMP      r0,#6
0000dc  d103              BNE      |L25.230|
;;;1857       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("DHCP_OFFER received in DHCP_STATE_SELECTING state\n"));
;;;1858       /* remember offered lease */
;;;1859       dhcp_handle_offer(netif, msg_in);
0000de  4611              MOV      r1,r2
0000e0  4628              MOV      r0,r5
0000e2  f7fffffe          BL       dhcp_handle_offer
                  |L25.230|
;;;1860     }
;;;1861   
;;;1862   free_pbuf_and_return:
;;;1863     pbuf_free(p);
0000e6  4630              MOV      r0,r6
0000e8  e8bd41f0          POP      {r4-r8,lr}
0000ec  f7ffbffe          B.W      pbuf_free
;;;1864   }
;;;1865   
                          ENDP

                  |L25.240|
                          DCD      ip_data
                  |L25.244|
                          DCD      ||.bss||+0x28

                          AREA ||i.dhcp_release||, CODE, READONLY, ALIGN=1

                  dhcp_release PROC
;;;1393   err_t
;;;1394   dhcp_release(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;1395   {
;;;1396     dhcp_release_and_stop(netif);
000002  f7fffffe          BL       dhcp_release_and_stop
;;;1397     return ERR_OK;
000006  2000              MOVS     r0,#0
;;;1398   }
000008  bd10              POP      {r4,pc}
;;;1399   
                          ENDP


                          AREA ||i.dhcp_release_and_stop||, CODE, READONLY, ALIGN=2

                  dhcp_release_and_stop PROC
;;;1317   void
;;;1318   dhcp_release_and_stop(struct netif *netif)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;1319   {
000004  4607              MOV      r7,r0
;;;1320     struct dhcp *dhcp = netif_dhcp_data(netif);
000006  6abc              LDR      r4,[r7,#0x28]
;;;1321     ip_addr_t server_ip_addr;
;;;1322   
;;;1323     LWIP_ASSERT_CORE_LOCKED();
;;;1324     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_release_and_stop()\n"));
;;;1325     if (dhcp == NULL) {
000008  2c00              CMP      r4,#0
00000a  d050              BEQ      |L27.174|
;;;1326       return;
;;;1327     }
;;;1328   
;;;1329     /* already off? -> nothing to do */
;;;1330     if (dhcp->state == DHCP_STATE_OFF) {
00000c  7960              LDRB     r0,[r4,#5]
00000e  2800              CMP      r0,#0
000010  d04d              BEQ      |L27.174|
;;;1331       return;
;;;1332     }
;;;1333   
;;;1334     ip_addr_copy(server_ip_addr, dhcp->server_ip_addr);
000012  69a0              LDR      r0,[r4,#0x18]
000014  9002              STR      r0,[sp,#8]
;;;1335   
;;;1336     /* clean old DHCP offer */
;;;1337     ip_addr_set_zero_ip4(&dhcp->server_ip_addr);
000016  2500              MOVS     r5,#0
000018  61a5              STR      r5,[r4,#0x18]
;;;1338     ip4_addr_set_zero(&dhcp->offered_ip_addr);
00001a  61e5              STR      r5,[r4,#0x1c]
;;;1339     ip4_addr_set_zero(&dhcp->offered_sn_mask);
00001c  6225              STR      r5,[r4,#0x20]
;;;1340     ip4_addr_set_zero(&dhcp->offered_gw_addr);
00001e  6265              STR      r5,[r4,#0x24]
;;;1341   #if LWIP_DHCP_BOOTP_FILE
;;;1342     ip4_addr_set_zero(&dhcp->offered_si_addr);
;;;1343   #endif /* LWIP_DHCP_BOOTP_FILE */
;;;1344     dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
000020  6325              STR      r5,[r4,#0x30]
000022  62e5              STR      r5,[r4,#0x2c]
000024  62a5              STR      r5,[r4,#0x28]
;;;1345     dhcp->t1_renew_time = dhcp->t2_rebind_time = dhcp->lease_used = dhcp->t0_timeout = 0;
000026  82a5              STRH     r5,[r4,#0x14]
000028  8265              STRH     r5,[r4,#0x12]
00002a  8225              STRH     r5,[r4,#0x10]
00002c  81e5              STRH     r5,[r4,#0xe]
;;;1346   
;;;1347     /* send release message when current IP was assigned via DHCP */
;;;1348     if (dhcp_supplied_address(netif)) {
00002e  4638              MOV      r0,r7
000030  f7fffffe          BL       dhcp_supplied_address
000034  b358              CBZ      r0,|L27.142|
;;;1349       /* create and initialize the DHCP message header */
;;;1350       struct pbuf *p_out;
;;;1351       u16_t options_out_len;
;;;1352       p_out = dhcp_create_msg(netif, dhcp, DHCP_RELEASE, &options_out_len);
000036  ab01              ADD      r3,sp,#4
000038  2207              MOVS     r2,#7
00003a  4621              MOV      r1,r4
00003c  4638              MOV      r0,r7
00003e  f7fffffe          BL       dhcp_create_msg
000042  4606              MOV      r6,r0
;;;1353       if (p_out != NULL) {
000044  0030              MOVS     r0,r6
000046  d022              BEQ      |L27.142|
;;;1354         struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
000048  6871              LDR      r1,[r6,#4]
;;;1355         options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_SERVER_ID, 4);
00004a  2304              MOVS     r3,#4
00004c  31f0              ADDS     r1,r1,#0xf0
00004e  2236              MOVS     r2,#0x36
000050  4688              MOV      r8,r1
000052  f8bd0004          LDRH     r0,[sp,#4]
000056  f7fffffe          BL       dhcp_option
00005a  9001              STR      r0,[sp,#4]
;;;1356         options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&server_ip_addr))));
00005c  9802              LDR      r0,[sp,#8]
00005e  f7fffffe          BL       lwip_htonl
000062  4602              MOV      r2,r0
000064  4641              MOV      r1,r8
000066  f8bd0004          LDRH     r0,[sp,#4]
00006a  f7fffffe          BL       dhcp_option_long
00006e  9001              STR      r0,[sp,#4]
;;;1357   
;;;1358         LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, dhcp->state, msg_out, DHCP_RELEASE, &options_out_len);
;;;1359         dhcp_option_trailer(options_out_len, msg_out->options, p_out);
000070  4632              MOV      r2,r6
000072  4641              MOV      r1,r8
000074  f7fffffe          BL       dhcp_option_trailer
;;;1360   
;;;1361         udp_sendto_if(dhcp_pcb, p_out, &server_ip_addr, LWIP_IANA_PORT_DHCP_SERVER, netif);
000078  480e              LDR      r0,|L27.180|
00007a  9700              STR      r7,[sp,#0]
00007c  2343              MOVS     r3,#0x43
00007e  aa02              ADD      r2,sp,#8
000080  4631              MOV      r1,r6
000082  68c0              LDR      r0,[r0,#0xc]  ; dhcp_pcb
000084  f7fffffe          BL       udp_sendto_if
;;;1362         pbuf_free(p_out);
000088  4630              MOV      r0,r6
00008a  f7fffffe          BL       pbuf_free
                  |L27.142|
;;;1363         LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_STATE_OFF\n"));
;;;1364       } else {
;;;1365         /* sending release failed, but that's not a problem since the correct behaviour of dhcp does not rely on release */
;;;1366         LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_release: could not allocate DHCP request\n"));
;;;1367       }
;;;1368     }
;;;1369   
;;;1370     /* remove IP address from interface (prevents routing from selecting this interface) */
;;;1371     netif_set_addr(netif, IP4_ADDR_ANY4, IP4_ADDR_ANY4, IP4_ADDR_ANY4);
00008e  4b0a              LDR      r3,|L27.184|
000090  4638              MOV      r0,r7
000092  461a              MOV      r2,r3
000094  4611              MOV      r1,r2
000096  f7fffffe          BL       netif_set_addr
;;;1372   
;;;1373   #if LWIP_DHCP_AUTOIP_COOP
;;;1374     if (dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_ON) {
;;;1375       autoip_stop(netif);
;;;1376       dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_OFF;
;;;1377     }
;;;1378   #endif /* LWIP_DHCP_AUTOIP_COOP */
;;;1379   
;;;1380     dhcp_set_state(dhcp, DHCP_STATE_OFF);
00009a  2100              MOVS     r1,#0
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       dhcp_set_state
;;;1381   
;;;1382     if (dhcp->pcb_allocated != 0) {
0000a2  7920              LDRB     r0,[r4,#4]
0000a4  2800              CMP      r0,#0
0000a6  d002              BEQ      |L27.174|
;;;1383       dhcp_dec_pcb_refcount(); /* free DHCP PCB if not needed any more */
0000a8  f7fffffe          BL       dhcp_dec_pcb_refcount
;;;1384       dhcp->pcb_allocated = 0;
0000ac  7125              STRB     r5,[r4,#4]
                  |L27.174|
;;;1385     }
;;;1386   }
0000ae  e8bd83fe          POP      {r1-r9,pc}
;;;1387   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L27.180|
                          DCD      ||.data||
                  |L27.184|
                          DCD      ip_addr_any

                          AREA ||i.dhcp_renew||, CODE, READONLY, ALIGN=2

                  dhcp_renew PROC
;;;1149   err_t
;;;1150   dhcp_renew(struct netif *netif)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;1151   {
000004  4680              MOV      r8,r0
;;;1152     struct dhcp *dhcp = netif_dhcp_data(netif);
000006  f8d85028          LDR      r5,[r8,#0x28]
;;;1153     err_t result;
;;;1154     u16_t msecs;
;;;1155     u8_t i;
;;;1156     struct pbuf *p_out;
;;;1157     u16_t options_out_len;
;;;1158   
;;;1159     LWIP_ASSERT_CORE_LOCKED();
;;;1160     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_renew()\n"));
;;;1161     dhcp_set_state(dhcp, DHCP_STATE_RENEWING);
00000a  2105              MOVS     r1,#5
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       dhcp_set_state
;;;1162   
;;;1163     /* create and initialize the DHCP message header */
;;;1164     p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
000012  ab01              ADD      r3,sp,#4
000014  2203              MOVS     r2,#3
000016  4629              MOV      r1,r5
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       dhcp_create_msg
00001e  4607              MOV      r7,r0
;;;1165     if (p_out != NULL) {
000020  0038              MOVS     r0,r7
000022  d038              BEQ      |L28.150|
;;;1166       struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
000024  6879              LDR      r1,[r7,#4]
;;;1167       options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
000026  2302              MOVS     r3,#2
000028  31f0              ADDS     r1,r1,#0xf0
00002a  2239              MOVS     r2,#0x39
00002c  4689              MOV      r9,r1
00002e  f8bd0004          LDRH     r0,[sp,#4]
000032  f7fffffe          BL       dhcp_option
000036  9001              STR      r0,[sp,#4]
;;;1168       options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
000038  f8b8202c          LDRH     r2,[r8,#0x2c]
00003c  4649              MOV      r1,r9
00003e  f7fffffe          BL       dhcp_option_short
000042  9001              STR      r0,[sp,#4]
;;;1169   
;;;1170       options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
000044  2304              MOVS     r3,#4
000046  2237              MOVS     r2,#0x37
000048  4649              MOV      r1,r9
00004a  f7fffffe          BL       dhcp_option
00004e  9001              STR      r0,[sp,#4]
;;;1171       for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
000050  2400              MOVS     r4,#0
;;;1172         options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
000052  4e1e              LDR      r6,|L28.204|
                  |L28.84|
000054  4649              MOV      r1,r9
000056  f8bd0004          LDRH     r0,[sp,#4]
00005a  5d32              LDRB     r2,[r6,r4]
00005c  f7fffffe          BL       dhcp_option_byte
000060  9001              STR      r0,[sp,#4]
000062  1c64              ADDS     r4,r4,#1              ;1171
000064  b2e4              UXTB     r4,r4                 ;1171
000066  2c04              CMP      r4,#4                 ;1171
000068  d3f4              BCC      |L28.84|
;;;1173       }
;;;1174   
;;;1175   #if LWIP_NETIF_HOSTNAME
;;;1176       options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
;;;1177   #endif /* LWIP_NETIF_HOSTNAME */
;;;1178   
;;;1179       LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_RENEWING, msg_out, DHCP_REQUEST, &options_out_len);
;;;1180       dhcp_option_trailer(options_out_len, msg_out->options, p_out);
00006a  463a              MOV      r2,r7
00006c  4649              MOV      r1,r9
00006e  f8bd0004          LDRH     r0,[sp,#4]
000072  f7fffffe          BL       dhcp_option_trailer
;;;1181   
;;;1182       result = udp_sendto_if(dhcp_pcb, p_out, &dhcp->server_ip_addr, LWIP_IANA_PORT_DHCP_SERVER, netif);
000076  4815              LDR      r0,|L28.204|
000078  f8cd8000          STR      r8,[sp,#0]
00007c  1e40              SUBS     r0,r0,#1
00007e  2343              MOVS     r3,#0x43
000080  f1050218          ADD      r2,r5,#0x18
000084  4639              MOV      r1,r7
000086  68c0              LDR      r0,[r0,#0xc]  ; dhcp_pcb
000088  f7fffffe          BL       udp_sendto_if
00008c  4604              MOV      r4,r0
;;;1183       pbuf_free(p_out);
00008e  4638              MOV      r0,r7
000090  f7fffffe          BL       pbuf_free
;;;1184   
;;;1185       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
;;;1186     } else {
000094  e001              B        |L28.154|
                  |L28.150|
;;;1187       LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_SERIOUS, ("dhcp_renew: could not allocate DHCP request\n"));
;;;1188       result = ERR_MEM;
000096  f04f34ff          MOV      r4,#0xffffffff
                  |L28.154|
;;;1189     }
;;;1190     if (dhcp->tries < 255) {
00009a  79a8              LDRB     r0,[r5,#6]
00009c  28ff              CMP      r0,#0xff
00009e  d201              BCS      |L28.164|
;;;1191       dhcp->tries++;
0000a0  1c40              ADDS     r0,r0,#1
0000a2  71a8              STRB     r0,[r5,#6]
                  |L28.164|
;;;1192     }
;;;1193     /* back-off on retries, but to a maximum of 20 seconds */
;;;1194     msecs = (u16_t)(dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000);
0000a4  79a8              LDRB     r0,[r5,#6]
0000a6  280a              CMP      r0,#0xa
0000a8  d203              BCS      |L28.178|
0000aa  f44f61fa          MOV      r1,#0x7d0
0000ae  4348              MULS     r0,r1,r0
0000b0  e001              B        |L28.182|
                  |L28.178|
0000b2  f6446020          MOV      r0,#0x4e20
                  |L28.182|
0000b6  b280              UXTH     r0,r0
;;;1195     dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
0000b8  f20010f3          ADD      r0,r0,#0x1f3
0000bc  f44f71fa          MOV      r1,#0x1f4
0000c0  fbb0f0f1          UDIV     r0,r0,r1
0000c4  8128              STRH     r0,[r5,#8]
;;;1196     LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
;;;1197     return result;
0000c6  4620              MOV      r0,r4
;;;1198   }
0000c8  e8bd87fc          POP      {r2-r10,pc}
;;;1199   
                          ENDP

                  |L28.204|
                          DCD      ||.data||+0x1

                          AREA ||i.dhcp_select||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  dhcp_select PROC
;;;365    static err_t
;;;366    dhcp_select(struct netif *netif)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;367    {
000004  4606              MOV      r6,r0
;;;368      struct dhcp *dhcp;
;;;369      err_t result;
;;;370      u16_t msecs;
;;;371      u8_t i;
;;;372      struct pbuf *p_out;
;;;373      u16_t options_out_len;
;;;374    
;;;375      LWIP_ERROR("dhcp_select: netif != NULL", (netif != NULL), return ERR_ARG;);
000006  2e00              CMP      r6,#0
000008  d069              BEQ      |L29.222|
;;;376      dhcp = netif_dhcp_data(netif);
00000a  6ab5              LDR      r5,[r6,#0x28]
;;;377      LWIP_ERROR("dhcp_select: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
00000c  2d00              CMP      r5,#0
00000e  d073              BEQ      |L29.248|
;;;378    
;;;379      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
;;;380      dhcp_set_state(dhcp, DHCP_STATE_REQUESTING);
000010  2101              MOVS     r1,#1
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       dhcp_set_state
;;;381    
;;;382      /* create and initialize the DHCP message header */
;;;383      p_out = dhcp_create_msg(netif, dhcp, DHCP_REQUEST, &options_out_len);
000018  ab02              ADD      r3,sp,#8
00001a  2203              MOVS     r2,#3
00001c  4629              MOV      r1,r5
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       dhcp_create_msg
000024  4680              MOV      r8,r0
;;;384      if (p_out != NULL) {
000026  ea5f0008          MOVS     r0,r8
00002a  d070              BEQ      |L29.270|
;;;385        struct dhcp_msg *msg_out = (struct dhcp_msg *)p_out->payload;
00002c  f8d81004          LDR      r1,[r8,#4]
;;;386        options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
000030  2302              MOVS     r3,#2
000032  31f0              ADDS     r1,r1,#0xf0
000034  2239              MOVS     r2,#0x39
000036  4689              MOV      r9,r1
000038  f8bd0008          LDRH     r0,[sp,#8]
00003c  f7fffffe          BL       dhcp_option
000040  9002              STR      r0,[sp,#8]
;;;387        options_out_len = dhcp_option_short(options_out_len, msg_out->options, DHCP_MAX_MSG_LEN(netif));
000042  8db2              LDRH     r2,[r6,#0x2c]
000044  4649              MOV      r1,r9
000046  f7fffffe          BL       dhcp_option_short
00004a  9002              STR      r0,[sp,#8]
;;;388    
;;;389        /* MUST request the offered IP address */
;;;390        options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_REQUESTED_IP, 4);
00004c  2304              MOVS     r3,#4
00004e  2232              MOVS     r2,#0x32
000050  4649              MOV      r1,r9
000052  f7fffffe          BL       dhcp_option
000056  9002              STR      r0,[sp,#8]
;;;391        options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(&dhcp->offered_ip_addr)));
000058  69e8              LDR      r0,[r5,#0x1c]
00005a  f7fffffe          BL       lwip_htonl
00005e  4602              MOV      r2,r0
000060  4649              MOV      r1,r9
000062  f8bd0008          LDRH     r0,[sp,#8]
000066  f7fffffe          BL       dhcp_option_long
00006a  9002              STR      r0,[sp,#8]
;;;392    
;;;393        options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_SERVER_ID, 4);
00006c  2304              MOVS     r3,#4
00006e  2236              MOVS     r2,#0x36
000070  4649              MOV      r1,r9
000072  f7fffffe          BL       dhcp_option
000076  9002              STR      r0,[sp,#8]
;;;394        options_out_len = dhcp_option_long(options_out_len, msg_out->options, lwip_ntohl(ip4_addr_get_u32(ip_2_ip4(&dhcp->server_ip_addr))));
000078  69a8              LDR      r0,[r5,#0x18]
00007a  f7fffffe          BL       lwip_htonl
00007e  4602              MOV      r2,r0
000080  4649              MOV      r1,r9
000082  f8bd0008          LDRH     r0,[sp,#8]
000086  f7fffffe          BL       dhcp_option_long
00008a  9002              STR      r0,[sp,#8]
;;;395    
;;;396        options_out_len = dhcp_option(options_out_len, msg_out->options, DHCP_OPTION_PARAMETER_REQUEST_LIST, LWIP_ARRAYSIZE(dhcp_discover_request_options));
00008c  2304              MOVS     r3,#4
00008e  2237              MOVS     r2,#0x37
000090  4649              MOV      r1,r9
000092  f7fffffe          BL       dhcp_option
000096  9002              STR      r0,[sp,#8]
;;;397        for (i = 0; i < LWIP_ARRAYSIZE(dhcp_discover_request_options); i++) {
000098  2400              MOVS     r4,#0
;;;398          options_out_len = dhcp_option_byte(options_out_len, msg_out->options, dhcp_discover_request_options[i]);
00009a  4f2c              LDR      r7,|L29.332|
                  |L29.156|
00009c  4649              MOV      r1,r9
00009e  f8bd0008          LDRH     r0,[sp,#8]
0000a2  5d3a              LDRB     r2,[r7,r4]
0000a4  f7fffffe          BL       dhcp_option_byte
0000a8  9002              STR      r0,[sp,#8]
0000aa  1c64              ADDS     r4,r4,#1              ;397
0000ac  b2e4              UXTB     r4,r4                 ;397
0000ae  2c04              CMP      r4,#4                 ;397
0000b0  d3f4              BCC      |L29.156|
;;;399        }
;;;400    
;;;401    #if LWIP_NETIF_HOSTNAME
;;;402        options_out_len = dhcp_option_hostname(options_out_len, msg_out->options, netif);
;;;403    #endif /* LWIP_NETIF_HOSTNAME */
;;;404    
;;;405        LWIP_HOOK_DHCP_APPEND_OPTIONS(netif, dhcp, DHCP_STATE_REQUESTING, msg_out, DHCP_REQUEST, &options_out_len);
;;;406        dhcp_option_trailer(options_out_len, msg_out->options, p_out);
0000b2  4642              MOV      r2,r8
0000b4  4649              MOV      r1,r9
0000b6  f8bd0008          LDRH     r0,[sp,#8]
0000ba  f7fffffe          BL       dhcp_option_trailer
;;;407    
;;;408        /* send broadcast to any DHCP server */
;;;409        result = udp_sendto_if_src(dhcp_pcb, p_out, IP_ADDR_BROADCAST, LWIP_IANA_PORT_DHCP_SERVER, netif, IP4_ADDR_ANY);
0000be  4824              LDR      r0,|L29.336|
0000c0  2343              MOVS     r3,#0x43
0000c2  e9cd6000          STRD     r6,r0,[sp,#0]
0000c6  4821              LDR      r0,|L29.332|
0000c8  4a22              LDR      r2,|L29.340|
0000ca  1e40              SUBS     r0,r0,#1
0000cc  4641              MOV      r1,r8
0000ce  68c0              LDR      r0,[r0,#0xc]  ; dhcp_pcb
0000d0  f7fffffe          BL       udp_sendto_if_src
0000d4  4604              MOV      r4,r0
;;;410        pbuf_free(p_out);
0000d6  4640              MOV      r0,r8
0000d8  f7fffffe          BL       pbuf_free
;;;411        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
;;;412      } else {
0000dc  e019              B        |L29.274|
                  |L29.222|
0000de  a31e              ADR      r3,|L29.344|
0000e0  f2401277          MOV      r2,#0x177             ;375
0000e4  a12a              ADR      r1,|L29.400|
0000e6  e000              B        |L29.234|
0000e8  e006              B        |L29.248|
                  |L29.234|
0000ea  a030              ADR      r0,|L29.428|
0000ec  f7fffffe          BL       __2printf
0000f0  f06f000f          MVN      r0,#0xf               ;375
                  |L29.244|
;;;413        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_LEVEL_WARNING, ("dhcp_select: could not allocate DHCP request\n"));
;;;414        result = ERR_MEM;
;;;415      }
;;;416      if (dhcp->tries < 255) {
;;;417        dhcp->tries++;
;;;418      }
;;;419      msecs = (u16_t)((dhcp->tries < 6 ? 1 << dhcp->tries : 60) * 1000);
;;;420      dhcp->request_timeout = (u16_t)((msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS);
;;;421      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
;;;422      return result;
;;;423    }
0000f4  e8bd83fe          POP      {r1-r9,pc}
                  |L29.248|
0000f8  a317              ADR      r3,|L29.344|
0000fa  f2401279          MOV      r2,#0x179             ;377
0000fe  a135              ADR      r1,|L29.468|
000100  a02a              ADR      r0,|L29.428|
000102  f7fffffe          BL       __2printf
000106  f06f0005          MVN      r0,#5                 ;377
00010a  e7f3              B        |L29.244|
00010c  e7ff              B        |L29.270|
                  |L29.270|
00010e  f04f34ff          MOV      r4,#0xffffffff        ;414
                  |L29.274|
000112  79a8              LDRB     r0,[r5,#6]            ;416
000114  28ff              CMP      r0,#0xff              ;416
000116  d201              BCS      |L29.284|
000118  1c40              ADDS     r0,r0,#1              ;417
00011a  71a8              STRB     r0,[r5,#6]            ;417
                  |L29.284|
00011c  79a9              LDRB     r1,[r5,#6]            ;419
00011e  2906              CMP      r1,#6                 ;419
000120  d202              BCS      |L29.296|
000122  2001              MOVS     r0,#1                 ;419
000124  4088              LSLS     r0,r0,r1              ;419
000126  e000              B        |L29.298|
                  |L29.296|
000128  203c              MOVS     r0,#0x3c              ;419
                  |L29.298|
00012a  eb000140          ADD      r1,r0,r0,LSL #1       ;419
00012e  ebc110c0          RSB      r0,r1,r0,LSL #7       ;419
000132  f64f71ff          MOV      r1,#0xffff            ;419
000136  ea0100c0          AND      r0,r1,r0,LSL #3       ;419
00013a  f20010f3          ADD      r0,r0,#0x1f3          ;420
00013e  f44f71fa          MOV      r1,#0x1f4             ;420
000142  fbb0f0f1          UDIV     r0,r0,r1              ;420
000146  8128              STRH     r0,[r5,#8]            ;420
000148  4620              MOV      r0,r4                 ;422
00014a  e7d3              B        |L29.244|
;;;424    
                          ENDP

                  |L29.332|
                          DCD      ||.data||+0x1
                  |L29.336|
                          DCD      ip_addr_any
                  |L29.340|
                          DCD      ip_addr_broadcast
                  |L29.344|
000158  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
00015c  6964646c
000160  65776172
000164  65735c54
000168  68697264
00016c  5f506172
000170  74795c4c
000174  7749505c
000178  7372635c
00017c  636f7265
000180  5c697076
000184  345c6468
000188  63702e63          DCB      "cp.c",0
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L29.400|
000190  64686370          DCB      "dhcp_select: netif != NULL",0
000194  5f73656c
000198  6563743a
00019c  206e6574
0001a0  69662021
0001a4  3d204e55
0001a8  4c4c00  
0001ab  00                DCB      0
                  |L29.428|
0001ac  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001b0  7274696f
0001b4  6e202225
0001b8  73222066
0001bc  61696c65
0001c0  64206174
0001c4  206c696e
0001c8  65202564
0001cc  20696e20
0001d0  25730a00
                  |L29.468|
0001d4  64686370          DCB      "dhcp_select: dhcp != NULL",0
0001d8  5f73656c
0001dc  6563743a
0001e0  20646863
0001e4  7020213d
0001e8  204e554c
0001ec  4c00    
0001ee  00                DCB      0
0001ef  00                DCB      0

                          AREA ||i.dhcp_set_state||, CODE, READONLY, ALIGN=1

                  dhcp_set_state PROC
;;;1416   static void
;;;1417   dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
000000  7942              LDRB     r2,[r0,#5]
;;;1418   {
;;;1419     if (new_state != dhcp->state) {
000002  428a              CMP      r2,r1
000004  d003              BEQ      |L30.14|
;;;1420       dhcp->state = new_state;
000006  7141              STRB     r1,[r0,#5]
;;;1421       dhcp->tries = 0;
000008  2100              MOVS     r1,#0
00000a  7181              STRB     r1,[r0,#6]
;;;1422       dhcp->request_timeout = 0;
00000c  8101              STRH     r1,[r0,#8]
                  |L30.14|
;;;1423     }
;;;1424   }
00000e  4770              BX       lr
;;;1425   
                          ENDP


                          AREA ||i.dhcp_set_struct||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  dhcp_set_struct PROC
;;;689    void
;;;690    dhcp_set_struct(struct netif *netif, struct dhcp *dhcp)
000000  b570              PUSH     {r4-r6,lr}
;;;691    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;692      LWIP_ASSERT_CORE_LOCKED();
;;;693      LWIP_ASSERT("netif != NULL", netif != NULL);
000006  2c00              CMP      r4,#0
000008  d106              BNE      |L31.24|
00000a  a30f              ADR      r3,|L31.72|
00000c  f24022b5          MOV      r2,#0x2b5
000010  a11b              ADR      r1,|L31.128|
000012  a01f              ADR      r0,|L31.144|
000014  f7fffffe          BL       __2printf
                  |L31.24|
;;;694      LWIP_ASSERT("dhcp != NULL", dhcp != NULL);
000018  b935              CBNZ     r5,|L31.40|
00001a  a30b              ADR      r3,|L31.72|
00001c  f24022b6          MOV      r2,#0x2b6
000020  a125              ADR      r1,|L31.184|
000022  a01b              ADR      r0,|L31.144|
000024  f7fffffe          BL       __2printf
                  |L31.40|
;;;695      LWIP_ASSERT("netif already has a struct dhcp set", netif_dhcp_data(netif) == NULL);
000028  6aa0              LDR      r0,[r4,#0x28]
00002a  2800              CMP      r0,#0
00002c  d006              BEQ      |L31.60|
00002e  a306              ADR      r3,|L31.72|
000030  f24022b7          MOV      r2,#0x2b7
000034  a124              ADR      r1,|L31.200|
000036  a016              ADR      r0,|L31.144|
000038  f7fffffe          BL       __2printf
                  |L31.60|
;;;696    
;;;697      /* clear data structure */
;;;698      memset(dhcp, 0, sizeof(struct dhcp));
00003c  2134              MOVS     r1,#0x34
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       __aeabi_memclr4
;;;699      /* dhcp_set_state(&dhcp, DHCP_STATE_OFF); */
;;;700      netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, dhcp);
000044  62a5              STR      r5,[r4,#0x28]
;;;701    }
000046  bd70              POP      {r4-r6,pc}
;;;702    
                          ENDP

                  |L31.72|
000048  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
00004c  6964646c
000050  65776172
000054  65735c54
000058  68697264
00005c  5f506172
000060  74795c4c
000064  7749505c
000068  7372635c
00006c  636f7265
000070  5c697076
000074  345c6468
000078  63702e63          DCB      "cp.c",0
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0
                  |L31.128|
000080  6e657469          DCB      "netif != NULL",0
000084  6620213d
000088  204e554c
00008c  4c00    
00008e  00                DCB      0
00008f  00                DCB      0
                  |L31.144|
000090  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000094  7274696f
000098  6e202225
00009c  73222066
0000a0  61696c65
0000a4  64206174
0000a8  206c696e
0000ac  65202564
0000b0  20696e20
0000b4  25730a00
                  |L31.184|
0000b8  64686370          DCB      "dhcp != NULL",0
0000bc  20213d20
0000c0  4e554c4c
0000c4  00      
0000c5  00                DCB      0
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L31.200|
0000c8  6e657469          DCB      "netif already has a struct dhcp set",0
0000cc  6620616c
0000d0  72656164
0000d4  79206861
0000d8  73206120
0000dc  73747275
0000e0  63742064
0000e4  68637020
0000e8  73657400

                          AREA ||i.dhcp_start||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  dhcp_start PROC
;;;736    err_t
;;;737    dhcp_start(struct netif *netif)
000000  b570              PUSH     {r4-r6,lr}
;;;738    {
000002  4605              MOV      r5,r0
;;;739      struct dhcp *dhcp;
;;;740      err_t result;
;;;741    
;;;742      LWIP_ASSERT_CORE_LOCKED();
;;;743      LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
000004  f06f040f          MVN      r4,#0xf
000008  2d00              CMP      r5,#0
00000a  d00c              BEQ      |L32.38|
;;;744      LWIP_ERROR("netif is not up, old style port?", netif_is_up(netif), return ERR_ARG;);
00000c  f8950035          LDRB     r0,[r5,#0x35]
000010  07c0              LSLS     r0,r0,#31
000012  d011              BEQ      |L32.56|
;;;745      dhcp = netif_dhcp_data(netif);
000014  6aac              LDR      r4,[r5,#0x28]
;;;746      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void *)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
;;;747    
;;;748      /* check MTU of the netif */
;;;749      if (netif->mtu < DHCP_MAX_MSG_LEN_MIN_REQUIRED) {
000016  8da8              LDRH     r0,[r5,#0x2c]
;;;750        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): Cannot use this netif with DHCP: MTU is too small\n"));
;;;751        return ERR_MEM;
000018  f04f36ff          MOV      r6,#0xffffffff
00001c  f5b07f10          CMP      r0,#0x240             ;749
000020  d213              BCS      |L32.74|
000022  4630              MOV      r0,r6
;;;752      }
;;;753    
;;;754      /* no DHCP client attached yet? */
;;;755      if (dhcp == NULL) {
;;;756        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): mallocing new DHCP client\n"));
;;;757        dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
;;;758        if (dhcp == NULL) {
;;;759          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
;;;760          return ERR_MEM;
;;;761        }
;;;762    
;;;763        /* store this dhcp client in the netif */
;;;764        netif_set_client_data(netif, LWIP_NETIF_CLIENT_DATA_INDEX_DHCP, dhcp);
;;;765        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): allocated dhcp"));
;;;766        /* already has DHCP client attached */
;;;767      } else {
;;;768        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(): restarting DHCP configuration\n"));
;;;769    
;;;770        if (dhcp->pcb_allocated != 0) {
;;;771          dhcp_dec_pcb_refcount(); /* free DHCP PCB if not needed any more */
;;;772        }
;;;773        /* dhcp is cleared below, no need to reset flag*/
;;;774      }
;;;775    
;;;776      /* clear data structure */
;;;777      memset(dhcp, 0, sizeof(struct dhcp));
;;;778      /* dhcp_set_state(&dhcp, DHCP_STATE_OFF); */
;;;779    
;;;780      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
;;;781    
;;;782      if (dhcp_inc_pcb_refcount() != ERR_OK) { /* ensure DHCP PCB is allocated */
;;;783        return ERR_MEM;
;;;784      }
;;;785      dhcp->pcb_allocated = 1;
;;;786    
;;;787      if (!netif_is_link_up(netif)) {
;;;788        /* set state INIT and wait for dhcp_network_changed() to call dhcp_discover() */
;;;789        dhcp_set_state(dhcp, DHCP_STATE_INIT);
;;;790        return ERR_OK;
;;;791      }
;;;792    
;;;793      /* (re)start the DHCP negotiation */
;;;794      result = dhcp_discover(netif);
;;;795      if (result != ERR_OK) {
;;;796        /* free resources allocated above */
;;;797        dhcp_release_and_stop(netif);
;;;798        return ERR_MEM;
;;;799      }
;;;800      return result;
;;;801    }
000024  bd70              POP      {r4-r6,pc}
                  |L32.38|
000026  a31f              ADR      r3,|L32.164|
000028  f24022e7          MOV      r2,#0x2e7             ;743
00002c  a12b              ADR      r1,|L32.220|
00002e  a02f              ADR      r0,|L32.236|
000030  f7fffffe          BL       __2printf
000034  4620              MOV      r0,r4                 ;743
000036  bd70              POP      {r4-r6,pc}
                  |L32.56|
000038  a31a              ADR      r3,|L32.164|
00003a  f44f723a          MOV      r2,#0x2e8             ;744
00003e  a135              ADR      r1,|L32.276|
000040  a02a              ADR      r0,|L32.236|
000042  f7fffffe          BL       __2printf
000046  4620              MOV      r0,r4                 ;744
000048  bd70              POP      {r4-r6,pc}
                  |L32.74|
00004a  b164              CBZ      r4,|L32.102|
00004c  7920              LDRB     r0,[r4,#4]            ;770
00004e  b108              CBZ      r0,|L32.84|
000050  f7fffffe          BL       dhcp_dec_pcb_refcount
                  |L32.84|
000054  2134              MOVS     r1,#0x34              ;777
000056  4620              MOV      r0,r4                 ;777
000058  f7fffffe          BL       __aeabi_memclr4
00005c  f7fffffe          BL       dhcp_inc_pcb_refcount
000060  b150              CBZ      r0,|L32.120|
000062  4630              MOV      r0,r6                 ;783
000064  bd70              POP      {r4-r6,pc}
                  |L32.102|
000066  2034              MOVS     r0,#0x34              ;757
000068  f7fffffe          BL       mem_malloc
00006c  4604              MOV      r4,r0                 ;757
00006e  b10c              CBZ      r4,|L32.116|
000070  62ac              STR      r4,[r5,#0x28]         ;764
000072  e7ef              B        |L32.84|
                  |L32.116|
000074  4630              MOV      r0,r6                 ;760
000076  bd70              POP      {r4-r6,pc}
                  |L32.120|
000078  2001              MOVS     r0,#1                 ;785
00007a  7120              STRB     r0,[r4,#4]            ;785
00007c  f8950035          LDRB     r0,[r5,#0x35]         ;787
000080  0740              LSLS     r0,r0,#29             ;787
000082  d405              BMI      |L32.144|
000084  2102              MOVS     r1,#2                 ;789
000086  4620              MOV      r0,r4                 ;789
000088  f7fffffe          BL       dhcp_set_state
00008c  2000              MOVS     r0,#0                 ;790
                  |L32.142|
00008e  bd70              POP      {r4-r6,pc}
                  |L32.144|
000090  4628              MOV      r0,r5                 ;794
000092  f7fffffe          BL       dhcp_discover
000096  2800              CMP      r0,#0                 ;795
000098  d0f9              BEQ      |L32.142|
00009a  4628              MOV      r0,r5                 ;797
00009c  f7fffffe          BL       dhcp_release_and_stop
0000a0  4630              MOV      r0,r6                 ;798
0000a2  bd70              POP      {r4-r6,pc}
;;;802    
                          ENDP

                  |L32.164|
0000a4  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dh"
0000a8  6964646c
0000ac  65776172
0000b0  65735c54
0000b4  68697264
0000b8  5f506172
0000bc  74795c4c
0000c0  7749505c
0000c4  7372635c
0000c8  636f7265
0000cc  5c697076
0000d0  345c6468
0000d4  63702e63          DCB      "cp.c",0
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L32.220|
0000dc  6e657469          DCB      "netif != NULL",0
0000e0  6620213d
0000e4  204e554c
0000e8  4c00    
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L32.236|
0000ec  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000f0  7274696f
0000f4  6e202225
0000f8  73222066
0000fc  61696c65
000100  64206174
000104  206c696e
000108  65202564
00010c  20696e20
000110  25730a00
                  |L32.276|
000114  6e657469          DCB      "netif is not up, old style port?",0
000118  66206973
00011c  206e6f74
000120  2075702c
000124  206f6c64
000128  20737479
00012c  6c652070
000130  6f72743f
000134  00      
000135  00                DCB      0
000136  00                DCB      0
000137  00                DCB      0

                          AREA ||i.dhcp_stop||, CODE, READONLY, ALIGN=1

                  dhcp_stop PROC
;;;1405   void
;;;1406   dhcp_stop(struct netif *netif)
000000  f7ffbffe          B.W      dhcp_release_and_stop
;;;1407   {
;;;1408     dhcp_release_and_stop(netif);
;;;1409   }
;;;1410   
                          ENDP


                          AREA ||i.dhcp_supplied_address||, CODE, READONLY, ALIGN=1

                  dhcp_supplied_address PROC
;;;1979   u8_t
;;;1980   dhcp_supplied_address(const struct netif *netif)
000000  2800              CMP      r0,#0
;;;1981   {
000002  d00c              BEQ      |L34.30|
;;;1982     if ((netif != NULL) && (netif_dhcp_data(netif) != NULL)) {
000004  6a80              LDR      r0,[r0,#0x28]
000006  b150              CBZ      r0,|L34.30|
;;;1983       struct dhcp *dhcp = netif_dhcp_data(netif);
;;;1984       return (dhcp->state == DHCP_STATE_BOUND) || (dhcp->state == DHCP_STATE_RENEWING) ||
000008  7940              LDRB     r0,[r0,#5]
00000a  280a              CMP      r0,#0xa
00000c  d005              BEQ      |L34.26|
00000e  2805              CMP      r0,#5
000010  d003              BEQ      |L34.26|
;;;1985              (dhcp->state == DHCP_STATE_REBINDING);
000012  2804              CMP      r0,#4
000014  d001              BEQ      |L34.26|
000016  2000              MOVS     r0,#0
;;;1986     }
;;;1987     return 0;
;;;1988   }
000018  4770              BX       lr
                  |L34.26|
00001a  2001              MOVS     r0,#1                 ;1985
00001c  4770              BX       lr
                  |L34.30|
00001e  2000              MOVS     r0,#0                 ;1987
000020  4770              BX       lr
;;;1989   
                          ENDP


                          AREA ||i.dhcp_t1_timeout||, CODE, READONLY, ALIGN=1

                  dhcp_t1_timeout PROC
;;;545    static void
;;;546    dhcp_t1_timeout(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;547    {
;;;548      struct dhcp *dhcp = netif_dhcp_data(netif);
000002  6a84              LDR      r4,[r0,#0x28]
;;;549    
;;;550      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
;;;551      if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
000004  7961              LDRB     r1,[r4,#5]
000006  2901              CMP      r1,#1
000008  d003              BEQ      |L35.18|
00000a  290a              CMP      r1,#0xa
00000c  d001              BEQ      |L35.18|
;;;552          (dhcp->state == DHCP_STATE_RENEWING)) {
00000e  2905              CMP      r1,#5
000010  d10a              BNE      |L35.40|
                  |L35.18|
;;;553        /* just retry to renew - note that the rebind timer (t2) will
;;;554         * eventually time-out if renew tries fail. */
;;;555        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
;;;556                    ("dhcp_t1_timeout(): must renew\n"));
;;;557        /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
;;;558           DHCP_STATE_RENEWING, not DHCP_STATE_BOUND */
;;;559        dhcp_renew(netif);
000012  f7fffffe          BL       dhcp_renew
;;;560        /* Calculate next timeout */
;;;561        if (((dhcp->t2_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS)) {
000016  89a0              LDRH     r0,[r4,#0xc]
000018  8a61              LDRH     r1,[r4,#0x12]
00001a  1a40              SUBS     r0,r0,r1
00001c  2802              CMP      r0,#2
00001e  db03              BLT      |L35.40|
;;;562          dhcp->t1_renew_time = (u16_t)((dhcp->t2_timeout - dhcp->lease_used) / 2);
000020  eb0070d0          ADD      r0,r0,r0,LSR #31
000024  0840              LSRS     r0,r0,#1
000026  81e0              STRH     r0,[r4,#0xe]
                  |L35.40|
;;;563        }
;;;564      }
;;;565    }
000028  bd10              POP      {r4,pc}
;;;566    
                          ENDP


                          AREA ||i.dhcp_t2_timeout||, CODE, READONLY, ALIGN=1

                  dhcp_t2_timeout PROC
;;;572    static void
;;;573    dhcp_t2_timeout(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;574    {
;;;575      struct dhcp *dhcp = netif_dhcp_data(netif);
000002  6a84              LDR      r4,[r0,#0x28]
;;;576    
;;;577      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
;;;578      if ((dhcp->state == DHCP_STATE_REQUESTING) || (dhcp->state == DHCP_STATE_BOUND) ||
000004  7961              LDRB     r1,[r4,#5]
000006  2901              CMP      r1,#1
000008  d005              BEQ      |L36.22|
00000a  290a              CMP      r1,#0xa
00000c  d003              BEQ      |L36.22|
;;;579          (dhcp->state == DHCP_STATE_RENEWING) || (dhcp->state == DHCP_STATE_REBINDING)) {
00000e  2905              CMP      r1,#5
000010  d001              BEQ      |L36.22|
000012  2904              CMP      r1,#4
000014  d10a              BNE      |L36.44|
                  |L36.22|
;;;580        /* just retry to rebind */
;;;581        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE,
;;;582                    ("dhcp_t2_timeout(): must rebind\n"));
;;;583        /* This slightly different to RFC2131: DHCPREQUEST will be sent from state
;;;584           DHCP_STATE_REBINDING, not DHCP_STATE_BOUND */
;;;585        dhcp_rebind(netif);
000016  f7fffffe          BL       dhcp_rebind
;;;586        /* Calculate next timeout */
;;;587        if (((dhcp->t0_timeout - dhcp->lease_used) / 2) >= ((60 + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS)) {
00001a  8aa0              LDRH     r0,[r4,#0x14]
00001c  8a61              LDRH     r1,[r4,#0x12]
00001e  1a40              SUBS     r0,r0,r1
000020  2802              CMP      r0,#2
000022  db03              BLT      |L36.44|
;;;588          dhcp->t2_rebind_time = (u16_t)((dhcp->t0_timeout - dhcp->lease_used) / 2);
000024  eb0070d0          ADD      r0,r0,r0,LSR #31
000028  0840              LSRS     r0,r0,#1
00002a  8220              STRH     r0,[r4,#0x10]
                  |L36.44|
;;;589        }
;;;590      }
;;;591    }
00002c  bd10              POP      {r4,pc}
;;;592    
                          ENDP


                          AREA ||i.dhcp_timeout||, CODE, READONLY, ALIGN=1

                  dhcp_timeout PROC
;;;498    static void
;;;499    dhcp_timeout(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;500    {
000002  4604              MOV      r4,r0
;;;501      struct dhcp *dhcp = netif_dhcp_data(netif);
000004  6aa1              LDR      r1,[r4,#0x28]
;;;502    
;;;503      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout()\n"));
;;;504      /* back-off period has passed, or server selection timed out */
;;;505      if ((dhcp->state == DHCP_STATE_BACKING_OFF) || (dhcp->state == DHCP_STATE_SELECTING)) {
000006  794a              LDRB     r2,[r1,#5]
000008  2a0c              CMP      r2,#0xc
00000a  d00f              BEQ      |L37.44|
00000c  2a06              CMP      r2,#6
00000e  d00d              BEQ      |L37.44|
;;;506        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
;;;507        dhcp_discover(netif);
;;;508        /* receiving the requested lease timed out */
;;;509      } else if (dhcp->state == DHCP_STATE_REQUESTING) {
000010  2a01              CMP      r2,#1
000012  d010              BEQ      |L37.54|
;;;510        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
;;;511        if (dhcp->tries <= 5) {
;;;512          dhcp_select(netif);
;;;513        } else {
;;;514          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
;;;515          dhcp_release_and_stop(netif);
;;;516          dhcp_start(netif);
;;;517        }
;;;518    #if DHCP_DOES_ARP_CHECK
;;;519        /* received no ARP reply for the offered address (which is good) */
;;;520      } else if (dhcp->state == DHCP_STATE_CHECKING) {
000014  2a08              CMP      r2,#8
000016  d01e              BEQ      |L37.86|
;;;521        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
;;;522        if (dhcp->tries <= 1) {
;;;523          dhcp_check(netif);
;;;524          /* no ARP replies on the offered address,
;;;525             looks like the IP address is indeed free */
;;;526        } else {
;;;527          /* bind the interface to the offered address */
;;;528          dhcp_bind(netif);
;;;529        }
;;;530    #endif /* DHCP_DOES_ARP_CHECK */
;;;531      } else if (dhcp->state == DHCP_STATE_REBOOTING) {
000018  2a03              CMP      r2,#3
00001a  d12e              BNE      |L37.122|
;;;532        if (dhcp->tries < REBOOT_TRIES) {
00001c  7988              LDRB     r0,[r1,#6]
00001e  2802              CMP      r0,#2
000020  d226              BCS      |L37.112|
;;;533          dhcp_reboot(netif);
000022  4620              MOV      r0,r4
000024  e8bd4010          POP      {r4,lr}
000028  f7ffbffe          B.W      dhcp_reboot
                  |L37.44|
00002c  4620              MOV      r0,r4                 ;507
00002e  e8bd4010          POP      {r4,lr}               ;507
000032  f7ffbffe          B.W      dhcp_discover
                  |L37.54|
000036  7988              LDRB     r0,[r1,#6]            ;511
000038  2805              CMP      r0,#5                 ;511
00003a  d804              BHI      |L37.70|
00003c  4620              MOV      r0,r4                 ;512
00003e  e8bd4010          POP      {r4,lr}               ;512
000042  f7ffbffe          B.W      dhcp_select
                  |L37.70|
000046  4620              MOV      r0,r4                 ;515
000048  f7fffffe          BL       dhcp_release_and_stop
00004c  4620              MOV      r0,r4                 ;516
00004e  e8bd4010          POP      {r4,lr}               ;516
000052  f7ffbffe          B.W      dhcp_start
                  |L37.86|
000056  7988              LDRB     r0,[r1,#6]            ;522
000058  2801              CMP      r0,#1                 ;522
00005a  d804              BHI      |L37.102|
00005c  4620              MOV      r0,r4                 ;523
00005e  e8bd4010          POP      {r4,lr}               ;523
000062  f7ffbffe          B.W      dhcp_check
                  |L37.102|
000066  4620              MOV      r0,r4                 ;528
000068  e8bd4010          POP      {r4,lr}               ;528
00006c  f7ffbffe          B.W      dhcp_bind
                  |L37.112|
;;;534        } else {
;;;535          dhcp_discover(netif);
000070  4620              MOV      r0,r4
000072  e8bd4010          POP      {r4,lr}
000076  f7ffbffe          B.W      dhcp_discover
                  |L37.122|
;;;536        }
;;;537      }
;;;538    }
00007a  bd10              POP      {r4,pc}
;;;539    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  dhcp_rx_options_val
                          %        40
                  dhcp_rx_options_given
                          %        10

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  64686370          DCB      "dhcp_option: options_out_len + 2 + option_len <= DHCP_O"
000004  5f6f7074
000008  696f6e3a
00000c  206f7074
000010  696f6e73
000014  5f6f7574
000018  5f6c656e
00001c  202b2032
000020  202b206f
000024  7074696f
000028  6e5f6c65
00002c  6e203c3d
000030  20444843
000034  505f4f  
000037  5054494f          DCB      "PTIONS_LEN",0
00003b  4e535f4c
00003f  454e00  

                          AREA ||.data||, DATA, ALIGN=2

                  dhcp_pcb_refcount
000000  00                DCB      0x00
                  dhcp_discover_request_options
000001  01031c            DCB      0x01,0x03,0x1c
000004  06000000          DCB      0x06,0x00,0x00,0x00
                  xid
                          DCD      0x00000000
                  dhcp_pcb
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\dhcp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_dhcp_c_7036610f____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_dhcp_c_7036610f____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_dhcp_c_7036610f____REVSH|
#line 478
|__asm___6_dhcp_c_7036610f____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_dhcp_c_7036610f____RRX|
#line 665
|__asm___6_dhcp_c_7036610f____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
