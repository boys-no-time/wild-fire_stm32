; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\stm32f1xx_hal_uart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f1xx_hal_uart.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\system\arch -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Inc -I..\Middlewares\Third_Party\LwIP\src\include -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\stm32f1xx_hal_uart.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2425     */
;;;2426   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;2427   {
;;;2428     uint32_t tmpreg = 0x00U;
;;;2429   
;;;2430     /* Process Locked */
;;;2431     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d012              BEQ      |L1.46|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;2432   
;;;2433     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;2434   
;;;2435     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2436     tmpreg = huart->Instance->CR1;
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
;;;2437   
;;;2438     /* Clear TE and RE bits */
;;;2439     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
000018  f022020c          BIC      r2,r2,#0xc
;;;2440   
;;;2441     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2442     tmpreg |= (uint32_t)USART_CR1_RE;
00001c  f0420204          ORR      r2,r2,#4
;;;2443   
;;;2444     /* Write to USART CR1 */
;;;2445     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
000020  60ca              STR      r2,[r1,#0xc]
;;;2446   
;;;2447     huart->gState = HAL_UART_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  7041              STRB     r1,[r0,#1]
;;;2448   
;;;2449     /* Process Unlocked */
;;;2450     __HAL_UNLOCK(huart);
000026  2100              MOVS     r1,#0
000028  7001              STRB     r1,[r0,#0]
;;;2451   
;;;2452     return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;2453   }
00002c  4770              BX       lr
                  |L1.46|
00002e  2002              MOVS     r0,#2                 ;2431
000030  4770              BX       lr
;;;2454   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2390     */
;;;2391   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;2392   {
;;;2393     uint32_t tmpreg = 0x00U;
;;;2394   
;;;2395     /* Process Locked */
;;;2396     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d012              BEQ      |L2.46|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;2397   
;;;2398     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;2399   
;;;2400     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2401     tmpreg = huart->Instance->CR1;
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
;;;2402   
;;;2403     /* Clear TE and RE bits */
;;;2404     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
000018  f022020c          BIC      r2,r2,#0xc
;;;2405   
;;;2406     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2407     tmpreg |= (uint32_t)USART_CR1_TE;
00001c  f0420208          ORR      r2,r2,#8
;;;2408   
;;;2409     /* Write to USART CR1 */
;;;2410     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
000020  60ca              STR      r2,[r1,#0xc]
;;;2411   
;;;2412     huart->gState = HAL_UART_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  7041              STRB     r1,[r0,#1]
;;;2413   
;;;2414     /* Process Unlocked */
;;;2415     __HAL_UNLOCK(huart);
000026  2100              MOVS     r1,#0
000028  7001              STRB     r1,[r0,#0]
;;;2416   
;;;2417     return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;2418   }
00002c  4770              BX       lr
                  |L2.46|
00002e  2002              MOVS     r0,#2                 ;2396
000030  4770              BX       lr
;;;2419   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;390      */
;;;391    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;392    {
000002  4604              MOV      r4,r0
;;;393      /* Check the UART handle allocation */
;;;394      if (huart == NULL)
000004  2c00              CMP      r4,#0
000006  d004              BEQ      |L3.18|
;;;395      {
;;;396        return HAL_ERROR;
;;;397      }
;;;398    
;;;399      /* Check the parameters */
;;;400      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;401      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;402    #if defined(USART_CR1_OVER8)
;;;403      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;404    #endif /* USART_CR1_OVER8 */
;;;405    
;;;406      if (huart->gState == HAL_UART_STATE_RESET)
000008  f8940039          LDRB     r0,[r4,#0x39]
00000c  2500              MOVS     r5,#0
00000e  b110              CBZ      r0,|L3.22|
000010  e006              B        |L3.32|
                  |L3.18|
000012  2001              MOVS     r0,#1                 ;396
;;;407      {
;;;408        /* Allocate lock resource and initialize it */
;;;409        huart->Lock = HAL_UNLOCKED;
;;;410    
;;;411    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;412        UART_InitCallbacksToDefault(huart);
;;;413    
;;;414        if (huart->MspInitCallback == NULL)
;;;415        {
;;;416          huart->MspInitCallback = HAL_UART_MspInit;
;;;417        }
;;;418    
;;;419        /* Init the low level hardware */
;;;420        huart->MspInitCallback(huart);
;;;421    #else
;;;422        /* Init the low level hardware : GPIO, CLOCK */
;;;423        HAL_UART_MspInit(huart);
;;;424    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;425      }
;;;426    
;;;427      huart->gState = HAL_UART_STATE_BUSY;
;;;428    
;;;429      /* Disable the peripheral */
;;;430      __HAL_UART_DISABLE(huart);
;;;431    
;;;432      /* Set the UART Communication parameters */
;;;433      UART_SetConfig(huart);
;;;434    
;;;435      /* In half-duplex mode, the following bits must be kept cleared:
;;;436         - LINEN and CLKEN bits in the USART_CR2 register,
;;;437         - SCEN and IREN bits in the USART_CR3 register.*/
;;;438      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;439      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;440    
;;;441      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;442      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;443    
;;;444      /* Enable the peripheral */
;;;445      __HAL_UART_ENABLE(huart);
;;;446    
;;;447      /* Initialize the UART state*/
;;;448      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;449      huart->gState = HAL_UART_STATE_READY;
;;;450      huart->RxState = HAL_UART_STATE_READY;
;;;451    
;;;452      return HAL_OK;
;;;453    }
000014  bd70              POP      {r4-r6,pc}
                  |L3.22|
000016  f8845038          STRB     r5,[r4,#0x38]         ;409
00001a  4620              MOV      r0,r4                 ;423
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L3.32|
000020  2024              MOVS     r0,#0x24              ;427
000022  f8840039          STRB     r0,[r4,#0x39]         ;427
000026  6820              LDR      r0,[r4,#0]            ;430
000028  68c1              LDR      r1,[r0,#0xc]          ;430
00002a  f4215100          BIC      r1,r1,#0x2000         ;430
00002e  60c1              STR      r1,[r0,#0xc]          ;430
000030  4620              MOV      r0,r4                 ;433
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;438
000038  6901              LDR      r1,[r0,#0x10]         ;438
00003a  f4214190          BIC      r1,r1,#0x4800         ;438
00003e  6101              STR      r1,[r0,#0x10]         ;438
000040  6820              LDR      r0,[r4,#0]            ;439
000042  6941              LDR      r1,[r0,#0x14]         ;439
000044  f0210122          BIC      r1,r1,#0x22           ;439
000048  6141              STR      r1,[r0,#0x14]         ;439
00004a  6820              LDR      r0,[r4,#0]            ;442
00004c  6941              LDR      r1,[r0,#0x14]         ;442
00004e  f0410108          ORR      r1,r1,#8              ;442
000052  6141              STR      r1,[r0,#0x14]         ;442
000054  6820              LDR      r0,[r4,#0]            ;445
000056  68c1              LDR      r1,[r0,#0xc]          ;445
000058  f4415100          ORR      r1,r1,#0x2000         ;445
00005c  60c1              STR      r1,[r0,#0xc]          ;445
00005e  63e5              STR      r5,[r4,#0x3c]         ;448
000060  2020              MOVS     r0,#0x20              ;449
000062  f8840039          STRB     r0,[r4,#0x39]         ;449
000066  f884003a          STRB     r0,[r4,#0x3a]         ;450
00006a  2000              MOVS     r0,#0                 ;452
00006c  bd70              POP      {r4-r6,pc}
;;;454    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;465      */
;;;466    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;467    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;468      /* Check the UART handle allocation */
;;;469      if (huart == NULL)
000006  2c00              CMP      r4,#0
000008  d004              BEQ      |L4.20|
;;;470      {
;;;471        return HAL_ERROR;
;;;472      }
;;;473    
;;;474      /* Check the LIN UART instance */
;;;475      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;476    
;;;477      /* Check the Break detection length parameter */
;;;478      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;479      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;480    #if defined(USART_CR1_OVER8)
;;;481      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;482    #endif /* USART_CR1_OVER8 */
;;;483    
;;;484      if (huart->gState == HAL_UART_STATE_RESET)
00000a  f8940039          LDRB     r0,[r4,#0x39]
00000e  2500              MOVS     r5,#0
000010  b110              CBZ      r0,|L4.24|
000012  e006              B        |L4.34|
                  |L4.20|
000014  2001              MOVS     r0,#1                 ;471
;;;485      {
;;;486        /* Allocate lock resource and initialize it */
;;;487        huart->Lock = HAL_UNLOCKED;
;;;488    
;;;489    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;490        UART_InitCallbacksToDefault(huart);
;;;491    
;;;492        if (huart->MspInitCallback == NULL)
;;;493        {
;;;494          huart->MspInitCallback = HAL_UART_MspInit;
;;;495        }
;;;496    
;;;497        /* Init the low level hardware */
;;;498        huart->MspInitCallback(huart);
;;;499    #else
;;;500        /* Init the low level hardware : GPIO, CLOCK */
;;;501        HAL_UART_MspInit(huart);
;;;502    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;503      }
;;;504    
;;;505      huart->gState = HAL_UART_STATE_BUSY;
;;;506    
;;;507      /* Disable the peripheral */
;;;508      __HAL_UART_DISABLE(huart);
;;;509    
;;;510      /* Set the UART Communication parameters */
;;;511      UART_SetConfig(huart);
;;;512    
;;;513      /* In LIN mode, the following bits must be kept cleared:
;;;514         - CLKEN bits in the USART_CR2 register,
;;;515         - SCEN, HDSEL and IREN bits in the USART_CR3 register.*/
;;;516      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_CLKEN));
;;;517      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;518    
;;;519      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;520      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;521    
;;;522      /* Set the USART LIN Break detection length. */
;;;523      CLEAR_BIT(huart->Instance->CR2, USART_CR2_LBDL);
;;;524      SET_BIT(huart->Instance->CR2, BreakDetectLength);
;;;525    
;;;526      /* Enable the peripheral */
;;;527      __HAL_UART_ENABLE(huart);
;;;528    
;;;529      /* Initialize the UART state*/
;;;530      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;531      huart->gState = HAL_UART_STATE_READY;
;;;532      huart->RxState = HAL_UART_STATE_READY;
;;;533    
;;;534      return HAL_OK;
;;;535    }
000016  bd70              POP      {r4-r6,pc}
                  |L4.24|
000018  f8845038          STRB     r5,[r4,#0x38]         ;487
00001c  4620              MOV      r0,r4                 ;501
00001e  f7fffffe          BL       HAL_UART_MspInit
                  |L4.34|
000022  2024              MOVS     r0,#0x24              ;505
000024  f8840039          STRB     r0,[r4,#0x39]         ;505
000028  6820              LDR      r0,[r4,#0]            ;508
00002a  68c1              LDR      r1,[r0,#0xc]          ;508
00002c  f4215100          BIC      r1,r1,#0x2000         ;508
000030  60c1              STR      r1,[r0,#0xc]          ;508
000032  4620              MOV      r0,r4                 ;511
000034  f7fffffe          BL       UART_SetConfig
000038  6820              LDR      r0,[r4,#0]            ;516
00003a  6901              LDR      r1,[r0,#0x10]         ;516
00003c  f4216100          BIC      r1,r1,#0x800          ;516
000040  6101              STR      r1,[r0,#0x10]         ;516
000042  6820              LDR      r0,[r4,#0]            ;517
000044  6941              LDR      r1,[r0,#0x14]         ;517
000046  f021012a          BIC      r1,r1,#0x2a           ;517
00004a  6141              STR      r1,[r0,#0x14]         ;517
00004c  6820              LDR      r0,[r4,#0]            ;520
00004e  6901              LDR      r1,[r0,#0x10]         ;520
000050  f4414180          ORR      r1,r1,#0x4000         ;520
000054  6101              STR      r1,[r0,#0x10]         ;520
000056  6820              LDR      r0,[r4,#0]            ;523
000058  6901              LDR      r1,[r0,#0x10]         ;523
00005a  f0210120          BIC      r1,r1,#0x20           ;523
00005e  6101              STR      r1,[r0,#0x10]         ;523
000060  6820              LDR      r0,[r4,#0]            ;524
000062  6901              LDR      r1,[r0,#0x10]         ;524
000064  4331              ORRS     r1,r1,r6              ;524
000066  6101              STR      r1,[r0,#0x10]         ;524
000068  6820              LDR      r0,[r4,#0]            ;527
00006a  68c1              LDR      r1,[r0,#0xc]          ;527
00006c  f4415100          ORR      r1,r1,#0x2000         ;527
000070  60c1              STR      r1,[r0,#0xc]          ;527
000072  63e5              STR      r5,[r4,#0x3c]         ;530
000074  2020              MOVS     r0,#0x20              ;531
000076  f8840039          STRB     r0,[r4,#0x39]         ;531
00007a  f884003a          STRB     r0,[r4,#0x3a]         ;532
00007e  2000              MOVS     r0,#0                 ;534
000080  bd70              POP      {r4-r6,pc}
;;;536    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;2309     */
;;;2310   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;2311   {
;;;2312     /* Check the parameters */
;;;2313     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2314   
;;;2315     /* Process Locked */
;;;2316     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L5.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;2317   
;;;2318     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;2319   
;;;2320     /* Send break characters */
;;;2321     SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0420201          ORR      r2,r2,#1
00001c  60ca              STR      r2,[r1,#0xc]
;;;2322   
;;;2323     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;2324   
;;;2325     /* Process Unlocked */
;;;2326     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;2327   
;;;2328     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;2329   }
000028  4770              BX       lr
                  |L5.42|
00002a  2002              MOVS     r0,#2                 ;2316
00002c  4770              BX       lr
;;;2330   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;2336     */
;;;2337   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;2338   {
;;;2339     /* Check the parameters */
;;;2340     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2341   
;;;2342     /* Process Locked */
;;;2343     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L6.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;2344   
;;;2345     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;2346   
;;;2347     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;2348     SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0420202          ORR      r2,r2,#2
00001c  60ca              STR      r2,[r1,#0xc]
;;;2349   
;;;2350     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;2351   
;;;2352     /* Process Unlocked */
;;;2353     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;2354   
;;;2355     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;2356   }
000028  4770              BX       lr
                  |L6.42|
00002a  2002              MOVS     r0,#2                 ;2343
00002c  4770              BX       lr
;;;2357   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_ExitMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;2363     */
;;;2364   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;2365   {
;;;2366     /* Check the parameters */
;;;2367     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2368   
;;;2369     /* Process Locked */
;;;2370     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L7.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;2371   
;;;2372     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;2373   
;;;2374     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;2375     CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0220202          BIC      r2,r2,#2
00001c  60ca              STR      r2,[r1,#0xc]
;;;2376   
;;;2377     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;2378   
;;;2379     /* Process Unlocked */
;;;2380     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;2381   
;;;2382     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;2383   }
000028  4770              BX       lr
                  |L7.42|
00002a  2002              MOVS     r0,#2                 ;2370
00002c  4770              BX       lr
;;;2384   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;548      */
;;;549    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;550    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;551      /* Check the UART handle allocation */
;;;552      if (huart == NULL)
00000a  2c00              CMP      r4,#0
00000c  d004              BEQ      |L8.24|
;;;553      {
;;;554        return HAL_ERROR;
;;;555      }
;;;556    
;;;557      /* Check the parameters */
;;;558      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;559    
;;;560      /* Check the Address & wake up method parameters */
;;;561      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;562      assert_param(IS_UART_ADDRESS(Address));
;;;563      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;564    #if defined(USART_CR1_OVER8)
;;;565      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;566    #endif /* USART_CR1_OVER8 */
;;;567    
;;;568      if (huart->gState == HAL_UART_STATE_RESET)
00000e  f8940039          LDRB     r0,[r4,#0x39]
000012  2500              MOVS     r5,#0
000014  b118              CBZ      r0,|L8.30|
000016  e007              B        |L8.40|
                  |L8.24|
000018  2001              MOVS     r0,#1                 ;554
                  |L8.26|
;;;569      {
;;;570        /* Allocate lock resource and initialize it */
;;;571        huart->Lock = HAL_UNLOCKED;
;;;572    
;;;573    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;574        UART_InitCallbacksToDefault(huart);
;;;575    
;;;576        if (huart->MspInitCallback == NULL)
;;;577        {
;;;578          huart->MspInitCallback = HAL_UART_MspInit;
;;;579        }
;;;580    
;;;581        /* Init the low level hardware */
;;;582        huart->MspInitCallback(huart);
;;;583    #else
;;;584        /* Init the low level hardware : GPIO, CLOCK */
;;;585        HAL_UART_MspInit(huart);
;;;586    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;587      }
;;;588    
;;;589      huart->gState = HAL_UART_STATE_BUSY;
;;;590    
;;;591      /* Disable the peripheral */
;;;592      __HAL_UART_DISABLE(huart);
;;;593    
;;;594      /* Set the UART Communication parameters */
;;;595      UART_SetConfig(huart);
;;;596    
;;;597      /* In Multi-Processor mode, the following bits must be kept cleared:
;;;598         - LINEN and CLKEN bits in the USART_CR2 register,
;;;599         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;600      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;601      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;602    
;;;603      /* Set the USART address node */
;;;604      CLEAR_BIT(huart->Instance->CR2, USART_CR2_ADD);
;;;605      SET_BIT(huart->Instance->CR2, Address);
;;;606    
;;;607      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;608      CLEAR_BIT(huart->Instance->CR1, USART_CR1_WAKE);
;;;609      SET_BIT(huart->Instance->CR1, WakeUpMethod);
;;;610    
;;;611      /* Enable the peripheral */
;;;612      __HAL_UART_ENABLE(huart);
;;;613    
;;;614      /* Initialize the UART state */
;;;615      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;616      huart->gState = HAL_UART_STATE_READY;
;;;617      huart->RxState = HAL_UART_STATE_READY;
;;;618    
;;;619      return HAL_OK;
;;;620    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L8.30|
00001e  f8845038          STRB     r5,[r4,#0x38]         ;571
000022  4620              MOV      r0,r4                 ;585
000024  f7fffffe          BL       HAL_UART_MspInit
                  |L8.40|
000028  2024              MOVS     r0,#0x24              ;589
00002a  f8840039          STRB     r0,[r4,#0x39]         ;589
00002e  6820              LDR      r0,[r4,#0]            ;592
000030  68c1              LDR      r1,[r0,#0xc]          ;592
000032  f4215100          BIC      r1,r1,#0x2000         ;592
000036  60c1              STR      r1,[r0,#0xc]          ;592
000038  4620              MOV      r0,r4                 ;595
00003a  f7fffffe          BL       UART_SetConfig
00003e  6820              LDR      r0,[r4,#0]            ;600
000040  6901              LDR      r1,[r0,#0x10]         ;600
000042  f4214190          BIC      r1,r1,#0x4800         ;600
000046  6101              STR      r1,[r0,#0x10]         ;600
000048  6820              LDR      r0,[r4,#0]            ;601
00004a  6941              LDR      r1,[r0,#0x14]         ;601
00004c  f021012a          BIC      r1,r1,#0x2a           ;601
000050  6141              STR      r1,[r0,#0x14]         ;601
000052  6820              LDR      r0,[r4,#0]            ;604
000054  6901              LDR      r1,[r0,#0x10]         ;604
000056  f021010f          BIC      r1,r1,#0xf            ;604
00005a  6101              STR      r1,[r0,#0x10]         ;604
00005c  6820              LDR      r0,[r4,#0]            ;605
00005e  6901              LDR      r1,[r0,#0x10]         ;605
000060  4331              ORRS     r1,r1,r6              ;605
000062  6101              STR      r1,[r0,#0x10]         ;605
000064  6820              LDR      r0,[r4,#0]            ;608
000066  68c1              LDR      r1,[r0,#0xc]          ;608
000068  f4216100          BIC      r1,r1,#0x800          ;608
00006c  60c1              STR      r1,[r0,#0xc]          ;608
00006e  6820              LDR      r0,[r4,#0]            ;609
000070  68c1              LDR      r1,[r0,#0xc]          ;609
000072  4339              ORRS     r1,r1,r7              ;609
000074  60c1              STR      r1,[r0,#0xc]          ;609
000076  6820              LDR      r0,[r4,#0]            ;612
000078  68c1              LDR      r1,[r0,#0xc]          ;612
00007a  f4415100          ORR      r1,r1,#0x2000         ;612
00007e  60c1              STR      r1,[r0,#0xc]          ;612
000080  63e5              STR      r5,[r4,#0x3c]         ;615
000082  2020              MOVS     r0,#0x20              ;616
000084  f8840039          STRB     r0,[r4,#0x39]         ;616
000088  f884003a          STRB     r0,[r4,#0x3a]         ;617
00008c  2000              MOVS     r0,#0                 ;619
00008e  e7c4              B        |L8.26|
;;;621    
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1558   */
;;;1559   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1560   {
000002  4604              MOV      r4,r0
;;;1561     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1562     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f42171f0          BIC      r1,r1,#0x1e0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1563     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1564   
;;;1565     /* Disable the UART DMA Tx request if enabled */
;;;1566     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
;;;1567     {
;;;1568       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1569   
;;;1570       /* Abort the UART DMA Tx channel: use blocking DMA Abort API (no callback) */
;;;1571       if (huart->hdmatx != NULL)
;;;1572       {
;;;1573         /* Set the UART DMA Abort callback to Null.
;;;1574            No call back execution at end of DMA abort procedure */
;;;1575         huart->hdmatx->XferAbortCallback = NULL;
;;;1576   
;;;1577         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
;;;1578         {
;;;1579           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
;;;1580           {
;;;1581             /* Set error code to DMA */
;;;1582             huart->ErrorCode = HAL_UART_ERROR_DMA;
00001c  f04f0610          MOV      r6,#0x10
000020  0609              LSLS     r1,r1,#24             ;1566
000022  f04f0500          MOV      r5,#0
000026  d50f              BPL      |L9.72|
000028  6941              LDR      r1,[r0,#0x14]         ;1568
00002a  f0210180          BIC      r1,r1,#0x80           ;1568
00002e  6141              STR      r1,[r0,#0x14]         ;1568
000030  6b20              LDR      r0,[r4,#0x30]         ;1571
000032  b148              CBZ      r0,|L9.72|
000034  6345              STR      r5,[r0,#0x34]         ;1575
000036  6b20              LDR      r0,[r4,#0x30]         ;1577
000038  f7fffffe          BL       HAL_DMA_Abort
00003c  b120              CBZ      r0,|L9.72|
00003e  6b20              LDR      r0,[r4,#0x30]         ;1579
000040  f7fffffe          BL       HAL_DMA_GetError
000044  2820              CMP      r0,#0x20              ;1579
000046  d01d              BEQ      |L9.132|
                  |L9.72|
;;;1583   
;;;1584             return HAL_TIMEOUT;
;;;1585           }
;;;1586         }
;;;1587       }
;;;1588     }
;;;1589   
;;;1590     /* Disable the UART DMA Rx request if enabled */
;;;1591     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000048  6820              LDR      r0,[r4,#0]
00004a  6941              LDR      r1,[r0,#0x14]
00004c  0649              LSLS     r1,r1,#25
00004e  d50f              BPL      |L9.112|
;;;1592     {
;;;1593       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000050  6941              LDR      r1,[r0,#0x14]
000052  f0210140          BIC      r1,r1,#0x40
000056  6141              STR      r1,[r0,#0x14]
;;;1594   
;;;1595       /* Abort the UART DMA Rx channel: use blocking DMA Abort API (no callback) */
;;;1596       if (huart->hdmarx != NULL)
000058  6b60              LDR      r0,[r4,#0x34]
00005a  b148              CBZ      r0,|L9.112|
;;;1597       {
;;;1598         /* Set the UART DMA Abort callback to Null.
;;;1599            No call back execution at end of DMA abort procedure */
;;;1600         huart->hdmarx->XferAbortCallback = NULL;
00005c  6345              STR      r5,[r0,#0x34]
;;;1601   
;;;1602         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
00005e  6b60              LDR      r0,[r4,#0x34]
000060  f7fffffe          BL       HAL_DMA_Abort
000064  b120              CBZ      r0,|L9.112|
;;;1603         {
;;;1604           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
000066  6b60              LDR      r0,[r4,#0x34]
000068  f7fffffe          BL       HAL_DMA_GetError
00006c  2820              CMP      r0,#0x20
00006e  d00c              BEQ      |L9.138|
                  |L9.112|
;;;1605           {
;;;1606             /* Set error code to DMA */
;;;1607             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1608   
;;;1609             return HAL_TIMEOUT;
;;;1610           }
;;;1611         }
;;;1612       }
;;;1613     }
;;;1614   
;;;1615     /* Reset Tx and Rx transfer counters */
;;;1616     huart->TxXferCount = 0x00U;
000070  84e5              STRH     r5,[r4,#0x26]
;;;1617     huart->RxXferCount = 0x00U;
000072  85e5              STRH     r5,[r4,#0x2e]
;;;1618   
;;;1619     /* Reset ErrorCode */
;;;1620     huart->ErrorCode = HAL_UART_ERROR_NONE;
000074  63e5              STR      r5,[r4,#0x3c]
;;;1621   
;;;1622     /* Restore huart->RxState and huart->gState to Ready */
;;;1623     huart->RxState = HAL_UART_STATE_READY;
000076  2020              MOVS     r0,#0x20
000078  f884003a          STRB     r0,[r4,#0x3a]
;;;1624     huart->gState = HAL_UART_STATE_READY;
00007c  f8840039          STRB     r0,[r4,#0x39]
;;;1625   
;;;1626     return HAL_OK;
000080  2000              MOVS     r0,#0
;;;1627   }
000082  bd70              POP      {r4-r6,pc}
                  |L9.132|
000084  63e6              STR      r6,[r4,#0x3c]         ;1582
000086  2003              MOVS     r0,#3                 ;1584
000088  bd70              POP      {r4-r6,pc}
                  |L9.138|
00008a  63e6              STR      r6,[r4,#0x3c]         ;1607
00008c  2003              MOVS     r0,#3                 ;1609
00008e  bd70              POP      {r4-r6,pc}
;;;1628   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;2240     */
;;;2241   __weak void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2242   {
;;;2243     /* Prevent unused argument(s) compilation warning */
;;;2244     UNUSED(huart);
;;;2245   
;;;2246     /* NOTE : This function should not be modified, when the callback is needed,
;;;2247               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;2248      */
;;;2249   }
;;;2250   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1691   */
;;;1692   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1693   {
000002  4604              MOV      r4,r0
;;;1694     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1695     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217190          BIC      r1,r1,#0x120
00000c  60c1              STR      r1,[r0,#0xc]
;;;1696     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1697   
;;;1698     /* Disable the UART DMA Rx request if enabled */
;;;1699     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0500          MOV      r5,#0
000020  0649              LSLS     r1,r1,#25
000022  d50f              BPL      |L11.68|
;;;1700     {
;;;1701       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000024  6941              LDR      r1,[r0,#0x14]
000026  f0210140          BIC      r1,r1,#0x40
00002a  6141              STR      r1,[r0,#0x14]
;;;1702   
;;;1703       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1704       if (huart->hdmarx != NULL)
00002c  6b60              LDR      r0,[r4,#0x34]
00002e  b148              CBZ      r0,|L11.68|
;;;1705       {
;;;1706         /* Set the UART DMA Abort callback to Null.
;;;1707            No call back execution at end of DMA abort procedure */
;;;1708         huart->hdmarx->XferAbortCallback = NULL;
000030  6345              STR      r5,[r0,#0x34]
;;;1709   
;;;1710         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
000032  6b60              LDR      r0,[r4,#0x34]
000034  f7fffffe          BL       HAL_DMA_Abort
000038  b120              CBZ      r0,|L11.68|
;;;1711         {
;;;1712           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
00003a  6b60              LDR      r0,[r4,#0x34]
00003c  f7fffffe          BL       HAL_DMA_GetError
000040  2820              CMP      r0,#0x20
000042  d005              BEQ      |L11.80|
                  |L11.68|
;;;1713           {
;;;1714             /* Set error code to DMA */
;;;1715             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1716   
;;;1717             return HAL_TIMEOUT;
;;;1718           }
;;;1719         }
;;;1720       }
;;;1721     }
;;;1722   
;;;1723     /* Reset Rx transfer counter */
;;;1724     huart->RxXferCount = 0x00U;
000044  85e5              STRH     r5,[r4,#0x2e]
;;;1725   
;;;1726     /* Restore huart->RxState to Ready */
;;;1727     huart->RxState = HAL_UART_STATE_READY;
000046  2020              MOVS     r0,#0x20
000048  f884003a          STRB     r0,[r4,#0x3a]
;;;1728   
;;;1729     return HAL_OK;
00004c  2000              MOVS     r0,#0
;;;1730   }
00004e  bd70              POP      {r4-r6,pc}
                  |L11.80|
000050  2010              MOVS     r0,#0x10              ;1715
000052  63e0              STR      r0,[r4,#0x3c]         ;1715
000054  2003              MOVS     r0,#3                 ;1717
000056  bd70              POP      {r4-r6,pc}
;;;1731   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;2270     */
;;;2271   __weak void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2272   {
;;;2273     /* Prevent unused argument(s) compilation warning */
;;;2274     UNUSED(huart);
;;;2275   
;;;2276     /* NOTE : This function should not be modified, when the callback is needed,
;;;2277               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;2278      */
;;;2279   }
;;;2280   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;1950   */
;;;1951   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1952   {
000002  4604              MOV      r4,r0
;;;1953     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1954     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217190          BIC      r1,r1,#0x120
00000c  60c1              STR      r1,[r0,#0xc]
;;;1955     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1956   
;;;1957     /* Disable the UART DMA Rx request if enabled */
;;;1958     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0200          MOV      r2,#0
000020  064b              LSLS     r3,r1,#25
;;;1959     {
;;;1960       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1961   
;;;1962       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1963       if (huart->hdmarx != NULL)
;;;1964       {
;;;1965         /* Set the UART DMA Abort callback :
;;;1966            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1967         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
;;;1968   
;;;1969         /* Abort DMA RX */
;;;1970         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1971         {
;;;1972           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1973           huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1974         }
;;;1975       }
;;;1976       else
;;;1977       {
;;;1978         /* Reset Rx transfer counter */
;;;1979         huart->RxXferCount = 0x00U;
;;;1980   
;;;1981         /* Restore huart->RxState to Ready */
;;;1982         huart->RxState = HAL_UART_STATE_READY;
000022  f04f0120          MOV      r1,#0x20
000026  d516              BPL      |L13.86|
000028  6943              LDR      r3,[r0,#0x14]         ;1960
00002a  f0230340          BIC      r3,r3,#0x40           ;1960
00002e  6143              STR      r3,[r0,#0x14]         ;1960
000030  6b60              LDR      r0,[r4,#0x34]         ;1963
000032  b148              CBZ      r0,|L13.72|
000034  490c              LDR      r1,|L13.104|
000036  6341              STR      r1,[r0,#0x34]         ;1967
000038  6b60              LDR      r0,[r4,#0x34]         ;1970
00003a  f7fffffe          BL       HAL_DMA_Abort_IT
00003e  b180              CBZ      r0,|L13.98|
000040  6b60              LDR      r0,[r4,#0x34]         ;1973
000042  6b41              LDR      r1,[r0,#0x34]         ;1973
000044  4788              BLX      r1                    ;1973
000046  e00c              B        |L13.98|
                  |L13.72|
000048  85e2              STRH     r2,[r4,#0x2e]         ;1979
00004a  f884103a          STRB     r1,[r4,#0x3a]
;;;1983   
;;;1984         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1985   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1986         /* Call registered Abort Receive Complete Callback */
;;;1987         huart->AbortReceiveCpltCallback(huart);
;;;1988   #else
;;;1989         /* Call legacy weak Abort Receive Complete Callback */
;;;1990         HAL_UART_AbortReceiveCpltCallback(huart);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
000054  e005              B        |L13.98|
                  |L13.86|
;;;1991   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1992       }
;;;1993     }
;;;1994     else
;;;1995     {
;;;1996       /* Reset Rx transfer counter */
;;;1997       huart->RxXferCount = 0x00U;
000056  85e2              STRH     r2,[r4,#0x2e]
;;;1998   
;;;1999       /* Restore huart->RxState to Ready */
;;;2000       huart->RxState = HAL_UART_STATE_READY;
000058  f884103a          STRB     r1,[r4,#0x3a]
;;;2001   
;;;2002       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2003   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2004       /* Call registered Abort Receive Complete Callback */
;;;2005       huart->AbortReceiveCpltCallback(huart);
;;;2006   #else
;;;2007       /* Call legacy weak Abort Receive Complete Callback */
;;;2008       HAL_UART_AbortReceiveCpltCallback(huart);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L13.98|
;;;2009   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2010     }
;;;2011   
;;;2012     return HAL_OK;
000062  2000              MOVS     r0,#0
;;;2013   }
000064  bd10              POP      {r4,pc}
;;;2014   
                          ENDP

000066  0000              DCW      0x0000
                  |L13.104|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1640   */
;;;1641   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1642   {
000002  4604              MOV      r4,r0
;;;1643     /* Disable TXEIE and TCIE interrupts */
;;;1644     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1645   
;;;1646     /* Disable the UART DMA Tx request if enabled */
;;;1647     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f04f0500          MOV      r5,#0
000016  0609              LSLS     r1,r1,#24
000018  d50f              BPL      |L14.58|
;;;1648     {
;;;1649       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f0210180          BIC      r1,r1,#0x80
000020  6141              STR      r1,[r0,#0x14]
;;;1650   
;;;1651       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1652       if (huart->hdmatx != NULL)
000022  6b20              LDR      r0,[r4,#0x30]
000024  b148              CBZ      r0,|L14.58|
;;;1653       {
;;;1654         /* Set the UART DMA Abort callback to Null.
;;;1655            No call back execution at end of DMA abort procedure */
;;;1656         huart->hdmatx->XferAbortCallback = NULL;
000026  6345              STR      r5,[r0,#0x34]
;;;1657   
;;;1658         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
000028  6b20              LDR      r0,[r4,#0x30]
00002a  f7fffffe          BL       HAL_DMA_Abort
00002e  b120              CBZ      r0,|L14.58|
;;;1659         {
;;;1660           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
000030  6b20              LDR      r0,[r4,#0x30]
000032  f7fffffe          BL       HAL_DMA_GetError
000036  2820              CMP      r0,#0x20
000038  d005              BEQ      |L14.70|
                  |L14.58|
;;;1661           {
;;;1662             /* Set error code to DMA */
;;;1663             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1664   
;;;1665             return HAL_TIMEOUT;
;;;1666           }
;;;1667         }
;;;1668       }
;;;1669     }
;;;1670   
;;;1671     /* Reset Tx transfer counter */
;;;1672     huart->TxXferCount = 0x00U;
00003a  84e5              STRH     r5,[r4,#0x26]
;;;1673   
;;;1674     /* Restore huart->gState to Ready */
;;;1675     huart->gState = HAL_UART_STATE_READY;
00003c  2020              MOVS     r0,#0x20
00003e  f8840039          STRB     r0,[r4,#0x39]
;;;1676   
;;;1677     return HAL_OK;
000042  2000              MOVS     r0,#0
;;;1678   }
000044  bd70              POP      {r4-r6,pc}
                  |L14.70|
000046  2010              MOVS     r0,#0x10              ;1663
000048  63e0              STR      r0,[r4,#0x3c]         ;1663
00004a  2003              MOVS     r0,#3                 ;1665
00004c  bd70              POP      {r4-r6,pc}
;;;1679   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;2255     */
;;;2256   __weak void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2257   {
;;;2258     /* Prevent unused argument(s) compilation warning */
;;;2259     UNUSED(huart);
;;;2260   
;;;2261     /* NOTE : This function should not be modified, when the callback is needed,
;;;2262               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;2263      */
;;;2264   }
;;;2265   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;1873   */
;;;1874   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1875   {
000002  4604              MOV      r4,r0
;;;1876     /* Disable TXEIE and TCIE interrupts */
;;;1877     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1878   
;;;1879     /* Disable the UART DMA Tx request if enabled */
;;;1880     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
;;;1881     {
;;;1882       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1883   
;;;1884       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1885       if (huart->hdmatx != NULL)
;;;1886       {
;;;1887         /* Set the UART DMA Abort callback :
;;;1888            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1889         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
;;;1890   
;;;1891         /* Abort DMA TX */
;;;1892         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
;;;1893         {
;;;1894           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;1895           huart->hdmatx->XferAbortCallback(huart->hdmatx);
;;;1896         }
;;;1897       }
;;;1898       else
;;;1899       {
;;;1900         /* Reset Tx transfer counter */
;;;1901         huart->TxXferCount = 0x00U;
;;;1902   
;;;1903         /* Restore huart->gState to Ready */
;;;1904         huart->gState = HAL_UART_STATE_READY;
000012  f04f0220          MOV      r2,#0x20
000016  060b              LSLS     r3,r1,#24             ;1880
000018  f04f0100          MOV      r1,#0                 ;1880
00001c  d516              BPL      |L16.76|
00001e  6943              LDR      r3,[r0,#0x14]         ;1882
000020  f0230380          BIC      r3,r3,#0x80           ;1882
000024  6143              STR      r3,[r0,#0x14]         ;1882
000026  6b20              LDR      r0,[r4,#0x30]         ;1885
000028  b148              CBZ      r0,|L16.62|
00002a  490c              LDR      r1,|L16.92|
00002c  6341              STR      r1,[r0,#0x34]         ;1889
00002e  6b20              LDR      r0,[r4,#0x30]         ;1892
000030  f7fffffe          BL       HAL_DMA_Abort_IT
000034  b180              CBZ      r0,|L16.88|
000036  6b20              LDR      r0,[r4,#0x30]         ;1895
000038  6b41              LDR      r1,[r0,#0x34]         ;1895
00003a  4788              BLX      r1                    ;1895
00003c  e00c              B        |L16.88|
                  |L16.62|
00003e  84e1              STRH     r1,[r4,#0x26]         ;1901
000040  f8842039          STRB     r2,[r4,#0x39]
;;;1905   
;;;1906         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1907   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1908         /* Call registered Abort Transmit Complete Callback */
;;;1909         huart->AbortTransmitCpltCallback(huart);
;;;1910   #else
;;;1911         /* Call legacy weak Abort Transmit Complete Callback */
;;;1912         HAL_UART_AbortTransmitCpltCallback(huart);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
00004a  e005              B        |L16.88|
                  |L16.76|
;;;1913   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1914       }
;;;1915     }
;;;1916     else
;;;1917     {
;;;1918       /* Reset Tx transfer counter */
;;;1919       huart->TxXferCount = 0x00U;
00004c  84e1              STRH     r1,[r4,#0x26]
;;;1920   
;;;1921       /* Restore huart->gState to Ready */
;;;1922       huart->gState = HAL_UART_STATE_READY;
00004e  f8842039          STRB     r2,[r4,#0x39]
;;;1923   
;;;1924       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1925   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1926       /* Call registered Abort Transmit Complete Callback */
;;;1927       huart->AbortTransmitCpltCallback(huart);
;;;1928   #else
;;;1929       /* Call legacy weak Abort Transmit Complete Callback */
;;;1930       HAL_UART_AbortTransmitCpltCallback(huart);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L16.88|
;;;1931   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1932     }
;;;1933   
;;;1934     return HAL_OK;
000058  2000              MOVS     r0,#0
;;;1935   }
00005a  bd10              POP      {r4,pc}
;;;1936   
                          ENDP

                  |L16.92|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;1745   */
;;;1746   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1747   {
000002  4604              MOV      r4,r0
;;;1748     uint32_t AbortCplt = 0x01U;
000004  2501              MOVS     r5,#1
;;;1749   
;;;1750     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1751     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000006  6820              LDR      r0,[r4,#0]
000008  68c1              LDR      r1,[r0,#0xc]
00000a  f42171f0          BIC      r1,r1,#0x1e0
00000e  60c1              STR      r1,[r0,#0xc]
;;;1752     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6941              LDR      r1,[r0,#0x14]
000014  f0210101          BIC      r1,r1,#1
000018  6141              STR      r1,[r0,#0x14]
;;;1753   
;;;1754     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;1755        before any call to DMA Abort functions */
;;;1756     /* DMA Tx Handle is valid */
;;;1757     if (huart->hdmatx != NULL)
00001a  6b20              LDR      r0,[r4,#0x30]
00001c  2600              MOVS     r6,#0
00001e  2800              CMP      r0,#0
000020  d007              BEQ      |L17.50|
;;;1758     {
;;;1759       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1760          Otherwise, set it to NULL */
;;;1761       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000022  6821              LDR      r1,[r4,#0]
000024  6949              LDR      r1,[r1,#0x14]
000026  0609              LSLS     r1,r1,#24
000028  d502              BPL      |L17.48|
;;;1762       {
;;;1763         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
00002a  4920              LDR      r1,|L17.172|
00002c  6341              STR      r1,[r0,#0x34]
00002e  e000              B        |L17.50|
                  |L17.48|
;;;1764       }
;;;1765       else
;;;1766       {
;;;1767         huart->hdmatx->XferAbortCallback = NULL;
000030  6346              STR      r6,[r0,#0x34]
                  |L17.50|
;;;1768       }
;;;1769     }
;;;1770     /* DMA Rx Handle is valid */
;;;1771     if (huart->hdmarx != NULL)
000032  6b60              LDR      r0,[r4,#0x34]
000034  b138              CBZ      r0,|L17.70|
;;;1772     {
;;;1773       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1774          Otherwise, set it to NULL */
;;;1775       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000036  6821              LDR      r1,[r4,#0]
000038  6949              LDR      r1,[r1,#0x14]
00003a  0649              LSLS     r1,r1,#25
00003c  d502              BPL      |L17.68|
;;;1776       {
;;;1777         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
00003e  491c              LDR      r1,|L17.176|
000040  6341              STR      r1,[r0,#0x34]
000042  e000              B        |L17.70|
                  |L17.68|
;;;1778       }
;;;1779       else
;;;1780       {
;;;1781         huart->hdmarx->XferAbortCallback = NULL;
000044  6346              STR      r6,[r0,#0x34]
                  |L17.70|
;;;1782       }
;;;1783     }
;;;1784   
;;;1785     /* Disable the UART DMA Tx request if enabled */
;;;1786     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000046  6820              LDR      r0,[r4,#0]
000048  6941              LDR      r1,[r0,#0x14]
00004a  0609              LSLS     r1,r1,#24
00004c  d50c              BPL      |L17.104|
;;;1787     {
;;;1788       /* Disable DMA Tx at UART level */
;;;1789       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00004e  6941              LDR      r1,[r0,#0x14]
000050  f0210180          BIC      r1,r1,#0x80
000054  6141              STR      r1,[r0,#0x14]
;;;1790   
;;;1791       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1792       if (huart->hdmatx != NULL)
000056  6b20              LDR      r0,[r4,#0x30]
000058  b130              CBZ      r0,|L17.104|
;;;1793       {
;;;1794         /* UART Tx DMA Abort callback has already been initialised :
;;;1795            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1796   
;;;1797         /* Abort DMA TX */
;;;1798         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
00005a  f7fffffe          BL       HAL_DMA_Abort_IT
00005e  b110              CBZ      r0,|L17.102|
;;;1799         {
;;;1800           huart->hdmatx->XferAbortCallback = NULL;
000060  6b20              LDR      r0,[r4,#0x30]
000062  6346              STR      r6,[r0,#0x34]
000064  e000              B        |L17.104|
                  |L17.102|
;;;1801         }
;;;1802         else
;;;1803         {
;;;1804           AbortCplt = 0x00U;
000066  2500              MOVS     r5,#0
                  |L17.104|
;;;1805         }
;;;1806       }
;;;1807     }
;;;1808   
;;;1809     /* Disable the UART DMA Rx request if enabled */
;;;1810     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000068  6820              LDR      r0,[r4,#0]
00006a  6941              LDR      r1,[r0,#0x14]
00006c  0649              LSLS     r1,r1,#25
00006e  d50d              BPL      |L17.140|
;;;1811     {
;;;1812       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000070  6941              LDR      r1,[r0,#0x14]
000072  f0210140          BIC      r1,r1,#0x40
000076  6141              STR      r1,[r0,#0x14]
;;;1813   
;;;1814       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1815       if (huart->hdmarx != NULL)
000078  6b60              LDR      r0,[r4,#0x34]
00007a  b138              CBZ      r0,|L17.140|
;;;1816       {
;;;1817         /* UART Rx DMA Abort callback has already been initialised :
;;;1818            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1819   
;;;1820         /* Abort DMA RX */
;;;1821         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
00007c  f7fffffe          BL       HAL_DMA_Abort_IT
000080  b118              CBZ      r0,|L17.138|
;;;1822         {
;;;1823           huart->hdmarx->XferAbortCallback = NULL;
000082  6b60              LDR      r0,[r4,#0x34]
000084  6346              STR      r6,[r0,#0x34]
;;;1824           AbortCplt = 0x01U;
000086  2501              MOVS     r5,#1
000088  e000              B        |L17.140|
                  |L17.138|
;;;1825         }
;;;1826         else
;;;1827         {
;;;1828           AbortCplt = 0x00U;
00008a  2500              MOVS     r5,#0
                  |L17.140|
;;;1829         }
;;;1830       }
;;;1831     }
;;;1832   
;;;1833     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1834     if (AbortCplt == 0x01U)
00008c  2d01              CMP      r5,#1
00008e  d10a              BNE      |L17.166|
;;;1835     {
;;;1836       /* Reset Tx and Rx transfer counters */
;;;1837       huart->TxXferCount = 0x00U;
000090  84e6              STRH     r6,[r4,#0x26]
;;;1838       huart->RxXferCount = 0x00U;
000092  85e6              STRH     r6,[r4,#0x2e]
;;;1839   
;;;1840       /* Reset ErrorCode */
;;;1841       huart->ErrorCode = HAL_UART_ERROR_NONE;
000094  63e6              STR      r6,[r4,#0x3c]
;;;1842   
;;;1843       /* Restore huart->gState and huart->RxState to Ready */
;;;1844       huart->gState  = HAL_UART_STATE_READY;
000096  2020              MOVS     r0,#0x20
000098  f8840039          STRB     r0,[r4,#0x39]
;;;1845       huart->RxState = HAL_UART_STATE_READY;
00009c  f884003a          STRB     r0,[r4,#0x3a]
;;;1846   
;;;1847       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1848   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1849       /* Call registered Abort complete callback */
;;;1850       huart->AbortCpltCallback(huart);
;;;1851   #else
;;;1852       /* Call legacy weak Abort complete callback */
;;;1853       HAL_UART_AbortCpltCallback(huart);
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L17.166|
;;;1854   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1855     }
;;;1856   
;;;1857     return HAL_OK;
0000a6  2000              MOVS     r0,#0
;;;1858   }
0000a8  bd70              POP      {r4-r6,pc}
;;;1859   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L17.172|
                          DCD      UART_DMATxAbortCallback
                  |L17.176|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1433     */
;;;1434   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1435   {
;;;1436     uint32_t dmarequest = 0x00U;
;;;1437   
;;;1438     /* Process Locked */
;;;1439     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00b              BEQ      |L18.32|
000008  2101              MOVS     r1,#1
00000a  f8801038          STRB     r1,[r0,#0x38]
;;;1440   
;;;1441     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
00000e  6801              LDR      r1,[r0,#0]
000010  694a              LDR      r2,[r1,#0x14]
000012  f3c212c0          UBFX     r2,r2,#7,#1
;;;1442     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000016  f8903039          LDRB     r3,[r0,#0x39]
00001a  2b21              CMP      r3,#0x21
00001c  d002              BEQ      |L18.36|
00001e  e006              B        |L18.46|
                  |L18.32|
000020  2002              MOVS     r0,#2                 ;1439
;;;1443     {
;;;1444       /* Disable the UART DMA Tx request */
;;;1445       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1446     }
;;;1447   
;;;1448     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;1449     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
;;;1450     {
;;;1451       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1452       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1453       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1454   
;;;1455       /* Disable the UART DMA Rx request */
;;;1456       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1457     }
;;;1458   
;;;1459     /* Process Unlocked */
;;;1460     __HAL_UNLOCK(huart);
;;;1461   
;;;1462     return HAL_OK;
;;;1463   }
000022  4770              BX       lr
                  |L18.36|
000024  b11a              CBZ      r2,|L18.46|
000026  694a              LDR      r2,[r1,#0x14]         ;1445
000028  f0220280          BIC      r2,r2,#0x80           ;1445
00002c  614a              STR      r2,[r1,#0x14]         ;1445
                  |L18.46|
00002e  6801              LDR      r1,[r0,#0]            ;1448
000030  694a              LDR      r2,[r1,#0x14]         ;1448
000032  f3c21280          UBFX     r2,r2,#6,#1           ;1448
000036  f890303a          LDRB     r3,[r0,#0x3a]         ;1449
00003a  2b22              CMP      r3,#0x22              ;1449
00003c  d10e              BNE      |L18.92|
00003e  b16a              CBZ      r2,|L18.92|
000040  68ca              LDR      r2,[r1,#0xc]          ;1452
000042  f4227280          BIC      r2,r2,#0x100          ;1452
000046  60ca              STR      r2,[r1,#0xc]          ;1452
000048  6801              LDR      r1,[r0,#0]            ;1453
00004a  694a              LDR      r2,[r1,#0x14]         ;1453
00004c  f0220201          BIC      r2,r2,#1              ;1453
000050  614a              STR      r2,[r1,#0x14]         ;1453
000052  6801              LDR      r1,[r0,#0]            ;1456
000054  694a              LDR      r2,[r1,#0x14]         ;1456
000056  f0220240          BIC      r2,r2,#0x40           ;1456
00005a  614a              STR      r2,[r1,#0x14]         ;1456
                  |L18.92|
00005c  2100              MOVS     r1,#0                 ;1460
00005e  f8801038          STRB     r1,[r0,#0x38]         ;1460
000062  2000              MOVS     r0,#0                 ;1462
000064  4770              BX       lr
;;;1464   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1470     */
;;;1471   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  b508              PUSH     {r3,lr}
;;;1472   {
;;;1473     /* Process Locked */
;;;1474     __HAL_LOCK(huart);
000002  f8901038          LDRB     r1,[r0,#0x38]
000006  2901              CMP      r1,#1
000008  d007              BEQ      |L19.26|
00000a  2101              MOVS     r1,#1
00000c  f8801038          STRB     r1,[r0,#0x38]
;;;1475   
;;;1476     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000010  f8901039          LDRB     r1,[r0,#0x39]
000014  2921              CMP      r1,#0x21
000016  d002              BEQ      |L19.30|
000018  e006              B        |L19.40|
                  |L19.26|
00001a  2002              MOVS     r0,#2                 ;1474
;;;1477     {
;;;1478       /* Enable the UART DMA Tx request */
;;;1479       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1480     }
;;;1481   
;;;1482     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1483     {
;;;1484       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1485       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1486   
;;;1487       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1488       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1489       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1490   
;;;1491       /* Enable the UART DMA Rx request */
;;;1492       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1493     }
;;;1494   
;;;1495     /* Process Unlocked */
;;;1496     __HAL_UNLOCK(huart);
;;;1497   
;;;1498     return HAL_OK;
;;;1499   }
00001c  bd08              POP      {r3,pc}
                  |L19.30|
00001e  6801              LDR      r1,[r0,#0]            ;1479
000020  694a              LDR      r2,[r1,#0x14]         ;1479
000022  f0420280          ORR      r2,r2,#0x80           ;1479
000026  614a              STR      r2,[r1,#0x14]         ;1479
                  |L19.40|
000028  f890103a          LDRB     r1,[r0,#0x3a]         ;1482
00002c  2200              MOVS     r2,#0                 ;1482
00002e  2922              CMP      r1,#0x22              ;1482
000030  d111              BNE      |L19.86|
000032  6801              LDR      r1,[r0,#0]            ;1485
000034  680b              LDR      r3,[r1,#0]            ;1485
000036  684b              LDR      r3,[r1,#4]            ;1485
000038  9300              STR      r3,[sp,#0]            ;1485
00003a  68cb              LDR      r3,[r1,#0xc]          ;1488
00003c  f4437380          ORR      r3,r3,#0x100          ;1488
000040  60cb              STR      r3,[r1,#0xc]          ;1488
000042  6801              LDR      r1,[r0,#0]            ;1489
000044  694b              LDR      r3,[r1,#0x14]         ;1489
000046  f0430301          ORR      r3,r3,#1              ;1489
00004a  614b              STR      r3,[r1,#0x14]         ;1489
00004c  6801              LDR      r1,[r0,#0]            ;1492
00004e  694b              LDR      r3,[r1,#0x14]         ;1492
000050  f0430340          ORR      r3,r3,#0x40           ;1492
000054  614b              STR      r3,[r1,#0x14]         ;1492
                  |L19.86|
000056  f8802038          STRB     r2,[r0,#0x38]         ;1496
00005a  2000              MOVS     r0,#0                 ;1498
00005c  bd08              POP      {r3,pc}
;;;1500   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1506     */
;;;1507   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1508   {
000002  4604              MOV      r4,r0
;;;1509     uint32_t dmarequest = 0x00U;
;;;1510     /* The Lock is not implemented on this API to allow the user application
;;;1511        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1512        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1513        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1514        */
;;;1515   
;;;1516     /* Stop UART DMA Tx request if ongoing */
;;;1517     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000004  6820              LDR      r0,[r4,#0]
000006  6941              LDR      r1,[r0,#0x14]
000008  f3c111c0          UBFX     r1,r1,#7,#1
;;;1518     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
00000c  f8942039          LDRB     r2,[r4,#0x39]
000010  2a21              CMP      r2,#0x21
000012  d10b              BNE      |L20.44|
000014  b151              CBZ      r1,|L20.44|
;;;1519     {
;;;1520       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000016  6941              LDR      r1,[r0,#0x14]
000018  f0210180          BIC      r1,r1,#0x80
00001c  6141              STR      r1,[r0,#0x14]
;;;1521   
;;;1522       /* Abort the UART DMA Tx channel */
;;;1523       if (huart->hdmatx != NULL)
00001e  6b20              LDR      r0,[r4,#0x30]
000020  b108              CBZ      r0,|L20.38|
;;;1524       {
;;;1525         HAL_DMA_Abort(huart->hdmatx);
000022  f7fffffe          BL       HAL_DMA_Abort
                  |L20.38|
;;;1526       }
;;;1527       UART_EndTxTransfer(huart);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       UART_EndTxTransfer
                  |L20.44|
;;;1528     }
;;;1529   
;;;1530     /* Stop UART DMA Rx request if ongoing */
;;;1531     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
00002c  6820              LDR      r0,[r4,#0]
00002e  6941              LDR      r1,[r0,#0x14]
000030  f3c11180          UBFX     r1,r1,#6,#1
;;;1532     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
000034  f894203a          LDRB     r2,[r4,#0x3a]
000038  2a22              CMP      r2,#0x22
00003a  d10b              BNE      |L20.84|
00003c  b151              CBZ      r1,|L20.84|
;;;1533     {
;;;1534       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00003e  6941              LDR      r1,[r0,#0x14]
000040  f0210140          BIC      r1,r1,#0x40
000044  6141              STR      r1,[r0,#0x14]
;;;1535   
;;;1536       /* Abort the UART DMA Rx channel */
;;;1537       if (huart->hdmarx != NULL)
000046  6b60              LDR      r0,[r4,#0x34]
000048  b108              CBZ      r0,|L20.78|
;;;1538       {
;;;1539         HAL_DMA_Abort(huart->hdmarx);
00004a  f7fffffe          BL       HAL_DMA_Abort
                  |L20.78|
;;;1540       }
;;;1541       UART_EndRxTransfer(huart);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       UART_EndRxTransfer
                  |L20.84|
;;;1542     }
;;;1543   
;;;1544     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1545   }
000056  bd10              POP      {r4,pc}
;;;1546   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;627      */
;;;628    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;629    {
000002  4604              MOV      r4,r0
;;;630      /* Check the UART handle allocation */
;;;631      if (huart == NULL)
000004  2c00              CMP      r4,#0
000006  d011              BEQ      |L21.44|
;;;632      {
;;;633        return HAL_ERROR;
;;;634      }
;;;635    
;;;636      /* Check the parameters */
;;;637      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;638    
;;;639      huart->gState = HAL_UART_STATE_BUSY;
000008  2024              MOVS     r0,#0x24
00000a  f8840039          STRB     r0,[r4,#0x39]
;;;640    
;;;641      /* Disable the Peripheral */
;;;642      __HAL_UART_DISABLE(huart);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f4215100          BIC      r1,r1,#0x2000
000016  60c1              STR      r1,[r0,#0xc]
;;;643    
;;;644    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;645      if (huart->MspDeInitCallback == NULL)
;;;646      {
;;;647        huart->MspDeInitCallback = HAL_UART_MspDeInit;
;;;648      }
;;;649      /* DeInit the low level hardware */
;;;650      huart->MspDeInitCallback(huart);
;;;651    #else
;;;652      /* DeInit the low level hardware */
;;;653      HAL_UART_MspDeInit(huart);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_UART_MspDeInit
;;;654    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;655    
;;;656      huart->ErrorCode = HAL_UART_ERROR_NONE;
00001e  2000              MOVS     r0,#0
000020  3438              ADDS     r4,r4,#0x38
000022  6060              STR      r0,[r4,#4]
;;;657      huart->gState = HAL_UART_STATE_RESET;
000024  7060              STRB     r0,[r4,#1]
;;;658      huart->RxState = HAL_UART_STATE_RESET;
000026  70a0              STRB     r0,[r4,#2]
;;;659    
;;;660      /* Process Unlock */
;;;661      __HAL_UNLOCK(huart);
000028  7020              STRB     r0,[r4,#0]
;;;662    
;;;663      return HAL_OK;
;;;664    }
00002a  bd10              POP      {r4,pc}
                  |L21.44|
00002c  2001              MOVS     r0,#1                 ;633
00002e  bd10              POP      {r4,pc}
;;;665    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;2226     */
;;;2227   __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2228   {
;;;2229     /* Prevent unused argument(s) compilation warning */
;;;2230     UNUSED(huart);
;;;2231     /* NOTE: This function should not be modified, when the callback is needed,
;;;2232              the HAL_UART_ErrorCallback could be implemented in the user file
;;;2233      */
;;;2234   }
;;;2235   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2497     */
;;;2498   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;2499   {
;;;2500     return huart->ErrorCode;
;;;2501   }
000002  4770              BX       lr
;;;2502   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;2482     */
;;;2483   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2484   {
;;;2485     uint32_t temp1 = 0x00U, temp2 = 0x00U;
;;;2486     temp1 = huart->gState;
000002  f8110f39          LDRB     r0,[r1,#0x39]!
;;;2487     temp2 = huart->RxState;
000006  7849              LDRB     r1,[r1,#1]
;;;2488   
;;;2489     return (HAL_UART_StateTypeDef)(temp1 | temp2);
000008  4308              ORRS     r0,r0,r1
;;;2490   }
00000a  4770              BX       lr
;;;2491   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;2020     */
;;;2021   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;2022   {
000002  4604              MOV      r4,r0
;;;2023     uint32_t isrflags   = READ_REG(huart->Instance->SR);
000004  6822              LDR      r2,[r4,#0]
000006  6810              LDR      r0,[r2,#0]
;;;2024     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
000008  68d1              LDR      r1,[r2,#0xc]
;;;2025     uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000a  6952              LDR      r2,[r2,#0x14]
;;;2026     uint32_t errorflags = 0x00U;
;;;2027     uint32_t dmarequest = 0x00U;
;;;2028   
;;;2029     /* If no error occurs */
;;;2030     errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
00000c  f000030f          AND      r3,r0,#0xf
;;;2031     if (errorflags == RESET)
000010  2b00              CMP      r3,#0
000012  d108              BNE      |L25.38|
;;;2032     {
;;;2033       /* UART in mode Receiver -------------------------------------------------*/
;;;2034       if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000014  0685              LSLS     r5,r0,#26
000016  d506              BPL      |L25.38|
000018  068d              LSLS     r5,r1,#26
00001a  d504              BPL      |L25.38|
;;;2035       {
;;;2036         UART_Receive_IT(huart);
00001c  4620              MOV      r0,r4
00001e  e8bd4070          POP      {r4-r6,lr}
000022  f7ffbffe          B.W      UART_Receive_IT
                  |L25.38|
;;;2037         return;
;;;2038       }
;;;2039     }
;;;2040   
;;;2041     /* If some errors occur */
;;;2042     if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
000026  2b00              CMP      r3,#0
000028  d05e              BEQ      |L25.232|
00002a  f0020301          AND      r3,r2,#1
00002e  f4017590          AND      r5,r1,#0x120
000032  432b              ORRS     r3,r3,r5
000034  d058              BEQ      |L25.232|
;;;2043     {
;;;2044       /* UART parity error interrupt occurred ----------------------------------*/
;;;2045       if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
000036  07c3              LSLS     r3,r0,#31
000038  d005              BEQ      |L25.70|
00003a  05cb              LSLS     r3,r1,#23
00003c  d503              BPL      |L25.70|
;;;2046       {
;;;2047         huart->ErrorCode |= HAL_UART_ERROR_PE;
00003e  6be3              LDR      r3,[r4,#0x3c]
000040  f0430301          ORR      r3,r3,#1
000044  63e3              STR      r3,[r4,#0x3c]
                  |L25.70|
;;;2048       }
;;;2049   
;;;2050       /* UART noise error interrupt occurred -----------------------------------*/
;;;2051       if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000046  0743              LSLS     r3,r0,#29
000048  d505              BPL      |L25.86|
00004a  07d3              LSLS     r3,r2,#31
00004c  d003              BEQ      |L25.86|
;;;2052       {
;;;2053         huart->ErrorCode |= HAL_UART_ERROR_NE;
00004e  6be3              LDR      r3,[r4,#0x3c]
000050  f0430302          ORR      r3,r3,#2
000054  63e3              STR      r3,[r4,#0x3c]
                  |L25.86|
;;;2054       }
;;;2055   
;;;2056       /* UART frame error interrupt occurred -----------------------------------*/
;;;2057       if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000056  0783              LSLS     r3,r0,#30
000058  d505              BPL      |L25.102|
00005a  07d3              LSLS     r3,r2,#31
00005c  d003              BEQ      |L25.102|
;;;2058       {
;;;2059         huart->ErrorCode |= HAL_UART_ERROR_FE;
00005e  6be3              LDR      r3,[r4,#0x3c]
000060  f0430304          ORR      r3,r3,#4
000064  63e3              STR      r3,[r4,#0x3c]
                  |L25.102|
;;;2060       }
;;;2061   
;;;2062       /* UART Over-Run interrupt occurred --------------------------------------*/
;;;2063       if (((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000066  0703              LSLS     r3,r0,#28
000068  d505              BPL      |L25.118|
00006a  07d2              LSLS     r2,r2,#31
00006c  d003              BEQ      |L25.118|
;;;2064       {
;;;2065         huart->ErrorCode |= HAL_UART_ERROR_ORE;
00006e  6be2              LDR      r2,[r4,#0x3c]
000070  f0420208          ORR      r2,r2,#8
000074  63e2              STR      r2,[r4,#0x3c]
                  |L25.118|
;;;2066       }
;;;2067   
;;;2068       /* Call UART Error Call back function if need be --------------------------*/
;;;2069       if (huart->ErrorCode != HAL_UART_ERROR_NONE)
000076  6be2              LDR      r2,[r4,#0x3c]
000078  2a00              CMP      r2,#0
00007a  d02a              BEQ      |L25.210|
;;;2070       {
;;;2071         /* UART in mode Receiver -----------------------------------------------*/
;;;2072         if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
00007c  0680              LSLS     r0,r0,#26
00007e  d504              BPL      |L25.138|
000080  0688              LSLS     r0,r1,#26
000082  d502              BPL      |L25.138|
;;;2073         {
;;;2074           UART_Receive_IT(huart);
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       UART_Receive_IT
                  |L25.138|
;;;2075         }
;;;2076   
;;;2077         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;2078            consider error as blocking */
;;;2079         dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
00008a  6820              LDR      r0,[r4,#0]
00008c  6940              LDR      r0,[r0,#0x14]
00008e  f3c01080          UBFX     r0,r0,#6,#1
;;;2080         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
000092  6be1              LDR      r1,[r4,#0x3c]
000094  0709              LSLS     r1,r1,#28
000096  d400              BMI      |L25.154|
000098  b300              CBZ      r0,|L25.220|
                  |L25.154|
;;;2081         {
;;;2082           /* Blocking error : transfer is aborted
;;;2083              Set the UART state ready to be able to start again the process,
;;;2084              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;2085           UART_EndRxTransfer(huart);
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       UART_EndRxTransfer
;;;2086   
;;;2087           /* Disable the UART DMA Rx request if enabled */
;;;2088           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
0000a0  6820              LDR      r0,[r4,#0]
0000a2  6941              LDR      r1,[r0,#0x14]
0000a4  0649              LSLS     r1,r1,#25
0000a6  d515              BPL      |L25.212|
;;;2089           {
;;;2090             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
0000a8  6941              LDR      r1,[r0,#0x14]
0000aa  f0210140          BIC      r1,r1,#0x40
0000ae  6141              STR      r1,[r0,#0x14]
;;;2091   
;;;2092             /* Abort the UART DMA Rx channel */
;;;2093             if (huart->hdmarx != NULL)
0000b0  6b60              LDR      r0,[r4,#0x34]
0000b2  b158              CBZ      r0,|L25.204|
;;;2094             {
;;;2095               /* Set the UART DMA Abort callback :
;;;2096                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;2097               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
0000b4  4915              LDR      r1,|L25.268|
0000b6  6341              STR      r1,[r0,#0x34]
;;;2098               if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
0000b8  6b60              LDR      r0,[r4,#0x34]
0000ba  f7fffffe          BL       HAL_DMA_Abort_IT
0000be  2800              CMP      r0,#0
0000c0  d007              BEQ      |L25.210|
;;;2099               {
;;;2100                 /* Call Directly XferAbortCallback function in case of error */
;;;2101                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
0000c2  6b60              LDR      r0,[r4,#0x34]
0000c4  6b41              LDR      r1,[r0,#0x34]
0000c6  e8bd4070          POP      {r4-r6,lr}
0000ca  4708              BX       r1
                  |L25.204|
;;;2102               }
;;;2103             }
;;;2104             else
;;;2105             {
;;;2106               /* Call user error callback */
;;;2107   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2108               /*Call registered error callback*/
;;;2109               huart->ErrorCallback(huart);
;;;2110   #else
;;;2111               /*Call legacy weak error callback*/
;;;2112               HAL_UART_ErrorCallback(huart);
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       HAL_UART_ErrorCallback
                  |L25.210|
;;;2113   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2114             }
;;;2115           }
;;;2116           else
;;;2117           {
;;;2118             /* Call user error callback */
;;;2119   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2120             /*Call registered error callback*/
;;;2121             huart->ErrorCallback(huart);
;;;2122   #else
;;;2123             /*Call legacy weak error callback*/
;;;2124             HAL_UART_ErrorCallback(huart);
;;;2125   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2126           }
;;;2127         }
;;;2128         else
;;;2129         {
;;;2130           /* Non Blocking error : transfer could go on.
;;;2131              Error is notified to user through user error callback */
;;;2132   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2133           /*Call registered error callback*/
;;;2134           huart->ErrorCallback(huart);
;;;2135   #else
;;;2136           /*Call legacy weak error callback*/
;;;2137           HAL_UART_ErrorCallback(huart);
;;;2138   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2139   
;;;2140           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2141         }
;;;2142       }
;;;2143       return;
;;;2144     } /* End if some error occurs */
;;;2145   
;;;2146     /* UART in mode Transmitter ------------------------------------------------*/
;;;2147     if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;2148     {
;;;2149       UART_Transmit_IT(huart);
;;;2150       return;
;;;2151     }
;;;2152   
;;;2153     /* UART in mode Transmitter end --------------------------------------------*/
;;;2154     if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;2155     {
;;;2156       UART_EndTransmit_IT(huart);
;;;2157       return;
;;;2158     }
;;;2159   }
0000d2  bd70              POP      {r4-r6,pc}
                  |L25.212|
0000d4  4620              MOV      r0,r4                 ;2124
0000d6  f7fffffe          BL       HAL_UART_ErrorCallback
0000da  bd70              POP      {r4-r6,pc}
                  |L25.220|
0000dc  4620              MOV      r0,r4                 ;2137
0000de  f7fffffe          BL       HAL_UART_ErrorCallback
0000e2  2000              MOVS     r0,#0                 ;2140
0000e4  63e0              STR      r0,[r4,#0x3c]         ;2140
                  |L25.230|
0000e6  bd70              POP      {r4-r6,pc}
                  |L25.232|
0000e8  0602              LSLS     r2,r0,#24             ;2147
0000ea  d506              BPL      |L25.250|
0000ec  060a              LSLS     r2,r1,#24             ;2147
0000ee  d504              BPL      |L25.250|
0000f0  4620              MOV      r0,r4                 ;2149
0000f2  e8bd4070          POP      {r4-r6,lr}            ;2149
0000f6  f7ffbffe          B.W      UART_Transmit_IT
                  |L25.250|
0000fa  0640              LSLS     r0,r0,#25             ;2154
0000fc  d5f3              BPL      |L25.230|
0000fe  0648              LSLS     r0,r1,#25             ;2154
000100  d5f1              BPL      |L25.230|
000102  4620              MOV      r0,r4                 ;2156
000104  e8bd4070          POP      {r4-r6,lr}            ;2156
000108  f7ffbffe          B.W      UART_EndTransmit_IT
;;;2160   
                          ENDP

                  |L25.268|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;313      */
;;;314    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;315    {
000002  4604              MOV      r4,r0
;;;316      /* Check the UART handle allocation */
;;;317      if (huart == NULL)
000004  2c00              CMP      r4,#0
000006  d004              BEQ      |L26.18|
;;;318      {
;;;319        return HAL_ERROR;
;;;320      }
;;;321    
;;;322      /* Check the parameters */
;;;323      if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;324      {
;;;325        /* The hardware flow control is available only for USART1, USART2 and USART3 */
;;;326        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;327        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;328      }
;;;329      else
;;;330      {
;;;331        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;332      }
;;;333      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;334    #if defined(USART_CR1_OVER8)
;;;335      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;336    #endif /* USART_CR1_OVER8 */
;;;337    
;;;338      if (huart->gState == HAL_UART_STATE_RESET)
000008  f8940039          LDRB     r0,[r4,#0x39]
00000c  2500              MOVS     r5,#0
00000e  b110              CBZ      r0,|L26.22|
000010  e006              B        |L26.32|
                  |L26.18|
000012  2001              MOVS     r0,#1                 ;319
;;;339      {
;;;340        /* Allocate lock resource and initialize it */
;;;341        huart->Lock = HAL_UNLOCKED;
;;;342    
;;;343    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;344        UART_InitCallbacksToDefault(huart);
;;;345    
;;;346        if (huart->MspInitCallback == NULL)
;;;347        {
;;;348          huart->MspInitCallback = HAL_UART_MspInit;
;;;349        }
;;;350    
;;;351        /* Init the low level hardware */
;;;352        huart->MspInitCallback(huart);
;;;353    #else
;;;354        /* Init the low level hardware : GPIO, CLOCK */
;;;355        HAL_UART_MspInit(huart);
;;;356    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;357      }
;;;358    
;;;359      huart->gState = HAL_UART_STATE_BUSY;
;;;360    
;;;361      /* Disable the peripheral */
;;;362      __HAL_UART_DISABLE(huart);
;;;363    
;;;364      /* Set the UART Communication parameters */
;;;365      UART_SetConfig(huart);
;;;366    
;;;367      /* In asynchronous mode, the following bits must be kept cleared:
;;;368         - LINEN and CLKEN bits in the USART_CR2 register,
;;;369         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;370      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;371      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;372    
;;;373      /* Enable the peripheral */
;;;374      __HAL_UART_ENABLE(huart);
;;;375    
;;;376      /* Initialize the UART state */
;;;377      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;378      huart->gState = HAL_UART_STATE_READY;
;;;379      huart->RxState = HAL_UART_STATE_READY;
;;;380    
;;;381      return HAL_OK;
;;;382    }
000014  bd70              POP      {r4-r6,pc}
                  |L26.22|
000016  f8845038          STRB     r5,[r4,#0x38]         ;341
00001a  4620              MOV      r0,r4                 ;355
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L26.32|
000020  2024              MOVS     r0,#0x24              ;359
000022  f8840039          STRB     r0,[r4,#0x39]         ;359
000026  6820              LDR      r0,[r4,#0]            ;362
000028  68c1              LDR      r1,[r0,#0xc]          ;362
00002a  f4215100          BIC      r1,r1,#0x2000         ;362
00002e  60c1              STR      r1,[r0,#0xc]          ;362
000030  4620              MOV      r0,r4                 ;365
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;370
000038  6901              LDR      r1,[r0,#0x10]         ;370
00003a  f4214190          BIC      r1,r1,#0x4800         ;370
00003e  6101              STR      r1,[r0,#0x10]         ;370
000040  6820              LDR      r0,[r4,#0]            ;371
000042  6941              LDR      r1,[r0,#0x14]         ;371
000044  f021012a          BIC      r1,r1,#0x2a           ;371
000048  6141              STR      r1,[r0,#0x14]         ;371
00004a  6820              LDR      r0,[r4,#0]            ;374
00004c  68c1              LDR      r1,[r0,#0xc]          ;374
00004e  f4415100          ORR      r1,r1,#0x2000         ;374
000052  60c1              STR      r1,[r0,#0xc]          ;374
000054  63e5              STR      r5,[r4,#0x3c]         ;377
000056  2020              MOVS     r0,#0x20              ;378
000058  f8840039          STRB     r0,[r4,#0x39]         ;378
00005c  f884003a          STRB     r0,[r4,#0x3a]         ;379
000060  2000              MOVS     r0,#0                 ;381
000062  bd70              POP      {r4-r6,pc}
;;;383    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;686      */
;;;687    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;688    {
;;;689      /* Prevent unused argument(s) compilation warning */
;;;690      UNUSED(huart);
;;;691      /* NOTE: This function should not be modified, when the callback is needed,
;;;692               the HAL_UART_MspDeInit could be implemented in the user file
;;;693       */
;;;694    }
;;;695    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;671      */
;;;672    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;673    {
;;;674      /* Prevent unused argument(s) compilation warning */
;;;675      UNUSED(huart);
;;;676      /* NOTE: This function should not be modified, when the callback is needed,
;;;677               the HAL_UART_MspInit could be implemented in the user file
;;;678       */
;;;679    }
;;;680    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;1111     */
;;;1112   HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1113   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;1114     uint16_t *tmp;
;;;1115     uint32_t tickstart = 0U;
;;;1116   
;;;1117     /* Check that a Rx process is not already ongoing */
;;;1118     if (huart->RxState == HAL_UART_STATE_READY)
00000c  f894003a          LDRB     r0,[r4,#0x3a]
000010  2820              CMP      r0,#0x20
000012  d002              BEQ      |L29.26|
;;;1119     {
;;;1120       if ((pData == NULL) || (Size == 0U))
;;;1121       {
;;;1122         return  HAL_ERROR;
;;;1123       }
;;;1124   
;;;1125       /* Process Locked */
;;;1126       __HAL_LOCK(huart);
;;;1127   
;;;1128       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1129       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1130   
;;;1131       /* Init tickstart for timeout managment */
;;;1132       tickstart = HAL_GetTick();
;;;1133   
;;;1134       huart->RxXferSize = Size;
;;;1135       huart->RxXferCount = Size;
;;;1136   
;;;1137       /* Check the remain data to be received */
;;;1138       while (huart->RxXferCount > 0U)
;;;1139       {
;;;1140         huart->RxXferCount--;
;;;1141         if (huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;1142         {
;;;1143           if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;1144           {
;;;1145             return HAL_TIMEOUT;
;;;1146           }
;;;1147           tmp = (uint16_t *) pData;
;;;1148           if (huart->Init.Parity == UART_PARITY_NONE)
;;;1149           {
;;;1150             *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;1151             pData += 2U;
;;;1152           }
;;;1153           else
;;;1154           {
;;;1155             *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;1156             pData += 1U;
;;;1157           }
;;;1158   
;;;1159         }
;;;1160         else
;;;1161         {
;;;1162           if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;1163           {
;;;1164             return HAL_TIMEOUT;
;;;1165           }
;;;1166           if (huart->Init.Parity == UART_PARITY_NONE)
;;;1167           {
;;;1168             *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;1169           }
;;;1170           else
;;;1171           {
;;;1172             *pData++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;1173           }
;;;1174   
;;;1175         }
;;;1176       }
;;;1177   
;;;1178       /* At end of Rx process, restore huart->RxState to Ready */
;;;1179       huart->RxState = HAL_UART_STATE_READY;
;;;1180   
;;;1181       /* Process Unlocked */
;;;1182       __HAL_UNLOCK(huart);
;;;1183   
;;;1184       return HAL_OK;
;;;1185     }
;;;1186     else
;;;1187     {
;;;1188       return HAL_BUSY;
000014  2002              MOVS     r0,#2
                  |L29.22|
;;;1189     }
;;;1190   }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L29.26|
00001a  b1b5              CBZ      r5,|L29.74|
00001c  f1b90f00          CMP      r9,#0                 ;1120
000020  d013              BEQ      |L29.74|
000022  f8940038          LDRB     r0,[r4,#0x38]         ;1126
000026  2801              CMP      r0,#1                 ;1126
000028  d011              BEQ      |L29.78|
00002a  2001              MOVS     r0,#1                 ;1126
00002c  f8840038          STRB     r0,[r4,#0x38]         ;1126
000030  2700              MOVS     r7,#0                 ;1128
000032  63e7              STR      r7,[r4,#0x3c]         ;1128
000034  2022              MOVS     r0,#0x22              ;1129
000036  f884003a          STRB     r0,[r4,#0x3a]         ;1129
00003a  f7fffffe          BL       HAL_GetTick
00003e  4680              MOV      r8,r0                 ;1132
000040  f8a4902c          STRH     r9,[r4,#0x2c]         ;1134
000044  f8a4902e          STRH     r9,[r4,#0x2e]         ;1135
000048  e035              B        |L29.182|
                  |L29.74|
00004a  2001              MOVS     r0,#1                 ;1122
00004c  e7e3              B        |L29.22|
                  |L29.78|
00004e  2002              MOVS     r0,#2                 ;1126
000050  e7e1              B        |L29.22|
                  |L29.82|
000052  8de0              LDRH     r0,[r4,#0x2e]         ;1140
000054  1e40              SUBS     r0,r0,#1              ;1140
000056  85e0              STRH     r0,[r4,#0x2e]         ;1140
000058  68a0              LDR      r0,[r4,#8]            ;1141
00005a  f5b05f80          CMP      r0,#0x1000            ;1141
00005e  d009              BEQ      |L29.116|
000060  4643              MOV      r3,r8                 ;1162
000062  2200              MOVS     r2,#0                 ;1162
000064  2120              MOVS     r1,#0x20              ;1162
000066  4620              MOV      r0,r4                 ;1162
000068  9600              STR      r6,[sp,#0]            ;1162
00006a  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00006e  b1d0              CBZ      r0,|L29.166|
000070  2003              MOVS     r0,#3                 ;1164
000072  e7d0              B        |L29.22|
                  |L29.116|
000074  4643              MOV      r3,r8                 ;1143
000076  2200              MOVS     r2,#0                 ;1143
000078  2120              MOVS     r1,#0x20              ;1143
00007a  4620              MOV      r0,r4                 ;1143
00007c  9600              STR      r6,[sp,#0]            ;1143
00007e  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000082  b108              CBZ      r0,|L29.136|
000084  2003              MOVS     r0,#3                 ;1145
000086  e7c6              B        |L29.22|
                  |L29.136|
000088  6920              LDR      r0,[r4,#0x10]         ;1148
00008a  b128              CBZ      r0,|L29.152|
00008c  6820              LDR      r0,[r4,#0]            ;1155
00008e  6840              LDR      r0,[r0,#4]            ;1155
000090  b2c1              UXTB     r1,r0                 ;1155
000092  8029              STRH     r1,[r5,#0]            ;1155
000094  1c6d              ADDS     r5,r5,#1              ;1156
000096  e00e              B        |L29.182|
                  |L29.152|
000098  6820              LDR      r0,[r4,#0]            ;1150
00009a  6840              LDR      r0,[r0,#4]            ;1150
00009c  f3c00108          UBFX     r1,r0,#0,#9           ;1150
0000a0  8029              STRH     r1,[r5,#0]            ;1150
0000a2  1cad              ADDS     r5,r5,#2              ;1151
0000a4  e007              B        |L29.182|
                  |L29.166|
0000a6  6920              LDR      r0,[r4,#0x10]         ;1166
0000a8  b170              CBZ      r0,|L29.200|
0000aa  6820              LDR      r0,[r4,#0]            ;1172
0000ac  6840              LDR      r0,[r0,#4]            ;1172
0000ae  f000007f          AND      r0,r0,#0x7f           ;1172
0000b2  f8050b01          STRB     r0,[r5],#1            ;1172
                  |L29.182|
0000b6  8de0              LDRH     r0,[r4,#0x2e]         ;1138
0000b8  2800              CMP      r0,#0                 ;1138
0000ba  d1ca              BNE      |L29.82|
0000bc  2020              MOVS     r0,#0x20              ;1179
0000be  3438              ADDS     r4,r4,#0x38           ;1179
0000c0  70a0              STRB     r0,[r4,#2]            ;1179
0000c2  7027              STRB     r7,[r4,#0]            ;1182
0000c4  2000              MOVS     r0,#0                 ;1184
0000c6  e7a6              B        |L29.22|
                  |L29.200|
0000c8  6820              LDR      r0,[r4,#0]            ;1168
0000ca  6840              LDR      r0,[r0,#4]            ;1168
0000cc  f8050b01          STRB     r0,[r5],#1            ;1168
0000d0  e7f1              B        |L29.182|
;;;1191   
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1366     */
;;;1367   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;1368   {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
000006  4613              MOV      r3,r2
;;;1369     uint32_t *tmp;
;;;1370   
;;;1371     /* Check that a Rx process is not already ongoing */
;;;1372     if (huart->RxState == HAL_UART_STATE_READY)
000008  f894003a          LDRB     r0,[r4,#0x3a]
00000c  2820              CMP      r0,#0x20
00000e  d002              BEQ      |L30.22|
;;;1373     {
;;;1374       if ((pData == NULL) || (Size == 0U))
;;;1375       {
;;;1376         return HAL_ERROR;
;;;1377       }
;;;1378   
;;;1379       /* Process Locked */
;;;1380       __HAL_LOCK(huart);
;;;1381   
;;;1382       huart->pRxBuffPtr = pData;
;;;1383       huart->RxXferSize = Size;
;;;1384   
;;;1385       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1386       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1387   
;;;1388       /* Set the UART DMA transfer complete callback */
;;;1389       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;1390   
;;;1391       /* Set the UART DMA Half transfer complete callback */
;;;1392       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1393   
;;;1394       /* Set the DMA error callback */
;;;1395       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1396   
;;;1397       /* Set the DMA abort callback */
;;;1398       huart->hdmarx->XferAbortCallback = NULL;
;;;1399   
;;;1400       /* Enable the DMA channel */
;;;1401       tmp = (uint32_t *)&pData;
;;;1402       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
;;;1403   
;;;1404       /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
;;;1405       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1406   
;;;1407       /* Process Unlocked */
;;;1408       __HAL_UNLOCK(huart);
;;;1409   
;;;1410       /* Enable the UART Parity Error Interrupt */
;;;1411       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1412   
;;;1413       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1414       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1415   
;;;1416       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1417       in the UART CR3 register */
;;;1418       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1419   
;;;1420       return HAL_OK;
;;;1421     }
;;;1422     else
;;;1423     {
;;;1424       return HAL_BUSY;
000010  2002              MOVS     r0,#2
                  |L30.18|
;;;1425     }
;;;1426   }
000012  b005              ADD      sp,sp,#0x14
000014  bd30              POP      {r4,r5,pc}
                  |L30.22|
000016  9a03              LDR      r2,[sp,#0xc]          ;1374
000018  b3a2              CBZ      r2,|L30.132|
00001a  b39b              CBZ      r3,|L30.132|
00001c  f8940038          LDRB     r0,[r4,#0x38]         ;1380
000020  2801              CMP      r0,#1                 ;1380
000022  d032              BEQ      |L30.138|
000024  2001              MOVS     r0,#1                 ;1380
000026  f8840038          STRB     r0,[r4,#0x38]         ;1380
00002a  62a2              STR      r2,[r4,#0x28]         ;1382
00002c  85a3              STRH     r3,[r4,#0x2c]         ;1383
00002e  2500              MOVS     r5,#0                 ;1385
000030  63e5              STR      r5,[r4,#0x3c]         ;1385
000032  2022              MOVS     r0,#0x22              ;1386
000034  f884003a          STRB     r0,[r4,#0x3a]         ;1386
000038  6b61              LDR      r1,[r4,#0x34]         ;1389
00003a  4815              LDR      r0,|L30.144|
00003c  6288              STR      r0,[r1,#0x28]         ;1389
00003e  6b61              LDR      r1,[r4,#0x34]         ;1392
000040  4814              LDR      r0,|L30.148|
000042  62c8              STR      r0,[r1,#0x2c]         ;1392
000044  6b61              LDR      r1,[r4,#0x34]         ;1395
000046  4814              LDR      r0,|L30.152|
000048  6308              STR      r0,[r1,#0x30]         ;1395
00004a  6b60              LDR      r0,[r4,#0x34]         ;1398
00004c  6345              STR      r5,[r0,#0x34]         ;1398
00004e  6821              LDR      r1,[r4,#0]            ;1402
000050  6b60              LDR      r0,[r4,#0x34]         ;1402
000052  1d09              ADDS     r1,r1,#4              ;1402
000054  f7fffffe          BL       HAL_DMA_Start_IT
000058  6820              LDR      r0,[r4,#0]            ;1405
00005a  6801              LDR      r1,[r0,#0]            ;1405
00005c  6841              LDR      r1,[r0,#4]            ;1405
00005e  9101              STR      r1,[sp,#4]            ;1405
000060  f8845038          STRB     r5,[r4,#0x38]         ;1408
000064  68c1              LDR      r1,[r0,#0xc]          ;1411
000066  f4417180          ORR      r1,r1,#0x100          ;1411
00006a  60c1              STR      r1,[r0,#0xc]          ;1411
00006c  6820              LDR      r0,[r4,#0]            ;1414
00006e  6941              LDR      r1,[r0,#0x14]         ;1414
000070  f0410101          ORR      r1,r1,#1              ;1414
000074  6141              STR      r1,[r0,#0x14]         ;1414
000076  6820              LDR      r0,[r4,#0]            ;1418
000078  6941              LDR      r1,[r0,#0x14]         ;1418
00007a  f0410140          ORR      r1,r1,#0x40           ;1418
00007e  6141              STR      r1,[r0,#0x14]         ;1418
000080  2000              MOVS     r0,#0                 ;1420
000082  e7c6              B        |L30.18|
                  |L30.132|
000084  e7ff              B        |L30.134|
                  |L30.134|
000086  2001              MOVS     r0,#1                 ;1376
000088  e7c3              B        |L30.18|
                  |L30.138|
00008a  2002              MOVS     r0,#2                 ;1380
00008c  e7c1              B        |L30.18|
;;;1427   
                          ENDP

00008e  0000              DCW      0x0000
                  |L30.144|
                          DCD      UART_DMAReceiveCplt
                  |L30.148|
                          DCD      UART_DMARxHalfCplt
                  |L30.152|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;1247     */
;;;1248   HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  f890303a          LDRB     r3,[r0,#0x3a]
;;;1249   {
;;;1250     /* Check that a Rx process is not already ongoing */
;;;1251     if (huart->RxState == HAL_UART_STATE_READY)
000004  2b20              CMP      r3,#0x20
000006  d001              BEQ      |L31.12|
;;;1252     {
;;;1253       if ((pData == NULL) || (Size == 0U))
;;;1254       {
;;;1255         return HAL_ERROR;
;;;1256       }
;;;1257   
;;;1258       /* Process Locked */
;;;1259       __HAL_LOCK(huart);
;;;1260   
;;;1261       huart->pRxBuffPtr = pData;
;;;1262       huart->RxXferSize = Size;
;;;1263       huart->RxXferCount = Size;
;;;1264   
;;;1265       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1266       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1267   
;;;1268       /* Process Unlocked */
;;;1269       __HAL_UNLOCK(huart);
;;;1270   
;;;1271       /* Enable the UART Parity Error Interrupt */
;;;1272       __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
;;;1273   
;;;1274       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1275       __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
;;;1276   
;;;1277       /* Enable the UART Data Register not empty Interrupt */
;;;1278       __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
;;;1279   
;;;1280       return HAL_OK;
;;;1281     }
;;;1282     else
;;;1283     {
;;;1284       return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;1285     }
;;;1286   }
00000a  4770              BX       lr
                  |L31.12|
00000c  b1f9              CBZ      r1,|L31.78|
00000e  b1f2              CBZ      r2,|L31.78|
000010  f8903038          LDRB     r3,[r0,#0x38]         ;1259
000014  2b01              CMP      r3,#1                 ;1259
000016  d01c              BEQ      |L31.82|
000018  6281              STR      r1,[r0,#0x28]         ;1261
00001a  8582              STRH     r2,[r0,#0x2c]         ;1262
00001c  85c2              STRH     r2,[r0,#0x2e]         ;1263
00001e  2100              MOVS     r1,#0                 ;1265
000020  63c1              STR      r1,[r0,#0x3c]         ;1265
000022  2222              MOVS     r2,#0x22              ;1266
000024  f880203a          STRB     r2,[r0,#0x3a]         ;1266
000028  f8801038          STRB     r1,[r0,#0x38]         ;1269
00002c  6801              LDR      r1,[r0,#0]            ;1272
00002e  68ca              LDR      r2,[r1,#0xc]          ;1272
000030  f4427280          ORR      r2,r2,#0x100          ;1272
000034  60ca              STR      r2,[r1,#0xc]          ;1272
000036  6801              LDR      r1,[r0,#0]            ;1275
000038  694a              LDR      r2,[r1,#0x14]         ;1275
00003a  f0420201          ORR      r2,r2,#1              ;1275
00003e  614a              STR      r2,[r1,#0x14]         ;1275
000040  6800              LDR      r0,[r0,#0]            ;1278
000042  68c1              LDR      r1,[r0,#0xc]          ;1278
000044  f0410120          ORR      r1,r1,#0x20           ;1278
000048  60c1              STR      r1,[r0,#0xc]          ;1278
00004a  2000              MOVS     r0,#0                 ;1280
00004c  4770              BX       lr
                  |L31.78|
00004e  2001              MOVS     r0,#1                 ;1255
000050  4770              BX       lr
                  |L31.82|
000052  2002              MOVS     r0,#2                 ;1259
000054  4770              BX       lr
;;;1287   
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;2196     */
;;;2197   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2198   {
;;;2199     /* Prevent unused argument(s) compilation warning */
;;;2200     UNUSED(huart);
;;;2201     /* NOTE: This function should not be modified, when the callback is needed,
;;;2202              the HAL_UART_RxCpltCallback could be implemented in the user file
;;;2203      */
;;;2204   }
;;;2205   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;2211     */
;;;2212   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2213   {
;;;2214     /* Prevent unused argument(s) compilation warning */
;;;2215     UNUSED(huart);
;;;2216     /* NOTE: This function should not be modified, when the callback is needed,
;;;2217              the HAL_UART_RxHalfCpltCallback could be implemented in the user file
;;;2218      */
;;;2219   }
;;;2220   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;1026     */
;;;1027   HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1028   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4691              MOV      r9,r2
00000a  461e              MOV      r6,r3
;;;1029     uint16_t *tmp;
;;;1030     uint32_t tickstart = 0U;
;;;1031   
;;;1032     /* Check that a Tx process is not already ongoing */
;;;1033     if (huart->gState == HAL_UART_STATE_READY)
00000c  f8940039          LDRB     r0,[r4,#0x39]
000010  2820              CMP      r0,#0x20
000012  d002              BEQ      |L34.26|
;;;1034     {
;;;1035       if ((pData == NULL) || (Size == 0U))
;;;1036       {
;;;1037         return  HAL_ERROR;
;;;1038       }
;;;1039   
;;;1040       /* Process Locked */
;;;1041       __HAL_LOCK(huart);
;;;1042   
;;;1043       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1044       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1045   
;;;1046       /* Init tickstart for timeout managment */
;;;1047       tickstart = HAL_GetTick();
;;;1048   
;;;1049       huart->TxXferSize = Size;
;;;1050       huart->TxXferCount = Size;
;;;1051       while (huart->TxXferCount > 0U)
;;;1052       {
;;;1053         huart->TxXferCount--;
;;;1054         if (huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;1055         {
;;;1056           if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;1057           {
;;;1058             return HAL_TIMEOUT;
;;;1059           }
;;;1060           tmp = (uint16_t *) pData;
;;;1061           huart->Instance->DR = (*tmp & (uint16_t)0x01FF);
;;;1062           if (huart->Init.Parity == UART_PARITY_NONE)
;;;1063           {
;;;1064             pData += 2U;
;;;1065           }
;;;1066           else
;;;1067           {
;;;1068             pData += 1U;
;;;1069           }
;;;1070         }
;;;1071         else
;;;1072         {
;;;1073           if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;1074           {
;;;1075             return HAL_TIMEOUT;
;;;1076           }
;;;1077           huart->Instance->DR = (*pData++ & (uint8_t)0xFF);
;;;1078         }
;;;1079       }
;;;1080   
;;;1081       if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;1082       {
;;;1083         return HAL_TIMEOUT;
;;;1084       }
;;;1085   
;;;1086       /* At end of Tx process, restore huart->gState to Ready */
;;;1087       huart->gState = HAL_UART_STATE_READY;
;;;1088   
;;;1089       /* Process Unlocked */
;;;1090       __HAL_UNLOCK(huart);
;;;1091   
;;;1092       return HAL_OK;
;;;1093     }
;;;1094     else
;;;1095     {
;;;1096       return HAL_BUSY;
000014  2002              MOVS     r0,#2
                  |L34.22|
;;;1097     }
;;;1098   }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L34.26|
00001a  b1b5              CBZ      r5,|L34.74|
00001c  f1b90f00          CMP      r9,#0                 ;1035
000020  d013              BEQ      |L34.74|
000022  f8940038          LDRB     r0,[r4,#0x38]         ;1041
000026  2801              CMP      r0,#1                 ;1041
000028  d011              BEQ      |L34.78|
00002a  2001              MOVS     r0,#1                 ;1041
00002c  f8840038          STRB     r0,[r4,#0x38]         ;1041
000030  2700              MOVS     r7,#0                 ;1043
000032  63e7              STR      r7,[r4,#0x3c]         ;1043
000034  2021              MOVS     r0,#0x21              ;1044
000036  f8840039          STRB     r0,[r4,#0x39]         ;1044
00003a  f7fffffe          BL       HAL_GetTick
00003e  4680              MOV      r8,r0                 ;1047
000040  f8a49024          STRH     r9,[r4,#0x24]         ;1049
000044  f8a49026          STRH     r9,[r4,#0x26]         ;1050
000048  e02d              B        |L34.166|
                  |L34.74|
00004a  2001              MOVS     r0,#1                 ;1037
00004c  e7e3              B        |L34.22|
                  |L34.78|
00004e  2002              MOVS     r0,#2                 ;1041
000050  e7e1              B        |L34.22|
                  |L34.82|
000052  8ce0              LDRH     r0,[r4,#0x26]         ;1053
000054  1e40              SUBS     r0,r0,#1              ;1053
000056  84e0              STRH     r0,[r4,#0x26]         ;1053
000058  68a0              LDR      r0,[r4,#8]            ;1054
00005a  f5b05f80          CMP      r0,#0x1000            ;1054
00005e  d009              BEQ      |L34.116|
000060  4643              MOV      r3,r8                 ;1073
000062  2200              MOVS     r2,#0                 ;1073
000064  2180              MOVS     r1,#0x80              ;1073
000066  4620              MOV      r0,r4                 ;1073
000068  9600              STR      r6,[sp,#0]            ;1073
00006a  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
00006e  b1b0              CBZ      r0,|L34.158|
000070  2003              MOVS     r0,#3                 ;1075
000072  e7d0              B        |L34.22|
                  |L34.116|
000074  4643              MOV      r3,r8                 ;1056
000076  2200              MOVS     r2,#0                 ;1056
000078  2180              MOVS     r1,#0x80              ;1056
00007a  4620              MOV      r0,r4                 ;1056
00007c  9600              STR      r6,[sp,#0]            ;1056
00007e  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000082  b108              CBZ      r0,|L34.136|
000084  2003              MOVS     r0,#3                 ;1058
000086  e7c6              B        |L34.22|
                  |L34.136|
000088  8828              LDRH     r0,[r5,#0]            ;1061
00008a  6821              LDR      r1,[r4,#0]            ;1061
00008c  f3c00008          UBFX     r0,r0,#0,#9           ;1061
000090  6048              STR      r0,[r1,#4]            ;1061
000092  6920              LDR      r0,[r4,#0x10]         ;1062
000094  b108              CBZ      r0,|L34.154|
000096  1c6d              ADDS     r5,r5,#1              ;1068
000098  e005              B        |L34.166|
                  |L34.154|
00009a  1cad              ADDS     r5,r5,#2              ;1064
00009c  e003              B        |L34.166|
                  |L34.158|
00009e  6821              LDR      r1,[r4,#0]            ;1077
0000a0  f8150b01          LDRB     r0,[r5],#1            ;1077
0000a4  6048              STR      r0,[r1,#4]            ;1077
                  |L34.166|
0000a6  8ce0              LDRH     r0,[r4,#0x26]         ;1051
0000a8  2800              CMP      r0,#0                 ;1051
0000aa  d1d2              BNE      |L34.82|
0000ac  4643              MOV      r3,r8                 ;1081
0000ae  2200              MOVS     r2,#0                 ;1081
0000b0  2140              MOVS     r1,#0x40              ;1081
0000b2  4620              MOV      r0,r4                 ;1081
0000b4  9600              STR      r6,[sp,#0]            ;1081
0000b6  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000ba  b108              CBZ      r0,|L34.192|
0000bc  2003              MOVS     r0,#3                 ;1083
0000be  e7aa              B        |L34.22|
                  |L34.192|
0000c0  2020              MOVS     r0,#0x20              ;1087
0000c2  3438              ADDS     r4,r4,#0x38           ;1087
0000c4  7060              STRB     r0,[r4,#1]            ;1087
0000c6  7027              STRB     r7,[r4,#0]            ;1090
0000c8  2000              MOVS     r0,#0                 ;1092
0000ca  e7a4              B        |L34.22|
;;;1099   
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;1298     */
;;;1299   HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1300   {
000002  4604              MOV      r4,r0
;;;1301     uint32_t *tmp;
;;;1302   
;;;1303     /* Check that a Tx process is not already ongoing */
;;;1304     if (huart->gState == HAL_UART_STATE_READY)
000004  f8940039          LDRB     r0,[r4,#0x39]
000008  2820              CMP      r0,#0x20
00000a  d001              BEQ      |L35.16|
;;;1305     {
;;;1306       if ((pData == NULL) || (Size == 0U))
;;;1307       {
;;;1308         return HAL_ERROR;
;;;1309       }
;;;1310   
;;;1311       /* Process Locked */
;;;1312       __HAL_LOCK(huart);
;;;1313   
;;;1314       huart->pTxBuffPtr = pData;
;;;1315       huart->TxXferSize = Size;
;;;1316       huart->TxXferCount = Size;
;;;1317   
;;;1318       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1319       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1320   
;;;1321       /* Set the UART DMA transfer complete callback */
;;;1322       huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;1323   
;;;1324       /* Set the UART DMA Half transfer complete callback */
;;;1325       huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;1326   
;;;1327       /* Set the DMA error callback */
;;;1328       huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;1329   
;;;1330       /* Set the DMA abort callback */
;;;1331       huart->hdmatx->XferAbortCallback = NULL;
;;;1332   
;;;1333       /* Enable the UART transmit DMA channel */
;;;1334       tmp = (uint32_t *)&pData;
;;;1335       HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
;;;1336   
;;;1337       /* Clear the TC flag in the SR register by writing 0 to it */
;;;1338       __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
;;;1339   
;;;1340       /* Process Unlocked */
;;;1341       __HAL_UNLOCK(huart);
;;;1342   
;;;1343       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1344          in the UART CR3 register */
;;;1345       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1346   
;;;1347       return HAL_OK;
;;;1348     }
;;;1349     else
;;;1350     {
;;;1351       return HAL_BUSY;
00000c  2002              MOVS     r0,#2
;;;1352     }
;;;1353   }
00000e  bdfe              POP      {r1-r7,pc}
                  |L35.16|
000010  9901              LDR      r1,[sp,#4]            ;1306
000012  b379              CBZ      r1,|L35.116|
000014  b372              CBZ      r2,|L35.116|
000016  f8940038          LDRB     r0,[r4,#0x38]         ;1312
00001a  2801              CMP      r0,#1                 ;1312
00001c  d02d              BEQ      |L35.122|
00001e  2001              MOVS     r0,#1                 ;1312
000020  f8840038          STRB     r0,[r4,#0x38]         ;1312
000024  6221              STR      r1,[r4,#0x20]         ;1314
000026  84a2              STRH     r2,[r4,#0x24]         ;1315
000028  84e2              STRH     r2,[r4,#0x26]         ;1316
00002a  2500              MOVS     r5,#0                 ;1318
00002c  63e5              STR      r5,[r4,#0x3c]         ;1318
00002e  2021              MOVS     r0,#0x21              ;1319
000030  f8840039          STRB     r0,[r4,#0x39]         ;1319
000034  6b23              LDR      r3,[r4,#0x30]         ;1322
000036  4812              LDR      r0,|L35.128|
000038  6298              STR      r0,[r3,#0x28]         ;1322
00003a  6b23              LDR      r3,[r4,#0x30]         ;1325
00003c  4811              LDR      r0,|L35.132|
00003e  62d8              STR      r0,[r3,#0x2c]         ;1325
000040  6b23              LDR      r3,[r4,#0x30]         ;1328
000042  4811              LDR      r0,|L35.136|
000044  6318              STR      r0,[r3,#0x30]         ;1328
000046  6b20              LDR      r0,[r4,#0x30]         ;1331
000048  6345              STR      r5,[r0,#0x34]         ;1331
00004a  6820              LDR      r0,[r4,#0]            ;1335
00004c  4613              MOV      r3,r2                 ;1335
00004e  1d00              ADDS     r0,r0,#4              ;1335
000050  6b26              LDR      r6,[r4,#0x30]         ;1335
000052  4602              MOV      r2,r0                 ;1335
000054  4630              MOV      r0,r6                 ;1335
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6821              LDR      r1,[r4,#0]            ;1338
00005c  f06f0040          MVN      r0,#0x40              ;1338
000060  6008              STR      r0,[r1,#0]            ;1338
000062  f8845038          STRB     r5,[r4,#0x38]         ;1341
000066  6820              LDR      r0,[r4,#0]            ;1345
000068  6941              LDR      r1,[r0,#0x14]         ;1345
00006a  f0410180          ORR      r1,r1,#0x80           ;1345
00006e  6141              STR      r1,[r0,#0x14]         ;1345
000070  2000              MOVS     r0,#0                 ;1347
                  |L35.114|
000072  bdfe              POP      {r1-r7,pc}
                  |L35.116|
000074  e7ff              B        |L35.118|
                  |L35.118|
000076  2001              MOVS     r0,#1                 ;1308
000078  e7fb              B        |L35.114|
                  |L35.122|
00007a  2002              MOVS     r0,#2                 ;1312
00007c  e7f9              B        |L35.114|
;;;1354   
                          ENDP

00007e  0000              DCW      0x0000
                  |L35.128|
                          DCD      UART_DMATransmitCplt
                  |L35.132|
                          DCD      UART_DMATxHalfCplt
                  |L35.136|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;1202     */
;;;1203   HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  f8903039          LDRB     r3,[r0,#0x39]
;;;1204   {
;;;1205     /* Check that a Tx process is not already ongoing */
;;;1206     if (huart->gState == HAL_UART_STATE_READY)
000004  2b20              CMP      r3,#0x20
000006  d001              BEQ      |L36.12|
;;;1207     {
;;;1208       if ((pData == NULL) || (Size == 0U))
;;;1209       {
;;;1210         return HAL_ERROR;
;;;1211       }
;;;1212   
;;;1213       /* Process Locked */
;;;1214       __HAL_LOCK(huart);
;;;1215   
;;;1216       huart->pTxBuffPtr = pData;
;;;1217       huart->TxXferSize = Size;
;;;1218       huart->TxXferCount = Size;
;;;1219   
;;;1220       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1221       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1222   
;;;1223       /* Process Unlocked */
;;;1224       __HAL_UNLOCK(huart);
;;;1225   
;;;1226       /* Enable the UART Transmit data register empty Interrupt */
;;;1227       __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
;;;1228   
;;;1229       return HAL_OK;
;;;1230     }
;;;1231     else
;;;1232     {
;;;1233       return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;1234     }
;;;1235   }
00000a  4770              BX       lr
                  |L36.12|
00000c  b1a9              CBZ      r1,|L36.58|
00000e  b1a2              CBZ      r2,|L36.58|
000010  f8903038          LDRB     r3,[r0,#0x38]         ;1214
000014  2b01              CMP      r3,#1                 ;1214
000016  d012              BEQ      |L36.62|
000018  6201              STR      r1,[r0,#0x20]         ;1216
00001a  8482              STRH     r2,[r0,#0x24]         ;1217
00001c  84c2              STRH     r2,[r0,#0x26]         ;1218
00001e  2100              MOVS     r1,#0                 ;1220
000020  63c1              STR      r1,[r0,#0x3c]         ;1220
000022  2221              MOVS     r2,#0x21              ;1221
000024  f8802039          STRB     r2,[r0,#0x39]         ;1221
000028  f8801038          STRB     r1,[r0,#0x38]         ;1224
00002c  6800              LDR      r0,[r0,#0]            ;1227
00002e  68c1              LDR      r1,[r0,#0xc]          ;1227
000030  f0410180          ORR      r1,r1,#0x80           ;1227
000034  60c1              STR      r1,[r0,#0xc]          ;1227
000036  2000              MOVS     r0,#0                 ;1229
000038  4770              BX       lr
                  |L36.58|
00003a  2001              MOVS     r0,#1                 ;1210
00003c  4770              BX       lr
                  |L36.62|
00003e  2002              MOVS     r0,#2                 ;1214
000040  4770              BX       lr
;;;1236   
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;2166     */
;;;2167   __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2168   {
;;;2169     /* Prevent unused argument(s) compilation warning */
;;;2170     UNUSED(huart);
;;;2171     /* NOTE: This function should not be modified, when the callback is needed,
;;;2172              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;2173      */
;;;2174   }
;;;2175   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;2181     */
;;;2182   __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2183   {
;;;2184     /* Prevent unused argument(s) compilation warning */
;;;2185     UNUSED(huart);
;;;2186     /* NOTE: This function should not be modified, when the callback is needed,
;;;2187              the HAL_UART_TxHalfCpltCallback could be implemented in the user file
;;;2188      */
;;;2189   }
;;;2190   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;2752     */
;;;2753   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2754   {
;;;2755     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2756     huart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;2757     huart->TxXferCount = 0x00U;
000008  84c1              STRH     r1,[r0,#0x26]
;;;2758   
;;;2759   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2760     /*Call registered error callback*/
;;;2761     huart->ErrorCallback(huart);
;;;2762   #else
;;;2763     /*Call legacy weak error callback*/
;;;2764     HAL_UART_ErrorCallback(huart);
00000a  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2765   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2766   }
00000e  bd10              POP      {r4,pc}
;;;2767   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;2648     */
;;;2649   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2650   {
;;;2651     uint32_t dmarequest = 0x00U;
;;;2652     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a44              LDR      r4,[r0,#0x24]
;;;2653   
;;;2654     /* Stop UART DMA Tx request if ongoing */
;;;2655     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000004  6820              LDR      r0,[r4,#0]
000006  6940              LDR      r0,[r0,#0x14]
000008  f3c010c0          UBFX     r0,r0,#7,#1
;;;2656     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
00000c  f8941039          LDRB     r1,[r4,#0x39]
000010  2500              MOVS     r5,#0
000012  2921              CMP      r1,#0x21
000014  d104              BNE      |L40.32|
000016  b118              CBZ      r0,|L40.32|
;;;2657     {
;;;2658       huart->TxXferCount = 0x00U;
000018  84e5              STRH     r5,[r4,#0x26]
;;;2659       UART_EndTxTransfer(huart);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       UART_EndTxTransfer
                  |L40.32|
;;;2660     }
;;;2661   
;;;2662     /* Stop UART DMA Rx request if ongoing */
;;;2663     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000020  6820              LDR      r0,[r4,#0]
000022  6940              LDR      r0,[r0,#0x14]
000024  f3c01080          UBFX     r0,r0,#6,#1
;;;2664     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
000028  f894103a          LDRB     r1,[r4,#0x3a]
00002c  2922              CMP      r1,#0x22
00002e  d104              BNE      |L40.58|
000030  b118              CBZ      r0,|L40.58|
;;;2665     {
;;;2666       huart->RxXferCount = 0x00U;
000032  85e5              STRH     r5,[r4,#0x2e]
;;;2667       UART_EndRxTransfer(huart);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       UART_EndRxTransfer
                  |L40.58|
;;;2668     }
;;;2669   
;;;2670     huart->ErrorCode |= HAL_UART_ERROR_DMA;
00003a  6be0              LDR      r0,[r4,#0x3c]
00003c  f0400010          ORR      r0,r0,#0x10
000040  63e0              STR      r0,[r4,#0x3c]
;;;2671   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2672     /*Call registered error callback*/
;;;2673     huart->ErrorCallback(huart);
;;;2674   #else
;;;2675     /*Call legacy weak error callback*/
;;;2676     HAL_UART_ErrorCallback(huart);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2677   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2678   }
000048  bd70              POP      {r4-r6,pc}
;;;2679   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;2595     */
;;;2596   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2597   {
000002  4601              MOV      r1,r0
;;;2598     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6a48              LDR      r0,[r1,#0x24]
;;;2599     /* DMA Normal mode*/
;;;2600     if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d413              BMI      |L41.54|
;;;2601     {
;;;2602       huart->RxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  85c1              STRH     r1,[r0,#0x2e]
;;;2603   
;;;2604       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2605       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000012  6801              LDR      r1,[r0,#0]
000014  68ca              LDR      r2,[r1,#0xc]
000016  f4227280          BIC      r2,r2,#0x100
00001a  60ca              STR      r2,[r1,#0xc]
;;;2606       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00001c  6801              LDR      r1,[r0,#0]
00001e  694a              LDR      r2,[r1,#0x14]
000020  f0220201          BIC      r2,r2,#1
000024  614a              STR      r2,[r1,#0x14]
;;;2607   
;;;2608       /* Disable the DMA transfer for the receiver request by setting the DMAR bit
;;;2609          in the UART CR3 register */
;;;2610       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000026  6801              LDR      r1,[r0,#0]
000028  694a              LDR      r2,[r1,#0x14]
00002a  f0220240          BIC      r2,r2,#0x40
00002e  614a              STR      r2,[r1,#0x14]
;;;2611   
;;;2612       /* At end of Rx process, restore huart->RxState to Ready */
;;;2613       huart->RxState = HAL_UART_STATE_READY;
000030  2120              MOVS     r1,#0x20
000032  f880103a          STRB     r1,[r0,#0x3a]
                  |L41.54|
;;;2614     }
;;;2615   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2616     /*Call registered Rx complete callback*/
;;;2617     huart->RxCpltCallback(huart);
;;;2618   #else
;;;2619     /*Call legacy weak Rx complete callback*/
;;;2620     HAL_UART_RxCpltCallback(huart);
000036  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;2621   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2622   }
00003a  bd10              POP      {r4,pc}
;;;2623   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;2821     */
;;;2822   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2823   {
;;;2824     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2825   
;;;2826     huart->hdmarx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6b41              LDR      r1,[r0,#0x34]
000008  634a              STR      r2,[r1,#0x34]
;;;2827   
;;;2828     /* Check if an Abort process is still ongoing */
;;;2829     if (huart->hdmatx != NULL)
00000a  6b01              LDR      r1,[r0,#0x30]
00000c  2900              CMP      r1,#0
00000e  d002              BEQ      |L42.22|
;;;2830     {
;;;2831       if (huart->hdmatx->XferAbortCallback != NULL)
000010  6b49              LDR      r1,[r1,#0x34]
000012  2900              CMP      r1,#0
000014  d109              BNE      |L42.42|
                  |L42.22|
;;;2832       {
;;;2833         return;
;;;2834       }
;;;2835     }
;;;2836   
;;;2837     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2838     huart->TxXferCount = 0x00U;
000016  84c2              STRH     r2,[r0,#0x26]
;;;2839     huart->RxXferCount = 0x00U;
000018  85c2              STRH     r2,[r0,#0x2e]
;;;2840   
;;;2841     /* Reset ErrorCode */
;;;2842     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001a  63c2              STR      r2,[r0,#0x3c]
;;;2843   
;;;2844     /* Restore huart->gState and huart->RxState to Ready */
;;;2845     huart->gState  = HAL_UART_STATE_READY;
00001c  2120              MOVS     r1,#0x20
00001e  f8801039          STRB     r1,[r0,#0x39]
;;;2846     huart->RxState = HAL_UART_STATE_READY;
000022  f880103a          STRB     r1,[r0,#0x3a]
;;;2847   
;;;2848     /* Call user Abort complete callback */
;;;2849   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2850     /* Call registered Abort complete callback */
;;;2851     huart->AbortCpltCallback(huart);
;;;2852   #else
;;;2853     /* Call legacy weak Abort complete callback */
;;;2854     HAL_UART_AbortCpltCallback(huart);
000026  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L42.42|
;;;2855   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2856   }
00002a  bd10              POP      {r4,pc}
;;;2857   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;2629     */
;;;2630   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2631   {
;;;2632     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2633   
;;;2634   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2635     /*Call registered Rx Half complete callback*/
;;;2636     huart->RxHalfCpltCallback(huart);
;;;2637   #else
;;;2638     /*Call legacy weak Rx Half complete callback*/
;;;2639     HAL_UART_RxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;2640   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2641   }
000008  bd10              POP      {r4,pc}
;;;2642   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;2894     */
;;;2895   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2896   {
;;;2897     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2898   
;;;2899     huart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;2900   
;;;2901     /* Restore huart->RxState to Ready */
;;;2902     huart->RxState = HAL_UART_STATE_READY;
000008  2120              MOVS     r1,#0x20
00000a  f880103a          STRB     r1,[r0,#0x3a]
;;;2903   
;;;2904     /* Call user Abort complete callback */
;;;2905   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2906     /* Call registered Abort Receive Complete Callback */
;;;2907     huart->AbortReceiveCpltCallback(huart);
;;;2908   #else
;;;2909     /* Call legacy weak Abort Receive Complete Callback */
;;;2910     HAL_UART_AbortReceiveCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;2911   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2912   }
000012  bd10              POP      {r4,pc}
;;;2913   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;2541     */
;;;2542   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2543   {
000002  4601              MOV      r1,r0
;;;2544     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6a48              LDR      r0,[r1,#0x24]
;;;2545     /* DMA Normal mode*/
;;;2546     if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d40c              BMI      |L45.40|
;;;2547     {
;;;2548       huart->TxXferCount = 0x00U;
00000e  2100              MOVS     r1,#0
000010  84c1              STRH     r1,[r0,#0x26]
;;;2549   
;;;2550       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;2551          in the UART CR3 register */
;;;2552       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000012  6801              LDR      r1,[r0,#0]
000014  694a              LDR      r2,[r1,#0x14]
000016  f0220280          BIC      r2,r2,#0x80
00001a  614a              STR      r2,[r1,#0x14]
;;;2553   
;;;2554       /* Enable the UART Transmit Complete Interrupt */
;;;2555       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
00001c  6800              LDR      r0,[r0,#0]
00001e  68c1              LDR      r1,[r0,#0xc]
000020  f0410140          ORR      r1,r1,#0x40
000024  60c1              STR      r1,[r0,#0xc]
;;;2556   
;;;2557     }
;;;2558     /* DMA Circular mode */
;;;2559     else
;;;2560     {
;;;2561   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2562       /*Call registered Tx complete callback*/
;;;2563       huart->TxCpltCallback(huart);
;;;2564   #else
;;;2565       /*Call legacy weak Tx complete callback*/
;;;2566       HAL_UART_TxCpltCallback(huart);
;;;2567   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2568     }
;;;2569   }
000026  bd10              POP      {r4,pc}
                  |L45.40|
000028  f7fffffe          BL       HAL_UART_TxCpltCallback
00002c  bd10              POP      {r4,pc}
;;;2570   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;2776     */
;;;2777   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2778   {
;;;2779     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2780   
;;;2781     huart->hdmatx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6b01              LDR      r1,[r0,#0x30]
000008  634a              STR      r2,[r1,#0x34]
;;;2782   
;;;2783     /* Check if an Abort process is still ongoing */
;;;2784     if (huart->hdmarx != NULL)
00000a  6b41              LDR      r1,[r0,#0x34]
00000c  2900              CMP      r1,#0
00000e  d002              BEQ      |L46.22|
;;;2785     {
;;;2786       if (huart->hdmarx->XferAbortCallback != NULL)
000010  6b49              LDR      r1,[r1,#0x34]
000012  2900              CMP      r1,#0
000014  d109              BNE      |L46.42|
                  |L46.22|
;;;2787       {
;;;2788         return;
;;;2789       }
;;;2790     }
;;;2791   
;;;2792     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2793     huart->TxXferCount = 0x00U;
000016  84c2              STRH     r2,[r0,#0x26]
;;;2794     huart->RxXferCount = 0x00U;
000018  85c2              STRH     r2,[r0,#0x2e]
;;;2795   
;;;2796     /* Reset ErrorCode */
;;;2797     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001a  63c2              STR      r2,[r0,#0x3c]
;;;2798   
;;;2799     /* Restore huart->gState and huart->RxState to Ready */
;;;2800     huart->gState  = HAL_UART_STATE_READY;
00001c  2120              MOVS     r1,#0x20
00001e  f8801039          STRB     r1,[r0,#0x39]
;;;2801     huart->RxState = HAL_UART_STATE_READY;
000022  f880103a          STRB     r1,[r0,#0x3a]
;;;2802   
;;;2803     /* Call user Abort complete callback */
;;;2804   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2805     /* Call registered Abort complete callback */
;;;2806     huart->AbortCpltCallback(huart);
;;;2807   #else
;;;2808     /* Call legacy weak Abort complete callback */
;;;2809     HAL_UART_AbortCpltCallback(huart);
000026  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L46.42|
;;;2810   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2811   }
00002a  bd10              POP      {r4,pc}
;;;2812   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;2576     */
;;;2577   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2578   {
;;;2579     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2580   
;;;2581   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2582     /*Call registered Tx complete callback*/
;;;2583     huart->TxHalfCpltCallback(huart);
;;;2584   #else
;;;2585     /*Call legacy weak Tx complete callback*/
;;;2586     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;2587   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2588   }
000008  bd10              POP      {r4,pc}
;;;2589   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;2866     */
;;;2867   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2868   {
;;;2869     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2870   
;;;2871     huart->TxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  84c1              STRH     r1,[r0,#0x26]
;;;2872   
;;;2873     /* Restore huart->gState to Ready */
;;;2874     huart->gState = HAL_UART_STATE_READY;
000008  2120              MOVS     r1,#0x20
00000a  f8801039          STRB     r1,[r0,#0x39]
;;;2875   
;;;2876     /* Call user Abort complete callback */
;;;2877   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2878     /* Call registered Abort Transmit Complete Callback */
;;;2879     huart->AbortTransmitCpltCallback(huart);
;;;2880   #else
;;;2881     /* Call legacy weak Abort Transmit Complete Callback */
;;;2882     HAL_UART_AbortTransmitCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;2883   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2884   }
000012  bd10              POP      {r4,pc}
;;;2885   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;2735     */
;;;2736   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2737   {
;;;2738     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2739     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  68ca              LDR      r2,[r1,#0xc]
000004  f4227290          BIC      r2,r2,#0x120
000008  60ca              STR      r2,[r1,#0xc]
;;;2740     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000a  6801              LDR      r1,[r0,#0]
00000c  694a              LDR      r2,[r1,#0x14]
00000e  f0220201          BIC      r2,r2,#1
000012  614a              STR      r2,[r1,#0x14]
;;;2741   
;;;2742     /* At end of Rx process, restore huart->RxState to Ready */
;;;2743     huart->RxState = HAL_UART_STATE_READY;
000014  2120              MOVS     r1,#0x20
000016  f880103a          STRB     r1,[r0,#0x3a]
;;;2744   }
00001a  4770              BX       lr
;;;2745   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;2966     */
;;;2967   static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2968   {
;;;2969     /* Disable the UART Transmit Complete Interrupt */
;;;2970     __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
000002  6801              LDR      r1,[r0,#0]
000004  68ca              LDR      r2,[r1,#0xc]
000006  f0220240          BIC      r2,r2,#0x40
00000a  60ca              STR      r2,[r1,#0xc]
;;;2971   
;;;2972     /* Tx process is ended, restore huart->gState to Ready */
;;;2973     huart->gState = HAL_UART_STATE_READY;
00000c  2120              MOVS     r1,#0x20
00000e  f8801039          STRB     r1,[r0,#0x39]
;;;2974   
;;;2975   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2976     /*Call registered Tx complete callback*/
;;;2977     huart->TxCpltCallback(huart);
;;;2978   #else
;;;2979     /*Call legacy weak Tx complete callback*/
;;;2980     HAL_UART_TxCpltCallback(huart);
000012  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;2981   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2982   
;;;2983     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;2984   }
000018  bd10              POP      {r4,pc}
;;;2985   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;2721     */
;;;2722   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2723   {
;;;2724     /* Disable TXEIE and TCIE interrupts */
;;;2725     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  68ca              LDR      r2,[r1,#0xc]
000004  f02202c0          BIC      r2,r2,#0xc0
000008  60ca              STR      r2,[r1,#0xc]
;;;2726   
;;;2727     /* At end of Tx process, restore huart->gState to Ready */
;;;2728     huart->gState = HAL_UART_STATE_READY;
00000a  2120              MOVS     r1,#0x20
00000c  f8801039          STRB     r1,[r0,#0x39]
;;;2729   }
000010  4770              BX       lr
;;;2730   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Receive_IT PROC
;;;2991     */
;;;2992   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2993   {
;;;2994     uint16_t *tmp;
;;;2995   
;;;2996     /* Check that a Rx process is ongoing */
;;;2997     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
000002  f890103a          LDRB     r1,[r0,#0x3a]
000006  2922              CMP      r1,#0x22
000008  d001              BEQ      |L52.14|
;;;2998     {
;;;2999       if (huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;3000       {
;;;3001         tmp = (uint16_t *) huart->pRxBuffPtr;
;;;3002         if (huart->Init.Parity == UART_PARITY_NONE)
;;;3003         {
;;;3004           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;3005           huart->pRxBuffPtr += 2U;
;;;3006         }
;;;3007         else
;;;3008         {
;;;3009           *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FF);
;;;3010           huart->pRxBuffPtr += 1U;
;;;3011         }
;;;3012       }
;;;3013       else
;;;3014       {
;;;3015         if (huart->Init.Parity == UART_PARITY_NONE)
;;;3016         {
;;;3017           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;3018         }
;;;3019         else
;;;3020         {
;;;3021           *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;3022         }
;;;3023       }
;;;3024   
;;;3025       if (--huart->RxXferCount == 0U)
;;;3026       {
;;;3027         /* Disable the UART Data Register not empty Interrupt */
;;;3028         __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
;;;3029   
;;;3030         /* Disable the UART Parity Error Interrupt */
;;;3031         __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
;;;3032   
;;;3033         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3034         __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
;;;3035   
;;;3036         /* Rx process is completed, restore huart->RxState to Ready */
;;;3037         huart->RxState = HAL_UART_STATE_READY;
;;;3038   
;;;3039   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3040         /*Call registered Rx complete callback*/
;;;3041         huart->RxCpltCallback(huart);
;;;3042   #else
;;;3043         /*Call legacy weak Rx complete callback*/
;;;3044         HAL_UART_RxCpltCallback(huart);
;;;3045   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3046   
;;;3047         return HAL_OK;
;;;3048       }
;;;3049       return HAL_OK;
;;;3050     }
;;;3051     else
;;;3052     {
;;;3053       return HAL_BUSY;
00000a  2002              MOVS     r0,#2
;;;3054     }
;;;3055   }
00000c  bd10              POP      {r4,pc}
                  |L52.14|
00000e  6881              LDR      r1,[r0,#8]            ;2999
000010  f5b15f80          CMP      r1,#0x1000            ;2999
000014  d011              BEQ      |L52.58|
000016  6901              LDR      r1,[r0,#0x10]         ;3015
000018  b319              CBZ      r1,|L52.98|
00001a  6801              LDR      r1,[r0,#0]            ;3021
00001c  6849              LDR      r1,[r1,#4]            ;3021
00001e  f001037f          AND      r3,r1,#0x7f           ;3021
000022  6a81              LDR      r1,[r0,#0x28]         ;3021
000024  1c4a              ADDS     r2,r1,#1              ;3021
000026  6282              STR      r2,[r0,#0x28]         ;3021
000028  700b              STRB     r3,[r1,#0]            ;3021
                  |L52.42|
00002a  8dc1              LDRH     r1,[r0,#0x2e]         ;3025
00002c  1e49              SUBS     r1,r1,#1              ;3025
00002e  0409              LSLS     r1,r1,#16             ;3025
000030  0c09              LSRS     r1,r1,#16             ;3025
000032  85c1              STRH     r1,[r0,#0x2e]         ;3025
000034  d01c              BEQ      |L52.112|
000036  2000              MOVS     r0,#0                 ;3049
000038  bd10              POP      {r4,pc}
                  |L52.58|
00003a  6a81              LDR      r1,[r0,#0x28]         ;3001
00003c  6902              LDR      r2,[r0,#0x10]         ;3002
00003e  b13a              CBZ      r2,|L52.80|
000040  6802              LDR      r2,[r0,#0]            ;3009
000042  6852              LDR      r2,[r2,#4]            ;3009
000044  b2d2              UXTB     r2,r2                 ;3009
000046  800a              STRH     r2,[r1,#0]            ;3009
000048  6a81              LDR      r1,[r0,#0x28]         ;3010
00004a  1c49              ADDS     r1,r1,#1              ;3010
00004c  6281              STR      r1,[r0,#0x28]         ;3010
00004e  e7ec              B        |L52.42|
                  |L52.80|
000050  6802              LDR      r2,[r0,#0]            ;3004
000052  6852              LDR      r2,[r2,#4]            ;3004
000054  f3c20208          UBFX     r2,r2,#0,#9           ;3004
000058  800a              STRH     r2,[r1,#0]            ;3004
00005a  6a81              LDR      r1,[r0,#0x28]         ;3005
00005c  1c89              ADDS     r1,r1,#2              ;3005
00005e  6281              STR      r1,[r0,#0x28]         ;3005
000060  e7e3              B        |L52.42|
                  |L52.98|
000062  6801              LDR      r1,[r0,#0]            ;3017
000064  684a              LDR      r2,[r1,#4]            ;3017
000066  6a81              LDR      r1,[r0,#0x28]         ;3017
000068  1c4b              ADDS     r3,r1,#1              ;3017
00006a  6283              STR      r3,[r0,#0x28]         ;3017
00006c  700a              STRB     r2,[r1,#0]            ;3017
00006e  e7dc              B        |L52.42|
                  |L52.112|
000070  6801              LDR      r1,[r0,#0]            ;3028
000072  68ca              LDR      r2,[r1,#0xc]          ;3028
000074  f0220220          BIC      r2,r2,#0x20           ;3028
000078  60ca              STR      r2,[r1,#0xc]          ;3028
00007a  6801              LDR      r1,[r0,#0]            ;3031
00007c  68ca              LDR      r2,[r1,#0xc]          ;3031
00007e  f4227280          BIC      r2,r2,#0x100          ;3031
000082  60ca              STR      r2,[r1,#0xc]          ;3031
000084  6801              LDR      r1,[r0,#0]            ;3034
000086  694a              LDR      r2,[r1,#0x14]         ;3034
000088  f0220201          BIC      r2,r2,#1              ;3034
00008c  614a              STR      r2,[r1,#0x14]         ;3034
00008e  2120              MOVS     r1,#0x20              ;3037
000090  f880103a          STRB     r1,[r0,#0x3a]         ;3037
000094  f7fffffe          BL       HAL_UART_RxCpltCallback
000098  2000              MOVS     r0,#0                 ;3047
00009a  bd10              POP      {r4,pc}
;;;3056   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;3062     */
;;;3063   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;3064   {
000004  4604              MOV      r4,r0
;;;3065     uint32_t tmpreg;
;;;3066     uint32_t pclk;
;;;3067   
;;;3068     /* Check the parameters */
;;;3069     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;3070     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;3071     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;3072     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;3073   
;;;3074     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;3075     /* Configure the UART Stop Bits: Set STOP[13:12] bits
;;;3076        according to huart->Init.StopBits value */
;;;3077     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000006  6820              LDR      r0,[r4,#0]
000008  6901              LDR      r1,[r0,#0x10]
00000a  68e2              LDR      r2,[r4,#0xc]
00000c  f4215140          BIC      r1,r1,#0x3000
000010  4311              ORRS     r1,r1,r2
000012  6101              STR      r1,[r0,#0x10]
;;;3078   
;;;3079     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;3080     /* Configure the UART Word Length, Parity and mode:
;;;3081        Set the M bits according to huart->Init.WordLength value
;;;3082        Set PCE and PS bits according to huart->Init.Parity value
;;;3083        Set TE and RE bits according to huart->Init.Mode value
;;;3084        Set OVER8 bit according to huart->Init.OverSampling value */
;;;3085   
;;;3086   #if defined(USART_CR1_OVER8)
;;;3087     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
;;;3088     MODIFY_REG(huart->Instance->CR1,
;;;3089                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
;;;3090                tmpreg);
;;;3091   #else
;;;3092     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
000014  68a1              LDR      r1,[r4,#8]
000016  6920              LDR      r0,[r4,#0x10]
000018  4301              ORRS     r1,r1,r0
00001a  6960              LDR      r0,[r4,#0x14]
00001c  4301              ORRS     r1,r1,r0
;;;3093     MODIFY_REG(huart->Instance->CR1,
00001e  6820              LDR      r0,[r4,#0]
000020  68c2              LDR      r2,[r0,#0xc]
000022  f241630c          MOV      r3,#0x160c
000026  439a              BICS     r2,r2,r3
000028  430a              ORRS     r2,r2,r1
00002a  60c2              STR      r2,[r0,#0xc]
;;;3094                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE),
;;;3095                tmpreg);
;;;3096   #endif /* USART_CR1_OVER8 */
;;;3097   
;;;3098     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;3099     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;3100     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
00002c  6820              LDR      r0,[r4,#0]
00002e  6941              LDR      r1,[r0,#0x14]
000030  69a2              LDR      r2,[r4,#0x18]
000032  f4217140          BIC      r1,r1,#0x300
000036  4311              ORRS     r1,r1,r2
000038  6141              STR      r1,[r0,#0x14]
;;;3101   
;;;3102   #if defined(USART_CR1_OVER8)
;;;3103     /* Check the Over Sampling */
;;;3104     if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
;;;3105     {
;;;3106       /*-------------------------- USART BRR Configuration ---------------------*/
;;;3107       if(huart->Instance == USART1)
;;;3108       {
;;;3109         pclk = HAL_RCC_GetPCLK2Freq();
;;;3110         huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
;;;3111       }
;;;3112       else
;;;3113       {
;;;3114         pclk = HAL_RCC_GetPCLK1Freq();
;;;3115         huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
;;;3116       }
;;;3117     }
;;;3118     else
;;;3119     {
;;;3120       /*-------------------------- USART BRR Configuration ---------------------*/
;;;3121       if(huart->Instance == USART1)
;;;3122       {
;;;3123         pclk = HAL_RCC_GetPCLK2Freq();
;;;3124         huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
;;;3125       }
;;;3126       else
;;;3127       {
;;;3128         pclk = HAL_RCC_GetPCLK1Freq();
;;;3129         huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
;;;3130       }
;;;3131     }
;;;3132   #else
;;;3133     /*-------------------------- USART BRR Configuration ---------------------*/
;;;3134     if(huart->Instance == USART1)
00003a  4935              LDR      r1,|L53.272|
00003c  6820              LDR      r0,[r4,#0]
;;;3135     {
;;;3136       pclk = HAL_RCC_GetPCLK2Freq();
;;;3137       huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
00003e  2564              MOVS     r5,#0x64
000040  2632              MOVS     r6,#0x32
000042  4288              CMP      r0,r1                 ;3134
000044  d132              BNE      |L53.172|
000046  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
00004a  eb0001c0          ADD      r1,r0,r0,LSL #3
00004e  eb011000          ADD      r0,r1,r0,LSL #4
000052  6861              LDR      r1,[r4,#4]
000054  f06f0718          MVN      r7,#0x18
000058  0089              LSLS     r1,r1,#2
00005a  fbb0f2f1          UDIV     r2,r0,r1
00005e  fbb2f2f5          UDIV     r2,r2,r5
000062  fbb0f3f1          UDIV     r3,r0,r1
000066  437a              MULS     r2,r7,r2
000068  eb030282          ADD      r2,r3,r2,LSL #2
00006c  fbb0f3f1          UDIV     r3,r0,r1
000070  eb061202          ADD      r2,r6,r2,LSL #4
000074  fbb2f2f5          UDIV     r2,r2,r5
000078  fbb3f3f5          UDIV     r3,r3,r5
00007c  f00202f0          AND      r2,r2,#0xf0
000080  eb021203          ADD      r2,r2,r3,LSL #4
000084  fbb0f3f1          UDIV     r3,r0,r1
000088  fbb0f0f1          UDIV     r0,r0,r1
00008c  fbb0f0f5          UDIV     r0,r0,r5
000090  4378              MULS     r0,r7,r0
000092  eb030080          ADD      r0,r3,r0,LSL #2
000096  eb061000          ADD      r0,r6,r0,LSL #4
00009a  fbb0f0f5          UDIV     r0,r0,r5
00009e  6821              LDR      r1,[r4,#0]
0000a0  f000000f          AND      r0,r0,#0xf
0000a4  4410              ADD      r0,r0,r2
0000a6  6088              STR      r0,[r1,#8]
                  |L53.168|
;;;3138     }
;;;3139     else
;;;3140     {
;;;3141       pclk = HAL_RCC_GetPCLK1Freq();
;;;3142       huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
;;;3143     }
;;;3144   #endif /* USART_CR1_OVER8 */
;;;3145   }
0000a8  e8bd81f0          POP      {r4-r8,pc}
                  |L53.172|
0000ac  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
0000b0  eb0001c0          ADD      r1,r0,r0,LSL #3       ;3142
0000b4  eb011000          ADD      r0,r1,r0,LSL #4       ;3142
0000b8  6861              LDR      r1,[r4,#4]            ;3142
0000ba  f06f0718          MVN      r7,#0x18              ;3142
0000be  0089              LSLS     r1,r1,#2              ;3142
0000c0  fbb0f2f1          UDIV     r2,r0,r1              ;3142
0000c4  fbb2f2f5          UDIV     r2,r2,r5              ;3142
0000c8  fbb0f3f1          UDIV     r3,r0,r1              ;3142
0000cc  437a              MULS     r2,r7,r2              ;3142
0000ce  eb030282          ADD      r2,r3,r2,LSL #2       ;3142
0000d2  fbb0f3f1          UDIV     r3,r0,r1              ;3142
0000d6  eb061202          ADD      r2,r6,r2,LSL #4       ;3142
0000da  fbb2f2f5          UDIV     r2,r2,r5              ;3142
0000de  fbb3f3f5          UDIV     r3,r3,r5              ;3142
0000e2  f00202f0          AND      r2,r2,#0xf0           ;3142
0000e6  eb021203          ADD      r2,r2,r3,LSL #4       ;3142
0000ea  fbb0f3f1          UDIV     r3,r0,r1              ;3142
0000ee  fbb0f0f1          UDIV     r0,r0,r1              ;3142
0000f2  fbb0f0f5          UDIV     r0,r0,r5              ;3142
0000f6  4378              MULS     r0,r7,r0              ;3142
0000f8  eb030080          ADD      r0,r3,r0,LSL #2       ;3142
0000fc  eb061000          ADD      r0,r6,r0,LSL #4       ;3142
000100  fbb0f0f5          UDIV     r0,r0,r5              ;3142
000104  6821              LDR      r1,[r4,#0]            ;3142
000106  f000000f          AND      r0,r0,#0xf            ;3142
00010a  4410              ADD      r0,r0,r2              ;3142
00010c  6088              STR      r0,[r1,#8]            ;3142
00010e  e7cb              B        |L53.168|
;;;3146   
                          ENDP

                  |L53.272|
                          DCD      0x40013800

                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;2919     */
;;;2920   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  f8901039          LDRB     r1,[r0,#0x39]
;;;2921   {
;;;2922     uint16_t *tmp;
;;;2923   
;;;2924     /* Check that a Tx process is ongoing */
;;;2925     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000004  2921              CMP      r1,#0x21
000006  d001              BEQ      |L54.12|
;;;2926     {
;;;2927       if (huart->Init.WordLength == UART_WORDLENGTH_9B)
;;;2928       {
;;;2929         tmp = (uint16_t *) huart->pTxBuffPtr;
;;;2930         huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
;;;2931         if (huart->Init.Parity == UART_PARITY_NONE)
;;;2932         {
;;;2933           huart->pTxBuffPtr += 2U;
;;;2934         }
;;;2935         else
;;;2936         {
;;;2937           huart->pTxBuffPtr += 1U;
;;;2938         }
;;;2939       }
;;;2940       else
;;;2941       {
;;;2942         huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
;;;2943       }
;;;2944   
;;;2945       if (--huart->TxXferCount == 0U)
;;;2946       {
;;;2947         /* Disable the UART Transmit Complete Interrupt */
;;;2948         __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
;;;2949   
;;;2950         /* Enable the UART Transmit Complete Interrupt */
;;;2951         __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
;;;2952       }
;;;2953       return HAL_OK;
;;;2954     }
;;;2955     else
;;;2956     {
;;;2957       return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;2958     }
;;;2959   }
00000a  4770              BX       lr
                  |L54.12|
00000c  6881              LDR      r1,[r0,#8]            ;2927
00000e  f5b15f80          CMP      r1,#0x1000            ;2927
000012  d00c              BEQ      |L54.46|
000014  6a01              LDR      r1,[r0,#0x20]         ;2942
000016  1c4a              ADDS     r2,r1,#1              ;2942
000018  6202              STR      r2,[r0,#0x20]         ;2942
00001a  6802              LDR      r2,[r0,#0]            ;2942
00001c  7809              LDRB     r1,[r1,#0]            ;2942
00001e  6051              STR      r1,[r2,#4]            ;2942
                  |L54.32|
000020  8cc1              LDRH     r1,[r0,#0x26]         ;2945
000022  1e49              SUBS     r1,r1,#1              ;2945
000024  0409              LSLS     r1,r1,#16             ;2945
000026  0c09              LSRS     r1,r1,#16             ;2945
000028  84c1              STRH     r1,[r0,#0x26]         ;2945
00002a  d010              BEQ      |L54.78|
00002c  e019              B        |L54.98|
                  |L54.46|
00002e  6a01              LDR      r1,[r0,#0x20]         ;2929
000030  6802              LDR      r2,[r0,#0]            ;2930
000032  8809              LDRH     r1,[r1,#0]            ;2930
000034  f3c10108          UBFX     r1,r1,#0,#9           ;2930
000038  6051              STR      r1,[r2,#4]            ;2930
00003a  6901              LDR      r1,[r0,#0x10]         ;2931
00003c  b119              CBZ      r1,|L54.70|
00003e  6a01              LDR      r1,[r0,#0x20]         ;2937
000040  1c49              ADDS     r1,r1,#1              ;2937
000042  6201              STR      r1,[r0,#0x20]         ;2937
000044  e7ec              B        |L54.32|
                  |L54.70|
000046  6a01              LDR      r1,[r0,#0x20]         ;2933
000048  1c89              ADDS     r1,r1,#2              ;2933
00004a  6201              STR      r1,[r0,#0x20]         ;2933
00004c  e7e8              B        |L54.32|
                  |L54.78|
00004e  6801              LDR      r1,[r0,#0]            ;2948
000050  68ca              LDR      r2,[r1,#0xc]          ;2948
000052  f0220280          BIC      r2,r2,#0x80           ;2948
000056  60ca              STR      r2,[r1,#0xc]          ;2948
000058  6800              LDR      r0,[r0,#0]            ;2951
00005a  68c1              LDR      r1,[r0,#0xc]          ;2951
00005c  f0410140          ORR      r1,r1,#0x40           ;2951
000060  60c1              STR      r1,[r0,#0xc]          ;2951
                  |L54.98|
000062  2000              MOVS     r0,#0                 ;2953
000064  4770              BX       lr
;;;2960   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;2689     */
;;;2690   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2691   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;2692     /* Wait until flag is set */
;;;2693     while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
;;;2694     {
;;;2695       /* Check for the Timeout */
;;;2696       if (Timeout != HAL_MAX_DELAY)
;;;2697       {
;;;2698         if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
;;;2699         {
;;;2700           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;2701           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
;;;2702           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;2703   
;;;2704           huart->gState  = HAL_UART_STATE_READY;
;;;2705           huart->RxState = HAL_UART_STATE_READY;
;;;2706   
;;;2707           /* Process Unlocked */
;;;2708           __HAL_UNLOCK(huart);
;;;2709   
;;;2710           return HAL_TIMEOUT;
00000e  e01d              B        |L55.76|
                  |L55.16|
000010  1c68              ADDS     r0,r5,#1              ;2696
000012  d01b              BEQ      |L55.76|
000014  b12d              CBZ      r5,|L55.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8              ;2698
00001e  42a8              CMP      r0,r5                 ;2698
000020  d914              BLS      |L55.76|
                  |L55.34|
000022  6820              LDR      r0,[r4,#0]            ;2701
000024  68c1              LDR      r1,[r0,#0xc]          ;2701
000026  f42171d0          BIC      r1,r1,#0x1a0          ;2701
00002a  60c1              STR      r1,[r0,#0xc]          ;2701
00002c  6820              LDR      r0,[r4,#0]            ;2702
00002e  6941              LDR      r1,[r0,#0x14]         ;2702
000030  f0210101          BIC      r1,r1,#1              ;2702
000034  6141              STR      r1,[r0,#0x14]         ;2702
000036  2020              MOVS     r0,#0x20              ;2704
000038  f8840039          STRB     r0,[r4,#0x39]         ;2704
00003c  f884003a          STRB     r0,[r4,#0x3a]         ;2705
000040  2000              MOVS     r0,#0                 ;2708
000042  f8840038          STRB     r0,[r4,#0x38]         ;2708
000046  2003              MOVS     r0,#3
                  |L55.72|
;;;2711         }
;;;2712       }
;;;2713     }
;;;2714     return HAL_OK;
;;;2715   }
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L55.76|
00004c  6820              LDR      r0,[r4,#0]            ;2693
00004e  6800              LDR      r0,[r0,#0]            ;2693
000050  ea360000          BICS     r0,r6,r0              ;2693
000054  d004              BEQ      |L55.96|
000056  2000              MOVS     r0,#0                 ;2693
                  |L55.88|
000058  42b8              CMP      r0,r7                 ;2693
00005a  d0d9              BEQ      |L55.16|
00005c  2000              MOVS     r0,#0                 ;2714
00005e  e7f3              B        |L55.72|
                  |L55.96|
000060  2001              MOVS     r0,#1                 ;2693
000062  e7f9              B        |L55.88|
;;;2716   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH|
#line 478
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX|
#line 665
|__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
