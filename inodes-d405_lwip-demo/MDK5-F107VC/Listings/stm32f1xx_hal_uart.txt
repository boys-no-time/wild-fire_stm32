; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\stm32f1xx_hal_uart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f1xx_hal_uart.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\stm32f1xx_hal_uart.crf ..\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_uart.c]
                          THUMB

                          AREA ||i.HAL_HalfDuplex_EnableReceiver||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableReceiver PROC
;;;2427     */
;;;2428   HAL_StatusTypeDef HAL_HalfDuplex_EnableReceiver(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;2429   {
;;;2430     uint32_t tmpreg = 0x00U;
;;;2431   
;;;2432     /* Process Locked */
;;;2433     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d012              BEQ      |L1.46|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;2434   
;;;2435     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;2436   
;;;2437     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2438     tmpreg = huart->Instance->CR1;
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
;;;2439   
;;;2440     /* Clear TE and RE bits */
;;;2441     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
000018  f022020c          BIC      r2,r2,#0xc
;;;2442   
;;;2443     /* Enable the USART's receive interface by setting the RE bit in the USART CR1 register */
;;;2444     tmpreg |= (uint32_t)USART_CR1_RE;
00001c  f0420204          ORR      r2,r2,#4
;;;2445   
;;;2446     /* Write to USART CR1 */
;;;2447     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
000020  60ca              STR      r2,[r1,#0xc]
;;;2448   
;;;2449     huart->gState = HAL_UART_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  7041              STRB     r1,[r0,#1]
;;;2450   
;;;2451     /* Process Unlocked */
;;;2452     __HAL_UNLOCK(huart);
000026  2100              MOVS     r1,#0
000028  7001              STRB     r1,[r0,#0]
;;;2453   
;;;2454     return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;2455   }
00002c  4770              BX       lr
                  |L1.46|
00002e  2002              MOVS     r0,#2                 ;2433
000030  4770              BX       lr
;;;2456   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_EnableTransmitter||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_EnableTransmitter PROC
;;;2392     */
;;;2393   HAL_StatusTypeDef HAL_HalfDuplex_EnableTransmitter(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;2394   {
;;;2395     uint32_t tmpreg = 0x00U;
;;;2396   
;;;2397     /* Process Locked */
;;;2398     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d012              BEQ      |L2.46|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;2399   
;;;2400     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;2401   
;;;2402     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;2403     tmpreg = huart->Instance->CR1;
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
;;;2404   
;;;2405     /* Clear TE and RE bits */
;;;2406     tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_TE | USART_CR1_RE));
000018  f022020c          BIC      r2,r2,#0xc
;;;2407   
;;;2408     /* Enable the USART's transmit interface by setting the TE bit in the USART CR1 register */
;;;2409     tmpreg |= (uint32_t)USART_CR1_TE;
00001c  f0420208          ORR      r2,r2,#8
;;;2410   
;;;2411     /* Write to USART CR1 */
;;;2412     WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
000020  60ca              STR      r2,[r1,#0xc]
;;;2413   
;;;2414     huart->gState = HAL_UART_STATE_READY;
000022  2120              MOVS     r1,#0x20
000024  7041              STRB     r1,[r0,#1]
;;;2415   
;;;2416     /* Process Unlocked */
;;;2417     __HAL_UNLOCK(huart);
000026  2100              MOVS     r1,#0
000028  7001              STRB     r1,[r0,#0]
;;;2418   
;;;2419     return HAL_OK;
00002a  2000              MOVS     r0,#0
;;;2420   }
00002c  4770              BX       lr
                  |L2.46|
00002e  2002              MOVS     r0,#2                 ;2398
000030  4770              BX       lr
;;;2421   
                          ENDP


                          AREA ||i.HAL_HalfDuplex_Init||, CODE, READONLY, ALIGN=1

                  HAL_HalfDuplex_Init PROC
;;;390      */
;;;391    HAL_StatusTypeDef HAL_HalfDuplex_Init(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;392    {
000002  4604              MOV      r4,r0
;;;393      /* Check the UART handle allocation */
;;;394      if (huart == NULL)
000004  2c00              CMP      r4,#0
000006  d004              BEQ      |L3.18|
;;;395      {
;;;396        return HAL_ERROR;
;;;397      }
;;;398    
;;;399      /* Check the parameters */
;;;400      assert_param(IS_UART_HALFDUPLEX_INSTANCE(huart->Instance));
;;;401      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;402    #if defined(USART_CR1_OVER8)
;;;403      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;404    #endif /* USART_CR1_OVER8 */
;;;405    
;;;406      if (huart->gState == HAL_UART_STATE_RESET)
000008  f8940039          LDRB     r0,[r4,#0x39]
00000c  2500              MOVS     r5,#0
00000e  b110              CBZ      r0,|L3.22|
000010  e006              B        |L3.32|
                  |L3.18|
000012  2001              MOVS     r0,#1                 ;396
;;;407      {
;;;408        /* Allocate lock resource and initialize it */
;;;409        huart->Lock = HAL_UNLOCKED;
;;;410    
;;;411    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;412        UART_InitCallbacksToDefault(huart);
;;;413    
;;;414        if (huart->MspInitCallback == NULL)
;;;415        {
;;;416          huart->MspInitCallback = HAL_UART_MspInit;
;;;417        }
;;;418    
;;;419        /* Init the low level hardware */
;;;420        huart->MspInitCallback(huart);
;;;421    #else
;;;422        /* Init the low level hardware : GPIO, CLOCK */
;;;423        HAL_UART_MspInit(huart);
;;;424    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;425      }
;;;426    
;;;427      huart->gState = HAL_UART_STATE_BUSY;
;;;428    
;;;429      /* Disable the peripheral */
;;;430      __HAL_UART_DISABLE(huart);
;;;431    
;;;432      /* Set the UART Communication parameters */
;;;433      UART_SetConfig(huart);
;;;434    
;;;435      /* In half-duplex mode, the following bits must be kept cleared:
;;;436         - LINEN and CLKEN bits in the USART_CR2 register,
;;;437         - SCEN and IREN bits in the USART_CR3 register.*/
;;;438      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;439      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_IREN | USART_CR3_SCEN));
;;;440    
;;;441      /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;442      SET_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
;;;443    
;;;444      /* Enable the peripheral */
;;;445      __HAL_UART_ENABLE(huart);
;;;446    
;;;447      /* Initialize the UART state*/
;;;448      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;449      huart->gState = HAL_UART_STATE_READY;
;;;450      huart->RxState = HAL_UART_STATE_READY;
;;;451    
;;;452      return HAL_OK;
;;;453    }
000014  bd70              POP      {r4-r6,pc}
                  |L3.22|
000016  f8845038          STRB     r5,[r4,#0x38]         ;409
00001a  4620              MOV      r0,r4                 ;423
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L3.32|
000020  2024              MOVS     r0,#0x24              ;427
000022  f8840039          STRB     r0,[r4,#0x39]         ;427
000026  6820              LDR      r0,[r4,#0]            ;430
000028  68c1              LDR      r1,[r0,#0xc]          ;430
00002a  f4215100          BIC      r1,r1,#0x2000         ;430
00002e  60c1              STR      r1,[r0,#0xc]          ;430
000030  4620              MOV      r0,r4                 ;433
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;438
000038  6901              LDR      r1,[r0,#0x10]         ;438
00003a  f4214190          BIC      r1,r1,#0x4800         ;438
00003e  6101              STR      r1,[r0,#0x10]         ;438
000040  6820              LDR      r0,[r4,#0]            ;439
000042  6941              LDR      r1,[r0,#0x14]         ;439
000044  f0210122          BIC      r1,r1,#0x22           ;439
000048  6141              STR      r1,[r0,#0x14]         ;439
00004a  6820              LDR      r0,[r4,#0]            ;442
00004c  6941              LDR      r1,[r0,#0x14]         ;442
00004e  f0410108          ORR      r1,r1,#8              ;442
000052  6141              STR      r1,[r0,#0x14]         ;442
000054  6820              LDR      r0,[r4,#0]            ;445
000056  68c1              LDR      r1,[r0,#0xc]          ;445
000058  f4415100          ORR      r1,r1,#0x2000         ;445
00005c  60c1              STR      r1,[r0,#0xc]          ;445
00005e  63e5              STR      r5,[r4,#0x3c]         ;448
000060  2020              MOVS     r0,#0x20              ;449
000062  f8840039          STRB     r0,[r4,#0x39]         ;449
000066  f884003a          STRB     r0,[r4,#0x3a]         ;450
00006a  2000              MOVS     r0,#0                 ;452
00006c  bd70              POP      {r4-r6,pc}
;;;454    
                          ENDP


                          AREA ||i.HAL_LIN_Init||, CODE, READONLY, ALIGN=1

                  HAL_LIN_Init PROC
;;;465      */
;;;466    HAL_StatusTypeDef HAL_LIN_Init(UART_HandleTypeDef *huart, uint32_t BreakDetectLength)
000000  b570              PUSH     {r4-r6,lr}
;;;467    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;468      /* Check the UART handle allocation */
;;;469      if (huart == NULL)
000006  2c00              CMP      r4,#0
000008  d004              BEQ      |L4.20|
;;;470      {
;;;471        return HAL_ERROR;
;;;472      }
;;;473    
;;;474      /* Check the LIN UART instance */
;;;475      assert_param(IS_UART_LIN_INSTANCE(huart->Instance));
;;;476    
;;;477      /* Check the Break detection length parameter */
;;;478      assert_param(IS_UART_LIN_BREAK_DETECT_LENGTH(BreakDetectLength));
;;;479      assert_param(IS_UART_LIN_WORD_LENGTH(huart->Init.WordLength));
;;;480    #if defined(USART_CR1_OVER8)
;;;481      assert_param(IS_UART_LIN_OVERSAMPLING(huart->Init.OverSampling));
;;;482    #endif /* USART_CR1_OVER8 */
;;;483    
;;;484      if (huart->gState == HAL_UART_STATE_RESET)
00000a  f8940039          LDRB     r0,[r4,#0x39]
00000e  2500              MOVS     r5,#0
000010  b110              CBZ      r0,|L4.24|
000012  e006              B        |L4.34|
                  |L4.20|
000014  2001              MOVS     r0,#1                 ;471
;;;485      {
;;;486        /* Allocate lock resource and initialize it */
;;;487        huart->Lock = HAL_UNLOCKED;
;;;488    
;;;489    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;490        UART_InitCallbacksToDefault(huart);
;;;491    
;;;492        if (huart->MspInitCallback == NULL)
;;;493        {
;;;494          huart->MspInitCallback = HAL_UART_MspInit;
;;;495        }
;;;496    
;;;497        /* Init the low level hardware */
;;;498        huart->MspInitCallback(huart);
;;;499    #else
;;;500        /* Init the low level hardware : GPIO, CLOCK */
;;;501        HAL_UART_MspInit(huart);
;;;502    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;503      }
;;;504    
;;;505      huart->gState = HAL_UART_STATE_BUSY;
;;;506    
;;;507      /* Disable the peripheral */
;;;508      __HAL_UART_DISABLE(huart);
;;;509    
;;;510      /* Set the UART Communication parameters */
;;;511      UART_SetConfig(huart);
;;;512    
;;;513      /* In LIN mode, the following bits must be kept cleared:
;;;514         - CLKEN bits in the USART_CR2 register,
;;;515         - SCEN, HDSEL and IREN bits in the USART_CR3 register.*/
;;;516      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_CLKEN));
;;;517      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_HDSEL | USART_CR3_IREN | USART_CR3_SCEN));
;;;518    
;;;519      /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;520      SET_BIT(huart->Instance->CR2, USART_CR2_LINEN);
;;;521    
;;;522      /* Set the USART LIN Break detection length. */
;;;523      CLEAR_BIT(huart->Instance->CR2, USART_CR2_LBDL);
;;;524      SET_BIT(huart->Instance->CR2, BreakDetectLength);
;;;525    
;;;526      /* Enable the peripheral */
;;;527      __HAL_UART_ENABLE(huart);
;;;528    
;;;529      /* Initialize the UART state*/
;;;530      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;531      huart->gState = HAL_UART_STATE_READY;
;;;532      huart->RxState = HAL_UART_STATE_READY;
;;;533    
;;;534      return HAL_OK;
;;;535    }
000016  bd70              POP      {r4-r6,pc}
                  |L4.24|
000018  f8845038          STRB     r5,[r4,#0x38]         ;487
00001c  4620              MOV      r0,r4                 ;501
00001e  f7fffffe          BL       HAL_UART_MspInit
                  |L4.34|
000022  2024              MOVS     r0,#0x24              ;505
000024  f8840039          STRB     r0,[r4,#0x39]         ;505
000028  6820              LDR      r0,[r4,#0]            ;508
00002a  68c1              LDR      r1,[r0,#0xc]          ;508
00002c  f4215100          BIC      r1,r1,#0x2000         ;508
000030  60c1              STR      r1,[r0,#0xc]          ;508
000032  4620              MOV      r0,r4                 ;511
000034  f7fffffe          BL       UART_SetConfig
000038  6820              LDR      r0,[r4,#0]            ;516
00003a  6901              LDR      r1,[r0,#0x10]         ;516
00003c  f4216100          BIC      r1,r1,#0x800          ;516
000040  6101              STR      r1,[r0,#0x10]         ;516
000042  6820              LDR      r0,[r4,#0]            ;517
000044  6941              LDR      r1,[r0,#0x14]         ;517
000046  f021012a          BIC      r1,r1,#0x2a           ;517
00004a  6141              STR      r1,[r0,#0x14]         ;517
00004c  6820              LDR      r0,[r4,#0]            ;520
00004e  6901              LDR      r1,[r0,#0x10]         ;520
000050  f4414180          ORR      r1,r1,#0x4000         ;520
000054  6101              STR      r1,[r0,#0x10]         ;520
000056  6820              LDR      r0,[r4,#0]            ;523
000058  6901              LDR      r1,[r0,#0x10]         ;523
00005a  f0210120          BIC      r1,r1,#0x20           ;523
00005e  6101              STR      r1,[r0,#0x10]         ;523
000060  6820              LDR      r0,[r4,#0]            ;524
000062  6901              LDR      r1,[r0,#0x10]         ;524
000064  4331              ORRS     r1,r1,r6              ;524
000066  6101              STR      r1,[r0,#0x10]         ;524
000068  6820              LDR      r0,[r4,#0]            ;527
00006a  68c1              LDR      r1,[r0,#0xc]          ;527
00006c  f4415100          ORR      r1,r1,#0x2000         ;527
000070  60c1              STR      r1,[r0,#0xc]          ;527
000072  63e5              STR      r5,[r4,#0x3c]         ;530
000074  2020              MOVS     r0,#0x20              ;531
000076  f8840039          STRB     r0,[r4,#0x39]         ;531
00007a  f884003a          STRB     r0,[r4,#0x3a]         ;532
00007e  2000              MOVS     r0,#0                 ;534
000080  bd70              POP      {r4-r6,pc}
;;;536    
                          ENDP


                          AREA ||i.HAL_LIN_SendBreak||, CODE, READONLY, ALIGN=1

                  HAL_LIN_SendBreak PROC
;;;2311     */
;;;2312   HAL_StatusTypeDef HAL_LIN_SendBreak(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;2313   {
;;;2314     /* Check the parameters */
;;;2315     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2316   
;;;2317     /* Process Locked */
;;;2318     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L5.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;2319   
;;;2320     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;2321   
;;;2322     /* Send break characters */
;;;2323     SET_BIT(huart->Instance->CR1, USART_CR1_SBK);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0420201          ORR      r2,r2,#1
00001c  60ca              STR      r2,[r1,#0xc]
;;;2324   
;;;2325     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;2326   
;;;2327     /* Process Unlocked */
;;;2328     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;2329   
;;;2330     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;2331   }
000028  4770              BX       lr
                  |L5.42|
00002a  2002              MOVS     r0,#2                 ;2318
00002c  4770              BX       lr
;;;2332   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_EnterMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_EnterMuteMode PROC
;;;2338     */
;;;2339   HAL_StatusTypeDef HAL_MultiProcessor_EnterMuteMode(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;2340   {
;;;2341     /* Check the parameters */
;;;2342     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2343   
;;;2344     /* Process Locked */
;;;2345     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L6.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;2346   
;;;2347     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;2348   
;;;2349     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;2350     SET_BIT(huart->Instance->CR1, USART_CR1_RWU);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0420202          ORR      r2,r2,#2
00001c  60ca              STR      r2,[r1,#0xc]
;;;2351   
;;;2352     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;2353   
;;;2354     /* Process Unlocked */
;;;2355     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;2356   
;;;2357     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;2358   }
000028  4770              BX       lr
                  |L6.42|
00002a  2002              MOVS     r0,#2                 ;2345
00002c  4770              BX       lr
;;;2359   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_ExitMuteMode||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_ExitMuteMode PROC
;;;2365     */
;;;2366   HAL_StatusTypeDef HAL_MultiProcessor_ExitMuteMode(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;2367   {
;;;2368     /* Check the parameters */
;;;2369     assert_param(IS_UART_INSTANCE(huart->Instance));
;;;2370   
;;;2371     /* Process Locked */
;;;2372     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d010              BEQ      |L7.42|
000008  2101              MOVS     r1,#1
00000a  f8001f38          STRB     r1,[r0,#0x38]!
;;;2373   
;;;2374     huart->gState = HAL_UART_STATE_BUSY;
00000e  2124              MOVS     r1,#0x24
000010  7041              STRB     r1,[r0,#1]
;;;2375   
;;;2376     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;2377     CLEAR_BIT(huart->Instance->CR1, USART_CR1_RWU);
000012  f8501c38          LDR      r1,[r0,#-0x38]
000016  68ca              LDR      r2,[r1,#0xc]
000018  f0220202          BIC      r2,r2,#2
00001c  60ca              STR      r2,[r1,#0xc]
;;;2378   
;;;2379     huart->gState = HAL_UART_STATE_READY;
00001e  2120              MOVS     r1,#0x20
000020  7041              STRB     r1,[r0,#1]
;;;2380   
;;;2381     /* Process Unlocked */
;;;2382     __HAL_UNLOCK(huart);
000022  2100              MOVS     r1,#0
000024  7001              STRB     r1,[r0,#0]
;;;2383   
;;;2384     return HAL_OK;
000026  2000              MOVS     r0,#0
;;;2385   }
000028  4770              BX       lr
                  |L7.42|
00002a  2002              MOVS     r0,#2                 ;2372
00002c  4770              BX       lr
;;;2386   
                          ENDP


                          AREA ||i.HAL_MultiProcessor_Init||, CODE, READONLY, ALIGN=1

                  HAL_MultiProcessor_Init PROC
;;;548      */
;;;549    HAL_StatusTypeDef HAL_MultiProcessor_Init(UART_HandleTypeDef *huart, uint8_t Address, uint32_t WakeUpMethod)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;550    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;551      /* Check the UART handle allocation */
;;;552      if (huart == NULL)
00000a  2c00              CMP      r4,#0
00000c  d004              BEQ      |L8.24|
;;;553      {
;;;554        return HAL_ERROR;
;;;555      }
;;;556    
;;;557      /* Check the parameters */
;;;558      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;559    
;;;560      /* Check the Address & wake up method parameters */
;;;561      assert_param(IS_UART_WAKEUPMETHOD(WakeUpMethod));
;;;562      assert_param(IS_UART_ADDRESS(Address));
;;;563      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;564    #if defined(USART_CR1_OVER8)
;;;565      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;566    #endif /* USART_CR1_OVER8 */
;;;567    
;;;568      if (huart->gState == HAL_UART_STATE_RESET)
00000e  f8940039          LDRB     r0,[r4,#0x39]
000012  2500              MOVS     r5,#0
000014  b118              CBZ      r0,|L8.30|
000016  e007              B        |L8.40|
                  |L8.24|
000018  2001              MOVS     r0,#1                 ;554
                  |L8.26|
;;;569      {
;;;570        /* Allocate lock resource and initialize it */
;;;571        huart->Lock = HAL_UNLOCKED;
;;;572    
;;;573    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;574        UART_InitCallbacksToDefault(huart);
;;;575    
;;;576        if (huart->MspInitCallback == NULL)
;;;577        {
;;;578          huart->MspInitCallback = HAL_UART_MspInit;
;;;579        }
;;;580    
;;;581        /* Init the low level hardware */
;;;582        huart->MspInitCallback(huart);
;;;583    #else
;;;584        /* Init the low level hardware : GPIO, CLOCK */
;;;585        HAL_UART_MspInit(huart);
;;;586    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;587      }
;;;588    
;;;589      huart->gState = HAL_UART_STATE_BUSY;
;;;590    
;;;591      /* Disable the peripheral */
;;;592      __HAL_UART_DISABLE(huart);
;;;593    
;;;594      /* Set the UART Communication parameters */
;;;595      UART_SetConfig(huart);
;;;596    
;;;597      /* In Multi-Processor mode, the following bits must be kept cleared:
;;;598         - LINEN and CLKEN bits in the USART_CR2 register,
;;;599         - SCEN, HDSEL and IREN  bits in the USART_CR3 register */
;;;600      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;601      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;602    
;;;603      /* Set the USART address node */
;;;604      CLEAR_BIT(huart->Instance->CR2, USART_CR2_ADD);
;;;605      SET_BIT(huart->Instance->CR2, Address);
;;;606    
;;;607      /* Set the wake up method by setting the WAKE bit in the CR1 register */
;;;608      CLEAR_BIT(huart->Instance->CR1, USART_CR1_WAKE);
;;;609      SET_BIT(huart->Instance->CR1, WakeUpMethod);
;;;610    
;;;611      /* Enable the peripheral */
;;;612      __HAL_UART_ENABLE(huart);
;;;613    
;;;614      /* Initialize the UART state */
;;;615      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;616      huart->gState = HAL_UART_STATE_READY;
;;;617      huart->RxState = HAL_UART_STATE_READY;
;;;618    
;;;619      return HAL_OK;
;;;620    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L8.30|
00001e  f8845038          STRB     r5,[r4,#0x38]         ;571
000022  4620              MOV      r0,r4                 ;585
000024  f7fffffe          BL       HAL_UART_MspInit
                  |L8.40|
000028  2024              MOVS     r0,#0x24              ;589
00002a  f8840039          STRB     r0,[r4,#0x39]         ;589
00002e  6820              LDR      r0,[r4,#0]            ;592
000030  68c1              LDR      r1,[r0,#0xc]          ;592
000032  f4215100          BIC      r1,r1,#0x2000         ;592
000036  60c1              STR      r1,[r0,#0xc]          ;592
000038  4620              MOV      r0,r4                 ;595
00003a  f7fffffe          BL       UART_SetConfig
00003e  6820              LDR      r0,[r4,#0]            ;600
000040  6901              LDR      r1,[r0,#0x10]         ;600
000042  f4214190          BIC      r1,r1,#0x4800         ;600
000046  6101              STR      r1,[r0,#0x10]         ;600
000048  6820              LDR      r0,[r4,#0]            ;601
00004a  6941              LDR      r1,[r0,#0x14]         ;601
00004c  f021012a          BIC      r1,r1,#0x2a           ;601
000050  6141              STR      r1,[r0,#0x14]         ;601
000052  6820              LDR      r0,[r4,#0]            ;604
000054  6901              LDR      r1,[r0,#0x10]         ;604
000056  f021010f          BIC      r1,r1,#0xf            ;604
00005a  6101              STR      r1,[r0,#0x10]         ;604
00005c  6820              LDR      r0,[r4,#0]            ;605
00005e  6901              LDR      r1,[r0,#0x10]         ;605
000060  4331              ORRS     r1,r1,r6              ;605
000062  6101              STR      r1,[r0,#0x10]         ;605
000064  6820              LDR      r0,[r4,#0]            ;608
000066  68c1              LDR      r1,[r0,#0xc]          ;608
000068  f4216100          BIC      r1,r1,#0x800          ;608
00006c  60c1              STR      r1,[r0,#0xc]          ;608
00006e  6820              LDR      r0,[r4,#0]            ;609
000070  68c1              LDR      r1,[r0,#0xc]          ;609
000072  4339              ORRS     r1,r1,r7              ;609
000074  60c1              STR      r1,[r0,#0xc]          ;609
000076  6820              LDR      r0,[r4,#0]            ;612
000078  68c1              LDR      r1,[r0,#0xc]          ;612
00007a  f4415100          ORR      r1,r1,#0x2000         ;612
00007e  60c1              STR      r1,[r0,#0xc]          ;612
000080  63e5              STR      r5,[r4,#0x3c]         ;615
000082  2020              MOVS     r0,#0x20              ;616
000084  f8840039          STRB     r0,[r4,#0x39]         ;616
000088  f884003a          STRB     r0,[r4,#0x3a]         ;617
00008c  2000              MOVS     r0,#0                 ;619
00008e  e7c4              B        |L8.26|
;;;621    
                          ENDP


                          AREA ||i.HAL_UART_Abort||, CODE, READONLY, ALIGN=1

                  HAL_UART_Abort PROC
;;;1560   */
;;;1561   HAL_StatusTypeDef HAL_UART_Abort(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1562   {
000002  4604              MOV      r4,r0
;;;1563     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1564     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f42171f0          BIC      r1,r1,#0x1e0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1565     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1566   
;;;1567     /* Disable the UART DMA Tx request if enabled */
;;;1568     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
;;;1569     {
;;;1570       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1571   
;;;1572       /* Abort the UART DMA Tx channel: use blocking DMA Abort API (no callback) */
;;;1573       if (huart->hdmatx != NULL)
;;;1574       {
;;;1575         /* Set the UART DMA Abort callback to Null.
;;;1576            No call back execution at end of DMA abort procedure */
;;;1577         huart->hdmatx->XferAbortCallback = NULL;
;;;1578   
;;;1579         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
;;;1580         {
;;;1581           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
;;;1582           {
;;;1583             /* Set error code to DMA */
;;;1584             huart->ErrorCode = HAL_UART_ERROR_DMA;
00001c  f04f0610          MOV      r6,#0x10
000020  0609              LSLS     r1,r1,#24             ;1568
000022  f04f0500          MOV      r5,#0
000026  d50f              BPL      |L9.72|
000028  6941              LDR      r1,[r0,#0x14]         ;1570
00002a  f0210180          BIC      r1,r1,#0x80           ;1570
00002e  6141              STR      r1,[r0,#0x14]         ;1570
000030  6b20              LDR      r0,[r4,#0x30]         ;1573
000032  b148              CBZ      r0,|L9.72|
000034  6345              STR      r5,[r0,#0x34]         ;1577
000036  6b20              LDR      r0,[r4,#0x30]         ;1579
000038  f7fffffe          BL       HAL_DMA_Abort
00003c  b120              CBZ      r0,|L9.72|
00003e  6b20              LDR      r0,[r4,#0x30]         ;1581
000040  f7fffffe          BL       HAL_DMA_GetError
000044  2820              CMP      r0,#0x20              ;1581
000046  d01d              BEQ      |L9.132|
                  |L9.72|
;;;1585   
;;;1586             return HAL_TIMEOUT;
;;;1587           }
;;;1588         }
;;;1589       }
;;;1590     }
;;;1591   
;;;1592     /* Disable the UART DMA Rx request if enabled */
;;;1593     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000048  6820              LDR      r0,[r4,#0]
00004a  6941              LDR      r1,[r0,#0x14]
00004c  0649              LSLS     r1,r1,#25
00004e  d50f              BPL      |L9.112|
;;;1594     {
;;;1595       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000050  6941              LDR      r1,[r0,#0x14]
000052  f0210140          BIC      r1,r1,#0x40
000056  6141              STR      r1,[r0,#0x14]
;;;1596   
;;;1597       /* Abort the UART DMA Rx channel: use blocking DMA Abort API (no callback) */
;;;1598       if (huart->hdmarx != NULL)
000058  6b60              LDR      r0,[r4,#0x34]
00005a  b148              CBZ      r0,|L9.112|
;;;1599       {
;;;1600         /* Set the UART DMA Abort callback to Null.
;;;1601            No call back execution at end of DMA abort procedure */
;;;1602         huart->hdmarx->XferAbortCallback = NULL;
00005c  6345              STR      r5,[r0,#0x34]
;;;1603   
;;;1604         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
00005e  6b60              LDR      r0,[r4,#0x34]
000060  f7fffffe          BL       HAL_DMA_Abort
000064  b120              CBZ      r0,|L9.112|
;;;1605         {
;;;1606           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
000066  6b60              LDR      r0,[r4,#0x34]
000068  f7fffffe          BL       HAL_DMA_GetError
00006c  2820              CMP      r0,#0x20
00006e  d00c              BEQ      |L9.138|
                  |L9.112|
;;;1607           {
;;;1608             /* Set error code to DMA */
;;;1609             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1610   
;;;1611             return HAL_TIMEOUT;
;;;1612           }
;;;1613         }
;;;1614       }
;;;1615     }
;;;1616   
;;;1617     /* Reset Tx and Rx transfer counters */
;;;1618     huart->TxXferCount = 0x00U;
000070  84e5              STRH     r5,[r4,#0x26]
;;;1619     huart->RxXferCount = 0x00U;
000072  85e5              STRH     r5,[r4,#0x2e]
;;;1620   
;;;1621     /* Reset ErrorCode */
;;;1622     huart->ErrorCode = HAL_UART_ERROR_NONE;
000074  63e5              STR      r5,[r4,#0x3c]
;;;1623   
;;;1624     /* Restore huart->RxState and huart->gState to Ready */
;;;1625     huart->RxState = HAL_UART_STATE_READY;
000076  2020              MOVS     r0,#0x20
000078  f884003a          STRB     r0,[r4,#0x3a]
;;;1626     huart->gState = HAL_UART_STATE_READY;
00007c  f8840039          STRB     r0,[r4,#0x39]
;;;1627   
;;;1628     return HAL_OK;
000080  2000              MOVS     r0,#0
;;;1629   }
000082  bd70              POP      {r4-r6,pc}
                  |L9.132|
000084  63e6              STR      r6,[r4,#0x3c]         ;1584
000086  2003              MOVS     r0,#3                 ;1586
000088  bd70              POP      {r4-r6,pc}
                  |L9.138|
00008a  63e6              STR      r6,[r4,#0x3c]         ;1609
00008c  2003              MOVS     r0,#3                 ;1611
00008e  bd70              POP      {r4-r6,pc}
;;;1630   
                          ENDP


                          AREA ||i.HAL_UART_AbortCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortCpltCallback PROC
;;;2242     */
;;;2243   __weak void HAL_UART_AbortCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2244   {
;;;2245     /* Prevent unused argument(s) compilation warning */
;;;2246     UNUSED(huart);
;;;2247   
;;;2248     /* NOTE : This function should not be modified, when the callback is needed,
;;;2249               the HAL_UART_AbortCpltCallback can be implemented in the user file.
;;;2250      */
;;;2251   }
;;;2252   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceive PROC
;;;1693   */
;;;1694   HAL_StatusTypeDef HAL_UART_AbortReceive(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1695   {
000002  4604              MOV      r4,r0
;;;1696     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1697     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217190          BIC      r1,r1,#0x120
00000c  60c1              STR      r1,[r0,#0xc]
;;;1698     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1699   
;;;1700     /* Disable the UART DMA Rx request if enabled */
;;;1701     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0500          MOV      r5,#0
000020  0649              LSLS     r1,r1,#25
000022  d50f              BPL      |L11.68|
;;;1702     {
;;;1703       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000024  6941              LDR      r1,[r0,#0x14]
000026  f0210140          BIC      r1,r1,#0x40
00002a  6141              STR      r1,[r0,#0x14]
;;;1704   
;;;1705       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1706       if (huart->hdmarx != NULL)
00002c  6b60              LDR      r0,[r4,#0x34]
00002e  b148              CBZ      r0,|L11.68|
;;;1707       {
;;;1708         /* Set the UART DMA Abort callback to Null.
;;;1709            No call back execution at end of DMA abort procedure */
;;;1710         huart->hdmarx->XferAbortCallback = NULL;
000030  6345              STR      r5,[r0,#0x34]
;;;1711   
;;;1712         if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
000032  6b60              LDR      r0,[r4,#0x34]
000034  f7fffffe          BL       HAL_DMA_Abort
000038  b120              CBZ      r0,|L11.68|
;;;1713         {
;;;1714           if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
00003a  6b60              LDR      r0,[r4,#0x34]
00003c  f7fffffe          BL       HAL_DMA_GetError
000040  2820              CMP      r0,#0x20
000042  d005              BEQ      |L11.80|
                  |L11.68|
;;;1715           {
;;;1716             /* Set error code to DMA */
;;;1717             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1718   
;;;1719             return HAL_TIMEOUT;
;;;1720           }
;;;1721         }
;;;1722       }
;;;1723     }
;;;1724   
;;;1725     /* Reset Rx transfer counter */
;;;1726     huart->RxXferCount = 0x00U;
000044  85e5              STRH     r5,[r4,#0x2e]
;;;1727   
;;;1728     /* Restore huart->RxState to Ready */
;;;1729     huart->RxState = HAL_UART_STATE_READY;
000046  2020              MOVS     r0,#0x20
000048  f884003a          STRB     r0,[r4,#0x3a]
;;;1730   
;;;1731     return HAL_OK;
00004c  2000              MOVS     r0,#0
;;;1732   }
00004e  bd70              POP      {r4-r6,pc}
                  |L11.80|
000050  2010              MOVS     r0,#0x10              ;1717
000052  63e0              STR      r0,[r4,#0x3c]         ;1717
000054  2003              MOVS     r0,#3                 ;1719
000056  bd70              POP      {r4-r6,pc}
;;;1733   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceiveCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortReceiveCpltCallback PROC
;;;2272     */
;;;2273   __weak void HAL_UART_AbortReceiveCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2274   {
;;;2275     /* Prevent unused argument(s) compilation warning */
;;;2276     UNUSED(huart);
;;;2277   
;;;2278     /* NOTE : This function should not be modified, when the callback is needed,
;;;2279               the HAL_UART_AbortReceiveCpltCallback can be implemented in the user file.
;;;2280      */
;;;2281   }
;;;2282   
                          ENDP


                          AREA ||i.HAL_UART_AbortReceive_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortReceive_IT PROC
;;;1952   */
;;;1953   HAL_StatusTypeDef HAL_UART_AbortReceive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1954   {
000002  4604              MOV      r4,r0
;;;1955     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1956     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f4217190          BIC      r1,r1,#0x120
00000c  60c1              STR      r1,[r0,#0xc]
;;;1957     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f0210101          BIC      r1,r1,#1
000016  6141              STR      r1,[r0,#0x14]
;;;1958   
;;;1959     /* Disable the UART DMA Rx request if enabled */
;;;1960     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000018  6820              LDR      r0,[r4,#0]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f04f0200          MOV      r2,#0
000020  064b              LSLS     r3,r1,#25
;;;1961     {
;;;1962       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1963   
;;;1964       /* Abort the UART DMA Rx channel : use blocking DMA Abort API (no callback) */
;;;1965       if (huart->hdmarx != NULL)
;;;1966       {
;;;1967         /* Set the UART DMA Abort callback :
;;;1968            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1969         huart->hdmarx->XferAbortCallback = UART_DMARxOnlyAbortCallback;
;;;1970   
;;;1971         /* Abort DMA RX */
;;;1972         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
;;;1973         {
;;;1974           /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
;;;1975           huart->hdmarx->XferAbortCallback(huart->hdmarx);
;;;1976         }
;;;1977       }
;;;1978       else
;;;1979       {
;;;1980         /* Reset Rx transfer counter */
;;;1981         huart->RxXferCount = 0x00U;
;;;1982   
;;;1983         /* Restore huart->RxState to Ready */
;;;1984         huart->RxState = HAL_UART_STATE_READY;
000022  f04f0120          MOV      r1,#0x20
000026  d516              BPL      |L13.86|
000028  6943              LDR      r3,[r0,#0x14]         ;1962
00002a  f0230340          BIC      r3,r3,#0x40           ;1962
00002e  6143              STR      r3,[r0,#0x14]         ;1962
000030  6b60              LDR      r0,[r4,#0x34]         ;1965
000032  b148              CBZ      r0,|L13.72|
000034  490c              LDR      r1,|L13.104|
000036  6341              STR      r1,[r0,#0x34]         ;1969
000038  6b60              LDR      r0,[r4,#0x34]         ;1972
00003a  f7fffffe          BL       HAL_DMA_Abort_IT
00003e  b180              CBZ      r0,|L13.98|
000040  6b60              LDR      r0,[r4,#0x34]         ;1975
000042  6b41              LDR      r1,[r0,#0x34]         ;1975
000044  4788              BLX      r1                    ;1975
000046  e00c              B        |L13.98|
                  |L13.72|
000048  85e2              STRH     r2,[r4,#0x2e]         ;1981
00004a  f884103a          STRB     r1,[r4,#0x3a]
;;;1985   
;;;1986         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1987   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1988         /* Call registered Abort Receive Complete Callback */
;;;1989         huart->AbortReceiveCpltCallback(huart);
;;;1990   #else
;;;1991         /* Call legacy weak Abort Receive Complete Callback */
;;;1992         HAL_UART_AbortReceiveCpltCallback(huart);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
000054  e005              B        |L13.98|
                  |L13.86|
;;;1993   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1994       }
;;;1995     }
;;;1996     else
;;;1997     {
;;;1998       /* Reset Rx transfer counter */
;;;1999       huart->RxXferCount = 0x00U;
000056  85e2              STRH     r2,[r4,#0x2e]
;;;2000   
;;;2001       /* Restore huart->RxState to Ready */
;;;2002       huart->RxState = HAL_UART_STATE_READY;
000058  f884103a          STRB     r1,[r4,#0x3a]
;;;2003   
;;;2004       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;2005   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2006       /* Call registered Abort Receive Complete Callback */
;;;2007       huart->AbortReceiveCpltCallback(huart);
;;;2008   #else
;;;2009       /* Call legacy weak Abort Receive Complete Callback */
;;;2010       HAL_UART_AbortReceiveCpltCallback(huart);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
                  |L13.98|
;;;2011   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2012     }
;;;2013   
;;;2014     return HAL_OK;
000062  2000              MOVS     r0,#0
;;;2015   }
000064  bd10              POP      {r4,pc}
;;;2016   
                          ENDP

000066  0000              DCW      0x0000
                  |L13.104|
                          DCD      UART_DMARxOnlyAbortCallback

                          AREA ||i.HAL_UART_AbortTransmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmit PROC
;;;1642   */
;;;1643   HAL_StatusTypeDef HAL_UART_AbortTransmit(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1644   {
000002  4604              MOV      r4,r0
;;;1645     /* Disable TXEIE and TCIE interrupts */
;;;1646     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1647   
;;;1648     /* Disable the UART DMA Tx request if enabled */
;;;1649     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  f04f0500          MOV      r5,#0
000016  0609              LSLS     r1,r1,#24
000018  d50f              BPL      |L14.58|
;;;1650     {
;;;1651       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00001a  6941              LDR      r1,[r0,#0x14]
00001c  f0210180          BIC      r1,r1,#0x80
000020  6141              STR      r1,[r0,#0x14]
;;;1652   
;;;1653       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1654       if (huart->hdmatx != NULL)
000022  6b20              LDR      r0,[r4,#0x30]
000024  b148              CBZ      r0,|L14.58|
;;;1655       {
;;;1656         /* Set the UART DMA Abort callback to Null.
;;;1657            No call back execution at end of DMA abort procedure */
;;;1658         huart->hdmatx->XferAbortCallback = NULL;
000026  6345              STR      r5,[r0,#0x34]
;;;1659   
;;;1660         if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
000028  6b20              LDR      r0,[r4,#0x30]
00002a  f7fffffe          BL       HAL_DMA_Abort
00002e  b120              CBZ      r0,|L14.58|
;;;1661         {
;;;1662           if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
000030  6b20              LDR      r0,[r4,#0x30]
000032  f7fffffe          BL       HAL_DMA_GetError
000036  2820              CMP      r0,#0x20
000038  d005              BEQ      |L14.70|
                  |L14.58|
;;;1663           {
;;;1664             /* Set error code to DMA */
;;;1665             huart->ErrorCode = HAL_UART_ERROR_DMA;
;;;1666   
;;;1667             return HAL_TIMEOUT;
;;;1668           }
;;;1669         }
;;;1670       }
;;;1671     }
;;;1672   
;;;1673     /* Reset Tx transfer counter */
;;;1674     huart->TxXferCount = 0x00U;
00003a  84e5              STRH     r5,[r4,#0x26]
;;;1675   
;;;1676     /* Restore huart->gState to Ready */
;;;1677     huart->gState = HAL_UART_STATE_READY;
00003c  2020              MOVS     r0,#0x20
00003e  f8840039          STRB     r0,[r4,#0x39]
;;;1678   
;;;1679     return HAL_OK;
000042  2000              MOVS     r0,#0
;;;1680   }
000044  bd70              POP      {r4-r6,pc}
                  |L14.70|
000046  2010              MOVS     r0,#0x10              ;1665
000048  63e0              STR      r0,[r4,#0x3c]         ;1665
00004a  2003              MOVS     r0,#3                 ;1667
00004c  bd70              POP      {r4-r6,pc}
;;;1681   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmitCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_AbortTransmitCpltCallback PROC
;;;2257     */
;;;2258   __weak void HAL_UART_AbortTransmitCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2259   {
;;;2260     /* Prevent unused argument(s) compilation warning */
;;;2261     UNUSED(huart);
;;;2262   
;;;2263     /* NOTE : This function should not be modified, when the callback is needed,
;;;2264               the HAL_UART_AbortTransmitCpltCallback can be implemented in the user file.
;;;2265      */
;;;2266   }
;;;2267   
                          ENDP


                          AREA ||i.HAL_UART_AbortTransmit_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_AbortTransmit_IT PROC
;;;1875   */
;;;1876   HAL_StatusTypeDef HAL_UART_AbortTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1877   {
000002  4604              MOV      r4,r0
;;;1878     /* Disable TXEIE and TCIE interrupts */
;;;1879     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000004  6820              LDR      r0,[r4,#0]
000006  68c1              LDR      r1,[r0,#0xc]
000008  f02101c0          BIC      r1,r1,#0xc0
00000c  60c1              STR      r1,[r0,#0xc]
;;;1880   
;;;1881     /* Disable the UART DMA Tx request if enabled */
;;;1882     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
;;;1883     {
;;;1884       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1885   
;;;1886       /* Abort the UART DMA Tx channel : use blocking DMA Abort API (no callback) */
;;;1887       if (huart->hdmatx != NULL)
;;;1888       {
;;;1889         /* Set the UART DMA Abort callback :
;;;1890            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1891         huart->hdmatx->XferAbortCallback = UART_DMATxOnlyAbortCallback;
;;;1892   
;;;1893         /* Abort DMA TX */
;;;1894         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
;;;1895         {
;;;1896           /* Call Directly huart->hdmatx->XferAbortCallback function in case of error */
;;;1897           huart->hdmatx->XferAbortCallback(huart->hdmatx);
;;;1898         }
;;;1899       }
;;;1900       else
;;;1901       {
;;;1902         /* Reset Tx transfer counter */
;;;1903         huart->TxXferCount = 0x00U;
;;;1904   
;;;1905         /* Restore huart->gState to Ready */
;;;1906         huart->gState = HAL_UART_STATE_READY;
000012  f04f0220          MOV      r2,#0x20
000016  060b              LSLS     r3,r1,#24             ;1882
000018  f04f0100          MOV      r1,#0                 ;1882
00001c  d516              BPL      |L16.76|
00001e  6943              LDR      r3,[r0,#0x14]         ;1884
000020  f0230380          BIC      r3,r3,#0x80           ;1884
000024  6143              STR      r3,[r0,#0x14]         ;1884
000026  6b20              LDR      r0,[r4,#0x30]         ;1887
000028  b148              CBZ      r0,|L16.62|
00002a  490c              LDR      r1,|L16.92|
00002c  6341              STR      r1,[r0,#0x34]         ;1891
00002e  6b20              LDR      r0,[r4,#0x30]         ;1894
000030  f7fffffe          BL       HAL_DMA_Abort_IT
000034  b180              CBZ      r0,|L16.88|
000036  6b20              LDR      r0,[r4,#0x30]         ;1897
000038  6b41              LDR      r1,[r0,#0x34]         ;1897
00003a  4788              BLX      r1                    ;1897
00003c  e00c              B        |L16.88|
                  |L16.62|
00003e  84e1              STRH     r1,[r4,#0x26]         ;1903
000040  f8842039          STRB     r2,[r4,#0x39]
;;;1907   
;;;1908         /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1909   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1910         /* Call registered Abort Transmit Complete Callback */
;;;1911         huart->AbortTransmitCpltCallback(huart);
;;;1912   #else
;;;1913         /* Call legacy weak Abort Transmit Complete Callback */
;;;1914         HAL_UART_AbortTransmitCpltCallback(huart);
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
00004a  e005              B        |L16.88|
                  |L16.76|
;;;1915   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1916       }
;;;1917     }
;;;1918     else
;;;1919     {
;;;1920       /* Reset Tx transfer counter */
;;;1921       huart->TxXferCount = 0x00U;
00004c  84e1              STRH     r1,[r4,#0x26]
;;;1922   
;;;1923       /* Restore huart->gState to Ready */
;;;1924       huart->gState = HAL_UART_STATE_READY;
00004e  f8842039          STRB     r2,[r4,#0x39]
;;;1925   
;;;1926       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1927   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1928       /* Call registered Abort Transmit Complete Callback */
;;;1929       huart->AbortTransmitCpltCallback(huart);
;;;1930   #else
;;;1931       /* Call legacy weak Abort Transmit Complete Callback */
;;;1932       HAL_UART_AbortTransmitCpltCallback(huart);
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
                  |L16.88|
;;;1933   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1934     }
;;;1935   
;;;1936     return HAL_OK;
000058  2000              MOVS     r0,#0
;;;1937   }
00005a  bd10              POP      {r4,pc}
;;;1938   
                          ENDP

                  |L16.92|
                          DCD      UART_DMATxOnlyAbortCallback

                          AREA ||i.HAL_UART_Abort_IT||, CODE, READONLY, ALIGN=2

                  HAL_UART_Abort_IT PROC
;;;1747   */
;;;1748   HAL_StatusTypeDef HAL_UART_Abort_IT(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;1749   {
000002  4604              MOV      r4,r0
;;;1750     uint32_t AbortCplt = 0x01U;
000004  2501              MOVS     r5,#1
;;;1751   
;;;1752     /* Disable TXEIE, TCIE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1753     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE | USART_CR1_TCIE));
000006  6820              LDR      r0,[r4,#0]
000008  68c1              LDR      r1,[r0,#0xc]
00000a  f42171f0          BIC      r1,r1,#0x1e0
00000e  60c1              STR      r1,[r0,#0xc]
;;;1754     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
000010  6820              LDR      r0,[r4,#0]
000012  6941              LDR      r1,[r0,#0x14]
000014  f0210101          BIC      r1,r1,#1
000018  6141              STR      r1,[r0,#0x14]
;;;1755   
;;;1756     /* If DMA Tx and/or DMA Rx Handles are associated to UART Handle, DMA Abort complete callbacks should be initialised
;;;1757        before any call to DMA Abort functions */
;;;1758     /* DMA Tx Handle is valid */
;;;1759     if (huart->hdmatx != NULL)
00001a  6b20              LDR      r0,[r4,#0x30]
00001c  2600              MOVS     r6,#0
00001e  2800              CMP      r0,#0
000020  d007              BEQ      |L17.50|
;;;1760     {
;;;1761       /* Set DMA Abort Complete callback if UART DMA Tx request if enabled.
;;;1762          Otherwise, set it to NULL */
;;;1763       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000022  6821              LDR      r1,[r4,#0]
000024  6949              LDR      r1,[r1,#0x14]
000026  0609              LSLS     r1,r1,#24
000028  d502              BPL      |L17.48|
;;;1764       {
;;;1765         huart->hdmatx->XferAbortCallback = UART_DMATxAbortCallback;
00002a  4920              LDR      r1,|L17.172|
00002c  6341              STR      r1,[r0,#0x34]
00002e  e000              B        |L17.50|
                  |L17.48|
;;;1766       }
;;;1767       else
;;;1768       {
;;;1769         huart->hdmatx->XferAbortCallback = NULL;
000030  6346              STR      r6,[r0,#0x34]
                  |L17.50|
;;;1770       }
;;;1771     }
;;;1772     /* DMA Rx Handle is valid */
;;;1773     if (huart->hdmarx != NULL)
000032  6b60              LDR      r0,[r4,#0x34]
000034  b138              CBZ      r0,|L17.70|
;;;1774     {
;;;1775       /* Set DMA Abort Complete callback if UART DMA Rx request if enabled.
;;;1776          Otherwise, set it to NULL */
;;;1777       if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000036  6821              LDR      r1,[r4,#0]
000038  6949              LDR      r1,[r1,#0x14]
00003a  0649              LSLS     r1,r1,#25
00003c  d502              BPL      |L17.68|
;;;1778       {
;;;1779         huart->hdmarx->XferAbortCallback = UART_DMARxAbortCallback;
00003e  491c              LDR      r1,|L17.176|
000040  6341              STR      r1,[r0,#0x34]
000042  e000              B        |L17.70|
                  |L17.68|
;;;1780       }
;;;1781       else
;;;1782       {
;;;1783         huart->hdmarx->XferAbortCallback = NULL;
000044  6346              STR      r6,[r0,#0x34]
                  |L17.70|
;;;1784       }
;;;1785     }
;;;1786   
;;;1787     /* Disable the UART DMA Tx request if enabled */
;;;1788     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT))
000046  6820              LDR      r0,[r4,#0]
000048  6941              LDR      r1,[r0,#0x14]
00004a  0609              LSLS     r1,r1,#24
00004c  d50c              BPL      |L17.104|
;;;1789     {
;;;1790       /* Disable DMA Tx at UART level */
;;;1791       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
00004e  6941              LDR      r1,[r0,#0x14]
000050  f0210180          BIC      r1,r1,#0x80
000054  6141              STR      r1,[r0,#0x14]
;;;1792   
;;;1793       /* Abort the UART DMA Tx channel : use non blocking DMA Abort API (callback) */
;;;1794       if (huart->hdmatx != NULL)
000056  6b20              LDR      r0,[r4,#0x30]
000058  b130              CBZ      r0,|L17.104|
;;;1795       {
;;;1796         /* UART Tx DMA Abort callback has already been initialised :
;;;1797            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1798   
;;;1799         /* Abort DMA TX */
;;;1800         if (HAL_DMA_Abort_IT(huart->hdmatx) != HAL_OK)
00005a  f7fffffe          BL       HAL_DMA_Abort_IT
00005e  b110              CBZ      r0,|L17.102|
;;;1801         {
;;;1802           huart->hdmatx->XferAbortCallback = NULL;
000060  6b20              LDR      r0,[r4,#0x30]
000062  6346              STR      r6,[r0,#0x34]
000064  e000              B        |L17.104|
                  |L17.102|
;;;1803         }
;;;1804         else
;;;1805         {
;;;1806           AbortCplt = 0x00U;
000066  2500              MOVS     r5,#0
                  |L17.104|
;;;1807         }
;;;1808       }
;;;1809     }
;;;1810   
;;;1811     /* Disable the UART DMA Rx request if enabled */
;;;1812     if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
000068  6820              LDR      r0,[r4,#0]
00006a  6941              LDR      r1,[r0,#0x14]
00006c  0649              LSLS     r1,r1,#25
00006e  d50d              BPL      |L17.140|
;;;1813     {
;;;1814       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000070  6941              LDR      r1,[r0,#0x14]
000072  f0210140          BIC      r1,r1,#0x40
000076  6141              STR      r1,[r0,#0x14]
;;;1815   
;;;1816       /* Abort the UART DMA Rx channel : use non blocking DMA Abort API (callback) */
;;;1817       if (huart->hdmarx != NULL)
000078  6b60              LDR      r0,[r4,#0x34]
00007a  b138              CBZ      r0,|L17.140|
;;;1818       {
;;;1819         /* UART Rx DMA Abort callback has already been initialised :
;;;1820            will lead to call HAL_UART_AbortCpltCallback() at end of DMA abort procedure */
;;;1821   
;;;1822         /* Abort DMA RX */
;;;1823         if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
00007c  f7fffffe          BL       HAL_DMA_Abort_IT
000080  b118              CBZ      r0,|L17.138|
;;;1824         {
;;;1825           huart->hdmarx->XferAbortCallback = NULL;
000082  6b60              LDR      r0,[r4,#0x34]
000084  6346              STR      r6,[r0,#0x34]
;;;1826           AbortCplt = 0x01U;
000086  2501              MOVS     r5,#1
000088  e000              B        |L17.140|
                  |L17.138|
;;;1827         }
;;;1828         else
;;;1829         {
;;;1830           AbortCplt = 0x00U;
00008a  2500              MOVS     r5,#0
                  |L17.140|
;;;1831         }
;;;1832       }
;;;1833     }
;;;1834   
;;;1835     /* if no DMA abort complete callback execution is required => call user Abort Complete callback */
;;;1836     if (AbortCplt == 0x01U)
00008c  2d01              CMP      r5,#1
00008e  d10a              BNE      |L17.166|
;;;1837     {
;;;1838       /* Reset Tx and Rx transfer counters */
;;;1839       huart->TxXferCount = 0x00U;
000090  84e6              STRH     r6,[r4,#0x26]
;;;1840       huart->RxXferCount = 0x00U;
000092  85e6              STRH     r6,[r4,#0x2e]
;;;1841   
;;;1842       /* Reset ErrorCode */
;;;1843       huart->ErrorCode = HAL_UART_ERROR_NONE;
000094  63e6              STR      r6,[r4,#0x3c]
;;;1844   
;;;1845       /* Restore huart->gState and huart->RxState to Ready */
;;;1846       huart->gState  = HAL_UART_STATE_READY;
000096  2020              MOVS     r0,#0x20
000098  f8840039          STRB     r0,[r4,#0x39]
;;;1847       huart->RxState = HAL_UART_STATE_READY;
00009c  f884003a          STRB     r0,[r4,#0x3a]
;;;1848   
;;;1849       /* As no DMA to be aborted, call directly user Abort complete callback */
;;;1850   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;1851       /* Call registered Abort complete callback */
;;;1852       huart->AbortCpltCallback(huart);
;;;1853   #else
;;;1854       /* Call legacy weak Abort complete callback */
;;;1855       HAL_UART_AbortCpltCallback(huart);
0000a0  4620              MOV      r0,r4
0000a2  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L17.166|
;;;1856   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;1857     }
;;;1858   
;;;1859     return HAL_OK;
0000a6  2000              MOVS     r0,#0
;;;1860   }
0000a8  bd70              POP      {r4-r6,pc}
;;;1861   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L17.172|
                          DCD      UART_DMATxAbortCallback
                  |L17.176|
                          DCD      UART_DMARxAbortCallback

                          AREA ||i.HAL_UART_DMAPause||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAPause PROC
;;;1435     */
;;;1436   HAL_StatusTypeDef HAL_UART_DMAPause(UART_HandleTypeDef *huart)
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;1437   {
;;;1438     uint32_t dmarequest = 0x00U;
;;;1439   
;;;1440     /* Process Locked */
;;;1441     __HAL_LOCK(huart);
000004  2901              CMP      r1,#1
000006  d00b              BEQ      |L18.32|
000008  2101              MOVS     r1,#1
00000a  f8801038          STRB     r1,[r0,#0x38]
;;;1442   
;;;1443     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
00000e  6801              LDR      r1,[r0,#0]
000010  694a              LDR      r2,[r1,#0x14]
000012  f3c212c0          UBFX     r2,r2,#7,#1
;;;1444     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
000016  f8903039          LDRB     r3,[r0,#0x39]
00001a  2b21              CMP      r3,#0x21
00001c  d002              BEQ      |L18.36|
00001e  e006              B        |L18.46|
                  |L18.32|
000020  2002              MOVS     r0,#2                 ;1441
;;;1445     {
;;;1446       /* Disable the UART DMA Tx request */
;;;1447       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1448     }
;;;1449   
;;;1450     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
;;;1451     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
;;;1452     {
;;;1453       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1454       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1455       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1456   
;;;1457       /* Disable the UART DMA Rx request */
;;;1458       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1459     }
;;;1460   
;;;1461     /* Process Unlocked */
;;;1462     __HAL_UNLOCK(huart);
;;;1463   
;;;1464     return HAL_OK;
;;;1465   }
000022  4770              BX       lr
                  |L18.36|
000024  b11a              CBZ      r2,|L18.46|
000026  694a              LDR      r2,[r1,#0x14]         ;1447
000028  f0220280          BIC      r2,r2,#0x80           ;1447
00002c  614a              STR      r2,[r1,#0x14]         ;1447
                  |L18.46|
00002e  6801              LDR      r1,[r0,#0]            ;1450
000030  694a              LDR      r2,[r1,#0x14]         ;1450
000032  f3c21280          UBFX     r2,r2,#6,#1           ;1450
000036  f890303a          LDRB     r3,[r0,#0x3a]         ;1451
00003a  2b22              CMP      r3,#0x22              ;1451
00003c  d10e              BNE      |L18.92|
00003e  b16a              CBZ      r2,|L18.92|
000040  68ca              LDR      r2,[r1,#0xc]          ;1454
000042  f4227280          BIC      r2,r2,#0x100          ;1454
000046  60ca              STR      r2,[r1,#0xc]          ;1454
000048  6801              LDR      r1,[r0,#0]            ;1455
00004a  694a              LDR      r2,[r1,#0x14]         ;1455
00004c  f0220201          BIC      r2,r2,#1              ;1455
000050  614a              STR      r2,[r1,#0x14]         ;1455
000052  6801              LDR      r1,[r0,#0]            ;1458
000054  694a              LDR      r2,[r1,#0x14]         ;1458
000056  f0220240          BIC      r2,r2,#0x40           ;1458
00005a  614a              STR      r2,[r1,#0x14]         ;1458
                  |L18.92|
00005c  2100              MOVS     r1,#0                 ;1462
00005e  f8801038          STRB     r1,[r0,#0x38]         ;1462
000062  2000              MOVS     r0,#0                 ;1464
000064  4770              BX       lr
;;;1466   
                          ENDP


                          AREA ||i.HAL_UART_DMAResume||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAResume PROC
;;;1472     */
;;;1473   HAL_StatusTypeDef HAL_UART_DMAResume(UART_HandleTypeDef *huart)
000000  b508              PUSH     {r3,lr}
;;;1474   {
;;;1475     /* Process Locked */
;;;1476     __HAL_LOCK(huart);
000002  f8901038          LDRB     r1,[r0,#0x38]
000006  2901              CMP      r1,#1
000008  d007              BEQ      |L19.26|
00000a  2101              MOVS     r1,#1
00000c  f8801038          STRB     r1,[r0,#0x38]
;;;1477   
;;;1478     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000010  f8901039          LDRB     r1,[r0,#0x39]
000014  2921              CMP      r1,#0x21
000016  d002              BEQ      |L19.30|
000018  e006              B        |L19.40|
                  |L19.26|
00001a  2002              MOVS     r0,#2                 ;1476
;;;1479     {
;;;1480       /* Enable the UART DMA Tx request */
;;;1481       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1482     }
;;;1483   
;;;1484     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
;;;1485     {
;;;1486       /* Clear the Overrun flag before resuming the Rx transfer*/
;;;1487       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1488   
;;;1489       /* Reenable PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;1490       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1491       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1492   
;;;1493       /* Enable the UART DMA Rx request */
;;;1494       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1495     }
;;;1496   
;;;1497     /* Process Unlocked */
;;;1498     __HAL_UNLOCK(huart);
;;;1499   
;;;1500     return HAL_OK;
;;;1501   }
00001c  bd08              POP      {r3,pc}
                  |L19.30|
00001e  6801              LDR      r1,[r0,#0]            ;1481
000020  694a              LDR      r2,[r1,#0x14]         ;1481
000022  f0420280          ORR      r2,r2,#0x80           ;1481
000026  614a              STR      r2,[r1,#0x14]         ;1481
                  |L19.40|
000028  f890103a          LDRB     r1,[r0,#0x3a]         ;1484
00002c  2200              MOVS     r2,#0                 ;1484
00002e  2922              CMP      r1,#0x22              ;1484
000030  d111              BNE      |L19.86|
000032  6801              LDR      r1,[r0,#0]            ;1487
000034  680b              LDR      r3,[r1,#0]            ;1487
000036  684b              LDR      r3,[r1,#4]            ;1487
000038  9300              STR      r3,[sp,#0]            ;1487
00003a  68cb              LDR      r3,[r1,#0xc]          ;1490
00003c  f4437380          ORR      r3,r3,#0x100          ;1490
000040  60cb              STR      r3,[r1,#0xc]          ;1490
000042  6801              LDR      r1,[r0,#0]            ;1491
000044  694b              LDR      r3,[r1,#0x14]         ;1491
000046  f0430301          ORR      r3,r3,#1              ;1491
00004a  614b              STR      r3,[r1,#0x14]         ;1491
00004c  6801              LDR      r1,[r0,#0]            ;1494
00004e  694b              LDR      r3,[r1,#0x14]         ;1494
000050  f0430340          ORR      r3,r3,#0x40           ;1494
000054  614b              STR      r3,[r1,#0x14]         ;1494
                  |L19.86|
000056  f8802038          STRB     r2,[r0,#0x38]         ;1498
00005a  2000              MOVS     r0,#0                 ;1500
00005c  bd08              POP      {r3,pc}
;;;1502   
                          ENDP


                          AREA ||i.HAL_UART_DMAStop||, CODE, READONLY, ALIGN=1

                  HAL_UART_DMAStop PROC
;;;1508     */
;;;1509   HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;1510   {
000002  4604              MOV      r4,r0
;;;1511     uint32_t dmarequest = 0x00U;
;;;1512     /* The Lock is not implemented on this API to allow the user application
;;;1513        to call the HAL UART API under callbacks HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback():
;;;1514        when calling HAL_DMA_Abort() API the DMA TX/RX Transfer complete interrupt is generated
;;;1515        and the correspond call back is executed HAL_UART_TxCpltCallback() / HAL_UART_RxCpltCallback()
;;;1516        */
;;;1517   
;;;1518     /* Stop UART DMA Tx request if ongoing */
;;;1519     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000004  6820              LDR      r0,[r4,#0]
000006  6941              LDR      r1,[r0,#0x14]
000008  f3c111c0          UBFX     r1,r1,#7,#1
;;;1520     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
00000c  f8942039          LDRB     r2,[r4,#0x39]
000010  2a21              CMP      r2,#0x21
000012  d10b              BNE      |L20.44|
000014  b151              CBZ      r1,|L20.44|
;;;1521     {
;;;1522       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000016  6941              LDR      r1,[r0,#0x14]
000018  f0210180          BIC      r1,r1,#0x80
00001c  6141              STR      r1,[r0,#0x14]
;;;1523   
;;;1524       /* Abort the UART DMA Tx channel */
;;;1525       if (huart->hdmatx != NULL)
00001e  6b20              LDR      r0,[r4,#0x30]
000020  b108              CBZ      r0,|L20.38|
;;;1526       {
;;;1527         HAL_DMA_Abort(huart->hdmatx);
000022  f7fffffe          BL       HAL_DMA_Abort
                  |L20.38|
;;;1528       }
;;;1529       UART_EndTxTransfer(huart);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       UART_EndTxTransfer
                  |L20.44|
;;;1530     }
;;;1531   
;;;1532     /* Stop UART DMA Rx request if ongoing */
;;;1533     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
00002c  6820              LDR      r0,[r4,#0]
00002e  6941              LDR      r1,[r0,#0x14]
000030  f3c11180          UBFX     r1,r1,#6,#1
;;;1534     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
000034  f894203a          LDRB     r2,[r4,#0x3a]
000038  2a22              CMP      r2,#0x22
00003a  d10b              BNE      |L20.84|
00003c  b151              CBZ      r1,|L20.84|
;;;1535     {
;;;1536       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
00003e  6941              LDR      r1,[r0,#0x14]
000040  f0210140          BIC      r1,r1,#0x40
000044  6141              STR      r1,[r0,#0x14]
;;;1537   
;;;1538       /* Abort the UART DMA Rx channel */
;;;1539       if (huart->hdmarx != NULL)
000046  6b60              LDR      r0,[r4,#0x34]
000048  b108              CBZ      r0,|L20.78|
;;;1540       {
;;;1541         HAL_DMA_Abort(huart->hdmarx);
00004a  f7fffffe          BL       HAL_DMA_Abort
                  |L20.78|
;;;1542       }
;;;1543       UART_EndRxTransfer(huart);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       UART_EndRxTransfer
                  |L20.84|
;;;1544     }
;;;1545   
;;;1546     return HAL_OK;
000054  2000              MOVS     r0,#0
;;;1547   }
000056  bd10              POP      {r4,pc}
;;;1548   
                          ENDP


                          AREA ||i.HAL_UART_DeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_DeInit PROC
;;;627      */
;;;628    HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;629    {
000002  4604              MOV      r4,r0
;;;630      /* Check the UART handle allocation */
;;;631      if (huart == NULL)
000004  2c00              CMP      r4,#0
000006  d011              BEQ      |L21.44|
;;;632      {
;;;633        return HAL_ERROR;
;;;634      }
;;;635    
;;;636      /* Check the parameters */
;;;637      assert_param(IS_UART_INSTANCE(huart->Instance));
;;;638    
;;;639      huart->gState = HAL_UART_STATE_BUSY;
000008  2024              MOVS     r0,#0x24
00000a  f8840039          STRB     r0,[r4,#0x39]
;;;640    
;;;641      /* Disable the Peripheral */
;;;642      __HAL_UART_DISABLE(huart);
00000e  6820              LDR      r0,[r4,#0]
000010  68c1              LDR      r1,[r0,#0xc]
000012  f4215100          BIC      r1,r1,#0x2000
000016  60c1              STR      r1,[r0,#0xc]
;;;643    
;;;644    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;645      if (huart->MspDeInitCallback == NULL)
;;;646      {
;;;647        huart->MspDeInitCallback = HAL_UART_MspDeInit;
;;;648      }
;;;649      /* DeInit the low level hardware */
;;;650      huart->MspDeInitCallback(huart);
;;;651    #else
;;;652      /* DeInit the low level hardware */
;;;653      HAL_UART_MspDeInit(huart);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       HAL_UART_MspDeInit
;;;654    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;655    
;;;656      huart->ErrorCode = HAL_UART_ERROR_NONE;
00001e  2000              MOVS     r0,#0
000020  3438              ADDS     r4,r4,#0x38
000022  6060              STR      r0,[r4,#4]
;;;657      huart->gState = HAL_UART_STATE_RESET;
000024  7060              STRB     r0,[r4,#1]
;;;658      huart->RxState = HAL_UART_STATE_RESET;
000026  70a0              STRB     r0,[r4,#2]
;;;659    
;;;660      /* Process Unlock */
;;;661      __HAL_UNLOCK(huart);
000028  7020              STRB     r0,[r4,#0]
;;;662    
;;;663      return HAL_OK;
;;;664    }
00002a  bd10              POP      {r4,pc}
                  |L21.44|
00002c  2001              MOVS     r0,#1                 ;633
00002e  bd10              POP      {r4,pc}
;;;665    
                          ENDP


                          AREA ||i.HAL_UART_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_ErrorCallback PROC
;;;2228     */
;;;2229   __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2230   {
;;;2231     /* Prevent unused argument(s) compilation warning */
;;;2232     UNUSED(huart);
;;;2233     /* NOTE: This function should not be modified, when the callback is needed,
;;;2234              the HAL_UART_ErrorCallback could be implemented in the user file
;;;2235      */
;;;2236   }
;;;2237   
                          ENDP


                          AREA ||i.HAL_UART_GetError||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetError PROC
;;;2499     */
;;;2500   uint32_t HAL_UART_GetError(UART_HandleTypeDef *huart)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;2501   {
;;;2502     return huart->ErrorCode;
;;;2503   }
000002  4770              BX       lr
;;;2504   
                          ENDP


                          AREA ||i.HAL_UART_GetState||, CODE, READONLY, ALIGN=1

                  HAL_UART_GetState PROC
;;;2484     */
;;;2485   HAL_UART_StateTypeDef HAL_UART_GetState(UART_HandleTypeDef *huart)
000000  4601              MOV      r1,r0
;;;2486   {
;;;2487     uint32_t temp1 = 0x00U, temp2 = 0x00U;
;;;2488     temp1 = huart->gState;
000002  f8110f39          LDRB     r0,[r1,#0x39]!
;;;2489     temp2 = huart->RxState;
000006  7849              LDRB     r1,[r1,#1]
;;;2490   
;;;2491     return (HAL_UART_StateTypeDef)(temp1 | temp2);
000008  4308              ORRS     r0,r0,r1
;;;2492   }
00000a  4770              BX       lr
;;;2493   
                          ENDP


                          AREA ||i.HAL_UART_IRQHandler||, CODE, READONLY, ALIGN=2

                  HAL_UART_IRQHandler PROC
;;;2022     */
;;;2023   void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;2024   {
000002  4604              MOV      r4,r0
;;;2025     uint32_t isrflags   = READ_REG(huart->Instance->SR);
000004  6822              LDR      r2,[r4,#0]
000006  6810              LDR      r0,[r2,#0]
;;;2026     uint32_t cr1its     = READ_REG(huart->Instance->CR1);
000008  68d1              LDR      r1,[r2,#0xc]
;;;2027     uint32_t cr3its     = READ_REG(huart->Instance->CR3);
00000a  6952              LDR      r2,[r2,#0x14]
;;;2028     uint32_t errorflags = 0x00U;
;;;2029     uint32_t dmarequest = 0x00U;
;;;2030   
;;;2031     /* If no error occurs */
;;;2032     errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
00000c  f000030f          AND      r3,r0,#0xf
;;;2033     if (errorflags == RESET)
000010  2b00              CMP      r3,#0
000012  d108              BNE      |L25.38|
;;;2034     {
;;;2035       /* UART in mode Receiver -------------------------------------------------*/
;;;2036       if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000014  0685              LSLS     r5,r0,#26
000016  d506              BPL      |L25.38|
000018  068d              LSLS     r5,r1,#26
00001a  d504              BPL      |L25.38|
;;;2037       {
;;;2038         UART_Receive_IT(huart);
00001c  4620              MOV      r0,r4
00001e  e8bd4070          POP      {r4-r6,lr}
000022  f7ffbffe          B.W      UART_Receive_IT
                  |L25.38|
;;;2039         return;
;;;2040       }
;;;2041     }
;;;2042   
;;;2043     /* If some errors occur */
;;;2044     if ((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
000026  2b00              CMP      r3,#0
000028  d060              BEQ      |L25.236|
00002a  f0020301          AND      r3,r2,#1
00002e  f4017590          AND      r5,r1,#0x120
000032  431d              ORRS     r5,r5,r3
000034  d05a              BEQ      |L25.236|
;;;2045     {
;;;2046       /* UART parity error interrupt occurred ----------------------------------*/
;;;2047       if (((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
000036  07c5              LSLS     r5,r0,#31
000038  d005              BEQ      |L25.70|
00003a  05cd              LSLS     r5,r1,#23
00003c  d503              BPL      |L25.70|
;;;2048       {
;;;2049         huart->ErrorCode |= HAL_UART_ERROR_PE;
00003e  6be5              LDR      r5,[r4,#0x3c]
000040  f0450501          ORR      r5,r5,#1
000044  63e5              STR      r5,[r4,#0x3c]
                  |L25.70|
;;;2050       }
;;;2051   
;;;2052       /* UART noise error interrupt occurred -----------------------------------*/
;;;2053       if (((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000046  0745              LSLS     r5,r0,#29
000048  d505              BPL      |L25.86|
00004a  07d5              LSLS     r5,r2,#31
00004c  d003              BEQ      |L25.86|
;;;2054       {
;;;2055         huart->ErrorCode |= HAL_UART_ERROR_NE;
00004e  6be5              LDR      r5,[r4,#0x3c]
000050  f0450502          ORR      r5,r5,#2
000054  63e5              STR      r5,[r4,#0x3c]
                  |L25.86|
;;;2056       }
;;;2057   
;;;2058       /* UART frame error interrupt occurred -----------------------------------*/
;;;2059       if (((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
000056  0785              LSLS     r5,r0,#30
000058  d505              BPL      |L25.102|
00005a  07d2              LSLS     r2,r2,#31
00005c  d003              BEQ      |L25.102|
;;;2060       {
;;;2061         huart->ErrorCode |= HAL_UART_ERROR_FE;
00005e  6be2              LDR      r2,[r4,#0x3c]
000060  f0420204          ORR      r2,r2,#4
000064  63e2              STR      r2,[r4,#0x3c]
                  |L25.102|
;;;2062       }
;;;2063   
;;;2064       /* UART Over-Run interrupt occurred --------------------------------------*/
;;;2065       if (((isrflags & USART_SR_ORE) != RESET) && (((cr1its & USART_CR1_RXNEIE) != RESET) || ((cr3its & USART_CR3_EIE) != RESET)))
000066  0702              LSLS     r2,r0,#28
000068  d507              BPL      |L25.122|
00006a  f0010220          AND      r2,r1,#0x20
00006e  431a              ORRS     r2,r2,r3
000070  d003              BEQ      |L25.122|
;;;2066       {
;;;2067         huart->ErrorCode |= HAL_UART_ERROR_ORE;
000072  6be2              LDR      r2,[r4,#0x3c]
000074  f0420208          ORR      r2,r2,#8
000078  63e2              STR      r2,[r4,#0x3c]
                  |L25.122|
;;;2068       }
;;;2069   
;;;2070       /* Call UART Error Call back function if need be --------------------------*/
;;;2071       if (huart->ErrorCode != HAL_UART_ERROR_NONE)
00007a  6be2              LDR      r2,[r4,#0x3c]
00007c  2a00              CMP      r2,#0
00007e  d02a              BEQ      |L25.214|
;;;2072       {
;;;2073         /* UART in mode Receiver -----------------------------------------------*/
;;;2074         if (((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
000080  0680              LSLS     r0,r0,#26
000082  d504              BPL      |L25.142|
000084  0688              LSLS     r0,r1,#26
000086  d502              BPL      |L25.142|
;;;2075         {
;;;2076           UART_Receive_IT(huart);
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       UART_Receive_IT
                  |L25.142|
;;;2077         }
;;;2078   
;;;2079         /* If Overrun error occurs, or if any error occurs in DMA mode reception,
;;;2080            consider error as blocking */
;;;2081         dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
00008e  6820              LDR      r0,[r4,#0]
000090  6940              LDR      r0,[r0,#0x14]
000092  f3c01080          UBFX     r0,r0,#6,#1
;;;2082         if (((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
000096  6be1              LDR      r1,[r4,#0x3c]
000098  0709              LSLS     r1,r1,#28
00009a  d400              BMI      |L25.158|
00009c  b300              CBZ      r0,|L25.224|
                  |L25.158|
;;;2083         {
;;;2084           /* Blocking error : transfer is aborted
;;;2085              Set the UART state ready to be able to start again the process,
;;;2086              Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
;;;2087           UART_EndRxTransfer(huart);
00009e  4620              MOV      r0,r4
0000a0  f7fffffe          BL       UART_EndRxTransfer
;;;2088   
;;;2089           /* Disable the UART DMA Rx request if enabled */
;;;2090           if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
0000a4  6820              LDR      r0,[r4,#0]
0000a6  6941              LDR      r1,[r0,#0x14]
0000a8  0649              LSLS     r1,r1,#25
0000aa  d515              BPL      |L25.216|
;;;2091           {
;;;2092             CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
0000ac  6941              LDR      r1,[r0,#0x14]
0000ae  f0210140          BIC      r1,r1,#0x40
0000b2  6141              STR      r1,[r0,#0x14]
;;;2093   
;;;2094             /* Abort the UART DMA Rx channel */
;;;2095             if (huart->hdmarx != NULL)
0000b4  6b60              LDR      r0,[r4,#0x34]
0000b6  b158              CBZ      r0,|L25.208|
;;;2096             {
;;;2097               /* Set the UART DMA Abort callback :
;;;2098                  will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
;;;2099               huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
0000b8  4915              LDR      r1,|L25.272|
0000ba  6341              STR      r1,[r0,#0x34]
;;;2100               if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
0000bc  6b60              LDR      r0,[r4,#0x34]
0000be  f7fffffe          BL       HAL_DMA_Abort_IT
0000c2  2800              CMP      r0,#0
0000c4  d007              BEQ      |L25.214|
;;;2101               {
;;;2102                 /* Call Directly XferAbortCallback function in case of error */
;;;2103                 huart->hdmarx->XferAbortCallback(huart->hdmarx);
0000c6  6b60              LDR      r0,[r4,#0x34]
0000c8  6b41              LDR      r1,[r0,#0x34]
0000ca  e8bd4070          POP      {r4-r6,lr}
0000ce  4708              BX       r1
                  |L25.208|
;;;2104               }
;;;2105             }
;;;2106             else
;;;2107             {
;;;2108               /* Call user error callback */
;;;2109   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2110               /*Call registered error callback*/
;;;2111               huart->ErrorCallback(huart);
;;;2112   #else
;;;2113               /*Call legacy weak error callback*/
;;;2114               HAL_UART_ErrorCallback(huart);
0000d0  4620              MOV      r0,r4
0000d2  f7fffffe          BL       HAL_UART_ErrorCallback
                  |L25.214|
;;;2115   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2116             }
;;;2117           }
;;;2118           else
;;;2119           {
;;;2120             /* Call user error callback */
;;;2121   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2122             /*Call registered error callback*/
;;;2123             huart->ErrorCallback(huart);
;;;2124   #else
;;;2125             /*Call legacy weak error callback*/
;;;2126             HAL_UART_ErrorCallback(huart);
;;;2127   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2128           }
;;;2129         }
;;;2130         else
;;;2131         {
;;;2132           /* Non Blocking error : transfer could go on.
;;;2133              Error is notified to user through user error callback */
;;;2134   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2135           /*Call registered error callback*/
;;;2136           huart->ErrorCallback(huart);
;;;2137   #else
;;;2138           /*Call legacy weak error callback*/
;;;2139           HAL_UART_ErrorCallback(huart);
;;;2140   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2141   
;;;2142           huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;2143         }
;;;2144       }
;;;2145       return;
;;;2146     } /* End if some error occurs */
;;;2147   
;;;2148     /* UART in mode Transmitter ------------------------------------------------*/
;;;2149     if (((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
;;;2150     {
;;;2151       UART_Transmit_IT(huart);
;;;2152       return;
;;;2153     }
;;;2154   
;;;2155     /* UART in mode Transmitter end --------------------------------------------*/
;;;2156     if (((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
;;;2157     {
;;;2158       UART_EndTransmit_IT(huart);
;;;2159       return;
;;;2160     }
;;;2161   }
0000d6  bd70              POP      {r4-r6,pc}
                  |L25.216|
0000d8  4620              MOV      r0,r4                 ;2126
0000da  f7fffffe          BL       HAL_UART_ErrorCallback
0000de  bd70              POP      {r4-r6,pc}
                  |L25.224|
0000e0  4620              MOV      r0,r4                 ;2139
0000e2  f7fffffe          BL       HAL_UART_ErrorCallback
0000e6  2000              MOVS     r0,#0                 ;2142
0000e8  63e0              STR      r0,[r4,#0x3c]         ;2142
                  |L25.234|
0000ea  bd70              POP      {r4-r6,pc}
                  |L25.236|
0000ec  0602              LSLS     r2,r0,#24             ;2149
0000ee  d506              BPL      |L25.254|
0000f0  060a              LSLS     r2,r1,#24             ;2149
0000f2  d504              BPL      |L25.254|
0000f4  4620              MOV      r0,r4                 ;2151
0000f6  e8bd4070          POP      {r4-r6,lr}            ;2151
0000fa  f7ffbffe          B.W      UART_Transmit_IT
                  |L25.254|
0000fe  0640              LSLS     r0,r0,#25             ;2156
000100  d5f3              BPL      |L25.234|
000102  0648              LSLS     r0,r1,#25             ;2156
000104  d5f1              BPL      |L25.234|
000106  4620              MOV      r0,r4                 ;2158
000108  e8bd4070          POP      {r4-r6,lr}            ;2158
00010c  f7ffbffe          B.W      UART_EndTransmit_IT
;;;2162   
                          ENDP

                  |L25.272|
                          DCD      UART_DMAAbortOnError

                          AREA ||i.HAL_UART_Init||, CODE, READONLY, ALIGN=1

                  HAL_UART_Init PROC
;;;313      */
;;;314    HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;315    {
000002  4604              MOV      r4,r0
;;;316      /* Check the UART handle allocation */
;;;317      if (huart == NULL)
000004  2c00              CMP      r4,#0
000006  d004              BEQ      |L26.18|
;;;318      {
;;;319        return HAL_ERROR;
;;;320      }
;;;321    
;;;322      /* Check the parameters */
;;;323      if (huart->Init.HwFlowCtl != UART_HWCONTROL_NONE)
;;;324      {
;;;325        /* The hardware flow control is available only for USART1, USART2 and USART3 */
;;;326        assert_param(IS_UART_HWFLOW_INSTANCE(huart->Instance));
;;;327        assert_param(IS_UART_HARDWARE_FLOW_CONTROL(huart->Init.HwFlowCtl));
;;;328      }
;;;329      else
;;;330      {
;;;331        assert_param(IS_UART_INSTANCE(huart->Instance));
;;;332      }
;;;333      assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
;;;334    #if defined(USART_CR1_OVER8)
;;;335      assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
;;;336    #endif /* USART_CR1_OVER8 */
;;;337    
;;;338      if (huart->gState == HAL_UART_STATE_RESET)
000008  f8940039          LDRB     r0,[r4,#0x39]
00000c  2500              MOVS     r5,#0
00000e  b110              CBZ      r0,|L26.22|
000010  e006              B        |L26.32|
                  |L26.18|
000012  2001              MOVS     r0,#1                 ;319
;;;339      {
;;;340        /* Allocate lock resource and initialize it */
;;;341        huart->Lock = HAL_UNLOCKED;
;;;342    
;;;343    #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;344        UART_InitCallbacksToDefault(huart);
;;;345    
;;;346        if (huart->MspInitCallback == NULL)
;;;347        {
;;;348          huart->MspInitCallback = HAL_UART_MspInit;
;;;349        }
;;;350    
;;;351        /* Init the low level hardware */
;;;352        huart->MspInitCallback(huart);
;;;353    #else
;;;354        /* Init the low level hardware : GPIO, CLOCK */
;;;355        HAL_UART_MspInit(huart);
;;;356    #endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
;;;357      }
;;;358    
;;;359      huart->gState = HAL_UART_STATE_BUSY;
;;;360    
;;;361      /* Disable the peripheral */
;;;362      __HAL_UART_DISABLE(huart);
;;;363    
;;;364      /* Set the UART Communication parameters */
;;;365      UART_SetConfig(huart);
;;;366    
;;;367      /* In asynchronous mode, the following bits must be kept cleared:
;;;368         - LINEN and CLKEN bits in the USART_CR2 register,
;;;369         - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
;;;370      CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
;;;371      CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
;;;372    
;;;373      /* Enable the peripheral */
;;;374      __HAL_UART_ENABLE(huart);
;;;375    
;;;376      /* Initialize the UART state */
;;;377      huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;378      huart->gState = HAL_UART_STATE_READY;
;;;379      huart->RxState = HAL_UART_STATE_READY;
;;;380    
;;;381      return HAL_OK;
;;;382    }
000014  bd70              POP      {r4-r6,pc}
                  |L26.22|
000016  f8845038          STRB     r5,[r4,#0x38]         ;341
00001a  4620              MOV      r0,r4                 ;355
00001c  f7fffffe          BL       HAL_UART_MspInit
                  |L26.32|
000020  2024              MOVS     r0,#0x24              ;359
000022  f8840039          STRB     r0,[r4,#0x39]         ;359
000026  6820              LDR      r0,[r4,#0]            ;362
000028  68c1              LDR      r1,[r0,#0xc]          ;362
00002a  f4215100          BIC      r1,r1,#0x2000         ;362
00002e  60c1              STR      r1,[r0,#0xc]          ;362
000030  4620              MOV      r0,r4                 ;365
000032  f7fffffe          BL       UART_SetConfig
000036  6820              LDR      r0,[r4,#0]            ;370
000038  6901              LDR      r1,[r0,#0x10]         ;370
00003a  f4214190          BIC      r1,r1,#0x4800         ;370
00003e  6101              STR      r1,[r0,#0x10]         ;370
000040  6820              LDR      r0,[r4,#0]            ;371
000042  6941              LDR      r1,[r0,#0x14]         ;371
000044  f021012a          BIC      r1,r1,#0x2a           ;371
000048  6141              STR      r1,[r0,#0x14]         ;371
00004a  6820              LDR      r0,[r4,#0]            ;374
00004c  68c1              LDR      r1,[r0,#0xc]          ;374
00004e  f4415100          ORR      r1,r1,#0x2000         ;374
000052  60c1              STR      r1,[r0,#0xc]          ;374
000054  63e5              STR      r5,[r4,#0x3c]         ;377
000056  2020              MOVS     r0,#0x20              ;378
000058  f8840039          STRB     r0,[r4,#0x39]         ;378
00005c  f884003a          STRB     r0,[r4,#0x3a]         ;379
000060  2000              MOVS     r0,#0                 ;381
000062  bd70              POP      {r4-r6,pc}
;;;383    
                          ENDP


                          AREA ||i.HAL_UART_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspDeInit PROC
;;;686      */
;;;687    __weak void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;688    {
;;;689      /* Prevent unused argument(s) compilation warning */
;;;690      UNUSED(huart);
;;;691      /* NOTE: This function should not be modified, when the callback is needed,
;;;692               the HAL_UART_MspDeInit could be implemented in the user file
;;;693       */
;;;694    }
;;;695    
                          ENDP


                          AREA ||i.HAL_UART_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_UART_MspInit PROC
;;;671      */
;;;672    __weak void HAL_UART_MspInit(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;673    {
;;;674      /* Prevent unused argument(s) compilation warning */
;;;675      UNUSED(huart);
;;;676      /* NOTE: This function should not be modified, when the callback is needed,
;;;677               the HAL_UART_MspInit could be implemented in the user file
;;;678       */
;;;679    }
;;;680    
                          ENDP


                          AREA ||i.HAL_UART_Receive||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive PROC
;;;1114     */
;;;1115   HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1116   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  4698              MOV      r8,r3
;;;1117     uint8_t  *pdata8bits;
;;;1118     uint16_t *pdata16bits;
;;;1119     uint32_t tickstart = 0U;
;;;1120   
;;;1121     /* Check that a Rx process is not already ongoing */
;;;1122     if (huart->RxState == HAL_UART_STATE_READY)
00000c  f894003a          LDRB     r0,[r4,#0x3a]
000010  2820              CMP      r0,#0x20
000012  d002              BEQ      |L29.26|
;;;1123     {
;;;1124       if ((pData == NULL) || (Size == 0U))
;;;1125       {
;;;1126         return  HAL_ERROR;
;;;1127       }
;;;1128   
;;;1129       /* Process Locked */
;;;1130       __HAL_LOCK(huart);
;;;1131   
;;;1132       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1133       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1134   
;;;1135       /* Init tickstart for timeout managment */
;;;1136       tickstart = HAL_GetTick();
;;;1137   
;;;1138       huart->RxXferSize = Size;
;;;1139       huart->RxXferCount = Size;
;;;1140   
;;;1141       /* In case of 9bits/No Parity transfer, pRxData needs to be handled as a uint16_t pointer */
;;;1142       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1143       {
;;;1144         pdata8bits  = NULL;
;;;1145         pdata16bits = (uint16_t *) pData;
;;;1146       }
;;;1147       else
;;;1148       {
;;;1149         pdata8bits  = pData;
;;;1150         pdata16bits = NULL;
;;;1151       }
;;;1152   
;;;1153       /* Process Unlocked */
;;;1154       __HAL_UNLOCK(huart);
;;;1155   
;;;1156       /* Check the remain data to be received */
;;;1157       while (huart->RxXferCount > 0U)
;;;1158       {
;;;1159         if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
;;;1160         {
;;;1161           return HAL_TIMEOUT;
;;;1162         }
;;;1163         if (pdata8bits == NULL)
;;;1164         {
;;;1165           *pdata16bits = (uint16_t)(huart->Instance->DR & 0x01FF);
;;;1166           pdata16bits++;
;;;1167         }
;;;1168         else
;;;1169         {
;;;1170           if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
;;;1171           {
;;;1172             *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;1173           }
;;;1174           else
;;;1175           {
;;;1176             *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;1177           }
;;;1178           pdata8bits++;
;;;1179         }
;;;1180         huart->RxXferCount--;
;;;1181       }
;;;1182   
;;;1183       /* At end of Rx process, restore huart->RxState to Ready */
;;;1184       huart->RxState = HAL_UART_STATE_READY;
;;;1185   
;;;1186       return HAL_OK;
;;;1187     }
;;;1188     else
;;;1189     {
;;;1190       return HAL_BUSY;
000014  2002              MOVS     r0,#2
                  |L29.22|
;;;1191     }
;;;1192   }
000016  e8bd8ff8          POP      {r3-r11,pc}
                  |L29.26|
00001a  b1fe              CBZ      r6,|L29.92|
00001c  b1f5              CBZ      r5,|L29.92|
00001e  f8940038          LDRB     r0,[r4,#0x38]         ;1130
000022  2801              CMP      r0,#1                 ;1130
000024  d01c              BEQ      |L29.96|
000026  2001              MOVS     r0,#1                 ;1130
000028  f8840038          STRB     r0,[r4,#0x38]         ;1130
00002c  f04f0a00          MOV      r10,#0                ;1132
000030  f8c4a03c          STR      r10,[r4,#0x3c]        ;1132
000034  2022              MOVS     r0,#0x22              ;1133
000036  f884003a          STRB     r0,[r4,#0x3a]         ;1133
00003a  f7fffffe          BL       HAL_GetTick
00003e  4681              MOV      r9,r0                 ;1136
000040  85a5              STRH     r5,[r4,#0x2c]         ;1138
000042  85e5              STRH     r5,[r4,#0x2e]         ;1139
000044  68a0              LDR      r0,[r4,#8]            ;1142
000046  f44f5780          MOV      r7,#0x1000            ;1142
00004a  42b8              CMP      r0,r7                 ;1142
00004c  d101              BNE      |L29.82|
00004e  6920              LDR      r0,[r4,#0x10]         ;1142
000050  b140              CBZ      r0,|L29.100|
                  |L29.82|
000052  4635              MOV      r5,r6                 ;1149
000054  2600              MOVS     r6,#0                 ;1150
                  |L29.86|
000056  f884a038          STRB     r10,[r4,#0x38]        ;1154
00005a  e028              B        |L29.174|
                  |L29.92|
00005c  2001              MOVS     r0,#1                 ;1126
00005e  e7da              B        |L29.22|
                  |L29.96|
000060  2002              MOVS     r0,#2                 ;1130
000062  e7d8              B        |L29.22|
                  |L29.100|
000064  2500              MOVS     r5,#0                 ;1144
000066  e7f6              B        |L29.86|
                  |L29.104|
000068  464b              MOV      r3,r9                 ;1159
00006a  2200              MOVS     r2,#0                 ;1159
00006c  2120              MOVS     r1,#0x20              ;1159
00006e  4620              MOV      r0,r4                 ;1159
000070  f8cd8000          STR      r8,[sp,#0]            ;1159
000074  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000078  b108              CBZ      r0,|L29.126|
00007a  2003              MOVS     r0,#3                 ;1161
00007c  e7cb              B        |L29.22|
                  |L29.126|
00007e  b125              CBZ      r5,|L29.138|
000080  68a0              LDR      r0,[r4,#8]            ;1170
000082  42b8              CMP      r0,r7                 ;1170
000084  d01b              BEQ      |L29.190|
000086  b138              CBZ      r0,|L29.152|
000088  e008              B        |L29.156|
                  |L29.138|
00008a  6820              LDR      r0,[r4,#0]            ;1165
00008c  6840              LDR      r0,[r0,#4]            ;1165
00008e  f3c00008          UBFX     r0,r0,#0,#9           ;1165
000092  f8260b02          STRH     r0,[r6],#2            ;1165
000096  e007              B        |L29.168|
                  |L29.152|
000098  6920              LDR      r0,[r4,#0x10]         ;1170
00009a  b180              CBZ      r0,|L29.190|
                  |L29.156|
00009c  6820              LDR      r0,[r4,#0]            ;1176
00009e  6840              LDR      r0,[r0,#4]            ;1176
0000a0  f000007f          AND      r0,r0,#0x7f           ;1176
0000a4  7028              STRB     r0,[r5,#0]            ;1176
                  |L29.166|
0000a6  1c6d              ADDS     r5,r5,#1              ;1178
                  |L29.168|
0000a8  8de0              LDRH     r0,[r4,#0x2e]         ;1180
0000aa  1e40              SUBS     r0,r0,#1              ;1180
0000ac  85e0              STRH     r0,[r4,#0x2e]         ;1180
                  |L29.174|
0000ae  8de0              LDRH     r0,[r4,#0x2e]         ;1157
0000b0  2800              CMP      r0,#0                 ;1157
0000b2  d1d9              BNE      |L29.104|
0000b4  2020              MOVS     r0,#0x20              ;1184
0000b6  f884003a          STRB     r0,[r4,#0x3a]         ;1184
0000ba  2000              MOVS     r0,#0                 ;1186
0000bc  e7ab              B        |L29.22|
                  |L29.190|
0000be  6820              LDR      r0,[r4,#0]            ;1172
0000c0  6840              LDR      r0,[r0,#4]            ;1172
0000c2  7028              STRB     r0,[r5,#0]            ;1172
0000c4  e7ef              B        |L29.166|
;;;1193   
                          ENDP


                          AREA ||i.HAL_UART_Receive_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Receive_DMA PROC
;;;1368     */
;;;1369   HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;1370   {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
000006  4613              MOV      r3,r2
;;;1371     uint32_t *tmp;
;;;1372   
;;;1373     /* Check that a Rx process is not already ongoing */
;;;1374     if (huart->RxState == HAL_UART_STATE_READY)
000008  f894003a          LDRB     r0,[r4,#0x3a]
00000c  2820              CMP      r0,#0x20
00000e  d002              BEQ      |L30.22|
;;;1375     {
;;;1376       if ((pData == NULL) || (Size == 0U))
;;;1377       {
;;;1378         return HAL_ERROR;
;;;1379       }
;;;1380   
;;;1381       /* Process Locked */
;;;1382       __HAL_LOCK(huart);
;;;1383   
;;;1384       huart->pRxBuffPtr = pData;
;;;1385       huart->RxXferSize = Size;
;;;1386   
;;;1387       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1388       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1389   
;;;1390       /* Set the UART DMA transfer complete callback */
;;;1391       huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
;;;1392   
;;;1393       /* Set the UART DMA Half transfer complete callback */
;;;1394       huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
;;;1395   
;;;1396       /* Set the DMA error callback */
;;;1397       huart->hdmarx->XferErrorCallback = UART_DMAError;
;;;1398   
;;;1399       /* Set the DMA abort callback */
;;;1400       huart->hdmarx->XferAbortCallback = NULL;
;;;1401   
;;;1402       /* Enable the DMA channel */
;;;1403       tmp = (uint32_t *)&pData;
;;;1404       HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->DR, *(uint32_t *)tmp, Size);
;;;1405   
;;;1406       /* Clear the Overrun flag just before enabling the DMA Rx request: can be mandatory for the second transfer */
;;;1407       __HAL_UART_CLEAR_OREFLAG(huart);
;;;1408   
;;;1409       /* Process Unlocked */
;;;1410       __HAL_UNLOCK(huart);
;;;1411   
;;;1412       /* Enable the UART Parity Error Interrupt */
;;;1413       SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
;;;1414   
;;;1415       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1416       SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;1417   
;;;1418       /* Enable the DMA transfer for the receiver request by setting the DMAR bit
;;;1419       in the UART CR3 register */
;;;1420       SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
;;;1421   
;;;1422       return HAL_OK;
;;;1423     }
;;;1424     else
;;;1425     {
;;;1426       return HAL_BUSY;
000010  2002              MOVS     r0,#2
                  |L30.18|
;;;1427     }
;;;1428   }
000012  b005              ADD      sp,sp,#0x14
000014  bd30              POP      {r4,r5,pc}
                  |L30.22|
000016  9a03              LDR      r2,[sp,#0xc]          ;1376
000018  b3a2              CBZ      r2,|L30.132|
00001a  b39b              CBZ      r3,|L30.132|
00001c  f8940038          LDRB     r0,[r4,#0x38]         ;1382
000020  2801              CMP      r0,#1                 ;1382
000022  d032              BEQ      |L30.138|
000024  2001              MOVS     r0,#1                 ;1382
000026  f8840038          STRB     r0,[r4,#0x38]         ;1382
00002a  62a2              STR      r2,[r4,#0x28]         ;1384
00002c  85a3              STRH     r3,[r4,#0x2c]         ;1385
00002e  2500              MOVS     r5,#0                 ;1387
000030  63e5              STR      r5,[r4,#0x3c]         ;1387
000032  2022              MOVS     r0,#0x22              ;1388
000034  f884003a          STRB     r0,[r4,#0x3a]         ;1388
000038  6b61              LDR      r1,[r4,#0x34]         ;1391
00003a  4815              LDR      r0,|L30.144|
00003c  6288              STR      r0,[r1,#0x28]         ;1391
00003e  6b61              LDR      r1,[r4,#0x34]         ;1394
000040  4814              LDR      r0,|L30.148|
000042  62c8              STR      r0,[r1,#0x2c]         ;1394
000044  6b61              LDR      r1,[r4,#0x34]         ;1397
000046  4814              LDR      r0,|L30.152|
000048  6308              STR      r0,[r1,#0x30]         ;1397
00004a  6b60              LDR      r0,[r4,#0x34]         ;1400
00004c  6345              STR      r5,[r0,#0x34]         ;1400
00004e  6821              LDR      r1,[r4,#0]            ;1404
000050  6b60              LDR      r0,[r4,#0x34]         ;1404
000052  1d09              ADDS     r1,r1,#4              ;1404
000054  f7fffffe          BL       HAL_DMA_Start_IT
000058  6820              LDR      r0,[r4,#0]            ;1407
00005a  6801              LDR      r1,[r0,#0]            ;1407
00005c  6841              LDR      r1,[r0,#4]            ;1407
00005e  9101              STR      r1,[sp,#4]            ;1407
000060  f8845038          STRB     r5,[r4,#0x38]         ;1410
000064  68c1              LDR      r1,[r0,#0xc]          ;1413
000066  f4417180          ORR      r1,r1,#0x100          ;1413
00006a  60c1              STR      r1,[r0,#0xc]          ;1413
00006c  6820              LDR      r0,[r4,#0]            ;1416
00006e  6941              LDR      r1,[r0,#0x14]         ;1416
000070  f0410101          ORR      r1,r1,#1              ;1416
000074  6141              STR      r1,[r0,#0x14]         ;1416
000076  6820              LDR      r0,[r4,#0]            ;1420
000078  6941              LDR      r1,[r0,#0x14]         ;1420
00007a  f0410140          ORR      r1,r1,#0x40           ;1420
00007e  6141              STR      r1,[r0,#0x14]         ;1420
000080  2000              MOVS     r0,#0                 ;1422
000082  e7c6              B        |L30.18|
                  |L30.132|
000084  e7ff              B        |L30.134|
                  |L30.134|
000086  2001              MOVS     r0,#1                 ;1378
000088  e7c3              B        |L30.18|
                  |L30.138|
00008a  2002              MOVS     r0,#2                 ;1382
00008c  e7c1              B        |L30.18|
;;;1429   
                          ENDP

00008e  0000              DCW      0x0000
                  |L30.144|
                          DCD      UART_DMAReceiveCplt
                  |L30.148|
                          DCD      UART_DMARxHalfCplt
                  |L30.152|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Receive_IT PROC
;;;1249     */
;;;1250   HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  f890303a          LDRB     r3,[r0,#0x3a]
;;;1251   {
;;;1252     /* Check that a Rx process is not already ongoing */
;;;1253     if (huart->RxState == HAL_UART_STATE_READY)
000004  2b20              CMP      r3,#0x20
000006  d001              BEQ      |L31.12|
;;;1254     {
;;;1255       if ((pData == NULL) || (Size == 0U))
;;;1256       {
;;;1257         return HAL_ERROR;
;;;1258       }
;;;1259   
;;;1260       /* Process Locked */
;;;1261       __HAL_LOCK(huart);
;;;1262   
;;;1263       huart->pRxBuffPtr = pData;
;;;1264       huart->RxXferSize = Size;
;;;1265       huart->RxXferCount = Size;
;;;1266   
;;;1267       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1268       huart->RxState = HAL_UART_STATE_BUSY_RX;
;;;1269   
;;;1270       /* Process Unlocked */
;;;1271       __HAL_UNLOCK(huart);
;;;1272   
;;;1273       /* Enable the UART Parity Error Interrupt */
;;;1274       __HAL_UART_ENABLE_IT(huart, UART_IT_PE);
;;;1275   
;;;1276       /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;1277       __HAL_UART_ENABLE_IT(huart, UART_IT_ERR);
;;;1278   
;;;1279       /* Enable the UART Data Register not empty Interrupt */
;;;1280       __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);
;;;1281   
;;;1282       return HAL_OK;
;;;1283     }
;;;1284     else
;;;1285     {
;;;1286       return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;1287     }
;;;1288   }
00000a  4770              BX       lr
                  |L31.12|
00000c  b1f9              CBZ      r1,|L31.78|
00000e  b1f2              CBZ      r2,|L31.78|
000010  f8903038          LDRB     r3,[r0,#0x38]         ;1261
000014  2b01              CMP      r3,#1                 ;1261
000016  d01c              BEQ      |L31.82|
000018  6281              STR      r1,[r0,#0x28]         ;1263
00001a  8582              STRH     r2,[r0,#0x2c]         ;1264
00001c  85c2              STRH     r2,[r0,#0x2e]         ;1265
00001e  2100              MOVS     r1,#0                 ;1267
000020  63c1              STR      r1,[r0,#0x3c]         ;1267
000022  2222              MOVS     r2,#0x22              ;1268
000024  f880203a          STRB     r2,[r0,#0x3a]         ;1268
000028  f8801038          STRB     r1,[r0,#0x38]         ;1271
00002c  6801              LDR      r1,[r0,#0]            ;1274
00002e  68ca              LDR      r2,[r1,#0xc]          ;1274
000030  f4427280          ORR      r2,r2,#0x100          ;1274
000034  60ca              STR      r2,[r1,#0xc]          ;1274
000036  6801              LDR      r1,[r0,#0]            ;1277
000038  694a              LDR      r2,[r1,#0x14]         ;1277
00003a  f0420201          ORR      r2,r2,#1              ;1277
00003e  614a              STR      r2,[r1,#0x14]         ;1277
000040  6800              LDR      r0,[r0,#0]            ;1280
000042  68c1              LDR      r1,[r0,#0xc]          ;1280
000044  f0410120          ORR      r1,r1,#0x20           ;1280
000048  60c1              STR      r1,[r0,#0xc]          ;1280
00004a  2000              MOVS     r0,#0                 ;1282
00004c  4770              BX       lr
                  |L31.78|
00004e  2001              MOVS     r0,#1                 ;1257
000050  4770              BX       lr
                  |L31.82|
000052  2002              MOVS     r0,#2                 ;1261
000054  4770              BX       lr
;;;1289   
                          ENDP


                          AREA ||i.HAL_UART_RxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxCpltCallback PROC
;;;2198     */
;;;2199   __weak void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2200   {
;;;2201     /* Prevent unused argument(s) compilation warning */
;;;2202     UNUSED(huart);
;;;2203     /* NOTE: This function should not be modified, when the callback is needed,
;;;2204              the HAL_UART_RxCpltCallback could be implemented in the user file
;;;2205      */
;;;2206   }
;;;2207   
                          ENDP


                          AREA ||i.HAL_UART_RxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_RxHalfCpltCallback PROC
;;;2213     */
;;;2214   __weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2215   {
;;;2216     /* Prevent unused argument(s) compilation warning */
;;;2217     UNUSED(huart);
;;;2218     /* NOTE: This function should not be modified, when the callback is needed,
;;;2219              the HAL_UART_RxHalfCpltCallback could be implemented in the user file
;;;2220      */
;;;2221   }
;;;2222   
                          ENDP


                          AREA ||i.HAL_UART_Transmit||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit PROC
;;;1026     */
;;;1027   HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;1028   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
00000a  461f              MOV      r7,r3
;;;1029     uint8_t  *pdata8bits;
;;;1030     uint16_t *pdata16bits;
;;;1031     uint32_t tickstart = 0U;
;;;1032   
;;;1033     /* Check that a Tx process is not already ongoing */
;;;1034     if (huart->gState == HAL_UART_STATE_READY)
00000c  f8940039          LDRB     r0,[r4,#0x39]
000010  2820              CMP      r0,#0x20
000012  d002              BEQ      |L34.26|
;;;1035     {
;;;1036       if ((pData == NULL) || (Size == 0U))
;;;1037       {
;;;1038         return  HAL_ERROR;
;;;1039       }
;;;1040   
;;;1041       /* Process Locked */
;;;1042       __HAL_LOCK(huart);
;;;1043   
;;;1044       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1045       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1046   
;;;1047       /* Init tickstart for timeout managment */
;;;1048       tickstart = HAL_GetTick();
;;;1049   
;;;1050       huart->TxXferSize = Size;
;;;1051       huart->TxXferCount = Size;
;;;1052   
;;;1053       /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
;;;1054       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;1055       {
;;;1056         pdata8bits  = NULL;
;;;1057         pdata16bits = (uint16_t *) pData;
;;;1058       }
;;;1059       else
;;;1060       {
;;;1061         pdata8bits  = pData;
;;;1062         pdata16bits = NULL;
;;;1063       }
;;;1064   
;;;1065       /* Process Unlocked */
;;;1066       __HAL_UNLOCK(huart);
;;;1067   
;;;1068       while (huart->TxXferCount > 0U)
;;;1069       {
;;;1070         if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
;;;1071         {
;;;1072           return HAL_TIMEOUT;
;;;1073         }
;;;1074         if (pdata8bits == NULL)
;;;1075         {
;;;1076           huart->Instance->DR = (uint16_t)(*pdata16bits & 0x01FFU);
;;;1077           pdata16bits++;
;;;1078         }
;;;1079         else
;;;1080         {
;;;1081           huart->Instance->DR = (uint8_t)(*pdata8bits & 0xFFU);
;;;1082           pdata8bits++;
;;;1083         }
;;;1084         huart->TxXferCount--;
;;;1085       }
;;;1086   
;;;1087       if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
;;;1088       {
;;;1089         return HAL_TIMEOUT;
;;;1090       }
;;;1091   
;;;1092       /* At end of Tx process, restore huart->gState to Ready */
;;;1093       huart->gState = HAL_UART_STATE_READY;
;;;1094   
;;;1095       return HAL_OK;
;;;1096     }
;;;1097     else
;;;1098     {
;;;1099       return HAL_BUSY;
000014  2002              MOVS     r0,#2
                  |L34.22|
;;;1100     }
;;;1101   }
000016  e8bd83f8          POP      {r3-r9,pc}
                  |L34.26|
00001a  b1c6              CBZ      r6,|L34.78|
00001c  b1bd              CBZ      r5,|L34.78|
00001e  f8940038          LDRB     r0,[r4,#0x38]         ;1042
000022  2801              CMP      r0,#1                 ;1042
000024  d015              BEQ      |L34.82|
000026  2001              MOVS     r0,#1                 ;1042
000028  f8840038          STRB     r0,[r4,#0x38]         ;1042
00002c  f04f0900          MOV      r9,#0                 ;1044
000030  f8c4903c          STR      r9,[r4,#0x3c]         ;1044
000034  2021              MOVS     r0,#0x21              ;1045
000036  f8840039          STRB     r0,[r4,#0x39]         ;1045
00003a  f7fffffe          BL       HAL_GetTick
00003e  4680              MOV      r8,r0                 ;1048
000040  84a5              STRH     r5,[r4,#0x24]         ;1050
000042  84e5              STRH     r5,[r4,#0x26]         ;1051
000044  68a0              LDR      r0,[r4,#8]            ;1054
000046  f5b05f80          CMP      r0,#0x1000            ;1054
00004a  d004              BEQ      |L34.86|
00004c  e005              B        |L34.90|
                  |L34.78|
00004e  2001              MOVS     r0,#1                 ;1038
000050  e7e1              B        |L34.22|
                  |L34.82|
000052  2002              MOVS     r0,#2                 ;1042
000054  e7df              B        |L34.22|
                  |L34.86|
000056  6920              LDR      r0,[r4,#0x10]         ;1054
000058  b120              CBZ      r0,|L34.100|
                  |L34.90|
00005a  4635              MOV      r5,r6                 ;1061
00005c  2600              MOVS     r6,#0                 ;1062
                  |L34.94|
00005e  f8849038          STRB     r9,[r4,#0x38]         ;1066
000062  e013              B        |L34.140|
                  |L34.100|
000064  2500              MOVS     r5,#0                 ;1056
000066  e7fa              B        |L34.94|
                  |L34.104|
000068  4643              MOV      r3,r8                 ;1070
00006a  2200              MOVS     r2,#0                 ;1070
00006c  2180              MOVS     r1,#0x80              ;1070
00006e  4620              MOV      r0,r4                 ;1070
000070  9700              STR      r7,[sp,#0]            ;1070
000072  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
000076  b108              CBZ      r0,|L34.124|
000078  2003              MOVS     r0,#3                 ;1072
00007a  e7cc              B        |L34.22|
                  |L34.124|
00007c  b19d              CBZ      r5,|L34.166|
00007e  6821              LDR      r1,[r4,#0]            ;1081
000080  f8150b01          LDRB     r0,[r5],#1            ;1081
000084  6048              STR      r0,[r1,#4]            ;1081
                  |L34.134|
000086  8ce0              LDRH     r0,[r4,#0x26]         ;1084
000088  1e40              SUBS     r0,r0,#1              ;1084
00008a  84e0              STRH     r0,[r4,#0x26]         ;1084
                  |L34.140|
00008c  8ce0              LDRH     r0,[r4,#0x26]         ;1068
00008e  2800              CMP      r0,#0                 ;1068
000090  d1ea              BNE      |L34.104|
000092  4643              MOV      r3,r8                 ;1087
000094  2200              MOVS     r2,#0                 ;1087
000096  2140              MOVS     r1,#0x40              ;1087
000098  4620              MOV      r0,r4                 ;1087
00009a  9700              STR      r7,[sp,#0]            ;1087
00009c  f7fffffe          BL       UART_WaitOnFlagUntilTimeout
0000a0  b140              CBZ      r0,|L34.180|
0000a2  2003              MOVS     r0,#3                 ;1089
0000a4  e7b7              B        |L34.22|
                  |L34.166|
0000a6  f8360b02          LDRH     r0,[r6],#2            ;1076
0000aa  6821              LDR      r1,[r4,#0]            ;1076
0000ac  f3c00008          UBFX     r0,r0,#0,#9           ;1076
0000b0  6048              STR      r0,[r1,#4]            ;1076
0000b2  e7e8              B        |L34.134|
                  |L34.180|
0000b4  2020              MOVS     r0,#0x20              ;1093
0000b6  f8840039          STRB     r0,[r4,#0x39]         ;1093
0000ba  2000              MOVS     r0,#0                 ;1095
0000bc  e7ab              B        |L34.22|
;;;1102   
                          ENDP


                          AREA ||i.HAL_UART_Transmit_DMA||, CODE, READONLY, ALIGN=2

                  HAL_UART_Transmit_DMA PROC
;;;1300     */
;;;1301   HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1302   {
000002  4604              MOV      r4,r0
;;;1303     uint32_t *tmp;
;;;1304   
;;;1305     /* Check that a Tx process is not already ongoing */
;;;1306     if (huart->gState == HAL_UART_STATE_READY)
000004  f8940039          LDRB     r0,[r4,#0x39]
000008  2820              CMP      r0,#0x20
00000a  d001              BEQ      |L35.16|
;;;1307     {
;;;1308       if ((pData == NULL) || (Size == 0U))
;;;1309       {
;;;1310         return HAL_ERROR;
;;;1311       }
;;;1312   
;;;1313       /* Process Locked */
;;;1314       __HAL_LOCK(huart);
;;;1315   
;;;1316       huart->pTxBuffPtr = pData;
;;;1317       huart->TxXferSize = Size;
;;;1318       huart->TxXferCount = Size;
;;;1319   
;;;1320       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1321       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1322   
;;;1323       /* Set the UART DMA transfer complete callback */
;;;1324       huart->hdmatx->XferCpltCallback = UART_DMATransmitCplt;
;;;1325   
;;;1326       /* Set the UART DMA Half transfer complete callback */
;;;1327       huart->hdmatx->XferHalfCpltCallback = UART_DMATxHalfCplt;
;;;1328   
;;;1329       /* Set the DMA error callback */
;;;1330       huart->hdmatx->XferErrorCallback = UART_DMAError;
;;;1331   
;;;1332       /* Set the DMA abort callback */
;;;1333       huart->hdmatx->XferAbortCallback = NULL;
;;;1334   
;;;1335       /* Enable the UART transmit DMA channel */
;;;1336       tmp = (uint32_t *)&pData;
;;;1337       HAL_DMA_Start_IT(huart->hdmatx, *(uint32_t *)tmp, (uint32_t)&huart->Instance->DR, Size);
;;;1338   
;;;1339       /* Clear the TC flag in the SR register by writing 0 to it */
;;;1340       __HAL_UART_CLEAR_FLAG(huart, UART_FLAG_TC);
;;;1341   
;;;1342       /* Process Unlocked */
;;;1343       __HAL_UNLOCK(huart);
;;;1344   
;;;1345       /* Enable the DMA transfer for transmit request by setting the DMAT bit
;;;1346          in the UART CR3 register */
;;;1347       SET_BIT(huart->Instance->CR3, USART_CR3_DMAT);
;;;1348   
;;;1349       return HAL_OK;
;;;1350     }
;;;1351     else
;;;1352     {
;;;1353       return HAL_BUSY;
00000c  2002              MOVS     r0,#2
;;;1354     }
;;;1355   }
00000e  bdfe              POP      {r1-r7,pc}
                  |L35.16|
000010  9901              LDR      r1,[sp,#4]            ;1308
000012  b379              CBZ      r1,|L35.116|
000014  b372              CBZ      r2,|L35.116|
000016  f8940038          LDRB     r0,[r4,#0x38]         ;1314
00001a  2801              CMP      r0,#1                 ;1314
00001c  d02d              BEQ      |L35.122|
00001e  2001              MOVS     r0,#1                 ;1314
000020  f8840038          STRB     r0,[r4,#0x38]         ;1314
000024  6221              STR      r1,[r4,#0x20]         ;1316
000026  84a2              STRH     r2,[r4,#0x24]         ;1317
000028  84e2              STRH     r2,[r4,#0x26]         ;1318
00002a  2500              MOVS     r5,#0                 ;1320
00002c  63e5              STR      r5,[r4,#0x3c]         ;1320
00002e  2021              MOVS     r0,#0x21              ;1321
000030  f8840039          STRB     r0,[r4,#0x39]         ;1321
000034  6b23              LDR      r3,[r4,#0x30]         ;1324
000036  4812              LDR      r0,|L35.128|
000038  6298              STR      r0,[r3,#0x28]         ;1324
00003a  6b23              LDR      r3,[r4,#0x30]         ;1327
00003c  4811              LDR      r0,|L35.132|
00003e  62d8              STR      r0,[r3,#0x2c]         ;1327
000040  6b23              LDR      r3,[r4,#0x30]         ;1330
000042  4811              LDR      r0,|L35.136|
000044  6318              STR      r0,[r3,#0x30]         ;1330
000046  6b20              LDR      r0,[r4,#0x30]         ;1333
000048  6345              STR      r5,[r0,#0x34]         ;1333
00004a  6820              LDR      r0,[r4,#0]            ;1337
00004c  4613              MOV      r3,r2                 ;1337
00004e  1d00              ADDS     r0,r0,#4              ;1337
000050  6b26              LDR      r6,[r4,#0x30]         ;1337
000052  4602              MOV      r2,r0                 ;1337
000054  4630              MOV      r0,r6                 ;1337
000056  f7fffffe          BL       HAL_DMA_Start_IT
00005a  6821              LDR      r1,[r4,#0]            ;1340
00005c  f06f0040          MVN      r0,#0x40              ;1340
000060  6008              STR      r0,[r1,#0]            ;1340
000062  f8845038          STRB     r5,[r4,#0x38]         ;1343
000066  6820              LDR      r0,[r4,#0]            ;1347
000068  6941              LDR      r1,[r0,#0x14]         ;1347
00006a  f0410180          ORR      r1,r1,#0x80           ;1347
00006e  6141              STR      r1,[r0,#0x14]         ;1347
000070  2000              MOVS     r0,#0                 ;1349
                  |L35.114|
000072  bdfe              POP      {r1-r7,pc}
                  |L35.116|
000074  e7ff              B        |L35.118|
                  |L35.118|
000076  2001              MOVS     r0,#1                 ;1310
000078  e7fb              B        |L35.114|
                  |L35.122|
00007a  2002              MOVS     r0,#2                 ;1314
00007c  e7f9              B        |L35.114|
;;;1356   
                          ENDP

00007e  0000              DCW      0x0000
                  |L35.128|
                          DCD      UART_DMATransmitCplt
                  |L35.132|
                          DCD      UART_DMATxHalfCplt
                  |L35.136|
                          DCD      UART_DMAError

                          AREA ||i.HAL_UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  HAL_UART_Transmit_IT PROC
;;;1204     */
;;;1205   HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
000000  f8903039          LDRB     r3,[r0,#0x39]
;;;1206   {
;;;1207     /* Check that a Tx process is not already ongoing */
;;;1208     if (huart->gState == HAL_UART_STATE_READY)
000004  2b20              CMP      r3,#0x20
000006  d001              BEQ      |L36.12|
;;;1209     {
;;;1210       if ((pData == NULL) || (Size == 0U))
;;;1211       {
;;;1212         return HAL_ERROR;
;;;1213       }
;;;1214   
;;;1215       /* Process Locked */
;;;1216       __HAL_LOCK(huart);
;;;1217   
;;;1218       huart->pTxBuffPtr = pData;
;;;1219       huart->TxXferSize = Size;
;;;1220       huart->TxXferCount = Size;
;;;1221   
;;;1222       huart->ErrorCode = HAL_UART_ERROR_NONE;
;;;1223       huart->gState = HAL_UART_STATE_BUSY_TX;
;;;1224   
;;;1225       /* Process Unlocked */
;;;1226       __HAL_UNLOCK(huart);
;;;1227   
;;;1228       /* Enable the UART Transmit data register empty Interrupt */
;;;1229       __HAL_UART_ENABLE_IT(huart, UART_IT_TXE);
;;;1230   
;;;1231       return HAL_OK;
;;;1232     }
;;;1233     else
;;;1234     {
;;;1235       return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;1236     }
;;;1237   }
00000a  4770              BX       lr
                  |L36.12|
00000c  b1a9              CBZ      r1,|L36.58|
00000e  b1a2              CBZ      r2,|L36.58|
000010  f8903038          LDRB     r3,[r0,#0x38]         ;1216
000014  2b01              CMP      r3,#1                 ;1216
000016  d012              BEQ      |L36.62|
000018  6201              STR      r1,[r0,#0x20]         ;1218
00001a  8482              STRH     r2,[r0,#0x24]         ;1219
00001c  84c2              STRH     r2,[r0,#0x26]         ;1220
00001e  2100              MOVS     r1,#0                 ;1222
000020  63c1              STR      r1,[r0,#0x3c]         ;1222
000022  2221              MOVS     r2,#0x21              ;1223
000024  f8802039          STRB     r2,[r0,#0x39]         ;1223
000028  f8801038          STRB     r1,[r0,#0x38]         ;1226
00002c  6800              LDR      r0,[r0,#0]            ;1229
00002e  68c1              LDR      r1,[r0,#0xc]          ;1229
000030  f0410180          ORR      r1,r1,#0x80           ;1229
000034  60c1              STR      r1,[r0,#0xc]          ;1229
000036  2000              MOVS     r0,#0                 ;1231
000038  4770              BX       lr
                  |L36.58|
00003a  2001              MOVS     r0,#1                 ;1212
00003c  4770              BX       lr
                  |L36.62|
00003e  2002              MOVS     r0,#2                 ;1216
000040  4770              BX       lr
;;;1238   
                          ENDP


                          AREA ||i.HAL_UART_TxCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxCpltCallback PROC
;;;2168     */
;;;2169   __weak void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2170   {
;;;2171     /* Prevent unused argument(s) compilation warning */
;;;2172     UNUSED(huart);
;;;2173     /* NOTE: This function should not be modified, when the callback is needed,
;;;2174              the HAL_UART_TxCpltCallback could be implemented in the user file
;;;2175      */
;;;2176   }
;;;2177   
                          ENDP


                          AREA ||i.HAL_UART_TxHalfCpltCallback||, CODE, READONLY, ALIGN=1

                  HAL_UART_TxHalfCpltCallback PROC
;;;2183     */
;;;2184   __weak void HAL_UART_TxHalfCpltCallback(UART_HandleTypeDef *huart)
000000  4770              BX       lr
;;;2185   {
;;;2186     /* Prevent unused argument(s) compilation warning */
;;;2187     UNUSED(huart);
;;;2188     /* NOTE: This function should not be modified, when the callback is needed,
;;;2189              the HAL_UART_TxHalfCpltCallback could be implemented in the user file
;;;2190      */
;;;2191   }
;;;2192   
                          ENDP


                          AREA ||i.UART_DMAAbortOnError||, CODE, READONLY, ALIGN=1

                  UART_DMAAbortOnError PROC
;;;2754     */
;;;2755   static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2756   {
;;;2757     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2758     huart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;2759     huart->TxXferCount = 0x00U;
000008  84c1              STRH     r1,[r0,#0x26]
;;;2760   
;;;2761   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2762     /*Call registered error callback*/
;;;2763     huart->ErrorCallback(huart);
;;;2764   #else
;;;2765     /*Call legacy weak error callback*/
;;;2766     HAL_UART_ErrorCallback(huart);
00000a  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2767   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2768   }
00000e  bd10              POP      {r4,pc}
;;;2769   
                          ENDP


                          AREA ||i.UART_DMAError||, CODE, READONLY, ALIGN=1

                  UART_DMAError PROC
;;;2650     */
;;;2651   static void UART_DMAError(DMA_HandleTypeDef *hdma)
000000  b570              PUSH     {r4-r6,lr}
;;;2652   {
;;;2653     uint32_t dmarequest = 0x00U;
;;;2654     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a44              LDR      r4,[r0,#0x24]
;;;2655   
;;;2656     /* Stop UART DMA Tx request if ongoing */
;;;2657     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT);
000004  6820              LDR      r0,[r4,#0]
000006  6940              LDR      r0,[r0,#0x14]
000008  f3c010c0          UBFX     r0,r0,#7,#1
;;;2658     if ((huart->gState == HAL_UART_STATE_BUSY_TX) && dmarequest)
00000c  f8941039          LDRB     r1,[r4,#0x39]
000010  2500              MOVS     r5,#0
000012  2921              CMP      r1,#0x21
000014  d104              BNE      |L40.32|
000016  b118              CBZ      r0,|L40.32|
;;;2659     {
;;;2660       huart->TxXferCount = 0x00U;
000018  84e5              STRH     r5,[r4,#0x26]
;;;2661       UART_EndTxTransfer(huart);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       UART_EndTxTransfer
                  |L40.32|
;;;2662     }
;;;2663   
;;;2664     /* Stop UART DMA Rx request if ongoing */
;;;2665     dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
000020  6820              LDR      r0,[r4,#0]
000022  6940              LDR      r0,[r0,#0x14]
000024  f3c01080          UBFX     r0,r0,#6,#1
;;;2666     if ((huart->RxState == HAL_UART_STATE_BUSY_RX) && dmarequest)
000028  f894103a          LDRB     r1,[r4,#0x3a]
00002c  2922              CMP      r1,#0x22
00002e  d104              BNE      |L40.58|
000030  b118              CBZ      r0,|L40.58|
;;;2667     {
;;;2668       huart->RxXferCount = 0x00U;
000032  85e5              STRH     r5,[r4,#0x2e]
;;;2669       UART_EndRxTransfer(huart);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       UART_EndRxTransfer
                  |L40.58|
;;;2670     }
;;;2671   
;;;2672     huart->ErrorCode |= HAL_UART_ERROR_DMA;
00003a  6be0              LDR      r0,[r4,#0x3c]
00003c  f0400010          ORR      r0,r0,#0x10
000040  63e0              STR      r0,[r4,#0x3c]
;;;2673   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2674     /*Call registered error callback*/
;;;2675     huart->ErrorCallback(huart);
;;;2676   #else
;;;2677     /*Call legacy weak error callback*/
;;;2678     HAL_UART_ErrorCallback(huart);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       HAL_UART_ErrorCallback
;;;2679   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2680   }
000048  bd70              POP      {r4-r6,pc}
;;;2681   
                          ENDP


                          AREA ||i.UART_DMAReceiveCplt||, CODE, READONLY, ALIGN=1

                  UART_DMAReceiveCplt PROC
;;;2597     */
;;;2598   static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2599   {
000002  4601              MOV      r1,r0
;;;2600     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6a48              LDR      r0,[r1,#0x24]
;;;2601     /* DMA Normal mode*/
;;;2602     if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d413              BMI      |L41.54|
;;;2603     {
;;;2604       huart->RxXferCount = 0U;
00000e  2100              MOVS     r1,#0
000010  85c1              STRH     r1,[r0,#0x2e]
;;;2605   
;;;2606       /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2607       CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
000012  6801              LDR      r1,[r0,#0]
000014  68ca              LDR      r2,[r1,#0xc]
000016  f4227280          BIC      r2,r2,#0x100
00001a  60ca              STR      r2,[r1,#0xc]
;;;2608       CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00001c  6801              LDR      r1,[r0,#0]
00001e  694a              LDR      r2,[r1,#0x14]
000020  f0220201          BIC      r2,r2,#1
000024  614a              STR      r2,[r1,#0x14]
;;;2609   
;;;2610       /* Disable the DMA transfer for the receiver request by setting the DMAR bit
;;;2611          in the UART CR3 register */
;;;2612       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
000026  6801              LDR      r1,[r0,#0]
000028  694a              LDR      r2,[r1,#0x14]
00002a  f0220240          BIC      r2,r2,#0x40
00002e  614a              STR      r2,[r1,#0x14]
;;;2613   
;;;2614       /* At end of Rx process, restore huart->RxState to Ready */
;;;2615       huart->RxState = HAL_UART_STATE_READY;
000030  2120              MOVS     r1,#0x20
000032  f880103a          STRB     r1,[r0,#0x3a]
                  |L41.54|
;;;2616     }
;;;2617   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2618     /*Call registered Rx complete callback*/
;;;2619     huart->RxCpltCallback(huart);
;;;2620   #else
;;;2621     /*Call legacy weak Rx complete callback*/
;;;2622     HAL_UART_RxCpltCallback(huart);
000036  f7fffffe          BL       HAL_UART_RxCpltCallback
;;;2623   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2624   }
00003a  bd10              POP      {r4,pc}
;;;2625   
                          ENDP


                          AREA ||i.UART_DMARxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxAbortCallback PROC
;;;2823     */
;;;2824   static void UART_DMARxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2825   {
;;;2826     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2827   
;;;2828     huart->hdmarx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6b41              LDR      r1,[r0,#0x34]
000008  634a              STR      r2,[r1,#0x34]
;;;2829   
;;;2830     /* Check if an Abort process is still ongoing */
;;;2831     if (huart->hdmatx != NULL)
00000a  6b01              LDR      r1,[r0,#0x30]
00000c  2900              CMP      r1,#0
00000e  d002              BEQ      |L42.22|
;;;2832     {
;;;2833       if (huart->hdmatx->XferAbortCallback != NULL)
000010  6b49              LDR      r1,[r1,#0x34]
000012  2900              CMP      r1,#0
000014  d109              BNE      |L42.42|
                  |L42.22|
;;;2834       {
;;;2835         return;
;;;2836       }
;;;2837     }
;;;2838   
;;;2839     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2840     huart->TxXferCount = 0x00U;
000016  84c2              STRH     r2,[r0,#0x26]
;;;2841     huart->RxXferCount = 0x00U;
000018  85c2              STRH     r2,[r0,#0x2e]
;;;2842   
;;;2843     /* Reset ErrorCode */
;;;2844     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001a  63c2              STR      r2,[r0,#0x3c]
;;;2845   
;;;2846     /* Restore huart->gState and huart->RxState to Ready */
;;;2847     huart->gState  = HAL_UART_STATE_READY;
00001c  2120              MOVS     r1,#0x20
00001e  f8801039          STRB     r1,[r0,#0x39]
;;;2848     huart->RxState = HAL_UART_STATE_READY;
000022  f880103a          STRB     r1,[r0,#0x3a]
;;;2849   
;;;2850     /* Call user Abort complete callback */
;;;2851   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2852     /* Call registered Abort complete callback */
;;;2853     huart->AbortCpltCallback(huart);
;;;2854   #else
;;;2855     /* Call legacy weak Abort complete callback */
;;;2856     HAL_UART_AbortCpltCallback(huart);
000026  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L42.42|
;;;2857   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2858   }
00002a  bd10              POP      {r4,pc}
;;;2859   
                          ENDP


                          AREA ||i.UART_DMARxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMARxHalfCplt PROC
;;;2631     */
;;;2632   static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2633   {
;;;2634     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2635   
;;;2636   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2637     /*Call registered Rx Half complete callback*/
;;;2638     huart->RxHalfCpltCallback(huart);
;;;2639   #else
;;;2640     /*Call legacy weak Rx Half complete callback*/
;;;2641     HAL_UART_RxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_RxHalfCpltCallback
;;;2642   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2643   }
000008  bd10              POP      {r4,pc}
;;;2644   
                          ENDP


                          AREA ||i.UART_DMARxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMARxOnlyAbortCallback PROC
;;;2896     */
;;;2897   static void UART_DMARxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2898   {
;;;2899     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2900   
;;;2901     huart->RxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  85c1              STRH     r1,[r0,#0x2e]
;;;2902   
;;;2903     /* Restore huart->RxState to Ready */
;;;2904     huart->RxState = HAL_UART_STATE_READY;
000008  2120              MOVS     r1,#0x20
00000a  f880103a          STRB     r1,[r0,#0x3a]
;;;2905   
;;;2906     /* Call user Abort complete callback */
;;;2907   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2908     /* Call registered Abort Receive Complete Callback */
;;;2909     huart->AbortReceiveCpltCallback(huart);
;;;2910   #else
;;;2911     /* Call legacy weak Abort Receive Complete Callback */
;;;2912     HAL_UART_AbortReceiveCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_AbortReceiveCpltCallback
;;;2913   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2914   }
000012  bd10              POP      {r4,pc}
;;;2915   
                          ENDP


                          AREA ||i.UART_DMATransmitCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATransmitCplt PROC
;;;2543     */
;;;2544   static void UART_DMATransmitCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2545   {
000002  4601              MOV      r1,r0
;;;2546     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000004  6a48              LDR      r0,[r1,#0x24]
;;;2547     /* DMA Normal mode*/
;;;2548     if ((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
000006  6809              LDR      r1,[r1,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  0689              LSLS     r1,r1,#26
00000c  d40c              BMI      |L45.40|
;;;2549     {
;;;2550       huart->TxXferCount = 0x00U;
00000e  2100              MOVS     r1,#0
000010  84c1              STRH     r1,[r0,#0x26]
;;;2551   
;;;2552       /* Disable the DMA transfer for transmit request by setting the DMAT bit
;;;2553          in the UART CR3 register */
;;;2554       CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
000012  6801              LDR      r1,[r0,#0]
000014  694a              LDR      r2,[r1,#0x14]
000016  f0220280          BIC      r2,r2,#0x80
00001a  614a              STR      r2,[r1,#0x14]
;;;2555   
;;;2556       /* Enable the UART Transmit Complete Interrupt */
;;;2557       SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
00001c  6800              LDR      r0,[r0,#0]
00001e  68c1              LDR      r1,[r0,#0xc]
000020  f0410140          ORR      r1,r1,#0x40
000024  60c1              STR      r1,[r0,#0xc]
;;;2558   
;;;2559     }
;;;2560     /* DMA Circular mode */
;;;2561     else
;;;2562     {
;;;2563   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2564       /*Call registered Tx complete callback*/
;;;2565       huart->TxCpltCallback(huart);
;;;2566   #else
;;;2567       /*Call legacy weak Tx complete callback*/
;;;2568       HAL_UART_TxCpltCallback(huart);
;;;2569   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2570     }
;;;2571   }
000026  bd10              POP      {r4,pc}
                  |L45.40|
000028  f7fffffe          BL       HAL_UART_TxCpltCallback
00002c  bd10              POP      {r4,pc}
;;;2572   
                          ENDP


                          AREA ||i.UART_DMATxAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxAbortCallback PROC
;;;2778     */
;;;2779   static void UART_DMATxAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2780   {
;;;2781     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2782   
;;;2783     huart->hdmatx->XferAbortCallback = NULL;
000004  2200              MOVS     r2,#0
000006  6b01              LDR      r1,[r0,#0x30]
000008  634a              STR      r2,[r1,#0x34]
;;;2784   
;;;2785     /* Check if an Abort process is still ongoing */
;;;2786     if (huart->hdmarx != NULL)
00000a  6b41              LDR      r1,[r0,#0x34]
00000c  2900              CMP      r1,#0
00000e  d002              BEQ      |L46.22|
;;;2787     {
;;;2788       if (huart->hdmarx->XferAbortCallback != NULL)
000010  6b49              LDR      r1,[r1,#0x34]
000012  2900              CMP      r1,#0
000014  d109              BNE      |L46.42|
                  |L46.22|
;;;2789       {
;;;2790         return;
;;;2791       }
;;;2792     }
;;;2793   
;;;2794     /* No Abort process still ongoing : All DMA channels are aborted, call user Abort Complete callback */
;;;2795     huart->TxXferCount = 0x00U;
000016  84c2              STRH     r2,[r0,#0x26]
;;;2796     huart->RxXferCount = 0x00U;
000018  85c2              STRH     r2,[r0,#0x2e]
;;;2797   
;;;2798     /* Reset ErrorCode */
;;;2799     huart->ErrorCode = HAL_UART_ERROR_NONE;
00001a  63c2              STR      r2,[r0,#0x3c]
;;;2800   
;;;2801     /* Restore huart->gState and huart->RxState to Ready */
;;;2802     huart->gState  = HAL_UART_STATE_READY;
00001c  2120              MOVS     r1,#0x20
00001e  f8801039          STRB     r1,[r0,#0x39]
;;;2803     huart->RxState = HAL_UART_STATE_READY;
000022  f880103a          STRB     r1,[r0,#0x3a]
;;;2804   
;;;2805     /* Call user Abort complete callback */
;;;2806   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2807     /* Call registered Abort complete callback */
;;;2808     huart->AbortCpltCallback(huart);
;;;2809   #else
;;;2810     /* Call legacy weak Abort complete callback */
;;;2811     HAL_UART_AbortCpltCallback(huart);
000026  f7fffffe          BL       HAL_UART_AbortCpltCallback
                  |L46.42|
;;;2812   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2813   }
00002a  bd10              POP      {r4,pc}
;;;2814   
                          ENDP


                          AREA ||i.UART_DMATxHalfCplt||, CODE, READONLY, ALIGN=1

                  UART_DMATxHalfCplt PROC
;;;2578     */
;;;2579   static void UART_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2580   {
;;;2581     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2582   
;;;2583   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2584     /*Call registered Tx complete callback*/
;;;2585     huart->TxHalfCpltCallback(huart);
;;;2586   #else
;;;2587     /*Call legacy weak Tx complete callback*/
;;;2588     HAL_UART_TxHalfCpltCallback(huart);
000004  f7fffffe          BL       HAL_UART_TxHalfCpltCallback
;;;2589   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2590   }
000008  bd10              POP      {r4,pc}
;;;2591   
                          ENDP


                          AREA ||i.UART_DMATxOnlyAbortCallback||, CODE, READONLY, ALIGN=1

                  UART_DMATxOnlyAbortCallback PROC
;;;2868     */
;;;2869   static void UART_DMATxOnlyAbortCallback(DMA_HandleTypeDef *hdma)
000000  b510              PUSH     {r4,lr}
;;;2870   {
;;;2871     UART_HandleTypeDef *huart = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
000002  6a40              LDR      r0,[r0,#0x24]
;;;2872   
;;;2873     huart->TxXferCount = 0x00U;
000004  2100              MOVS     r1,#0
000006  84c1              STRH     r1,[r0,#0x26]
;;;2874   
;;;2875     /* Restore huart->gState to Ready */
;;;2876     huart->gState = HAL_UART_STATE_READY;
000008  2120              MOVS     r1,#0x20
00000a  f8801039          STRB     r1,[r0,#0x39]
;;;2877   
;;;2878     /* Call user Abort complete callback */
;;;2879   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2880     /* Call registered Abort Transmit Complete Callback */
;;;2881     huart->AbortTransmitCpltCallback(huart);
;;;2882   #else
;;;2883     /* Call legacy weak Abort Transmit Complete Callback */
;;;2884     HAL_UART_AbortTransmitCpltCallback(huart);
00000e  f7fffffe          BL       HAL_UART_AbortTransmitCpltCallback
;;;2885   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2886   }
000012  bd10              POP      {r4,pc}
;;;2887   
                          ENDP


                          AREA ||i.UART_EndRxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndRxTransfer PROC
;;;2737     */
;;;2738   static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2739   {
;;;2740     /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
;;;2741     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
000002  68ca              LDR      r2,[r1,#0xc]
000004  f4227290          BIC      r2,r2,#0x120
000008  60ca              STR      r2,[r1,#0xc]
;;;2742     CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
00000a  6801              LDR      r1,[r0,#0]
00000c  694a              LDR      r2,[r1,#0x14]
00000e  f0220201          BIC      r2,r2,#1
000012  614a              STR      r2,[r1,#0x14]
;;;2743   
;;;2744     /* At end of Rx process, restore huart->RxState to Ready */
;;;2745     huart->RxState = HAL_UART_STATE_READY;
000014  2120              MOVS     r1,#0x20
000016  f880103a          STRB     r1,[r0,#0x3a]
;;;2746   }
00001a  4770              BX       lr
;;;2747   
                          ENDP


                          AREA ||i.UART_EndTransmit_IT||, CODE, READONLY, ALIGN=1

                  UART_EndTransmit_IT PROC
;;;2961     */
;;;2962   static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2963   {
;;;2964     /* Disable the UART Transmit Complete Interrupt */
;;;2965     __HAL_UART_DISABLE_IT(huart, UART_IT_TC);
000002  6801              LDR      r1,[r0,#0]
000004  68ca              LDR      r2,[r1,#0xc]
000006  f0220240          BIC      r2,r2,#0x40
00000a  60ca              STR      r2,[r1,#0xc]
;;;2966   
;;;2967     /* Tx process is ended, restore huart->gState to Ready */
;;;2968     huart->gState = HAL_UART_STATE_READY;
00000c  2120              MOVS     r1,#0x20
00000e  f8801039          STRB     r1,[r0,#0x39]
;;;2969   
;;;2970   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;2971     /*Call registered Tx complete callback*/
;;;2972     huart->TxCpltCallback(huart);
;;;2973   #else
;;;2974     /*Call legacy weak Tx complete callback*/
;;;2975     HAL_UART_TxCpltCallback(huart);
000012  f7fffffe          BL       HAL_UART_TxCpltCallback
;;;2976   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;2977   
;;;2978     return HAL_OK;
000016  2000              MOVS     r0,#0
;;;2979   }
000018  bd10              POP      {r4,pc}
;;;2980   
                          ENDP


                          AREA ||i.UART_EndTxTransfer||, CODE, READONLY, ALIGN=1

                  UART_EndTxTransfer PROC
;;;2723     */
;;;2724   static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
000000  6801              LDR      r1,[r0,#0]
;;;2725   {
;;;2726     /* Disable TXEIE and TCIE interrupts */
;;;2727     CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
000002  68ca              LDR      r2,[r1,#0xc]
000004  f02202c0          BIC      r2,r2,#0xc0
000008  60ca              STR      r2,[r1,#0xc]
;;;2728   
;;;2729     /* At end of Tx process, restore huart->gState to Ready */
;;;2730     huart->gState = HAL_UART_STATE_READY;
00000a  2120              MOVS     r1,#0x20
00000c  f8801039          STRB     r1,[r0,#0x39]
;;;2731   }
000010  4770              BX       lr
;;;2732   
                          ENDP


                          AREA ||i.UART_Receive_IT||, CODE, READONLY, ALIGN=1

                  UART_Receive_IT PROC
;;;2986     */
;;;2987   static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
000000  b510              PUSH     {r4,lr}
;;;2988   {
;;;2989     uint8_t  *pdata8bits;
;;;2990     uint16_t *pdata16bits;
;;;2991   
;;;2992     /* Check that a Rx process is ongoing */
;;;2993     if (huart->RxState == HAL_UART_STATE_BUSY_RX)
000002  f890103a          LDRB     r1,[r0,#0x3a]
000006  2922              CMP      r1,#0x22
000008  d001              BEQ      |L52.14|
;;;2994     {
;;;2995       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;2996       {
;;;2997         pdata8bits  = NULL;
;;;2998         pdata16bits = (uint16_t *) huart->pRxBuffPtr;
;;;2999         *pdata16bits = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FF);
;;;3000         huart->pRxBuffPtr += 2U;
;;;3001       }
;;;3002       else
;;;3003       {
;;;3004         pdata8bits = (uint8_t *) huart->pRxBuffPtr;
;;;3005         pdata16bits  = NULL;
;;;3006   
;;;3007         if ((huart->Init.WordLength == UART_WORDLENGTH_9B) || ((huart->Init.WordLength == UART_WORDLENGTH_8B) && (huart->Init.Parity == UART_PARITY_NONE)))
;;;3008         {
;;;3009           *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FF);
;;;3010         }
;;;3011         else
;;;3012         {
;;;3013           *pdata8bits = (uint8_t)(huart->Instance->DR & (uint8_t)0x007F);
;;;3014         }
;;;3015         huart->pRxBuffPtr += 1U;
;;;3016       }
;;;3017   
;;;3018       if (--huart->RxXferCount == 0U)
;;;3019       {
;;;3020         /* Disable the UART Data Register not empty Interrupt */
;;;3021         __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE);
;;;3022   
;;;3023         /* Disable the UART Parity Error Interrupt */
;;;3024         __HAL_UART_DISABLE_IT(huart, UART_IT_PE);
;;;3025   
;;;3026         /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
;;;3027         __HAL_UART_DISABLE_IT(huart, UART_IT_ERR);
;;;3028   
;;;3029         /* Rx process is completed, restore huart->RxState to Ready */
;;;3030         huart->RxState = HAL_UART_STATE_READY;
;;;3031   
;;;3032   #if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
;;;3033         /*Call registered Rx complete callback*/
;;;3034         huart->RxCpltCallback(huart);
;;;3035   #else
;;;3036         /*Call legacy weak Rx complete callback*/
;;;3037         HAL_UART_RxCpltCallback(huart);
;;;3038   #endif /* USE_HAL_UART_REGISTER_CALLBACKS */
;;;3039   
;;;3040         return HAL_OK;
;;;3041       }
;;;3042       return HAL_OK;
;;;3043     }
;;;3044     else
;;;3045     {
;;;3046       return HAL_BUSY;
00000a  2002              MOVS     r0,#2
;;;3047     }
;;;3048   }
00000c  bd10              POP      {r4,pc}
                  |L52.14|
00000e  6882              LDR      r2,[r0,#8]            ;2995
000010  f44f5380          MOV      r3,#0x1000            ;2995
000014  429a              CMP      r2,r3                 ;2995
000016  d101              BNE      |L52.28|
000018  6901              LDR      r1,[r0,#0x10]         ;2995
00001a  b121              CBZ      r1,|L52.38|
                  |L52.28|
00001c  6a81              LDR      r1,[r0,#0x28]         ;3004
00001e  429a              CMP      r2,r3                 ;3007
000020  d01d              BEQ      |L52.94|
000022  b152              CBZ      r2,|L52.58|
000024  e00b              B        |L52.62|
                  |L52.38|
000026  6a81              LDR      r1,[r0,#0x28]         ;2998
000028  6802              LDR      r2,[r0,#0]            ;2999
00002a  6852              LDR      r2,[r2,#4]            ;2999
00002c  f3c20208          UBFX     r2,r2,#0,#9           ;2999
000030  800a              STRH     r2,[r1,#0]            ;2999
000032  6a81              LDR      r1,[r0,#0x28]         ;3000
000034  1c89              ADDS     r1,r1,#2              ;3000
000036  6281              STR      r1,[r0,#0x28]         ;3000
000038  e009              B        |L52.78|
                  |L52.58|
00003a  6902              LDR      r2,[r0,#0x10]         ;3007
00003c  b17a              CBZ      r2,|L52.94|
                  |L52.62|
00003e  6802              LDR      r2,[r0,#0]            ;3013
000040  6852              LDR      r2,[r2,#4]            ;3013
000042  f002027f          AND      r2,r2,#0x7f           ;3013
000046  700a              STRB     r2,[r1,#0]            ;3013
                  |L52.72|
000048  6a81              LDR      r1,[r0,#0x28]         ;3015
00004a  1c49              ADDS     r1,r1,#1              ;3015
00004c  6281              STR      r1,[r0,#0x28]         ;3015
                  |L52.78|
00004e  8dc1              LDRH     r1,[r0,#0x2e]         ;3018
000050  1e49              SUBS     r1,r1,#1              ;3018
000052  0409              LSLS     r1,r1,#16             ;3018
000054  0c09              LSRS     r1,r1,#16             ;3018
000056  85c1              STRH     r1,[r0,#0x2e]         ;3018
000058  d005              BEQ      |L52.102|
00005a  2000              MOVS     r0,#0                 ;3042
00005c  bd10              POP      {r4,pc}
                  |L52.94|
00005e  6802              LDR      r2,[r0,#0]            ;3009
000060  6852              LDR      r2,[r2,#4]            ;3009
000062  700a              STRB     r2,[r1,#0]            ;3009
000064  e7f0              B        |L52.72|
                  |L52.102|
000066  6801              LDR      r1,[r0,#0]            ;3021
000068  68ca              LDR      r2,[r1,#0xc]          ;3021
00006a  f0220220          BIC      r2,r2,#0x20           ;3021
00006e  60ca              STR      r2,[r1,#0xc]          ;3021
000070  6801              LDR      r1,[r0,#0]            ;3024
000072  68ca              LDR      r2,[r1,#0xc]          ;3024
000074  f4227280          BIC      r2,r2,#0x100          ;3024
000078  60ca              STR      r2,[r1,#0xc]          ;3024
00007a  6801              LDR      r1,[r0,#0]            ;3027
00007c  694a              LDR      r2,[r1,#0x14]         ;3027
00007e  f0220201          BIC      r2,r2,#1              ;3027
000082  614a              STR      r2,[r1,#0x14]         ;3027
000084  2120              MOVS     r1,#0x20              ;3030
000086  f880103a          STRB     r1,[r0,#0x3a]         ;3030
00008a  f7fffffe          BL       HAL_UART_RxCpltCallback
00008e  2000              MOVS     r0,#0                 ;3040
000090  bd10              POP      {r4,pc}
;;;3049   
                          ENDP


                          AREA ||i.UART_SetConfig||, CODE, READONLY, ALIGN=2

                  UART_SetConfig PROC
;;;3055     */
;;;3056   static void UART_SetConfig(UART_HandleTypeDef *huart)
000000  b570              PUSH     {r4-r6,lr}
;;;3057   {
000002  4604              MOV      r4,r0
;;;3058     uint32_t tmpreg;
;;;3059     uint32_t pclk;
;;;3060   
;;;3061     /* Check the parameters */
;;;3062     assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
;;;3063     assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
;;;3064     assert_param(IS_UART_PARITY(huart->Init.Parity));
;;;3065     assert_param(IS_UART_MODE(huart->Init.Mode));
;;;3066   
;;;3067     /*-------------------------- USART CR2 Configuration -----------------------*/
;;;3068     /* Configure the UART Stop Bits: Set STOP[13:12] bits
;;;3069        according to huart->Init.StopBits value */
;;;3070     MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
000004  6820              LDR      r0,[r4,#0]
000006  6901              LDR      r1,[r0,#0x10]
000008  68e2              LDR      r2,[r4,#0xc]
00000a  f4215140          BIC      r1,r1,#0x3000
00000e  4311              ORRS     r1,r1,r2
000010  6101              STR      r1,[r0,#0x10]
;;;3071   
;;;3072     /*-------------------------- USART CR1 Configuration -----------------------*/
;;;3073     /* Configure the UART Word Length, Parity and mode:
;;;3074        Set the M bits according to huart->Init.WordLength value
;;;3075        Set PCE and PS bits according to huart->Init.Parity value
;;;3076        Set TE and RE bits according to huart->Init.Mode value
;;;3077        Set OVER8 bit according to huart->Init.OverSampling value */
;;;3078   
;;;3079   #if defined(USART_CR1_OVER8)
;;;3080     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
;;;3081     MODIFY_REG(huart->Instance->CR1,
;;;3082                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
;;;3083                tmpreg);
;;;3084   #else
;;;3085     tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode;
000012  68a1              LDR      r1,[r4,#8]
000014  6920              LDR      r0,[r4,#0x10]
000016  4301              ORRS     r1,r1,r0
000018  6960              LDR      r0,[r4,#0x14]
00001a  4301              ORRS     r1,r1,r0
;;;3086     MODIFY_REG(huart->Instance->CR1,
00001c  6820              LDR      r0,[r4,#0]
00001e  68c2              LDR      r2,[r0,#0xc]
000020  f241630c          MOV      r3,#0x160c
000024  439a              BICS     r2,r2,r3
000026  430a              ORRS     r2,r2,r1
000028  60c2              STR      r2,[r0,#0xc]
;;;3087                (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE),
;;;3088                tmpreg);
;;;3089   #endif /* USART_CR1_OVER8 */
;;;3090   
;;;3091     /*-------------------------- USART CR3 Configuration -----------------------*/
;;;3092     /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
;;;3093     MODIFY_REG(huart->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), huart->Init.HwFlowCtl);
00002a  6820              LDR      r0,[r4,#0]
00002c  6941              LDR      r1,[r0,#0x14]
00002e  69a2              LDR      r2,[r4,#0x18]
000030  f4217140          BIC      r1,r1,#0x300
000034  4311              ORRS     r1,r1,r2
000036  6141              STR      r1,[r0,#0x14]
;;;3094   
;;;3095   
;;;3096     if(huart->Instance == USART1)
000038  491e              LDR      r1,|L53.180|
00003a  6820              LDR      r0,[r4,#0]
00003c  4288              CMP      r0,r1
00003e  d102              BNE      |L53.70|
;;;3097     {
;;;3098       pclk = HAL_RCC_GetPCLK2Freq();
000040  f7fffffe          BL       HAL_RCC_GetPCLK2Freq
000044  e001              B        |L53.74|
                  |L53.70|
;;;3099     }
;;;3100     else
;;;3101     {
;;;3102       pclk = HAL_RCC_GetPCLK1Freq();
000046  f7fffffe          BL       HAL_RCC_GetPCLK1Freq
                  |L53.74|
;;;3103     }
;;;3104   
;;;3105     /*-------------------------- USART BRR Configuration ---------------------*/
;;;3106   #if defined(USART_CR1_OVER8)
;;;3107     if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
;;;3108     {
;;;3109       huart->Instance->BRR = UART_BRR_SAMPLING8(pclk, huart->Init.BaudRate);
;;;3110     }
;;;3111     else
;;;3112     {
;;;3113       huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
;;;3114     }
;;;3115   #else
;;;3116     huart->Instance->BRR = UART_BRR_SAMPLING16(pclk, huart->Init.BaudRate);
00004a  eb0001c0          ADD      r1,r0,r0,LSL #3
00004e  eb011000          ADD      r0,r1,r0,LSL #4
000052  6861              LDR      r1,[r4,#4]
000054  2264              MOVS     r2,#0x64
000056  0089              LSLS     r1,r1,#2
000058  fbb0f3f1          UDIV     r3,r0,r1
00005c  fbb3f3f2          UDIV     r3,r3,r2
000060  f06f0618          MVN      r6,#0x18
000064  4373              MULS     r3,r6,r3
000066  fbb0f5f1          UDIV     r5,r0,r1
00006a  fbb0f6f1          UDIV     r6,r0,r1
00006e  eb050583          ADD      r5,r5,r3,LSL #2
000072  2332              MOVS     r3,#0x32
000074  eb031505          ADD      r5,r3,r5,LSL #4
000078  fbb5f5f2          UDIV     r5,r5,r2
00007c  fbb6f6f2          UDIV     r6,r6,r2
000080  f00505f0          AND      r5,r5,#0xf0
000084  eb051506          ADD      r5,r5,r6,LSL #4
000088  fbb0f6f1          UDIV     r6,r0,r1
00008c  fbb0f0f1          UDIV     r0,r0,r1
000090  fbb0f0f2          UDIV     r0,r0,r2
000094  f06f0118          MVN      r1,#0x18
000098  4348              MULS     r0,r1,r0
00009a  eb060080          ADD      r0,r6,r0,LSL #2
00009e  eb031000          ADD      r0,r3,r0,LSL #4
0000a2  fbb0f0f2          UDIV     r0,r0,r2
0000a6  6821              LDR      r1,[r4,#0]
0000a8  f000000f          AND      r0,r0,#0xf
0000ac  4428              ADD      r0,r0,r5
0000ae  6088              STR      r0,[r1,#8]
;;;3117   #endif /* USART_CR1_OVER8 */
;;;3118   }
0000b0  bd70              POP      {r4-r6,pc}
;;;3119   
                          ENDP

0000b2  0000              DCW      0x0000
                  |L53.180|
                          DCD      0x40013800

                          AREA ||i.UART_Transmit_IT||, CODE, READONLY, ALIGN=1

                  UART_Transmit_IT PROC
;;;2921     */
;;;2922   static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
000000  f8901039          LDRB     r1,[r0,#0x39]
;;;2923   {
;;;2924     uint16_t *tmp;
;;;2925   
;;;2926     /* Check that a Tx process is ongoing */
;;;2927     if (huart->gState == HAL_UART_STATE_BUSY_TX)
000004  2921              CMP      r1,#0x21
000006  d001              BEQ      |L54.12|
;;;2928     {
;;;2929       if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
;;;2930       {
;;;2931         tmp = (uint16_t *) huart->pTxBuffPtr;
;;;2932         huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FF);
;;;2933         huart->pTxBuffPtr += 2U;
;;;2934       }
;;;2935       else
;;;2936       {
;;;2937         huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FF);
;;;2938       }
;;;2939   
;;;2940       if (--huart->TxXferCount == 0U)
;;;2941       {
;;;2942         /* Disable the UART Transmit Complete Interrupt */
;;;2943         __HAL_UART_DISABLE_IT(huart, UART_IT_TXE);
;;;2944   
;;;2945         /* Enable the UART Transmit Complete Interrupt */
;;;2946         __HAL_UART_ENABLE_IT(huart, UART_IT_TC);
;;;2947       }
;;;2948       return HAL_OK;
;;;2949     }
;;;2950     else
;;;2951     {
;;;2952       return HAL_BUSY;
000008  2002              MOVS     r0,#2
;;;2953     }
;;;2954   }
00000a  4770              BX       lr
                  |L54.12|
00000c  6881              LDR      r1,[r0,#8]            ;2929
00000e  f5b15f80          CMP      r1,#0x1000            ;2929
000012  d101              BNE      |L54.24|
000014  6901              LDR      r1,[r0,#0x10]         ;2929
000016  b161              CBZ      r1,|L54.50|
                  |L54.24|
000018  6a01              LDR      r1,[r0,#0x20]         ;2937
00001a  1c4a              ADDS     r2,r1,#1              ;2937
00001c  6202              STR      r2,[r0,#0x20]         ;2937
00001e  6802              LDR      r2,[r0,#0]            ;2937
000020  7809              LDRB     r1,[r1,#0]            ;2937
000022  6051              STR      r1,[r2,#4]            ;2937
                  |L54.36|
000024  8cc1              LDRH     r1,[r0,#0x26]         ;2940
000026  1e49              SUBS     r1,r1,#1              ;2940
000028  0409              LSLS     r1,r1,#16             ;2940
00002a  0c09              LSRS     r1,r1,#16             ;2940
00002c  84c1              STRH     r1,[r0,#0x26]         ;2940
00002e  d00a              BEQ      |L54.70|
000030  e013              B        |L54.90|
                  |L54.50|
000032  6a01              LDR      r1,[r0,#0x20]         ;2931
000034  6802              LDR      r2,[r0,#0]            ;2932
000036  8809              LDRH     r1,[r1,#0]            ;2932
000038  f3c10108          UBFX     r1,r1,#0,#9           ;2932
00003c  6051              STR      r1,[r2,#4]            ;2932
00003e  6a01              LDR      r1,[r0,#0x20]         ;2933
000040  1c89              ADDS     r1,r1,#2              ;2933
000042  6201              STR      r1,[r0,#0x20]         ;2933
000044  e7ee              B        |L54.36|
                  |L54.70|
000046  6801              LDR      r1,[r0,#0]            ;2943
000048  68ca              LDR      r2,[r1,#0xc]          ;2943
00004a  f0220280          BIC      r2,r2,#0x80           ;2943
00004e  60ca              STR      r2,[r1,#0xc]          ;2943
000050  6800              LDR      r0,[r0,#0]            ;2946
000052  68c1              LDR      r1,[r0,#0xc]          ;2946
000054  f0410140          ORR      r1,r1,#0x40           ;2946
000058  60c1              STR      r1,[r0,#0xc]          ;2946
                  |L54.90|
00005a  2000              MOVS     r0,#0                 ;2948
00005c  4770              BX       lr
;;;2955   
                          ENDP


                          AREA ||i.UART_WaitOnFlagUntilTimeout||, CODE, READONLY, ALIGN=1

                  UART_WaitOnFlagUntilTimeout PROC
;;;2691     */
;;;2692   static HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2693   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  9d06              LDR      r5,[sp,#0x18]
;;;2694     /* Wait until flag is set */
;;;2695     while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
;;;2696     {
;;;2697       /* Check for the Timeout */
;;;2698       if (Timeout != HAL_MAX_DELAY)
;;;2699       {
;;;2700         if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
;;;2701         {
;;;2702           /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
;;;2703           CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
;;;2704           CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
;;;2705   
;;;2706           huart->gState  = HAL_UART_STATE_READY;
;;;2707           huart->RxState = HAL_UART_STATE_READY;
;;;2708   
;;;2709           /* Process Unlocked */
;;;2710           __HAL_UNLOCK(huart);
;;;2711   
;;;2712           return HAL_TIMEOUT;
00000e  e01d              B        |L55.76|
                  |L55.16|
000010  1c68              ADDS     r0,r5,#1              ;2698
000012  d01b              BEQ      |L55.76|
000014  b12d              CBZ      r5,|L55.34|
000016  f7fffffe          BL       HAL_GetTick
00001a  eba00008          SUB      r0,r0,r8              ;2700
00001e  42a8              CMP      r0,r5                 ;2700
000020  d914              BLS      |L55.76|
                  |L55.34|
000022  6820              LDR      r0,[r4,#0]            ;2703
000024  68c1              LDR      r1,[r0,#0xc]          ;2703
000026  f42171d0          BIC      r1,r1,#0x1a0          ;2703
00002a  60c1              STR      r1,[r0,#0xc]          ;2703
00002c  6820              LDR      r0,[r4,#0]            ;2704
00002e  6941              LDR      r1,[r0,#0x14]         ;2704
000030  f0210101          BIC      r1,r1,#1              ;2704
000034  6141              STR      r1,[r0,#0x14]         ;2704
000036  2020              MOVS     r0,#0x20              ;2706
000038  f8840039          STRB     r0,[r4,#0x39]         ;2706
00003c  f884003a          STRB     r0,[r4,#0x3a]         ;2707
000040  2000              MOVS     r0,#0                 ;2710
000042  f8840038          STRB     r0,[r4,#0x38]         ;2710
000046  2003              MOVS     r0,#3
                  |L55.72|
;;;2713         }
;;;2714       }
;;;2715     }
;;;2716     return HAL_OK;
;;;2717   }
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L55.76|
00004c  6820              LDR      r0,[r4,#0]            ;2695
00004e  6800              LDR      r0,[r0,#0]            ;2695
000050  ea360000          BICS     r0,r6,r0              ;2695
000054  d004              BEQ      |L55.96|
000056  2000              MOVS     r0,#0                 ;2695
                  |L55.88|
000058  42b8              CMP      r0,r7                 ;2695
00005a  d0d9              BEQ      |L55.16|
00005c  2000              MOVS     r0,#0                 ;2716
00005e  e7f3              B        |L55.72|
                  |L55.96|
000060  2001              MOVS     r0,#1                 ;2695
000062  e7f9              B        |L55.88|
;;;2718   
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\Drivers\\STM32F1xx_HAL_Driver\\Src\\stm32f1xx_hal_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH|
#line 478
|__asm___20_stm32f1xx_hal_uart_c_d497114f____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX|
#line 665
|__asm___20_stm32f1xx_hal_uart_c_d497114f____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
