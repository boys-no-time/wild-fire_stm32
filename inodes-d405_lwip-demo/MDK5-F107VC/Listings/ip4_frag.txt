; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\ip4_frag.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ip4_frag.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\system\arch -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Inc -I..\Middlewares\Third_Party\LwIP\src\include -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\ip4_frag.crf ..\Middlewares\Third_Party\LwIP\src\core\ipv4\ip4_frag.c]
                          THUMB

                          AREA ||i.ip4_frag||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  ip4_frag PROC
;;;717    err_t
;;;718    ip4_frag(struct pbuf *p, struct netif *netif, const ip4_addr_t *dest)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;719    {
000004  b088              SUB      sp,sp,#0x20
000006  4604              MOV      r4,r0
;;;720      struct pbuf *rambuf;
;;;721    #if !LWIP_NETIF_TX_SINGLE_PBUF
;;;722      struct pbuf *newpbuf;
;;;723      u16_t newpbuflen = 0;
000008  2700              MOVS     r7,#0
;;;724      u16_t left_to_copy;
;;;725    #endif
;;;726      struct ip_hdr *original_iphdr;
;;;727      struct ip_hdr *iphdr;
;;;728      const u16_t nfb = (netif->mtu - IP_HLEN) / 8;
00000a  9809              LDR      r0,[sp,#0x24]
00000c  8dc0              LDRH     r0,[r0,#0x2e]
00000e  3814              SUBS     r0,r0,#0x14
000010  17c1              ASRS     r1,r0,#31
000012  eb007051          ADD      r0,r0,r1,LSR #29
000016  f3c000cf          UBFX     r0,r0,#3,#16
00001a  9005              STR      r0,[sp,#0x14]
;;;729      u16_t left, fragsize;
;;;730      u16_t ofo;
;;;731      int last;
;;;732      u16_t poff = IP_HLEN;
00001c  2614              MOVS     r6,#0x14
;;;733      u16_t tmp;
;;;734    
;;;735      original_iphdr = (struct ip_hdr *)p->payload;
00001e  6860              LDR      r0,[r4,#4]
000020  9007              STR      r0,[sp,#0x1c]
;;;736      iphdr = original_iphdr;
000022  9807              LDR      r0,[sp,#0x1c]
;;;737      LWIP_ERROR("ip4_frag() does not support IP options", IPH_HL(iphdr) * 4 == IP_HLEN, return ERR_VAL);
000024  1fbd              SUBS     r5,r7,#6
000026  7801              LDRB     r1,[r0,#0]
000028  f001010f          AND      r1,r1,#0xf
00002c  2905              CMP      r1,#5
00002e  d00a              BEQ      |L1.70|
000030  a35e              ADR      r3,|L1.428|
000032  f24022e1          MOV      r2,#0x2e1
000036  a16c              ADR      r1,|L1.488|
000038  a075              ADR      r0,|L1.528|
00003a  f7fffffe          BL       __2printf
00003e  4628              MOV      r0,r5
                  |L1.64|
;;;738    
;;;739      /* Save original offset */
;;;740      tmp = lwip_ntohs(IPH_OFFSET(iphdr));
;;;741      ofo = tmp & IP_OFFMASK;
;;;742      LWIP_ERROR("ip_frag(): MF already set", (tmp & IP_MF) == 0, return ERR_VAL);
;;;743    
;;;744      left = p->tot_len - IP_HLEN;
;;;745    
;;;746      while (left) {
;;;747        /* Fill this fragment */
;;;748        fragsize = LWIP_MIN(left, nfb * 8);
;;;749    
;;;750    #if LWIP_NETIF_TX_SINGLE_PBUF
;;;751        rambuf = pbuf_alloc(PBUF_IP, fragsize, PBUF_RAM);
;;;752        if (rambuf == NULL) {
;;;753          goto memerr;
;;;754        }
;;;755        LWIP_ASSERT("this needs a pbuf in one piece!",
;;;756          (rambuf->len == rambuf->tot_len) && (rambuf->next == NULL));
;;;757        poff += pbuf_copy_partial(p, rambuf->payload, fragsize, poff);
;;;758        /* make room for the IP header */
;;;759        if (pbuf_header(rambuf, IP_HLEN)) {
;;;760          pbuf_free(rambuf);
;;;761          goto memerr;
;;;762        }
;;;763        /* fill in the IP header */
;;;764        SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
;;;765        iphdr = (struct ip_hdr*)rambuf->payload;
;;;766    #else /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;767        /* When not using a static buffer, create a chain of pbufs.
;;;768         * The first will be a PBUF_RAM holding the link and IP header.
;;;769         * The rest will be PBUF_REFs mirroring the pbuf chain to be fragged,
;;;770         * but limited to the size of an mtu.
;;;771         */
;;;772        rambuf = pbuf_alloc(PBUF_LINK, IP_HLEN, PBUF_RAM);
;;;773        if (rambuf == NULL) {
;;;774          goto memerr;
;;;775        }
;;;776        LWIP_ASSERT("this needs a pbuf in one piece!",
;;;777                    (p->len >= (IP_HLEN)));
;;;778        SMEMCPY(rambuf->payload, original_iphdr, IP_HLEN);
;;;779        iphdr = (struct ip_hdr *)rambuf->payload;
;;;780    
;;;781        left_to_copy = fragsize;
;;;782        while (left_to_copy) {
;;;783          struct pbuf_custom_ref *pcr;
;;;784          u16_t plen = p->len - poff;
;;;785          newpbuflen = LWIP_MIN(left_to_copy, plen);
;;;786          /* Is this pbuf already empty? */
;;;787          if (!newpbuflen) {
;;;788            poff = 0;
;;;789            p = p->next;
;;;790            continue;
;;;791          }
;;;792          pcr = ip_frag_alloc_pbuf_custom_ref();
;;;793          if (pcr == NULL) {
;;;794            pbuf_free(rambuf);
;;;795            goto memerr;
;;;796          }
;;;797          /* Mirror this pbuf, although we might not need all of it. */
;;;798          newpbuf = pbuf_alloced_custom(PBUF_RAW, newpbuflen, PBUF_REF, &pcr->pc,
;;;799            (u8_t*)p->payload + poff, newpbuflen);
;;;800          if (newpbuf == NULL) {
;;;801            ip_frag_free_pbuf_custom_ref(pcr);
;;;802            pbuf_free(rambuf);
;;;803            goto memerr;
;;;804          }
;;;805          pbuf_ref(p);
;;;806          pcr->original = p;
;;;807          pcr->pc.custom_free_function = ipfrag_free_pbuf_custom;
;;;808    
;;;809          /* Add it to end of rambuf's chain, but using pbuf_cat, not pbuf_chain
;;;810           * so that it is removed when pbuf_dechain is later called on rambuf.
;;;811           */
;;;812          pbuf_cat(rambuf, newpbuf);
;;;813          left_to_copy -= newpbuflen;
;;;814          if (left_to_copy) {
;;;815            poff = 0;
;;;816            p = p->next;
;;;817          }
;;;818        }
;;;819        poff += newpbuflen;
;;;820    #endif /* LWIP_NETIF_TX_SINGLE_PBUF */
;;;821    
;;;822        /* Correct header */
;;;823        last = (left <= netif->mtu - IP_HLEN);
;;;824    
;;;825        /* Set new offset and MF flag */
;;;826        tmp = (IP_OFFMASK & (ofo));
;;;827        if (!last) {
;;;828          tmp = tmp | IP_MF;
;;;829        }
;;;830        IPH_OFFSET_SET(iphdr, lwip_htons(tmp));
;;;831        IPH_LEN_SET(iphdr, lwip_htons(fragsize + IP_HLEN));
;;;832        IPH_CHKSUM_SET(iphdr, 0);
;;;833    #if CHECKSUM_GEN_IP
;;;834        IF__NETIF_CHECKSUM_ENABLED(netif, NETIF_CHECKSUM_GEN_IP) {
;;;835          IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
;;;836        }
;;;837    #endif /* CHECKSUM_GEN_IP */
;;;838    
;;;839        /* No need for separate header pbuf - we allowed room for it in rambuf
;;;840         * when allocated.
;;;841         */
;;;842        netif->output(netif, rambuf, dest);
;;;843        IPFRAG_STATS_INC(ip_frag.xmit);
;;;844    
;;;845        /* Unfortunately we can't reuse rambuf - the hardware may still be
;;;846         * using the buffer. Instead we free it (and the ensuing chain) and
;;;847         * recreate it next time round the loop. If we're lucky the hardware
;;;848         * will have already sent the packet, the free will really free, and
;;;849         * there will be zero memory penalty.
;;;850         */
;;;851    
;;;852        pbuf_free(rambuf);
;;;853        left -= fragsize;
;;;854        ofo += nfb;
;;;855      }
;;;856      MIB2_STATS_INC(mib2.ipfragoks);
;;;857      return ERR_OK;
;;;858    memerr:
;;;859      MIB2_STATS_INC(mib2.ipfragfails);
;;;860      return ERR_MEM;
;;;861    }
000040  b00b              ADD      sp,sp,#0x2c
000042  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.70|
000046  88c0              LDRH     r0,[r0,#6]            ;740
000048  f7fffffe          BL       lwip_htons
00004c  f3c0010c          UBFX     r1,r0,#0,#13          ;741
000050  9103              STR      r1,[sp,#0xc]          ;741
000052  0480              LSLS     r0,r0,#18             ;742
000054  d508              BPL      |L1.104|
000056  a355              ADR      r3,|L1.428|
000058  f24022e6          MOV      r2,#0x2e6             ;742
00005c  a176              ADR      r1,|L1.568|
00005e  a06c              ADR      r0,|L1.528|
000060  f7fffffe          BL       __2printf
000064  4628              MOV      r0,r5                 ;742
000066  e7eb              B        |L1.64|
                  |L1.104|
000068  8920              LDRH     r0,[r4,#8]            ;744
00006a  3814              SUBS     r0,r0,#0x14           ;744
00006c  fa1ff880          UXTH     r8,r0                 ;744
000070  e096              B        |L1.416|
                  |L1.114|
000072  9805              LDR      r0,[sp,#0x14]         ;748
000074  ebb80fc0          CMP      r8,r0,LSL #3          ;748
000078  d201              BCS      |L1.126|
00007a  4640              MOV      r0,r8                 ;748
00007c  e001              B        |L1.130|
                  |L1.126|
00007e  9805              LDR      r0,[sp,#0x14]         ;748
000080  00c0              LSLS     r0,r0,#3              ;748
                  |L1.130|
000082  b280              UXTH     r0,r0                 ;748
000084  9004              STR      r0,[sp,#0x10]         ;748
000086  2200              MOVS     r2,#0                 ;772
000088  2114              MOVS     r1,#0x14              ;772
00008a  2002              MOVS     r0,#2                 ;772
00008c  f7fffffe          BL       pbuf_alloc
000090  4683              MOV      r11,r0                ;772
000092  ea5f000b          MOVS     r0,r11                ;773
000096  d059              BEQ      |L1.332|
000098  8960              LDRH     r0,[r4,#0xa]          ;776
00009a  2814              CMP      r0,#0x14              ;776
00009c  d206              BCS      |L1.172|
00009e  a343              ADR      r3,|L1.428|
0000a0  f44f7242          MOV      r2,#0x308             ;776
0000a4  a16b              ADR      r1,|L1.596|
0000a6  a05a              ADR      r0,|L1.528|
0000a8  f7fffffe          BL       __2printf
                  |L1.172|
0000ac  2214              MOVS     r2,#0x14              ;778
0000ae  f8db0004          LDR      r0,[r11,#4]           ;778
0000b2  9907              LDR      r1,[sp,#0x1c]         ;778
0000b4  f7fffffe          BL       __aeabi_memcpy
0000b8  f8db0004          LDR      r0,[r11,#4]           ;779
0000bc  9006              STR      r0,[sp,#0x18]         ;779
0000be  9d04              LDR      r5,[sp,#0x10]         ;781
0000c0  e02b              B        |L1.282|
                  |L1.194|
0000c2  8960              LDRH     r0,[r4,#0xa]          ;784
0000c4  1b80              SUBS     r0,r0,r6              ;784
0000c6  b287              UXTH     r7,r0                 ;784
0000c8  42bd              CMP      r5,r7                 ;785
0000ca  d200              BCS      |L1.206|
0000cc  462f              MOV      r7,r5                 ;785
                  |L1.206|
0000ce  b37f              CBZ      r7,|L1.304|
0000d0  f7fffffe          BL       ip_frag_alloc_pbuf_custom_ref
0000d4  4681              MOV      r9,r0                 ;792
0000d6  ea5f0009          MOVS     r0,r9                 ;793
0000da  d02d              BEQ      |L1.312|
0000dc  6860              LDR      r0,[r4,#4]            ;798
0000de  464b              MOV      r3,r9                 ;798
0000e0  4430              ADD      r0,r0,r6              ;798
0000e2  e9cd0700          STRD     r0,r7,[sp,#0]         ;798
0000e6  2202              MOVS     r2,#2                 ;798
0000e8  4639              MOV      r1,r7                 ;798
0000ea  2004              MOVS     r0,#4                 ;798
0000ec  f7fffffe          BL       pbuf_alloced_custom
0000f0  4682              MOV      r10,r0                ;798
0000f2  f1ba0f00          CMP      r10,#0                ;800
0000f6  d023              BEQ      |L1.320|
0000f8  4620              MOV      r0,r4                 ;805
0000fa  f7fffffe          BL       pbuf_ref
0000fe  f8c94014          STR      r4,[r9,#0x14]         ;806
000102  485c              LDR      r0,|L1.628|
000104  f8c90010          STR      r0,[r9,#0x10]         ;807
000108  4651              MOV      r1,r10                ;812
00010a  4658              MOV      r0,r11                ;812
00010c  f7fffffe          BL       pbuf_cat
000110  1be8              SUBS     r0,r5,r7              ;813
000112  b285              UXTH     r5,r0                 ;813
000114  b10d              CBZ      r5,|L1.282|
000116  2600              MOVS     r6,#0                 ;815
000118  6824              LDR      r4,[r4,#0]            ;816
                  |L1.282|
00011a  2d00              CMP      r5,#0                 ;782
00011c  d1d1              BNE      |L1.194|
00011e  19f0              ADDS     r0,r6,r7              ;819
000120  b286              UXTH     r6,r0                 ;819
000122  9809              LDR      r0,[sp,#0x24]         ;823
000124  8dc0              LDRH     r0,[r0,#0x2e]         ;823
000126  3814              SUBS     r0,r0,#0x14           ;823
000128  4540              CMP      r0,r8                 ;823
00012a  db12              BLT      |L1.338|
00012c  2101              MOVS     r1,#1                 ;823
00012e  e011              B        |L1.340|
                  |L1.304|
000130  e7ff              B        |L1.306|
                  |L1.306|
000132  2600              MOVS     r6,#0                 ;788
000134  6824              LDR      r4,[r4,#0]            ;789
000136  e7f0              B        |L1.282|
                  |L1.312|
000138  4658              MOV      r0,r11                ;794
00013a  f7fffffe          BL       pbuf_free
00013e  e005              B        |L1.332|
                  |L1.320|
000140  4648              MOV      r0,r9                 ;801
000142  f7fffffe          BL       ip_frag_free_pbuf_custom_ref
000146  4658              MOV      r0,r11                ;802
000148  f7fffffe          BL       pbuf_free
                  |L1.332|
00014c  f04f30ff          MOV      r0,#0xffffffff        ;860
000150  e776              B        |L1.64|
                  |L1.338|
000152  2100              MOVS     r1,#0                 ;823
                  |L1.340|
000154  9803              LDR      r0,[sp,#0xc]          ;826
000156  f3c0000c          UBFX     r0,r0,#0,#13          ;826
00015a  b909              CBNZ     r1,|L1.352|
00015c  f4405000          ORR      r0,r0,#0x2000         ;828
                  |L1.352|
000160  f7fffffe          BL       lwip_htons
000164  9906              LDR      r1,[sp,#0x18]         ;830
000166  80c8              STRH     r0,[r1,#6]            ;830
000168  9804              LDR      r0,[sp,#0x10]         ;831
00016a  3014              ADDS     r0,r0,#0x14           ;831
00016c  b280              UXTH     r0,r0                 ;831
00016e  f7fffffe          BL       lwip_htons
000172  9906              LDR      r1,[sp,#0x18]         ;831
000174  8048              STRH     r0,[r1,#2]            ;831
000176  9806              LDR      r0,[sp,#0x18]         ;832
000178  2100              MOVS     r1,#0                 ;832
00017a  8141              STRH     r1,[r0,#0xa]          ;832
00017c  9809              LDR      r0,[sp,#0x24]         ;842
00017e  4659              MOV      r1,r11                ;842
000180  9a0a              LDR      r2,[sp,#0x28]         ;842
000182  6943              LDR      r3,[r0,#0x14]         ;842
000184  4798              BLX      r3                    ;842
000186  4658              MOV      r0,r11                ;852
000188  f7fffffe          BL       pbuf_free
00018c  9804              LDR      r0,[sp,#0x10]         ;853
00018e  eba80000          SUB      r0,r8,r0              ;853
000192  fa1ff880          UXTH     r8,r0                 ;853
000196  9905              LDR      r1,[sp,#0x14]         ;854
000198  9803              LDR      r0,[sp,#0xc]          ;854
00019a  4408              ADD      r0,r0,r1              ;854
00019c  b280              UXTH     r0,r0                 ;854
00019e  9003              STR      r0,[sp,#0xc]          ;854
                  |L1.416|
0001a0  f1b80f00          CMP      r8,#0                 ;746
0001a4  f47faf65          BNE      |L1.114|
0001a8  2000              MOVS     r0,#0                 ;857
0001aa  e749              B        |L1.64|
;;;862    #endif /* IP_FRAG */
                          ENDP

                  |L1.428|
0001ac  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip"
0001b0  6964646c
0001b4  65776172
0001b8  65735c54
0001bc  68697264
0001c0  5f506172
0001c4  74795c4c
0001c8  7749505c
0001cc  7372635c
0001d0  636f7265
0001d4  5c697076
0001d8  345c6970
0001dc  345f6672          DCB      "4_frag.c",0
0001e0  61672e63
0001e4  00      
0001e5  00                DCB      0
0001e6  00                DCB      0
0001e7  00                DCB      0
                  |L1.488|
0001e8  6970345f          DCB      "ip4_frag() does not support IP options",0
0001ec  66726167
0001f0  28292064
0001f4  6f657320
0001f8  6e6f7420
0001fc  73757070
000200  6f727420
000204  4950206f
000208  7074696f
00020c  6e7300  
00020f  00                DCB      0
                  |L1.528|
000210  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000214  7274696f
000218  6e202225
00021c  73222066
000220  61696c65
000224  64206174
000228  206c696e
00022c  65202564
000230  20696e20
000234  25730a00
                  |L1.568|
000238  69705f66          DCB      "ip_frag(): MF already set",0
00023c  72616728
000240  293a204d
000244  4620616c
000248  72656164
00024c  79207365
000250  7400    
000252  00                DCB      0
000253  00                DCB      0
                  |L1.596|
000254  74686973          DCB      "this needs a pbuf in one piece!",0
000258  206e6565
00025c  64732061
000260  20706275
000264  6620696e
000268  206f6e65
00026c  20706965
000270  63652100
                  |L1.628|
                          DCD      ipfrag_free_pbuf_custom

                          AREA ||i.ip4_reass||, CODE, READONLY, ALIGN=2

                  ip4_reass PROC
;;;497    struct pbuf *
;;;498    ip4_reass(struct pbuf *p)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;499    {
000004  4682              MOV      r10,r0
;;;500      struct pbuf *r;
;;;501      struct ip_hdr *fraghdr;
;;;502      struct ip_reassdata *ipr;
;;;503      struct ip_reass_helper *iprh;
;;;504      u16_t offset, len, clen;
;;;505      int valid;
;;;506      int is_last;
;;;507    
;;;508      IPFRAG_STATS_INC(ip_frag.recv);
;;;509      MIB2_STATS_INC(mib2.ipreasmreqds);
;;;510    
;;;511      fraghdr = (struct ip_hdr*)p->payload;
000006  f8da5004          LDR      r5,[r10,#4]
;;;512    
;;;513      if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
00000a  7828              LDRB     r0,[r5,#0]
00000c  f000000f          AND      r0,r0,#0xf
000010  2805              CMP      r0,#5
000012  d173              BNE      |L2.252|
;;;514        LWIP_DEBUGF(IP_REASS_DEBUG,("ip4_reass: IP options currently not supported!\n"));
;;;515        IPFRAG_STATS_INC(ip_frag.err);
;;;516        goto nullreturn;
;;;517      }
;;;518    
;;;519      offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
000014  88e8              LDRH     r0,[r5,#6]
000016  f7fffffe          BL       lwip_htons
00001a  04c0              LSLS     r0,r0,#19
00001c  ea4f4810          LSR      r8,r0,#16
;;;520      len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
000020  8868              LDRH     r0,[r5,#2]
000022  f7fffffe          BL       lwip_htons
000026  7829              LDRB     r1,[r5,#0]
000028  f001010f          AND      r1,r1,#0xf
00002c  4249              RSBS     r1,r1,#0
00002e  eb000081          ADD      r0,r0,r1,LSL #2
000032  fa1ff980          UXTH     r9,r0
;;;521    
;;;522      /* Check if we are allowed to enqueue more datagrams. */
;;;523      clen = pbuf_clen(p);
000036  4650              MOV      r0,r10
000038  f7fffffe          BL       pbuf_clen
00003c  4606              MOV      r6,r0
;;;524      if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
00003e  4f4f              LDR      r7,|L2.380|
000040  8838              LDRH     r0,[r7,#0]  ; ip_reass_pbufcount
000042  4430              ADD      r0,r0,r6
000044  280a              CMP      r0,#0xa
000046  d909              BLS      |L2.92|
;;;525    #if IP_REASS_FREE_OLDEST
;;;526        if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
000048  4631              MOV      r1,r6
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       ip_reass_remove_oldest_datagram
000050  2800              CMP      r0,#0
000052  d053              BEQ      |L2.252|
;;;527            ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
000054  8838              LDRH     r0,[r7,#0]  ; ip_reass_pbufcount
000056  4430              ADD      r0,r0,r6
000058  280a              CMP      r0,#0xa
00005a  d84f              BHI      |L2.252|
                  |L2.92|
;;;528    #endif /* IP_REASS_FREE_OLDEST */
;;;529        {
;;;530          /* No datagram could be freed and still too many pbufs enqueued */
;;;531          LWIP_DEBUGF(IP_REASS_DEBUG,("ip4_reass: Overflow condition: pbufct=%d, clen=%d, MAX=%d\n",
;;;532            ip_reass_pbufcount, clen, IP_REASS_MAX_PBUFS));
;;;533          IPFRAG_STATS_INC(ip_frag.memerr);
;;;534          /* @todo: send ICMP time exceeded here? */
;;;535          /* drop this pbuf */
;;;536          goto nullreturn;
;;;537        }
;;;538      }
;;;539    
;;;540      /* Look for the datagram the fragment belongs to in the current datagram queue,
;;;541       * remembering the previous in the queue for later dequeueing. */
;;;542      for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
00005c  687c              LDR      r4,[r7,#4]  ; reassdatagrams
00005e  e00c              B        |L2.122|
                  |L2.96|
;;;543        /* Check if the incoming fragment matches the one currently present
;;;544           in the reassembly buffer. If so, we proceed with copying the
;;;545           fragment into the buffer. */
;;;546        if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
000060  6960              LDR      r0,[r4,#0x14]
000062  68e9              LDR      r1,[r5,#0xc]
000064  4288              CMP      r0,r1
000066  d107              BNE      |L2.120|
000068  69a0              LDR      r0,[r4,#0x18]
00006a  6929              LDR      r1,[r5,#0x10]
00006c  4288              CMP      r0,r1
00006e  d103              BNE      |L2.120|
000070  89a0              LDRH     r0,[r4,#0xc]
000072  88a9              LDRH     r1,[r5,#4]
000074  4288              CMP      r0,r1
000076  d002              BEQ      |L2.126|
                  |L2.120|
000078  6824              LDR      r4,[r4,#0]            ;542
                  |L2.122|
00007a  2c00              CMP      r4,#0                 ;542
00007c  d1f0              BNE      |L2.96|
                  |L2.126|
;;;547          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip4_reass: matching previous fragment ID=%"X16_F"\n",
;;;548            lwip_ntohs(IPH_ID(fraghdr))));
;;;549          IPFRAG_STATS_INC(ip_frag.cachehit);
;;;550          break;
;;;551        }
;;;552      }
;;;553    
;;;554      if (ipr == NULL) {
00007e  b12c              CBZ      r4,|L2.140|
;;;555      /* Enqueue a new datagram into the datagram queue */
;;;556        ipr = ip_reass_enqueue_new_datagram(fraghdr, clen);
;;;557        /* Bail if unable to enqueue */
;;;558        if (ipr == NULL) {
;;;559          goto nullreturn;
;;;560        }
;;;561      } else {
;;;562        if (((lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) &&
000080  88e8              LDRH     r0,[r5,#6]
000082  f7fffffe          BL       lwip_htons
000086  04c0              LSLS     r0,r0,#19
000088  d008              BEQ      |L2.156|
00008a  e012              B        |L2.178|
                  |L2.140|
00008c  4631              MOV      r1,r6                 ;556
00008e  4628              MOV      r0,r5                 ;556
000090  f7fffffe          BL       ip_reass_enqueue_new_datagram
000094  4604              MOV      r4,r0                 ;556
000096  0020              MOVS     r0,r4                 ;558
000098  d06b              BEQ      |L2.370|
00009a  e00a              B        |L2.178|
                  |L2.156|
;;;563          ((lwip_ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
00009c  89e0              LDRH     r0,[r4,#0xe]
00009e  f7fffffe          BL       lwip_htons
0000a2  04c0              LSLS     r0,r0,#19
0000a4  d005              BEQ      |L2.178|
;;;564          /* ipr->iphdr is not the header from the first fragment, but fraghdr is
;;;565           * -> copy fraghdr into ipr->iphdr since we want to have the header
;;;566           * of the first fragment (for ICMP time exceeded and later, for copying
;;;567           * all options, if supported)*/
;;;568          SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
0000a6  2214              MOVS     r2,#0x14
0000a8  4629              MOV      r1,r5
0000aa  f1040008          ADD      r0,r4,#8
0000ae  f7fffffe          BL       __aeabi_memcpy
                  |L2.178|
;;;569        }
;;;570      }
;;;571    
;;;572      /* At this point, we have either created a new entry or pointing
;;;573       * to an existing one */
;;;574    
;;;575      /* check for 'no more fragments', and update queue entry*/
;;;576      is_last = (IPH_OFFSET(fraghdr) & PP_NTOHS(IP_MF)) == 0;
0000b2  79a8              LDRB     r0,[r5,#6]
0000b4  f3401540          SBFX     r5,r0,#5,#1
0000b8  1c6d              ADDS     r5,r5,#1
;;;577      if (is_last) {
0000ba  b145              CBZ      r5,|L2.206|
;;;578        u16_t datagram_len = (u16_t)(offset + len);
0000bc  eb080009          ADD      r0,r8,r9
0000c0  b280              UXTH     r0,r0
;;;579        if ((datagram_len < offset) || (datagram_len > (0xFFFF - IP_HLEN))) {
0000c2  4540              CMP      r0,r8
0000c4  d355              BCC      |L2.370|
0000c6  f64f71eb          MOV      r1,#0xffeb
0000ca  4288              CMP      r0,r1
0000cc  d851              BHI      |L2.370|
                  |L2.206|
;;;580          /* u16_t overflow, cannot handle this */
;;;581          goto nullreturn;
;;;582        }
;;;583      }
;;;584      /* find the right place to insert this pbuf */
;;;585      /* @todo: trim pbufs if fragments are overlapping */
;;;586      valid = ip_reass_chain_frag_into_datagram_and_validate(ipr, p, is_last);
0000ce  462a              MOV      r2,r5
0000d0  4651              MOV      r1,r10
0000d2  4620              MOV      r0,r4
0000d4  f7fffffe          BL       ip_reass_chain_frag_into_datagram_and_validate
;;;587      if (valid == IP_REASS_VALIDATE_PBUF_DROPPED) {
0000d8  1c41              ADDS     r1,r0,#1
0000da  d04a              BEQ      |L2.370|
;;;588        goto nullreturn;
;;;589      }
;;;590      /* if we come here, the pbuf has been enqueued */
;;;591    
;;;592      /* Track the current number of pbufs current 'in-flight', in order to limit
;;;593         the number of fragments that may be enqueued at any one time
;;;594         (overflow checked by testing against IP_REASS_MAX_PBUFS) */
;;;595      ip_reass_pbufcount = (u16_t)(ip_reass_pbufcount + clen);
0000dc  8839              LDRH     r1,[r7,#0]  ; ip_reass_pbufcount
0000de  4431              ADD      r1,r1,r6
0000e0  8039              STRH     r1,[r7,#0]
;;;596      if (is_last) {
0000e2  b135              CBZ      r5,|L2.242|
;;;597        u16_t datagram_len = (u16_t)(offset + len);
0000e4  eb080109          ADD      r1,r8,r9
;;;598        ipr->datagram_len = datagram_len;
0000e8  83a1              STRH     r1,[r4,#0x1c]
;;;599        ipr->flags |= IP_REASS_FLAG_LASTFRAG;
0000ea  7fa1              LDRB     r1,[r4,#0x1e]
0000ec  f0410101          ORR      r1,r1,#1
0000f0  77a1              STRB     r1,[r4,#0x1e]
                  |L2.242|
;;;600        LWIP_DEBUGF(IP_REASS_DEBUG,
;;;601         ("ip4_reass: last fragment seen, total len %"S16_F"\n",
;;;602          ipr->datagram_len));
;;;603      }
;;;604    
;;;605      if (valid == IP_REASS_VALIDATE_TELEGRAM_FINISHED) {
0000f2  2801              CMP      r0,#1
0000f4  d003              BEQ      |L2.254|
;;;606        struct ip_reassdata *ipr_prev;
;;;607        /* the totally last fragment (flag more fragments = 0) was received at least
;;;608         * once AND all fragments are received */
;;;609        ipr->datagram_len += IP_HLEN;
;;;610    
;;;611        /* save the second pbuf before copying the header over the pointer */
;;;612        r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
;;;613    
;;;614        /* copy the original ip header back to the first pbuf */
;;;615        fraghdr = (struct ip_hdr*)(ipr->p->payload);
;;;616        SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
;;;617        IPH_LEN_SET(fraghdr, lwip_htons(ipr->datagram_len));
;;;618        IPH_OFFSET_SET(fraghdr, 0);
;;;619        IPH_CHKSUM_SET(fraghdr, 0);
;;;620        /* @todo: do we need to set/calculate the correct checksum? */
;;;621    #if CHECKSUM_GEN_IP
;;;622        IF__NETIF_CHECKSUM_ENABLED(ip_current_input_netif(), NETIF_CHECKSUM_GEN_IP) {
;;;623          IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
;;;624        }
;;;625    #endif /* CHECKSUM_GEN_IP */
;;;626    
;;;627        p = ipr->p;
;;;628    
;;;629        /* chain together the pbufs contained within the reass_data list. */
;;;630        while (r != NULL) {
;;;631          iprh = (struct ip_reass_helper*)r->payload;
;;;632    
;;;633          /* hide the ip header for every succeeding fragment */
;;;634          pbuf_header(r, -IP_HLEN);
;;;635          pbuf_cat(p, r);
;;;636          r = iprh->next_pbuf;
;;;637        }
;;;638    
;;;639        /* find the previous entry in the linked list */
;;;640        if (ipr == reassdatagrams) {
;;;641          ipr_prev = NULL;
;;;642        } else {
;;;643          for (ipr_prev = reassdatagrams; ipr_prev != NULL; ipr_prev = ipr_prev->next) {
;;;644            if (ipr_prev->next == ipr) {
;;;645              break;
;;;646            }
;;;647          }
;;;648        }
;;;649    
;;;650        /* release the sources allocate for the fragment queue entry */
;;;651        ip_reass_dequeue_datagram(ipr, ipr_prev);
;;;652    
;;;653        /* and adjust the number of pbufs currently queued for reassembly. */
;;;654        ip_reass_pbufcount -= pbuf_clen(p);
;;;655    
;;;656        MIB2_STATS_INC(mib2.ipreasmoks);
;;;657    
;;;658        /* Return the pbuf chain */
;;;659        return p;
;;;660      }
;;;661      /* the datagram is not (yet?) reassembled completely */
;;;662      LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
;;;663      return NULL;
0000f6  2000              MOVS     r0,#0
                  |L2.248|
;;;664    
;;;665    nullreturn:
;;;666      LWIP_DEBUGF(IP_REASS_DEBUG,("ip4_reass: nullreturn\n"));
;;;667      IPFRAG_STATS_INC(ip_frag.drop);
;;;668      pbuf_free(p);
;;;669      return NULL;
;;;670    }
0000f8  e8bd87f0          POP      {r4-r10,pc}
                  |L2.252|
0000fc  e039              B        |L2.370|
                  |L2.254|
0000fe  8ba0              LDRH     r0,[r4,#0x1c]         ;609
000100  3014              ADDS     r0,r0,#0x14           ;609
000102  83a0              STRH     r0,[r4,#0x1c]         ;609
000104  6860              LDR      r0,[r4,#4]            ;612
000106  6846              LDR      r6,[r0,#4]            ;612
000108  6835              LDR      r5,[r6,#0]            ;612
00010a  2214              MOVS     r2,#0x14              ;616
00010c  f1040108          ADD      r1,r4,#8              ;616
000110  4630              MOV      r0,r6                 ;616
000112  f7fffffe          BL       __aeabi_memcpy
000116  8ba0              LDRH     r0,[r4,#0x1c]         ;617
000118  f7fffffe          BL       lwip_htons
00011c  8070              STRH     r0,[r6,#2]            ;617
00011e  2000              MOVS     r0,#0                 ;618
000120  80f0              STRH     r0,[r6,#6]            ;618
000122  8170              STRH     r0,[r6,#0xa]          ;619
000124  f8d48004          LDR      r8,[r4,#4]            ;627
000128  f06f0913          MVN      r9,#0x13              ;634
00012c  e009              B        |L2.322|
                  |L2.302|
00012e  686e              LDR      r6,[r5,#4]            ;631
000130  4649              MOV      r1,r9                 ;634
000132  4628              MOV      r0,r5                 ;634
000134  f7fffffe          BL       pbuf_header
000138  4629              MOV      r1,r5                 ;635
00013a  4640              MOV      r0,r8                 ;635
00013c  f7fffffe          BL       pbuf_cat
000140  6835              LDR      r5,[r6,#0]            ;636
                  |L2.322|
000142  2d00              CMP      r5,#0                 ;630
000144  d1f3              BNE      |L2.302|
000146  6879              LDR      r1,[r7,#4]            ;640  ; reassdatagrams
000148  428c              CMP      r4,r1                 ;640
00014a  d105              BNE      |L2.344|
00014c  2100              MOVS     r1,#0                 ;641
00014e  e005              B        |L2.348|
                  |L2.336|
000150  6808              LDR      r0,[r1,#0]            ;644
000152  42a0              CMP      r0,r4                 ;644
000154  d002              BEQ      |L2.348|
000156  4601              MOV      r1,r0                 ;643
                  |L2.344|
000158  2900              CMP      r1,#0                 ;643
00015a  d1f9              BNE      |L2.336|
                  |L2.348|
00015c  4620              MOV      r0,r4                 ;651
00015e  f7fffffe          BL       ip_reass_dequeue_datagram
000162  4640              MOV      r0,r8                 ;654
000164  f7fffffe          BL       pbuf_clen
000168  8839              LDRH     r1,[r7,#0]            ;654  ; ip_reass_pbufcount
00016a  1a08              SUBS     r0,r1,r0              ;654
00016c  8038              STRH     r0,[r7,#0]            ;654
00016e  4640              MOV      r0,r8                 ;659
000170  e7c2              B        |L2.248|
                  |L2.370|
000172  4650              MOV      r0,r10                ;668
000174  f7fffffe          BL       pbuf_free
000178  2000              MOVS     r0,#0                 ;669
00017a  e7bd              B        |L2.248|
;;;671    #endif /* IP_REASSEMBLY */
                          ENDP

                  |L2.380|
                          DCD      ||.data||

                          AREA ||i.ip_frag_alloc_pbuf_custom_ref||, CODE, READONLY, ALIGN=1

                  ip_frag_alloc_pbuf_custom_ref PROC
;;;676    static struct pbuf_custom_ref*
;;;677    ip_frag_alloc_pbuf_custom_ref(void)
000000  2005              MOVS     r0,#5
;;;678    {
;;;679      return (struct pbuf_custom_ref*)memp_malloc(MEMP_FRAG_PBUF);
000002  f7ffbffe          B.W      memp_malloc
;;;680    }
;;;681    
                          ENDP


                          AREA ||i.ip_frag_free_pbuf_custom_ref||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  ip_frag_free_pbuf_custom_ref PROC
;;;683    static void
;;;684    ip_frag_free_pbuf_custom_ref(struct pbuf_custom_ref* p)
000000  b510              PUSH     {r4,lr}
;;;685    {
000002  4604              MOV      r4,r0
;;;686      LWIP_ASSERT("p != NULL", p != NULL);
000004  2c00              CMP      r4,#0
000006  d106              BNE      |L4.22|
000008  a306              ADR      r3,|L4.36|
00000a  f24022ae          MOV      r2,#0x2ae
00000e  a114              ADR      r1,|L4.96|
000010  a016              ADR      r0,|L4.108|
000012  f7fffffe          BL       __2printf
                  |L4.22|
;;;687      memp_free(MEMP_FRAG_PBUF, p);
000016  4621              MOV      r1,r4
000018  e8bd4010          POP      {r4,lr}
00001c  2005              MOVS     r0,#5
00001e  f7ffbffe          B.W      memp_free
;;;688    }
;;;689    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
000024  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip"
000028  6964646c
00002c  65776172
000030  65735c54
000034  68697264
000038  5f506172
00003c  74795c4c
000040  7749505c
000044  7372635c
000048  636f7265
00004c  5c697076
000050  345c6970
000054  345f6672          DCB      "4_frag.c",0
000058  61672e63
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0
                  |L4.96|
000060  7020213d          DCB      "p != NULL",0
000064  204e554c
000068  4c00    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L4.108|
00006c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000070  7274696f
000074  6e202225
000078  73222066
00007c  61696c65
000080  64206174
000084  206c696e
000088  65202564
00008c  20696e20
000090  25730a00

                          AREA ||i.ip_reass_chain_frag_into_datagram_and_validate||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  ip_reass_chain_frag_into_datagram_and_validate PROC
;;;343    static int
;;;344    ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p, int is_last)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;345    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
;;;346      struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
00000a  2500              MOVS     r5,#0
;;;347      struct pbuf *q;
;;;348      u16_t offset, len;
;;;349      struct ip_hdr *fraghdr;
;;;350      int valid = 1;
00000c  2601              MOVS     r6,#1
;;;351    
;;;352      /* Extract length and fragment offset from current fragment */
;;;353      fraghdr = (struct ip_hdr*)new_p->payload;
00000e  f8d84004          LDR      r4,[r8,#4]
;;;354      len = lwip_ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
000012  8860              LDRH     r0,[r4,#2]
000014  f7fffffe          BL       lwip_htons
000018  7821              LDRB     r1,[r4,#0]
00001a  f001010f          AND      r1,r1,#0xf
00001e  4249              RSBS     r1,r1,#0
000020  eb000a81          ADD      r10,r0,r1,LSL #2
;;;355      offset = (lwip_ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
000024  88e0              LDRH     r0,[r4,#6]
000026  f7fffffe          BL       lwip_htons
00002a  04c0              LSLS     r0,r0,#19
00002c  0c01              LSRS     r1,r0,#16
;;;356    
;;;357      /* overwrite the fragment's ip header from the pbuf with our helper struct,
;;;358       * and setup the embedded helper structure. */
;;;359      /* make sure the struct ip_reass_helper fits into the IP header */
;;;360      LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
;;;361                  sizeof(struct ip_reass_helper) <= IP_HLEN);
;;;362      iprh = (struct ip_reass_helper*)new_p->payload;
00002e  f8d84004          LDR      r4,[r8,#4]
;;;363      iprh->next_pbuf = NULL;
000032  2000              MOVS     r0,#0
000034  6020              STR      r0,[r4,#0]
;;;364      iprh->start = offset;
000036  80a1              STRH     r1,[r4,#4]
;;;365      iprh->end = offset + len;
000038  eb01000a          ADD      r0,r1,r10
00003c  fa1ffc80          UXTH     r12,r0
000040  f8a4c006          STRH     r12,[r4,#6]
;;;366    
;;;367      /* Iterate through until we either get to the end of the list (append),
;;;368       * or we find one with a larger offset (insert). */
;;;369      for (q = ipr->p; q != NULL;) {
000044  687b              LDR      r3,[r7,#4]
000046  e023              B        |L5.144|
                  |L5.72|
;;;370        iprh_tmp = (struct ip_reass_helper*)q->payload;
000048  6858              LDR      r0,[r3,#4]
;;;371        if (iprh->start < iprh_tmp->start) {
00004a  8882              LDRH     r2,[r0,#4]
00004c  4291              CMP      r1,r2
00004e  d214              BCS      |L5.122|
;;;372          /* the new pbuf should be inserted before this */
;;;373          iprh->next_pbuf = q;
000050  6023              STR      r3,[r4,#0]
;;;374          if (iprh_prev != NULL) {
000052  b165              CBZ      r5,|L5.110|
;;;375            /* not the fragment with the lowest offset */
;;;376    #if IP_REASS_CHECK_OVERLAP
;;;377            if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
000054  88ea              LDRH     r2,[r5,#6]
000056  4291              CMP      r1,r2
000058  d37e              BCC      |L5.344|
00005a  8880              LDRH     r0,[r0,#4]
00005c  4584              CMP      r12,r0
00005e  d87b              BHI      |L5.344|
;;;378              /* fragment overlaps with previous or following, throw away */
;;;379              goto freepbuf;
;;;380            }
;;;381    #endif /* IP_REASS_CHECK_OVERLAP */
;;;382            iprh_prev->next_pbuf = new_p;
000060  f8c58000          STR      r8,[r5,#0]
;;;383            if (iprh_prev->end != iprh->start) {
000064  88a0              LDRH     r0,[r4,#4]
000066  4282              CMP      r2,r0
000068  d014              BEQ      |L5.148|
;;;384              /* There is a fragment missing between the current
;;;385               * and the previous fragment */
;;;386              valid = 0;
00006a  2600              MOVS     r6,#0
00006c  e012              B        |L5.148|
                  |L5.110|
;;;387            }
;;;388          } else {
;;;389    #if IP_REASS_CHECK_OVERLAP
;;;390            if (iprh->end > iprh_tmp->start) {
00006e  8880              LDRH     r0,[r0,#4]
000070  4584              CMP      r12,r0
000072  d876              BHI      |L5.354|
;;;391              /* fragment overlaps with following, throw away */
;;;392              goto freepbuf;
;;;393            }
;;;394    #endif /* IP_REASS_CHECK_OVERLAP */
;;;395            /* fragment with the lowest offset */
;;;396            ipr->p = new_p;
000074  f8c78004          STR      r8,[r7,#4]
000078  e00c              B        |L5.148|
                  |L5.122|
;;;397          }
;;;398          break;
;;;399        } else if (iprh->start == iprh_tmp->start) {
00007a  d072              BEQ      |L5.354|
;;;400          /* received the same datagram twice: no need to keep the datagram */
;;;401          goto freepbuf;
;;;402    #if IP_REASS_CHECK_OVERLAP
;;;403        } else if (iprh->start < iprh_tmp->end) {
00007c  88c3              LDRH     r3,[r0,#6]
00007e  4299              CMP      r1,r3
000080  d36f              BCC      |L5.354|
;;;404          /* overlap: no need to keep the new datagram */
;;;405          goto freepbuf;
;;;406    #endif /* IP_REASS_CHECK_OVERLAP */
;;;407        } else {
;;;408          /* Check if the fragments received so far have no holes. */
;;;409          if (iprh_prev != NULL) {
000082  b11d              CBZ      r5,|L5.140|
;;;410            if (iprh_prev->end != iprh_tmp->start) {
000084  88eb              LDRH     r3,[r5,#6]
000086  4293              CMP      r3,r2
000088  d000              BEQ      |L5.140|
;;;411              /* There is a fragment missing between the current
;;;412               * and the previous fragment */
;;;413              valid = 0;
00008a  2600              MOVS     r6,#0
                  |L5.140|
;;;414            }
;;;415          }
;;;416        }
;;;417        q = iprh_tmp->next_pbuf;
00008c  6803              LDR      r3,[r0,#0]
;;;418        iprh_prev = iprh_tmp;
00008e  4605              MOV      r5,r0
                  |L5.144|
000090  2b00              CMP      r3,#0                 ;369
000092  d1d9              BNE      |L5.72|
                  |L5.148|
;;;419      }
;;;420    
;;;421      /* If q is NULL, then we made it to the end of the list. Determine what to do now */
;;;422      if (q == NULL) {
000094  2b00              CMP      r3,#0
000096  d120              BNE      |L5.218|
;;;423        if (iprh_prev != NULL) {
000098  2d00              CMP      r5,#0
00009a  d012              BEQ      |L5.194|
;;;424          /* this is (for now), the fragment with the highest offset:
;;;425           * chain it to the last fragment */
;;;426    #if IP_REASS_CHECK_OVERLAP
;;;427          LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
00009c  88e8              LDRH     r0,[r5,#6]
00009e  88a1              LDRH     r1,[r4,#4]
0000a0  4288              CMP      r0,r1
0000a2  d906              BLS      |L5.178|
0000a4  a335              ADR      r3,|L5.380|
0000a6  f24012ab          MOV      r2,#0x1ab
0000aa  a143              ADR      r1,|L5.440|
0000ac  a04a              ADR      r0,|L5.472|
0000ae  f7fffffe          BL       __2printf
                  |L5.178|
;;;428    #endif /* IP_REASS_CHECK_OVERLAP */
;;;429          iprh_prev->next_pbuf = new_p;
0000b2  f8c58000          STR      r8,[r5,#0]
;;;430          if (iprh_prev->end != iprh->start) {
0000b6  88e8              LDRH     r0,[r5,#6]
0000b8  88a1              LDRH     r1,[r4,#4]
0000ba  4288              CMP      r0,r1
0000bc  d00d              BEQ      |L5.218|
;;;431            valid = 0;
0000be  2600              MOVS     r6,#0
0000c0  e00b              B        |L5.218|
                  |L5.194|
;;;432          }
;;;433        } else {
;;;434    #if IP_REASS_CHECK_OVERLAP
;;;435          LWIP_ASSERT("no previous fragment, this must be the first fragment!",
0000c2  6878              LDR      r0,[r7,#4]
0000c4  2800              CMP      r0,#0
0000c6  d006              BEQ      |L5.214|
0000c8  a32c              ADR      r3,|L5.380|
0000ca  f24012b3          MOV      r2,#0x1b3
0000ce  a14c              ADR      r1,|L5.512|
0000d0  a041              ADR      r0,|L5.472|
0000d2  f7fffffe          BL       __2printf
                  |L5.214|
;;;436            ipr->p == NULL);
;;;437    #endif /* IP_REASS_CHECK_OVERLAP */
;;;438          /* this is the first fragment we ever received for this ip datagram */
;;;439          ipr->p = new_p;
0000d6  f8c78004          STR      r8,[r7,#4]
                  |L5.218|
;;;440        }
;;;441      }
;;;442    
;;;443      /* At this point, the validation part begins: */
;;;444      /* If we already received the last fragment */
;;;445      if (is_last || ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0)) {
0000da  f1b90f00          CMP      r9,#0
0000de  d102              BNE      |L5.230|
0000e0  7fb8              LDRB     r0,[r7,#0x1e]
0000e2  07c0              LSLS     r0,r0,#31
0000e4  d03b              BEQ      |L5.350|
                  |L5.230|
;;;446        /* and had no holes so far */
;;;447        if (valid) {
0000e6  2e00              CMP      r6,#0
0000e8  d032              BEQ      |L5.336|
;;;448          /* then check if the rest of the fragments is here */
;;;449          /* Check if the queue starts with the first datagram */
;;;450          if ((ipr->p == NULL) || (((struct ip_reass_helper*)ipr->p->payload)->start != 0)) {
0000ea  687a              LDR      r2,[r7,#4]
0000ec  b112              CBZ      r2,|L5.244|
0000ee  6850              LDR      r0,[r2,#4]
0000f0  8880              LDRH     r0,[r0,#4]
0000f2  b108              CBZ      r0,|L5.248|
                  |L5.244|
;;;451            valid = 0;
0000f4  2600              MOVS     r6,#0
0000f6  e02b              B        |L5.336|
                  |L5.248|
;;;452          } else {
;;;453            /* and check that there are no holes after this datagram */
;;;454            iprh_prev = iprh;
;;;455            q = iprh->next_pbuf;
0000f8  4621              MOV      r1,r4
0000fa  6820              LDR      r0,[r4,#0]
;;;456            while (q != NULL) {
0000fc  e008              B        |L5.272|
                  |L5.254|
;;;457              iprh = (struct ip_reass_helper*)q->payload;
0000fe  6844              LDR      r4,[r0,#4]
;;;458              if (iprh_prev->end != iprh->start) {
000100  88c8              LDRH     r0,[r1,#6]
000102  88a1              LDRH     r1,[r4,#4]
000104  4288              CMP      r0,r1
000106  d001              BEQ      |L5.268|
;;;459                valid = 0;
000108  2600              MOVS     r6,#0
;;;460                break;
00010a  e003              B        |L5.276|
                  |L5.268|
;;;461              }
;;;462              iprh_prev = iprh;
;;;463              q = iprh->next_pbuf;
00010c  6820              LDR      r0,[r4,#0]
00010e  4621              MOV      r1,r4
                  |L5.272|
000110  2800              CMP      r0,#0                 ;456
000112  d1f4              BNE      |L5.254|
                  |L5.276|
;;;464            }
;;;465            /* if still valid, all fragments are received
;;;466             * (because to the MF==0 already arrived */
;;;467            if (valid) {
000114  2e00              CMP      r6,#0
000116  d01b              BEQ      |L5.336|
;;;468              LWIP_ASSERT("sanity check", ipr->p != NULL);
000118  b932              CBNZ     r2,|L5.296|
00011a  a318              ADR      r3,|L5.380|
00011c  f44f72ea          MOV      r2,#0x1d4
000120  a145              ADR      r1,|L5.568|
000122  a02d              ADR      r0,|L5.472|
000124  f7fffffe          BL       __2printf
                  |L5.296|
;;;469              LWIP_ASSERT("sanity check",
000128  6878              LDR      r0,[r7,#4]
00012a  6840              LDR      r0,[r0,#4]
00012c  42a0              CMP      r0,r4
00012e  d106              BNE      |L5.318|
000130  a312              ADR      r3,|L5.380|
000132  f24012d5          MOV      r2,#0x1d5
000136  a140              ADR      r1,|L5.568|
000138  a027              ADR      r0,|L5.472|
00013a  f7fffffe          BL       __2printf
                  |L5.318|
;;;470                ((struct ip_reass_helper*)ipr->p->payload) != iprh);
;;;471              LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
00013e  6820              LDR      r0,[r4,#0]
000140  b130              CBZ      r0,|L5.336|
000142  a30e              ADR      r3,|L5.380|
000144  f24012d7          MOV      r2,#0x1d7
000148  a13f              ADR      r1,|L5.584|
00014a  a023              ADR      r0,|L5.472|
00014c  f7fffffe          BL       __2printf
                  |L5.336|
;;;472                iprh->next_pbuf == NULL);
;;;473            }
;;;474          }
;;;475        }
;;;476        /* If valid is 0 here, there are some fragments missing in the middle
;;;477         * (since MF == 0 has already arrived). Such datagrams simply time out if
;;;478         * no more fragments are received... */
;;;479        return valid ? IP_REASS_VALIDATE_TELEGRAM_FINISHED : IP_REASS_VALIDATE_PBUF_QUEUED;
000150  b11e              CBZ      r6,|L5.346|
000152  2001              MOVS     r0,#1
                  |L5.340|
;;;480      }
;;;481      /* If we come here, not all fragments were received, yet! */
;;;482      return IP_REASS_VALIDATE_PBUF_QUEUED; /* not yet valid! */
;;;483    #if IP_REASS_CHECK_OVERLAP
;;;484    freepbuf:
;;;485      ip_reass_pbufcount -= pbuf_clen(new_p);
;;;486      pbuf_free(new_p);
;;;487      return IP_REASS_VALIDATE_PBUF_DROPPED;
;;;488    #endif /* IP_REASS_CHECK_OVERLAP */
;;;489    }
000154  e8bd87f0          POP      {r4-r10,pc}
                  |L5.344|
000158  e003              B        |L5.354|
                  |L5.346|
00015a  2000              MOVS     r0,#0                 ;479
00015c  e7fa              B        |L5.340|
                  |L5.350|
00015e  2000              MOVS     r0,#0                 ;482
000160  e7f8              B        |L5.340|
                  |L5.354|
000162  4640              MOV      r0,r8                 ;485
000164  f7fffffe          BL       pbuf_clen
000168  4940              LDR      r1,|L5.620|
00016a  880a              LDRH     r2,[r1,#0]            ;485  ; ip_reass_pbufcount
00016c  1a10              SUBS     r0,r2,r0              ;485
00016e  8008              STRH     r0,[r1,#0]            ;485
000170  4640              MOV      r0,r8                 ;486
000172  f7fffffe          BL       pbuf_free
000176  f04f30ff          MOV      r0,#0xffffffff        ;487
00017a  e7eb              B        |L5.340|
;;;490    
                          ENDP

                  |L5.380|
00017c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip"
000180  6964646c
000184  65776172
000188  65735c54
00018c  68697264
000190  5f506172
000194  74795c4c
000198  7749505c
00019c  7372635c
0001a0  636f7265
0001a4  5c697076
0001a8  345c6970
0001ac  345f6672          DCB      "4_frag.c",0
0001b0  61672e63
0001b4  00      
0001b5  00                DCB      0
0001b6  00                DCB      0
0001b7  00                DCB      0
                  |L5.440|
0001b8  63686563          DCB      "check fragments don't overlap",0
0001bc  6b206672
0001c0  61676d65
0001c4  6e747320
0001c8  646f6e27
0001cc  74206f76
0001d0  65726c61
0001d4  7000    
0001d6  00                DCB      0
0001d7  00                DCB      0
                  |L5.472|
0001d8  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0001dc  7274696f
0001e0  6e202225
0001e4  73222066
0001e8  61696c65
0001ec  64206174
0001f0  206c696e
0001f4  65202564
0001f8  20696e20
0001fc  25730a00
                  |L5.512|
000200  6e6f2070          DCB      "no previous fragment, this must be the first fragment!",0
000204  72657669
000208  6f757320
00020c  66726167
000210  6d656e74
000214  2c207468
000218  6973206d
00021c  75737420
000220  62652074
000224  68652066
000228  69727374
00022c  20667261
000230  676d656e
000234  742100  
000237  00                DCB      0
                  |L5.568|
000238  73616e69          DCB      "sanity check",0
00023c  74792063
000240  6865636b
000244  00      
000245  00                DCB      0
000246  00                DCB      0
000247  00                DCB      0
                  |L5.584|
000248  76616c69          DCB      "validate_datagram:next_pbuf!=NULL",0
00024c  64617465
000250  5f646174
000254  61677261
000258  6d3a6e65
00025c  78745f70
000260  62756621
000264  3d4e554c
000268  4c00    
00026a  00                DCB      0
00026b  00                DCB      0
                  |L5.620|
                          DCD      ||.data||

                          AREA ||i.ip_reass_dequeue_datagram||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  ip_reass_dequeue_datagram PROC
;;;316    static void
;;;317    ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  b570              PUSH     {r4-r6,lr}
;;;318    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;319      /* dequeue the reass struct  */
;;;320      if (reassdatagrams == ipr) {
000006  480c              LDR      r0,|L6.56|
000008  6841              LDR      r1,[r0,#4]  ; reassdatagrams
00000a  42a1              CMP      r1,r4
00000c  d102              BNE      |L6.20|
;;;321        /* it was the first in the list */
;;;322        reassdatagrams = ipr->next;
00000e  6821              LDR      r1,[r4,#0]
000010  6041              STR      r1,[r0,#4]  ; reassdatagrams
000012  e00a              B        |L6.42|
                  |L6.20|
;;;323      } else {
;;;324        /* it wasn't the first, so it must have a valid 'prev' */
;;;325        LWIP_ASSERT("sanity check linked list", prev != NULL);
000014  2d00              CMP      r5,#0
000016  d106              BNE      |L6.38|
000018  a308              ADR      r3,|L6.60|
00001a  f2401245          MOV      r2,#0x145
00001e  a116              ADR      r1,|L6.120|
000020  a01c              ADR      r0,|L6.148|
000022  f7fffffe          BL       __2printf
                  |L6.38|
;;;326        prev->next = ipr->next;
000026  6820              LDR      r0,[r4,#0]
000028  6028              STR      r0,[r5,#0]
                  |L6.42|
;;;327      }
;;;328    
;;;329      /* now we can free the ip_reassdata struct */
;;;330      memp_free(MEMP_REASSDATA, ipr);
00002a  4621              MOV      r1,r4
00002c  e8bd4070          POP      {r4-r6,lr}
000030  2004              MOVS     r0,#4
000032  f7ffbffe          B.W      memp_free
;;;331    }
;;;332    
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      ||.data||
                  |L6.60|
00003c  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip"
000040  6964646c
000044  65776172
000048  65735c54
00004c  68697264
000050  5f506172
000054  74795c4c
000058  7749505c
00005c  7372635c
000060  636f7265
000064  5c697076
000068  345c6970
00006c  345f6672          DCB      "4_frag.c",0
000070  61672e63
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L6.120|
000078  73616e69          DCB      "sanity check linked list",0
00007c  74792063
000080  6865636b
000084  206c696e
000088  6b656420
00008c  6c697374
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
                  |L6.148|
000094  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000098  7274696f
00009c  6e202225
0000a0  73222066
0000a4  61696c65
0000a8  64206174
0000ac  206c696e
0000b0  65202564
0000b4  20696e20
0000b8  25730a00

                          AREA ||i.ip_reass_enqueue_new_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_enqueue_new_datagram PROC
;;;277    static struct ip_reassdata*
;;;278    ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
000000  b570              PUSH     {r4-r6,lr}
;;;279    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;280      struct ip_reassdata* ipr;
;;;281    #if ! IP_REASS_FREE_OLDEST
;;;282      LWIP_UNUSED_ARG(clen);
;;;283    #endif
;;;284    
;;;285      /* No matching previous fragment found, allocate a new reassdata struct */
;;;286      ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       memp_malloc
00000c  4604              MOV      r4,r0
;;;287      if (ipr == NULL) {
00000e  b954              CBNZ     r4,|L7.38|
;;;288    #if IP_REASS_FREE_OLDEST
;;;289        if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
000010  4629              MOV      r1,r5
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       ip_reass_remove_oldest_datagram
000018  42a8              CMP      r0,r5
00001a  db03              BLT      |L7.36|
;;;290          ipr = (struct ip_reassdata *)memp_malloc(MEMP_REASSDATA);
00001c  2004              MOVS     r0,#4
00001e  f7fffffe          BL       memp_malloc
000022  4604              MOV      r4,r0
                  |L7.36|
;;;291        }
;;;292        if (ipr == NULL)
000024  b18c              CBZ      r4,|L7.74|
                  |L7.38|
;;;293    #endif /* IP_REASS_FREE_OLDEST */
;;;294        {
;;;295          IPFRAG_STATS_INC(ip_frag.memerr);
;;;296          LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
;;;297          return NULL;
;;;298        }
;;;299      }
;;;300      memset(ipr, 0, sizeof(struct ip_reassdata));
000026  2120              MOVS     r1,#0x20
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       __aeabi_memclr4
;;;301      ipr->timer = IP_REASS_MAXAGE;
00002e  2003              MOVS     r0,#3
000030  77e0              STRB     r0,[r4,#0x1f]
;;;302    
;;;303      /* enqueue the new structure to the front of the list */
;;;304      ipr->next = reassdatagrams;
000032  4807              LDR      r0,|L7.80|
000034  6841              LDR      r1,[r0,#4]  ; reassdatagrams
000036  6021              STR      r1,[r4,#0]
;;;305      reassdatagrams = ipr;
000038  6044              STR      r4,[r0,#4]  ; reassdatagrams
;;;306      /* copy the ip header for later tests and input */
;;;307      /* @todo: no ip options supported? */
;;;308      SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
00003a  2214              MOVS     r2,#0x14
00003c  4631              MOV      r1,r6
00003e  f1040008          ADD      r0,r4,#8
000042  f7fffffe          BL       __aeabi_memcpy
;;;309      return ipr;
000046  4620              MOV      r0,r4
;;;310    }
000048  bd70              POP      {r4-r6,pc}
                  |L7.74|
00004a  2000              MOVS     r0,#0                 ;297
00004c  bd70              POP      {r4-r6,pc}
;;;311    
                          ENDP

00004e  0000              DCW      0x0000
                  |L7.80|
                          DCD      ||.data||

                          AREA ||i.ip_reass_free_complete_datagram||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  ip_reass_free_complete_datagram PROC
;;;163    static int
;;;164    ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;165    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;166      u16_t pbufs_freed = 0;
000008  2500              MOVS     r5,#0
;;;167      u16_t clen;
;;;168      struct pbuf *p;
;;;169      struct ip_reass_helper *iprh;
;;;170    
;;;171      LWIP_ASSERT("prev != ipr", prev != ipr);
00000a  42b7              CMP      r7,r6
00000c  d105              BNE      |L8.26|
00000e  a331              ADR      r3,|L8.212|
000010  22ab              MOVS     r2,#0xab
000012  a13f              ADR      r1,|L8.272|
000014  a041              ADR      r0,|L8.284|
000016  f7fffffe          BL       __2printf
                  |L8.26|
;;;172      if (prev != NULL) {
00001a  2f00              CMP      r7,#0
00001c  d008              BEQ      |L8.48|
;;;173        LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
00001e  6838              LDR      r0,[r7,#0]
000020  42b0              CMP      r0,r6
000022  d005              BEQ      |L8.48|
000024  a32b              ADR      r3,|L8.212|
000026  22ad              MOVS     r2,#0xad
000028  a146              ADR      r1,|L8.324|
00002a  a03c              ADR      r0,|L8.284|
00002c  f7fffffe          BL       __2printf
                  |L8.48|
;;;174      }
;;;175    
;;;176      MIB2_STATS_INC(mib2.ipreasmfails);
;;;177    #if LWIP_ICMP
;;;178      iprh = (struct ip_reass_helper *)ipr->p->payload;
000030  f8d68004          LDR      r8,[r6,#4]
000034  f8d80004          LDR      r0,[r8,#4]
;;;179      if (iprh->start == 0) {
;;;180        /* The first fragment was received, send ICMP time exceeded. */
;;;181        /* First, de-queue the first pbuf from r->p. */
;;;182        p = ipr->p;
;;;183        ipr->p = iprh->next_pbuf;
;;;184        /* Then, copy the original header into it. */
;;;185        SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
;;;186        icmp_time_exceeded(p, ICMP_TE_FRAG);
;;;187        clen = pbuf_clen(p);
;;;188        LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
000038  f44f3980          MOV      r9,#0x10000
00003c  8881              LDRH     r1,[r0,#4]            ;179
00003e  2900              CMP      r1,#0                 ;179
000040  d11c              BNE      |L8.124|
000042  6800              LDR      r0,[r0,#0]            ;183
000044  6070              STR      r0,[r6,#4]            ;183
000046  2214              MOVS     r2,#0x14              ;185
000048  f1060108          ADD      r1,r6,#8              ;185
00004c  f8d80004          LDR      r0,[r8,#4]            ;185
000050  f7fffffe          BL       __aeabi_memcpy
000054  2101              MOVS     r1,#1                 ;186
000056  4640              MOV      r0,r8                 ;186
000058  f7fffffe          BL       icmp_time_exceeded
00005c  4640              MOV      r0,r8                 ;187
00005e  f7fffffe          BL       pbuf_clen
000062  4604              MOV      r4,r0                 ;187
000064  454c              CMP      r4,r9
000066  d305              BCC      |L8.116|
000068  a31a              ADR      r3,|L8.212|
00006a  22bc              MOVS     r2,#0xbc
00006c  a13a              ADR      r1,|L8.344|
00006e  a02b              ADR      r0,|L8.284|
000070  f7fffffe          BL       __2printf
                  |L8.116|
;;;189        pbufs_freed += clen;
000074  b2a5              UXTH     r5,r4
;;;190        pbuf_free(p);
000076  4640              MOV      r0,r8
000078  f7fffffe          BL       pbuf_free
                  |L8.124|
;;;191      }
;;;192    #endif /* LWIP_ICMP */
;;;193    
;;;194      /* First, free all received pbufs.  The individual pbufs need to be released
;;;195         separately as they have not yet been chained */
;;;196      p = ipr->p;
00007c  6874              LDR      r4,[r6,#4]
;;;197      while (p != NULL) {
00007e  e012              B        |L8.166|
                  |L8.128|
;;;198        struct pbuf *pcur;
;;;199        iprh = (struct ip_reass_helper *)p->payload;
000080  6860              LDR      r0,[r4,#4]
;;;200        pcur = p;
000082  46a0              MOV      r8,r4
;;;201        /* get the next pointer before freeing */
;;;202        p = iprh->next_pbuf;
000084  6804              LDR      r4,[r0,#0]
;;;203        clen = pbuf_clen(pcur);
000086  4640              MOV      r0,r8
000088  f7fffffe          BL       pbuf_clen
;;;204        LWIP_ASSERT("pbufs_freed + clen <= 0xffff", pbufs_freed + clen <= 0xffff);
00008c  4405              ADD      r5,r5,r0
00008e  454d              CMP      r5,r9
000090  d305              BCC      |L8.158|
000092  a310              ADR      r3,|L8.212|
000094  22cc              MOVS     r2,#0xcc
000096  a130              ADR      r1,|L8.344|
000098  a020              ADR      r0,|L8.284|
00009a  f7fffffe          BL       __2printf
                  |L8.158|
;;;205        pbufs_freed += clen;
00009e  b2ad              UXTH     r5,r5
;;;206        pbuf_free(pcur);
0000a0  4640              MOV      r0,r8
0000a2  f7fffffe          BL       pbuf_free
                  |L8.166|
0000a6  2c00              CMP      r4,#0                 ;197
0000a8  d1ea              BNE      |L8.128|
;;;207      }
;;;208      /* Then, unchain the struct ip_reassdata from the list and free it. */
;;;209      ip_reass_dequeue_datagram(ipr, prev);
0000aa  4639              MOV      r1,r7
0000ac  4630              MOV      r0,r6
0000ae  f7fffffe          BL       ip_reass_dequeue_datagram
;;;210      LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
0000b2  4c31              LDR      r4,|L8.376|
0000b4  8820              LDRH     r0,[r4,#0]  ; ip_reass_pbufcount
0000b6  42a8              CMP      r0,r5
0000b8  d205              BCS      |L8.198|
0000ba  a306              ADR      r3,|L8.212|
0000bc  22d2              MOVS     r2,#0xd2
0000be  a12f              ADR      r1,|L8.380|
0000c0  a016              ADR      r0,|L8.284|
0000c2  f7fffffe          BL       __2printf
                  |L8.198|
;;;211      ip_reass_pbufcount -= pbufs_freed;
0000c6  8820              LDRH     r0,[r4,#0]  ; ip_reass_pbufcount
0000c8  1b40              SUBS     r0,r0,r5
0000ca  8020              STRH     r0,[r4,#0]
;;;212    
;;;213      return pbufs_freed;
0000cc  4628              MOV      r0,r5
;;;214    }
0000ce  e8bd87f0          POP      {r4-r10,pc}
;;;215    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L8.212|
0000d4  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip"
0000d8  6964646c
0000dc  65776172
0000e0  65735c54
0000e4  68697264
0000e8  5f506172
0000ec  74795c4c
0000f0  7749505c
0000f4  7372635c
0000f8  636f7265
0000fc  5c697076
000100  345c6970
000104  345f6672          DCB      "4_frag.c",0
000108  61672e63
00010c  00      
00010d  00                DCB      0
00010e  00                DCB      0
00010f  00                DCB      0
                  |L8.272|
000110  70726576          DCB      "prev != ipr",0
000114  20213d20
000118  69707200
                  |L8.284|
00011c  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000120  7274696f
000124  6e202225
000128  73222066
00012c  61696c65
000130  64206174
000134  206c696e
000138  65202564
00013c  20696e20
000140  25730a00
                  |L8.324|
000144  70726576          DCB      "prev->next == ipr",0
000148  2d3e6e65
00014c  7874203d
000150  3d206970
000154  7200    
000156  00                DCB      0
000157  00                DCB      0
                  |L8.344|
000158  70627566          DCB      "pbufs_freed + clen <= 0xffff",0
00015c  735f6672
000160  65656420
000164  2b20636c
000168  656e203c
00016c  3d203078
000170  66666666
000174  00      
000175  00                DCB      0
000176  00                DCB      0
000177  00                DCB      0
                  |L8.376|
                          DCD      ||.data||
                  |L8.380|
00017c  69705f72          DCB      "ip_reass_pbufcount >= clen",0
000180  65617373
000184  5f706275
000188  66636f75
00018c  6e74203e
000190  3d20636c
000194  656e00  
000197  00                DCB      0

                          AREA ||i.ip_reass_remove_oldest_datagram||, CODE, READONLY, ALIGN=2

                  ip_reass_remove_oldest_datagram PROC
;;;226    static int
;;;227    ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;228    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;229      /* @todo Can't we simply remove the last datagram in the
;;;230       *       linked list behind reassdatagrams?
;;;231       */
;;;232      struct ip_reassdata *r, *oldest, *prev, *oldest_prev;
;;;233      int pbufs_freed = 0, pbufs_freed_current;
000008  2600              MOVS     r6,#0
;;;234      int other_datagrams;
;;;235    
;;;236      /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
;;;237       * but don't free the datagram that 'fraghdr' belongs to! */
;;;238      do {
;;;239        oldest = NULL;
;;;240        prev = NULL;
;;;241        oldest_prev = NULL;
;;;242        other_datagrams = 0;
;;;243        r = reassdatagrams;
00000a  f8df8078          LDR      r8,|L9.132|
                  |L9.14|
00000e  2000              MOVS     r0,#0                 ;239
000010  2100              MOVS     r1,#0                 ;240
000012  2300              MOVS     r3,#0                 ;241
000014  2400              MOVS     r4,#0                 ;242
000016  f8d82004          LDR      r2,[r8,#4]  ; reassdatagrams
;;;244        while (r != NULL) {
00001a  e022              B        |L9.98|
                  |L9.28|
;;;245          if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
00001c  f8d2c014          LDR      r12,[r2,#0x14]
000020  f8d5900c          LDR      r9,[r5,#0xc]
000024  45cc              CMP      r12,r9
000026  d10b              BNE      |L9.64|
000028  f8d2c018          LDR      r12,[r2,#0x18]
00002c  f8d59010          LDR      r9,[r5,#0x10]
000030  45cc              CMP      r12,r9
000032  d105              BNE      |L9.64|
000034  f8b2c00c          LDRH     r12,[r2,#0xc]
000038  f8b59004          LDRH     r9,[r5,#4]
00003c  45cc              CMP      r12,r9
00003e  d009              BEQ      |L9.84|
                  |L9.64|
;;;246            /* Not the same datagram as fraghdr */
;;;247            other_datagrams++;
000040  1c64              ADDS     r4,r4,#1
;;;248            if (oldest == NULL) {
000042  b1e0              CBZ      r0,|L9.126|
;;;249              oldest = r;
;;;250              oldest_prev = prev;
;;;251            } else if (r->timer <= oldest->timer) {
000044  f892c01f          LDRB     r12,[r2,#0x1f]
000048  f890901f          LDRB     r9,[r0,#0x1f]
00004c  45cc              CMP      r12,r9
00004e  d801              BHI      |L9.84|
;;;252              /* older than the previous oldest */
;;;253              oldest = r;
000050  4610              MOV      r0,r2
;;;254              oldest_prev = prev;
000052  460b              MOV      r3,r1
                  |L9.84|
;;;255            }
;;;256          }
;;;257          if (r->next != NULL) {
000054  f8d2c000          LDR      r12,[r2,#0]
000058  f1bc0f00          CMP      r12,#0
00005c  d000              BEQ      |L9.96|
;;;258            prev = r;
00005e  4611              MOV      r1,r2
                  |L9.96|
;;;259          }
;;;260          r = r->next;
000060  4662              MOV      r2,r12
                  |L9.98|
000062  2a00              CMP      r2,#0                 ;244
000064  d1da              BNE      |L9.28|
;;;261        }
;;;262        if (oldest != NULL) {
000066  b118              CBZ      r0,|L9.112|
;;;263          pbufs_freed_current = ip_reass_free_complete_datagram(oldest, oldest_prev);
000068  4619              MOV      r1,r3
00006a  f7fffffe          BL       ip_reass_free_complete_datagram
;;;264          pbufs_freed += pbufs_freed_current;
00006e  4406              ADD      r6,r6,r0
                  |L9.112|
;;;265        }
;;;266      } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
000070  42be              CMP      r6,r7
000072  da01              BGE      |L9.120|
000074  2c01              CMP      r4,#1
000076  dcca              BGT      |L9.14|
                  |L9.120|
;;;267      return pbufs_freed;
000078  4630              MOV      r0,r6
;;;268    }
00007a  e8bd87f0          POP      {r4-r10,pc}
                  |L9.126|
00007e  4610              MOV      r0,r2                 ;249
000080  460b              MOV      r3,r1                 ;250
000082  e7e7              B        |L9.84|
;;;269    #endif /* IP_REASS_FREE_OLDEST */
                          ENDP

                  |L9.132|
                          DCD      ||.data||

                          AREA ||i.ip_reass_tmr||, CODE, READONLY, ALIGN=2

                  ip_reass_tmr PROC
;;;127    void
;;;128    ip_reass_tmr(void)
000000  b570              PUSH     {r4-r6,lr}
;;;129    {
;;;130      struct ip_reassdata *r, *prev = NULL;
000002  2500              MOVS     r5,#0
;;;131    
;;;132      r = reassdatagrams;
000004  4808              LDR      r0,|L10.40|
000006  6844              LDR      r4,[r0,#4]  ; reassdatagrams
000008  e00b              B        |L10.34|
                  |L10.10|
;;;133      while (r != NULL) {
;;;134        /* Decrement the timer. Once it reaches 0,
;;;135         * clean up the incomplete fragment assembly */
;;;136        if (r->timer > 0) {
00000a  7fe0              LDRB     r0,[r4,#0x1f]
00000c  b120              CBZ      r0,|L10.24|
;;;137          r->timer--;
00000e  1e40              SUBS     r0,r0,#1
000010  77e0              STRB     r0,[r4,#0x1f]
;;;138          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
;;;139          prev = r;
000012  4625              MOV      r5,r4
;;;140          r = r->next;
000014  6824              LDR      r4,[r4,#0]
000016  e004              B        |L10.34|
                  |L10.24|
;;;141        } else {
;;;142          /* reassembly timed out */
;;;143          struct ip_reassdata *tmp;
;;;144          LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
;;;145          tmp = r;
000018  4620              MOV      r0,r4
;;;146          /* get the next pointer before freeing */
;;;147          r = r->next;
00001a  6824              LDR      r4,[r4,#0]
;;;148          /* free the helper struct and all enqueued pbufs */
;;;149          ip_reass_free_complete_datagram(tmp, prev);
00001c  4629              MOV      r1,r5
00001e  f7fffffe          BL       ip_reass_free_complete_datagram
                  |L10.34|
000022  2c00              CMP      r4,#0                 ;133
000024  d1f1              BNE      |L10.10|
;;;150         }
;;;151       }
;;;152    }
000026  bd70              POP      {r4-r6,pc}
;;;153    
                          ENDP

                  |L10.40|
                          DCD      ||.data||

                          AREA ||i.ipfrag_free_pbuf_custom||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  ipfrag_free_pbuf_custom PROC
;;;692    static void
;;;693    ipfrag_free_pbuf_custom(struct pbuf *p)
000000  b510              PUSH     {r4,lr}
;;;694    {
000002  4604              MOV      r4,r0
;;;695      struct pbuf_custom_ref *pcr = (struct pbuf_custom_ref*)p;
;;;696      LWIP_ASSERT("pcr != NULL", pcr != NULL);
000004  2c00              CMP      r4,#0
000006  d106              BNE      |L11.22|
000008  a307              ADR      r3,|L11.40|
00000a  f44f722e          MOV      r2,#0x2b8
00000e  a115              ADR      r1,|L11.100|
000010  a017              ADR      r0,|L11.112|
000012  f7fffffe          BL       __2printf
                  |L11.22|
;;;697      LWIP_ASSERT("pcr == p", (void*)pcr == (void*)p);
;;;698      if (pcr->original != NULL) {
000016  6960              LDR      r0,[r4,#0x14]
000018  b108              CBZ      r0,|L11.30|
;;;699        pbuf_free(pcr->original);
00001a  f7fffffe          BL       pbuf_free
                  |L11.30|
;;;700      }
;;;701      ip_frag_free_pbuf_custom_ref(pcr);
00001e  4620              MOV      r0,r4
000020  e8bd4010          POP      {r4,lr}
000024  f7ffbffe          B.W      ip_frag_free_pbuf_custom_ref
;;;702    }
;;;703    #endif /* !LWIP_NETIF_TX_SINGLE_PBUF */
                          ENDP

                  |L11.40|
000028  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip"
00002c  6964646c
000030  65776172
000034  65735c54
000038  68697264
00003c  5f506172
000040  74795c4c
000044  7749505c
000048  7372635c
00004c  636f7265
000050  5c697076
000054  345c6970
000058  345f6672          DCB      "4_frag.c",0
00005c  61672e63
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0
                  |L11.100|
000064  70637220          DCB      "pcr != NULL",0
000068  213d204e
00006c  554c4c00
                  |L11.112|
000070  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
000074  7274696f
000078  6e202225
00007c  73222066
000080  61696c65
000084  64206174
000088  206c696e
00008c  65202564
000090  20696e20
000094  25730a00

                          AREA ||.data||, DATA, ALIGN=2

                  ip_reass_pbufcount
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  reassdatagrams
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\ipv4\\ip4_frag.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_ip4_frag_c_8e8622ef____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_ip4_frag_c_8e8622ef____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_ip4_frag_c_8e8622ef____REVSH|
#line 478
|__asm___10_ip4_frag_c_8e8622ef____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_ip4_frag_c_8e8622ef____RRX|
#line 665
|__asm___10_ip4_frag_c_8e8622ef____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
