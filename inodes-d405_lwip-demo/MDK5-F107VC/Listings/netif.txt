; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\netif.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\netif.d --cpu=Cortex-M3 --apcs=interwork -O1 --diag_suppress=9931 -I..\Inc -I..\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy -I..\Drivers\STM32F1xx_HAL_Driver\Inc -I..\Drivers\CMSIS\Device -I..\Drivers\CMSIS\Include -I..\Middlewares\Third_Party\LwIP\src\include -I..\Middlewares\Third_Party\LwIP\system -I..\Middlewares\Third_Party\LwIP\src\include\netif\ppp -I..\Middlewares\Third_Party\LwIP\src\include\lwip -I..\Middlewares\Third_Party\LwIP\src\include\lwip\apps -I..\Middlewares\Third_Party\LwIP\src\include\lwip\priv -I..\Middlewares\Third_Party\LwIP\src\include\lwip\prot -I..\Middlewares\Third_Party\LwIP\src\include\netif -I..\Middlewares\Third_Party\LwIP\src\include\posix -I..\Middlewares\Third_Party\LwIP\src\include\posix\sys -I..\Middlewares\Third_Party\LwIP\system\arch -I..\App -I..\Middlewares\Third_Party\LwIP\system -I.\RTE\_f107vc -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=530 -DSTM32F10X_CL -D_RTE_ -DUSE_HAL_DRIVER -DSTM32F107xC --omf_browse=.\objects\netif.crf ..\Middlewares\Third_Party\LwIP\src\core\netif.c]
                          THUMB

                          AREA ||i.netif_add||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  netif_add PROC
;;;240    struct netif *
;;;241    netif_add(struct netif *netif,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;242    #if LWIP_IPV4
;;;243              const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw,
;;;244    #endif /* LWIP_IPV4 */
;;;245              void *state, netif_init_fn init, netif_input_fn input)
;;;246    {
000004  e9dda508          LDRD     r10,r5,[sp,#0x20]
000008  9e0a              LDR      r6,[sp,#0x28]
00000a  4604              MOV      r4,r0
00000c  460f              MOV      r7,r1
00000e  4690              MOV      r8,r2
000010  4699              MOV      r9,r3
;;;247    #if LWIP_IPV6
;;;248      s8_t i;
;;;249    #endif
;;;250    
;;;251      LWIP_ASSERT("No init function given", init != NULL);
000012  2d00              CMP      r5,#0
000014  d105              BNE      |L1.34|
000016  a318              ADR      r3,|L1.120|
000018  22fb              MOVS     r2,#0xfb
00001a  a124              ADR      r1,|L1.172|
00001c  a029              ADR      r0,|L1.196|
00001e  f7fffffe          BL       __2printf
                  |L1.34|
;;;252    
;;;253      /* reset new interface configuration state */
;;;254    #if LWIP_IPV4
;;;255      ip_addr_set_zero_ip4(&netif->ip_addr);
000022  2000              MOVS     r0,#0
000024  6060              STR      r0,[r4,#4]
;;;256      ip_addr_set_zero_ip4(&netif->netmask);
000026  60a0              STR      r0,[r4,#8]
;;;257      ip_addr_set_zero_ip4(&netif->gw);
000028  60e0              STR      r0,[r4,#0xc]
;;;258    #endif /* LWIP_IPV4 */
;;;259    #if LWIP_IPV6
;;;260      for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
;;;261        ip_addr_set_zero_ip6(&netif->ip6_addr[i]);
;;;262        netif->ip6_addr_state[i] = IP6_ADDR_INVALID;
;;;263      }
;;;264      netif->output_ip6 = netif_null_output_ip6;
;;;265    #endif /* LWIP_IPV6 */
;;;266      NETIF_SET_CHECKSUM_CTRL(netif, NETIF_CHECKSUM_ENABLE_ALL);
;;;267      netif->flags = 0;
00002a  f8840037          STRB     r0,[r4,#0x37]
;;;268    #ifdef netif_get_client_data
;;;269      memset(netif->client_data, 0, sizeof(netif->client_data));
00002e  62a0              STR      r0,[r4,#0x28]
;;;270    #endif /* LWIP_NUM_NETIF_CLIENT_DATA */
;;;271    #if LWIP_IPV6_AUTOCONFIG
;;;272      /* IPv6 address autoconfiguration not enabled by default */
;;;273      netif->ip6_autoconfig_enabled = 0;
;;;274    #endif /* LWIP_IPV6_AUTOCONFIG */
;;;275    #if LWIP_IPV6_SEND_ROUTER_SOLICIT
;;;276      netif->rs_count = LWIP_ND6_MAX_MULTICAST_SOLICIT;
000030  2103              MOVS     r1,#3
000032  f884102c          STRB     r1,[r4,#0x2c]
;;;277    #endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
;;;278    #if LWIP_NETIF_STATUS_CALLBACK
;;;279      netif->status_callback = NULL;
000036  61e0              STR      r0,[r4,#0x1c]
;;;280    #endif /* LWIP_NETIF_STATUS_CALLBACK */
;;;281    #if LWIP_NETIF_LINK_CALLBACK
;;;282      netif->link_callback = NULL;
000038  6220              STR      r0,[r4,#0x20]
;;;283    #endif /* LWIP_NETIF_LINK_CALLBACK */
;;;284    #if LWIP_IGMP
;;;285      netif->igmp_mac_filter = NULL;
;;;286    #endif /* LWIP_IGMP */
;;;287    #if LWIP_IPV6 && LWIP_IPV6_MLD
;;;288      netif->mld_mac_filter = NULL;
;;;289    #endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
;;;290    #if ENABLE_LOOPBACK
;;;291      netif->loop_first = NULL;
;;;292      netif->loop_last = NULL;
;;;293    #endif /* ENABLE_LOOPBACK */
;;;294    
;;;295      /* remember netif specific state information data */
;;;296      netif->state = state;
00003a  f8c4a024          STR      r10,[r4,#0x24]
;;;297      netif->num = netif_num++;
00003e  f8dfa0ac          LDR      r10,|L1.236|
000042  f89a0000          LDRB     r0,[r10,#0]  ; netif_num
000046  f884003a          STRB     r0,[r4,#0x3a]
00004a  1c40              ADDS     r0,r0,#1
00004c  f88a0000          STRB     r0,[r10,#0]
;;;298      netif->input = input;
000050  6126              STR      r6,[r4,#0x10]
;;;299    
;;;300      NETIF_SET_HWADDRHINT(netif, NULL);
;;;301    #if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
;;;302      netif->loop_cnt_current = 0;
;;;303    #endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */
;;;304    
;;;305    #if LWIP_IPV4
;;;306      netif_set_addr(netif, ipaddr, netmask, gw);
000052  464b              MOV      r3,r9
000054  4642              MOV      r2,r8
000056  4639              MOV      r1,r7
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       netif_set_addr
;;;307    #endif /* LWIP_IPV4 */
;;;308    
;;;309      /* call user specified initialization function for netif */
;;;310      if (init(netif) != ERR_OK) {
00005e  4620              MOV      r0,r4
000060  47a8              BLX      r5
000062  b110              CBZ      r0,|L1.106|
;;;311        return NULL;
000064  2000              MOVS     r0,#0
                  |L1.102|
;;;312      }
;;;313    
;;;314      /* add this netif to the list */
;;;315      netif->next = netif_list;
;;;316      netif_list = netif;
;;;317      mib2_netif_added(netif);
;;;318    
;;;319    #if LWIP_IGMP
;;;320      /* start IGMP processing */
;;;321      if (netif->flags & NETIF_FLAG_IGMP) {
;;;322        igmp_start(netif);
;;;323      }
;;;324    #endif /* LWIP_IGMP */
;;;325    
;;;326      LWIP_DEBUGF(NETIF_DEBUG, ("netif: added interface %c%c IP",
;;;327        netif->name[0], netif->name[1]));
;;;328    #if LWIP_IPV4
;;;329      LWIP_DEBUGF(NETIF_DEBUG, (" addr "));
;;;330      ip4_addr_debug_print(NETIF_DEBUG, ipaddr);
;;;331      LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
;;;332      ip4_addr_debug_print(NETIF_DEBUG, netmask);
;;;333      LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
;;;334      ip4_addr_debug_print(NETIF_DEBUG, gw);
;;;335    #endif /* LWIP_IPV4 */
;;;336      LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
;;;337      return netif;
;;;338    }
000066  e8bd87f0          POP      {r4-r10,pc}
                  |L1.106|
00006a  f8da0004          LDR      r0,[r10,#4]           ;315  ; netif_list
00006e  6020              STR      r0,[r4,#0]            ;315
000070  f8ca4004          STR      r4,[r10,#4]           ;316  ; netif_list
000074  4620              MOV      r0,r4                 ;337
000076  e7f6              B        |L1.102|
;;;339    
                          ENDP

                  |L1.120|
000078  2e2e5c4d          DCB      "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\netif.c",0
00007c  6964646c
000080  65776172
000084  65735c54
000088  68697264
00008c  5f506172
000090  74795c4c
000094  7749505c
000098  7372635c
00009c  636f7265
0000a0  5c6e6574
0000a4  69662e63
0000a8  00      
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L1.172|
0000ac  4e6f2069          DCB      "No init function given",0
0000b0  6e697420
0000b4  66756e63
0000b8  74696f6e
0000bc  20676976
0000c0  656e00  
0000c3  00                DCB      0
                  |L1.196|
0000c4  41737365          DCB      "Assertion ""%s"" failed at line %d in %s\n",0
0000c8  7274696f
0000cc  6e202225
0000d0  73222066
0000d4  61696c65
0000d8  64206174
0000dc  206c696e
0000e0  65202564
0000e4  20696e20
0000e8  25730a00
                  |L1.236|
                          DCD      ||.data||

                          AREA ||i.netif_find||, CODE, READONLY, ALIGN=2

                  netif_find PROC
;;;471    struct netif *
;;;472    netif_find(const char *name)
000000  b510              PUSH     {r4,lr}
;;;473    {
000002  4601              MOV      r1,r0
;;;474      struct netif *netif;
;;;475      u8_t num;
;;;476    
;;;477      if (name == NULL) {
000004  2900              CMP      r1,#0
000006  d005              BEQ      |L2.20|
;;;478        return NULL;
;;;479      }
;;;480    
;;;481      num = (u8_t)(name[2] - '0');
000008  7888              LDRB     r0,[r1,#2]
00000a  3830              SUBS     r0,r0,#0x30
00000c  b2c2              UXTB     r2,r0
;;;482    
;;;483      for (netif = netif_list; netif != NULL; netif = netif->next) {
00000e  480b              LDR      r0,|L2.60|
000010  6840              LDR      r0,[r0,#4]  ; netif_list
000012  e010              B        |L2.54|
                  |L2.20|
000014  2000              MOVS     r0,#0                 ;478
                  |L2.22|
;;;484        if (num == netif->num &&
;;;485           name[0] == netif->name[0] &&
;;;486           name[1] == netif->name[1]) {
;;;487          LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: found %c%c\n", name[0], name[1]));
;;;488          return netif;
;;;489        }
;;;490      }
;;;491      LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
;;;492      return NULL;
;;;493    }
000016  bd10              POP      {r4,pc}
                  |L2.24|
000018  f890303a          LDRB     r3,[r0,#0x3a]         ;484
00001c  4293              CMP      r3,r2                 ;484
00001e  d109              BNE      |L2.52|
000020  780b              LDRB     r3,[r1,#0]            ;485
000022  f8904038          LDRB     r4,[r0,#0x38]         ;485
000026  42a3              CMP      r3,r4                 ;485
000028  d104              BNE      |L2.52|
00002a  784b              LDRB     r3,[r1,#1]            ;486
00002c  f8904039          LDRB     r4,[r0,#0x39]         ;486
000030  42a3              CMP      r3,r4                 ;486
000032  d0f0              BEQ      |L2.22|
                  |L2.52|
000034  6800              LDR      r0,[r0,#0]            ;483
                  |L2.54|
000036  2800              CMP      r0,#0                 ;483
000038  d1ee              BNE      |L2.24|
00003a  bd10              POP      {r4,pc}
;;;494    
                          ENDP

                  |L2.60|
                          DCD      ||.data||

                          AREA ||i.netif_init||, CODE, READONLY, ALIGN=1

                  netif_init PROC
;;;162    void
;;;163    netif_init(void)
000000  4770              BX       lr
;;;164    {
;;;165    #if LWIP_HAVE_LOOPIF
;;;166    #if LWIP_IPV4
;;;167    #define LOOPIF_ADDRINIT &loop_ipaddr, &loop_netmask, &loop_gw,
;;;168      ip4_addr_t loop_ipaddr, loop_netmask, loop_gw;
;;;169      IP4_ADDR(&loop_gw, 127,0,0,1);
;;;170      IP4_ADDR(&loop_ipaddr, 127,0,0,1);
;;;171      IP4_ADDR(&loop_netmask, 255,0,0,0);
;;;172    #else /* LWIP_IPV4 */
;;;173    #define LOOPIF_ADDRINIT
;;;174    #endif /* LWIP_IPV4 */
;;;175    
;;;176    #if NO_SYS
;;;177      netif_add(&loop_netif, LOOPIF_ADDRINIT NULL, netif_loopif_init, ip_input);
;;;178    #else  /* NO_SYS */
;;;179      netif_add(&loop_netif, LOOPIF_ADDRINIT NULL, netif_loopif_init, tcpip_input);
;;;180    #endif /* NO_SYS */
;;;181    
;;;182    #if LWIP_IPV6
;;;183      IP_ADDR6_HOST(loop_netif.ip6_addr, 0, 0, 0, 0x00000001UL);
;;;184      loop_netif.ip6_addr_state[0] = IP6_ADDR_VALID;
;;;185    #endif /* LWIP_IPV6 */
;;;186    
;;;187      netif_set_link_up(&loop_netif);
;;;188      netif_set_up(&loop_netif);
;;;189    
;;;190    #endif /* LWIP_HAVE_LOOPIF */
;;;191    }
;;;192    
                          ENDP


                          AREA ||i.netif_input||, CODE, READONLY, ALIGN=1

                  netif_input PROC
;;;202    err_t
;;;203    netif_input(struct pbuf *p, struct netif *inp)
000000  f8912037          LDRB     r2,[r1,#0x37]
;;;204    {
;;;205    #if LWIP_ETHERNET
;;;206      if (inp->flags & (NETIF_FLAG_ETHARP | NETIF_FLAG_ETHERNET)) {
000004  f0120f18          TST      r2,#0x18
000008  d001              BEQ      |L4.14|
;;;207        return ethernet_input(p, inp);
00000a  f7ffbffe          B.W      ethernet_input
                  |L4.14|
;;;208      } else
;;;209    #endif /* LWIP_ETHERNET */
;;;210      return ip_input(p, inp);
00000e  f7ffbffe          B.W      ip4_input
;;;211    }
;;;212    
                          ENDP


                          AREA ||i.netif_issue_reports||, CODE, READONLY, ALIGN=1

                  netif_issue_reports PROC
;;;641    static void
;;;642    netif_issue_reports(struct netif* netif, u8_t report_type)
000000  07c9              LSLS     r1,r1,#31
;;;643    {
000002  d009              BEQ      |L5.24|
;;;644    #if LWIP_IPV4
;;;645      if ((report_type & NETIF_REPORT_TYPE_IPV4) &&
;;;646          !ip4_addr_isany_val(*netif_ip4_addr(netif))) {
000004  6841              LDR      r1,[r0,#4]
000006  2900              CMP      r1,#0
000008  d006              BEQ      |L5.24|
;;;647    #if LWIP_ARP
;;;648        /* For Ethernet network interfaces, we would like to send a "gratuitous ARP" */
;;;649        if (netif->flags & (NETIF_FLAG_ETHARP)) {
00000a  f8901037          LDRB     r1,[r0,#0x37]
00000e  0709              LSLS     r1,r1,#28
000010  d502              BPL      |L5.24|
;;;650          etharp_gratuitous(netif);
000012  1d01              ADDS     r1,r0,#4
000014  f7ffbffe          B.W      etharp_request
                  |L5.24|
;;;651        }
;;;652    #endif /* LWIP_ARP */
;;;653    
;;;654    #if LWIP_IGMP
;;;655        /* resend IGMP memberships */
;;;656        if (netif->flags & NETIF_FLAG_IGMP) {
;;;657          igmp_report_groups(netif);
;;;658        }
;;;659    #endif /* LWIP_IGMP */
;;;660      }
;;;661    #endif /* LWIP_IPV4 */
;;;662    
;;;663    #if LWIP_IPV6
;;;664      if (report_type & NETIF_REPORT_TYPE_IPV6) {
;;;665    #if LWIP_IPV6_MLD
;;;666        /* send mld memberships */
;;;667        mld6_report_groups(netif);
;;;668    #endif /* LWIP_IPV6_MLD */
;;;669    #if LWIP_IPV6_SEND_ROUTER_SOLICIT
;;;670        /* Send Router Solicitation messages. */
;;;671        netif->rs_count = LWIP_ND6_MAX_MULTICAST_SOLICIT;
;;;672    #endif /* LWIP_IPV6_SEND_ROUTER_SOLICIT */
;;;673      }
;;;674    #endif /* LWIP_IPV6 */
;;;675    }
000018  4770              BX       lr
;;;676    
                          ENDP


                          AREA ||i.netif_remove||, CODE, READONLY, ALIGN=2

                  netif_remove PROC
;;;376    void
;;;377    netif_remove(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;378    {
000002  4604              MOV      r4,r0
;;;379    #if LWIP_IPV6
;;;380      int i;
;;;381    #endif
;;;382    
;;;383      if (netif == NULL) {
000004  2c00              CMP      r4,#0
000006  d01c              BEQ      |L6.66|
;;;384        return;
;;;385      }
;;;386    
;;;387    #if LWIP_IPV4
;;;388      if (!ip4_addr_isany_val(*netif_ip4_addr(netif))) {
000008  6860              LDR      r0,[r4,#4]
00000a  b138              CBZ      r0,|L6.28|
;;;389    #if LWIP_TCP
;;;390        tcp_netif_ip_addr_changed(netif_ip_addr4(netif), NULL);
00000c  2100              MOVS     r1,#0
00000e  1d20              ADDS     r0,r4,#4
000010  f7fffffe          BL       tcp_netif_ip_addr_changed
;;;391    #endif /* LWIP_TCP */
;;;392    #if LWIP_UDP
;;;393        udp_netif_ip_addr_changed(netif_ip_addr4(netif), NULL);
000014  2100              MOVS     r1,#0
000016  1d20              ADDS     r0,r4,#4
000018  f7fffffe          BL       udp_netif_ip_addr_changed
                  |L6.28|
;;;394    #endif /* LWIP_UDP */
;;;395    #if LWIP_RAW
;;;396        raw_netif_ip_addr_changed(netif_ip_addr4(netif), NULL);
;;;397    #endif /* LWIP_RAW */
;;;398      }
;;;399    
;;;400    #if LWIP_IGMP
;;;401      /* stop IGMP processing */
;;;402      if (netif->flags & NETIF_FLAG_IGMP) {
;;;403        igmp_stop(netif);
;;;404      }
;;;405    #endif /* LWIP_IGMP */
;;;406    #endif /* LWIP_IPV4*/
;;;407    
;;;408    #if LWIP_IPV6
;;;409      for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
;;;410        if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i))) {
;;;411    #if LWIP_TCP
;;;412          tcp_netif_ip_addr_changed(netif_ip_addr6(netif, i), NULL);
;;;413    #endif /* LWIP_TCP */
;;;414    #if LWIP_UDP
;;;415          udp_netif_ip_addr_changed(netif_ip_addr6(netif, i), NULL);
;;;416    #endif /* LWIP_UDP */
;;;417    #if LWIP_RAW
;;;418          raw_netif_ip_addr_changed(netif_ip_addr6(netif, i), NULL);
;;;419    #endif /* LWIP_RAW */
;;;420        }
;;;421      }
;;;422    #if LWIP_IPV6_MLD
;;;423      /* stop MLD processing */
;;;424      mld6_stop(netif);
;;;425    #endif /* LWIP_IPV6_MLD */
;;;426    #endif /* LWIP_IPV6 */
;;;427      if (netif_is_up(netif)) {
00001c  f8940037          LDRB     r0,[r4,#0x37]
000020  07c0              LSLS     r0,r0,#31
000022  d002              BEQ      |L6.42|
;;;428        /* set netif down before removing (call callback function) */
;;;429        netif_set_down(netif);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       netif_set_down
                  |L6.42|
;;;430      }
;;;431    
;;;432      mib2_remove_ip4(netif);
;;;433    
;;;434      /* this netif is default? */
;;;435      if (netif_default == netif) {
00002a  4a0b              LDR      r2,|L6.88|
00002c  6890              LDR      r0,[r2,#8]  ; netif_default
00002e  42a0              CMP      r0,r4
000030  d102              BNE      |L6.56|
;;;436        /* reset default netif */
;;;437        netif_set_default(NULL);
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       netif_set_default
                  |L6.56|
;;;438      }
;;;439      /*  is it the first netif? */
;;;440      if (netif_list == netif) {
000038  6850              LDR      r0,[r2,#4]  ; netif_list
00003a  42a0              CMP      r0,r4
00003c  d109              BNE      |L6.82|
;;;441        netif_list = netif->next;
00003e  6820              LDR      r0,[r4,#0]
000040  6050              STR      r0,[r2,#4]  ; netif_list
                  |L6.66|
;;;442      } else {
;;;443        /*  look for netif further down the list */
;;;444        struct netif * tmp_netif;
;;;445        for (tmp_netif = netif_list; tmp_netif != NULL; tmp_netif = tmp_netif->next) {
;;;446          if (tmp_netif->next == netif) {
;;;447            tmp_netif->next = netif->next;
;;;448            break;
;;;449          }
;;;450        }
;;;451        if (tmp_netif == NULL) {
;;;452          return; /* netif is not on the list */
;;;453        }
;;;454      }
;;;455      mib2_netif_removed(netif);
;;;456    #if LWIP_NETIF_REMOVE_CALLBACK
;;;457      if (netif->remove_callback) {
;;;458        netif->remove_callback(netif);
;;;459      }
;;;460    #endif /* LWIP_NETIF_REMOVE_CALLBACK */
;;;461      LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
;;;462    }
000042  bd10              POP      {r4,pc}
                  |L6.68|
000044  6801              LDR      r1,[r0,#0]            ;446
000046  42a1              CMP      r1,r4                 ;446
000048  d102              BNE      |L6.80|
00004a  6821              LDR      r1,[r4,#0]            ;447
00004c  6001              STR      r1,[r0,#0]            ;447
00004e  bd10              POP      {r4,pc}
                  |L6.80|
000050  4608              MOV      r0,r1                 ;445
                  |L6.82|
000052  2800              CMP      r0,#0                 ;445
000054  d1f6              BNE      |L6.68|
000056  bd10              POP      {r4,pc}
;;;463    
                          ENDP

                  |L6.88|
                          DCD      ||.data||

                          AREA ||i.netif_set_addr||, CODE, READONLY, ALIGN=1

                  netif_set_addr PROC
;;;351    void
;;;352    netif_set_addr(struct netif *netif, const ip4_addr_t *ipaddr, const ip4_addr_t *netmask,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;353        const ip4_addr_t *gw)
;;;354    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;355      if (ip4_addr_isany(ipaddr)) {
00000c  2c00              CMP      r4,#0
00000e  d00f              BEQ      |L7.48|
000010  6821              LDR      r1,[r4,#0]
000012  b169              CBZ      r1,|L7.48|
;;;356        /* when removing an address, we have to remove it *before* changing netmask/gw
;;;357           to ensure that tcp RST segment can be sent correctly */
;;;358        netif_set_ipaddr(netif, ipaddr);
;;;359        netif_set_netmask(netif, netmask);
;;;360        netif_set_gw(netif, gw);
;;;361      } else {
;;;362        netif_set_netmask(netif, netmask);
000014  4629              MOV      r1,r5
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       netif_set_netmask
;;;363        netif_set_gw(netif, gw);
00001c  4631              MOV      r1,r6
00001e  4638              MOV      r0,r7
000020  f7fffffe          BL       netif_set_gw
;;;364        /* set ipaddr last to ensure netmask/gw have been set when status callback is called */
;;;365        netif_set_ipaddr(netif, ipaddr);
000024  4621              MOV      r1,r4
000026  4638              MOV      r0,r7
000028  e8bd41f0          POP      {r4-r8,lr}
00002c  f7ffbffe          B.W      netif_set_ipaddr
                  |L7.48|
000030  4621              MOV      r1,r4                 ;358
000032  4638              MOV      r0,r7                 ;358
000034  f7fffffe          BL       netif_set_ipaddr
000038  4629              MOV      r1,r5                 ;359
00003a  4638              MOV      r0,r7                 ;359
00003c  f7fffffe          BL       netif_set_netmask
000040  4631              MOV      r1,r6                 ;360
000042  4638              MOV      r0,r7                 ;360
000044  e8bd41f0          POP      {r4-r8,lr}            ;360
000048  f7ffbffe          B.W      netif_set_gw
;;;366      }
;;;367    }
;;;368    #endif /* LWIP_IPV4*/
                          ENDP


                          AREA ||i.netif_set_default||, CODE, READONLY, ALIGN=2

                  netif_set_default PROC
;;;603    void
;;;604    netif_set_default(struct netif *netif)
000000  4901              LDR      r1,|L8.8|
;;;605    {
;;;606      if (netif == NULL) {
;;;607        /* remove default route */
;;;608        mib2_remove_route_ip4(1, netif);
;;;609      } else {
;;;610        /* install default route */
;;;611        mib2_add_route_ip4(1, netif);
;;;612      }
;;;613      netif_default = netif;
000002  6088              STR      r0,[r1,#8]  ; netif_default
;;;614      LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
;;;615               netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
;;;616    }
000004  4770              BX       lr
;;;617    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      ||.data||

                          AREA ||i.netif_set_down||, CODE, READONLY, ALIGN=1

                  netif_set_down PROC
;;;681    void
;;;682    netif_set_down(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;683    {
000002  4604              MOV      r4,r0
;;;684      if (netif->flags & NETIF_FLAG_UP) {
000004  f8940037          LDRB     r0,[r4,#0x37]
000008  07c1              LSLS     r1,r0,#31
00000a  d00f              BEQ      |L9.44|
;;;685        netif->flags &= ~NETIF_FLAG_UP;
00000c  f0200001          BIC      r0,r0,#1
000010  f8840037          STRB     r0,[r4,#0x37]
;;;686        MIB2_COPY_SYSUPTIME_TO(&netif->ts);
;;;687    
;;;688    #if LWIP_IPV4 && LWIP_ARP
;;;689        if (netif->flags & NETIF_FLAG_ETHARP) {
000014  0700              LSLS     r0,r0,#28
000016  d502              BPL      |L9.30|
;;;690          etharp_cleanup_netif(netif);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       etharp_cleanup_netif
                  |L9.30|
;;;691        }
;;;692    #endif /* LWIP_IPV4 && LWIP_ARP */
;;;693    
;;;694    #if LWIP_IPV6
;;;695        nd6_cleanup_netif(netif);
;;;696    #endif /* LWIP_IPV6 */
;;;697    
;;;698        NETIF_STATUS_CALLBACK(netif);
00001e  69e1              LDR      r1,[r4,#0x1c]
000020  2900              CMP      r1,#0
000022  d003              BEQ      |L9.44|
000024  4620              MOV      r0,r4
000026  e8bd4010          POP      {r4,lr}
00002a  4708              BX       r1
                  |L9.44|
;;;699      }
;;;700    }
00002c  bd10              POP      {r4,pc}
;;;701    
                          ENDP


                          AREA ||i.netif_set_gw||, CODE, READONLY, ALIGN=1

                  netif_set_gw PROC
;;;556    void
;;;557    netif_set_gw(struct netif *netif, const ip4_addr_t *gw)
000000  2900              CMP      r1,#0
;;;558    {
000002  d002              BEQ      |L10.10|
;;;559      ip4_addr_set(ip_2_ip4(&netif->gw), gw);
000004  6809              LDR      r1,[r1,#0]
                  |L10.6|
000006  60c1              STR      r1,[r0,#0xc]
;;;560      IP_SET_TYPE_VAL(netif->gw, IPADDR_TYPE_V4);
;;;561      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: GW address of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;562        netif->name[0], netif->name[1],
;;;563        ip4_addr1_16(netif_ip4_gw(netif)),
;;;564        ip4_addr2_16(netif_ip4_gw(netif)),
;;;565        ip4_addr3_16(netif_ip4_gw(netif)),
;;;566        ip4_addr4_16(netif_ip4_gw(netif))));
;;;567    }
000008  4770              BX       lr
                  |L10.10|
00000a  2100              MOVS     r1,#0                 ;559
00000c  e7fb              B        |L10.6|
;;;568    
                          ENDP


                          AREA ||i.netif_set_ipaddr||, CODE, READONLY, ALIGN=2

                  netif_set_ipaddr PROC
;;;506    void
;;;507    netif_set_ipaddr(struct netif *netif, const ip4_addr_t *ipaddr)
000000  b538              PUSH     {r3-r5,lr}
;;;508    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;509      ip_addr_t new_addr;
;;;510      *ip_2_ip4(&new_addr) = (ipaddr ? *ipaddr : *IP4_ADDR_ANY4);
000006  2d00              CMP      r5,#0
000008  d002              BEQ      |L11.16|
00000a  6828              LDR      r0,[r5,#0]
00000c  9000              STR      r0,[sp,#0]
00000e  e002              B        |L11.22|
                  |L11.16|
000010  480e              LDR      r0,|L11.76|
000012  6800              LDR      r0,[r0,#0]  ; ip_addr_any
000014  9000              STR      r0,[sp,#0]
                  |L11.22|
;;;511      IP_SET_TYPE_VAL(new_addr, IPADDR_TYPE_V4);
;;;512    
;;;513      /* address is actually being changed? */
;;;514      if (ip4_addr_cmp(ip_2_ip4(&new_addr), netif_ip4_addr(netif)) == 0) {
000016  9800              LDR      r0,[sp,#0]
000018  6861              LDR      r1,[r4,#4]
00001a  4288              CMP      r0,r1
00001c  d013              BEQ      |L11.70|
;;;515        LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_STATE, ("netif_set_ipaddr: netif address being changed\n"));
;;;516    #if LWIP_TCP
;;;517        tcp_netif_ip_addr_changed(netif_ip_addr4(netif), &new_addr);
00001e  4669              MOV      r1,sp
000020  1d20              ADDS     r0,r4,#4
000022  f7fffffe          BL       tcp_netif_ip_addr_changed
;;;518    #endif /* LWIP_TCP */
;;;519    #if LWIP_UDP
;;;520        udp_netif_ip_addr_changed(netif_ip_addr4(netif), &new_addr);
000026  4669              MOV      r1,sp
000028  1d20              ADDS     r0,r4,#4
00002a  f7fffffe          BL       udp_netif_ip_addr_changed
;;;521    #endif /* LWIP_UDP */
;;;522    #if LWIP_RAW
;;;523        raw_netif_ip_addr_changed(netif_ip_addr4(netif), &new_addr);
;;;524    #endif /* LWIP_RAW */
;;;525    
;;;526        mib2_remove_ip4(netif);
;;;527        mib2_remove_route_ip4(0, netif);
;;;528        /* set new IP address to netif */
;;;529        ip4_addr_set(ip_2_ip4(&netif->ip_addr), ipaddr);
00002e  b15d              CBZ      r5,|L11.72|
000030  6828              LDR      r0,[r5,#0]
                  |L11.50|
000032  6060              STR      r0,[r4,#4]
;;;530        IP_SET_TYPE_VAL(netif->ip_addr, IPADDR_TYPE_V4);
;;;531        mib2_add_ip4(netif);
;;;532        mib2_add_route_ip4(0, netif);
;;;533    
;;;534        netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4);
000034  2101              MOVS     r1,#1
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       netif_issue_reports
;;;535    
;;;536        NETIF_STATUS_CALLBACK(netif);
00003c  69e1              LDR      r1,[r4,#0x1c]
00003e  2900              CMP      r1,#0
000040  d001              BEQ      |L11.70|
000042  4620              MOV      r0,r4
000044  4788              BLX      r1
                  |L11.70|
;;;537      }
;;;538    
;;;539      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: IP address of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;540        netif->name[0], netif->name[1],
;;;541        ip4_addr1_16(netif_ip4_addr(netif)),
;;;542        ip4_addr2_16(netif_ip4_addr(netif)),
;;;543        ip4_addr3_16(netif_ip4_addr(netif)),
;;;544        ip4_addr4_16(netif_ip4_addr(netif))));
;;;545    }
000046  bd38              POP      {r3-r5,pc}
                  |L11.72|
000048  2000              MOVS     r0,#0                 ;529
00004a  e7f2              B        |L11.50|
;;;546    
                          ENDP

                  |L11.76|
                          DCD      ip_addr_any

                          AREA ||i.netif_set_link_callback||, CODE, READONLY, ALIGN=1

                  netif_set_link_callback PROC
;;;773    void
;;;774    netif_set_link_callback(struct netif *netif, netif_status_callback_fn link_callback)
000000  2800              CMP      r0,#0
;;;775    {
000002  d000              BEQ      |L12.6|
;;;776      if (netif) {
;;;777        netif->link_callback = link_callback;
000004  6201              STR      r1,[r0,#0x20]
                  |L12.6|
;;;778      }
;;;779    }
000006  4770              BX       lr
;;;780    #endif /* LWIP_NETIF_LINK_CALLBACK */
                          ENDP


                          AREA ||i.netif_set_link_down||, CODE, READONLY, ALIGN=1

                  netif_set_link_down PROC
;;;759    void
;;;760    netif_set_link_down(struct netif *netif )
000000  f8901037          LDRB     r1,[r0,#0x37]
;;;761    {
;;;762      if (netif->flags & NETIF_FLAG_LINK_UP) {
000004  074a              LSLS     r2,r1,#29
000006  d507              BPL      |L13.24|
;;;763        netif->flags &= ~NETIF_FLAG_LINK_UP;
000008  f0210104          BIC      r1,r1,#4
00000c  f8801037          STRB     r1,[r0,#0x37]
;;;764        NETIF_LINK_CALLBACK(netif);
000010  6a01              LDR      r1,[r0,#0x20]
000012  2900              CMP      r1,#0
000014  d000              BEQ      |L13.24|
000016  4708              BX       r1
                  |L13.24|
;;;765      }
;;;766    }
000018  4770              BX       lr
;;;767    
                          ENDP


                          AREA ||i.netif_set_link_up||, CODE, READONLY, ALIGN=1

                  netif_set_link_up PROC
;;;734    void
;;;735    netif_set_link_up(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;736    {
000002  4604              MOV      r4,r0
;;;737      if (!(netif->flags & NETIF_FLAG_LINK_UP)) {
000004  f8940037          LDRB     r0,[r4,#0x37]
000008  0741              LSLS     r1,r0,#29
00000a  d415              BMI      |L14.56|
;;;738        netif->flags |= NETIF_FLAG_LINK_UP;
00000c  f0400004          ORR      r0,r0,#4
000010  f8840037          STRB     r0,[r4,#0x37]
;;;739    
;;;740    #if LWIP_DHCP
;;;741        dhcp_network_changed(netif);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       dhcp_network_changed
;;;742    #endif /* LWIP_DHCP */
;;;743    
;;;744    #if LWIP_AUTOIP
;;;745        autoip_network_changed(netif);
;;;746    #endif /* LWIP_AUTOIP */
;;;747    
;;;748        if (netif->flags & NETIF_FLAG_UP) {
00001a  f8940037          LDRB     r0,[r4,#0x37]
00001e  07c0              LSLS     r0,r0,#31
000020  d003              BEQ      |L14.42|
;;;749          netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4|NETIF_REPORT_TYPE_IPV6);
000022  2103              MOVS     r1,#3
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       netif_issue_reports
                  |L14.42|
;;;750        }
;;;751        NETIF_LINK_CALLBACK(netif);
00002a  6a21              LDR      r1,[r4,#0x20]
00002c  2900              CMP      r1,#0
00002e  d003              BEQ      |L14.56|
000030  4620              MOV      r0,r4
000032  e8bd4010          POP      {r4,lr}
000036  4708              BX       r1
                  |L14.56|
;;;752      }
;;;753    }
000038  bd10              POP      {r4,pc}
;;;754    
                          ENDP


                          AREA ||i.netif_set_netmask||, CODE, READONLY, ALIGN=1

                  netif_set_netmask PROC
;;;579    void
;;;580    netif_set_netmask(struct netif *netif, const ip4_addr_t *netmask)
000000  2900              CMP      r1,#0
;;;581    {
000002  d002              BEQ      |L15.10|
;;;582      mib2_remove_route_ip4(0, netif);
;;;583      /* set new netmask to netif */
;;;584      ip4_addr_set(ip_2_ip4(&netif->netmask), netmask);
000004  6809              LDR      r1,[r1,#0]
                  |L15.6|
000006  6081              STR      r1,[r0,#8]
;;;585      IP_SET_TYPE_VAL(netif->netmask, IPADDR_TYPE_V4);
;;;586      mib2_add_route_ip4(0, netif);
;;;587      LWIP_DEBUGF(NETIF_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("netif: netmask of interface %c%c set to %"U16_F".%"U16_F".%"U16_F".%"U16_F"\n",
;;;588        netif->name[0], netif->name[1],
;;;589        ip4_addr1_16(netif_ip4_netmask(netif)),
;;;590        ip4_addr2_16(netif_ip4_netmask(netif)),
;;;591        ip4_addr3_16(netif_ip4_netmask(netif)),
;;;592        ip4_addr4_16(netif_ip4_netmask(netif))));
;;;593    }
000008  4770              BX       lr
                  |L15.10|
00000a  2100              MOVS     r1,#0                 ;584
00000c  e7fb              B        |L15.6|
;;;594    #endif /* LWIP_IPV4 */
                          ENDP


                          AREA ||i.netif_set_status_callback||, CODE, READONLY, ALIGN=1

                  netif_set_status_callback PROC
;;;707    void
;;;708    netif_set_status_callback(struct netif *netif, netif_status_callback_fn status_callback)
000000  2800              CMP      r0,#0
;;;709    {
000002  d000              BEQ      |L16.6|
;;;710      if (netif) {
;;;711        netif->status_callback = status_callback;
000004  61c1              STR      r1,[r0,#0x1c]
                  |L16.6|
;;;712      }
;;;713    }
000006  4770              BX       lr
;;;714    #endif /* LWIP_NETIF_STATUS_CALLBACK */
                          ENDP


                          AREA ||i.netif_set_up||, CODE, READONLY, ALIGN=1

                  netif_set_up PROC
;;;623    void
;;;624    netif_set_up(struct netif *netif)
000000  b510              PUSH     {r4,lr}
;;;625    {
000002  4604              MOV      r4,r0
;;;626      if (!(netif->flags & NETIF_FLAG_UP)) {
000004  f8940037          LDRB     r0,[r4,#0x37]
000008  07c1              LSLS     r1,r0,#31
00000a  d111              BNE      |L17.48|
;;;627        netif->flags |= NETIF_FLAG_UP;
00000c  f0400001          ORR      r0,r0,#1
000010  f8840037          STRB     r0,[r4,#0x37]
;;;628    
;;;629        MIB2_COPY_SYSUPTIME_TO(&netif->ts);
;;;630    
;;;631        NETIF_STATUS_CALLBACK(netif);
000014  69e1              LDR      r1,[r4,#0x1c]
000016  b109              CBZ      r1,|L17.28|
000018  4620              MOV      r0,r4
00001a  4788              BLX      r1
                  |L17.28|
;;;632    
;;;633        if (netif->flags & NETIF_FLAG_LINK_UP) {
00001c  f8940037          LDRB     r0,[r4,#0x37]
000020  0740              LSLS     r0,r0,#29
000022  d505              BPL      |L17.48|
;;;634          netif_issue_reports(netif, NETIF_REPORT_TYPE_IPV4|NETIF_REPORT_TYPE_IPV6);
000024  4620              MOV      r0,r4
000026  e8bd4010          POP      {r4,lr}
00002a  2103              MOVS     r1,#3
00002c  f7ffbffe          B.W      netif_issue_reports
                  |L17.48|
;;;635        }
;;;636      }
;;;637    }
000030  bd10              POP      {r4,pc}
;;;638    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  netif_num
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  netif_list
                          DCD      0x00000000
                  netif_default
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\Middlewares\\Third_Party\\LwIP\\src\\core\\netif.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_netif_c_8fba8137____REV16|
#line 463 "..\\Drivers\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___7_netif_c_8fba8137____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_netif_c_8fba8137____REVSH|
#line 478
|__asm___7_netif_c_8fba8137____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_netif_c_8fba8137____RRX|
#line 665
|__asm___7_netif_c_8fba8137____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
